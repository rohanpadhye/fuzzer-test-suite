diff --git a/.gitattributes b/.gitattributes
new file mode 100644
index 0000000..4ad67d3
--- /dev/null
+++ b/.gitattributes
@@ -0,0 +1,4 @@
+/.travis.yml export-ignore
+/appveyor.yml export-ignore
+/ci export-ignore
+/.gitattributes export-ignore
diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index db7a0c4..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,14 +0,0 @@
-.DS_Store
-Makefile.in
-aclocal.m4
-ar-lib
-autom4te.cache
-compile
-config.guess
-config.h.in
-config.sub
-configure
-depcomp
-install-sh
-ltmain.sh
-missing
diff --git a/.travis.yml b/.travis.yml
index c1e36bd..73001cf 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,35 +11,41 @@ matrix:
       env: BUILD_OFFICIAL=1
       osx_image: xcode7.3
     - os: linux
+      dist: trusty
       compiler: clang
       env:
-        CFLAGS="-O1 -g -fsanitize=address -fno-omit-frame-pointer"
-        CONFIGURE_FLAGS="--disable-shared"
+        CMAKE_BUILD_TYPE=RelWithDebInfo
+        CFLAGS_RELWITHDEBINFO="-O1 -g -fsanitize=address -fno-omit-frame-pointer"
+        CMAKE_FLAGS="-DENABLE_SHARED=0"
         ASAN_OPTIONS="detect_leaks=1 symbolize=1"
       addons:
         apt:
           packages:
             - nasm
     - os: linux
+      dist: trusty
       compiler: gcc
-      env: CONFIGURE_FLAGS="--with-12bit"
+      env: CMAKE_FLAGS="-DWITH_12BIT=1"
     - os: linux
+      dist: trusty
       compiler: gcc
-      env: CONFIGURE_FLAGS="--with-jpeg7"
+      env: CMAKE_FLAGS="-DWITH_JPEG7=1"
       addons:
         apt:
           packages:
             - nasm
     - os: linux
+      dist: trusty
       compiler: gcc
-      env: CONFIGURE_FLAGS="--with-jpeg8"
+      env: CMAKE_FLAGS="-DWITH_JPEG8=1"
       addons:
         apt:
           packages:
             - nasm
     - os: linux
+      dist: trusty
       compiler: gcc
-      env: CONFIGURE_FLAGS="--without-simd"
+      env: CMAKE_FLAGS="-DWITH_SIMD=0"
 
 before_install:
   - if [ "$TRAVIS_OS_NAME" = "osx" ]; then
@@ -80,17 +86,16 @@ script:
       fi
     fi
   - if [ "${BUILD_OFFICIAL:-}" == "" ]; then
-      autoreconf -fiv &&
       mkdir build &&
       pushd build &&
-      ../configure ${CONFIGURE_FLAGS} &&
+      cmake -G"Unix Makefiles" -DCMAKE_BUILD_TYPE=$CMAKE_BUILD_TYPE "-DCMAKE_C_FLAGS_RELWITHDEBINFO=$CFLAGS_RELWITHDEBINFO" $CMAKE_FLAGS .. &&
       make -j &&
-      if [[ "${CONFIGURE_FLAGS}" =~ "with-12bit" ||
-            "${CONFIGURE_FLAGS}" =~ "without-simd" ]]; then
-        make test FLOATTEST=32bit;
-      else
-        make test FLOATTEST=sse &&
-        JSIMD_FORCENONE=1 make test FLOATTEST=32bit;
+      make test &&
+      if [[ ! "${CMAKE_FLAGS[0]}" =~ "WITH_12BIT" &&
+            ! "${CMAKE_FLAGS[0]}" =~ "WITH_SIMD" ]]; then
+        JSIMD_FORCESSE2=1 make test &&
+        cmake -DFLOATTEST=32bit .. &&
+        JSIMD_FORCENONE=1 make test;
       fi &&
       popd;
     fi
diff --git a/BUILDING.md b/BUILDING.md
index 2725f30..c9f6468 100644
--- a/BUILDING.md
+++ b/BUILDING.md
@@ -1,26 +1,24 @@
-Un*x Platforms (including Mac and Cygwin)
-=========================================
+Building libjpeg-turbo
+======================
 
 
 Build Requirements
 ------------------
 
-- autoconf 2.56 or later
-- automake 1.7 or later
-- libtool 1.4 or later
-  * If using Xcode 4.3 or later on OS X, autoconf and automake are no longer
-    provided.  The easiest way to obtain them is from
-    [MacPorts](http://www.MacPorts.org) or [Homebrew](http://brew.sh/).
+
+### All Systems
+
+- [CMake](http://www.cmake.org) v2.8.12 or later
 
 - [NASM](http://www.nasm.us) or [YASM](http://yasm.tortall.net)
   (if building x86 or x86-64 SIMD extensions)
-  * If using NASM, 0.98, or 2.01 or later is required for an x86 build (0.99
-    and 2.00 do not work properly with libjpeg-turbo's x86 SIMD code.)
-  * If using NASM, 2.00 or later is required for an x86-64 build.
-  * If using NASM, 2.07 or later (except 2.11.08) is required for an x86-64
-    Mac build (2.11.08 does not work properly with libjpeg-turbo's x86-64 SIMD
-    code when building macho64 objects.)  NASM or YASM can be obtained from
+  * If using NASM, 2.10 or later is required.
+  * If using NASM, 2.10 or later (except 2.11.08) is required for an x86-64 Mac
+    build (2.11.08 does not work properly with libjpeg-turbo's x86-64 SIMD code
+    when building macho64 objects.)  NASM or YASM can be obtained from
     [MacPorts](http://www.macports.org/) or [Homebrew](http://brew.sh/).
+  * If using YASM, 1.2.0 or later is required.
+  * If building on Windows, **nasm.exe**/**yasm.exe** should be in your `PATH`.
 
   The binary RPMs released by the NASM project do not work on older Linux
   systems, such as Red Hat Enterprise Linux 5.  On such systems, you can easily
@@ -36,6 +34,9 @@ Build Requirements
 
   NOTE: the NASM build will fail if texinfo is not installed.
 
+
+### Un*x Platforms (including Linux, Mac, FreeBSD, Solaris, and Cygwin)
+
 - GCC v4.1 (or later) or Clang recommended for best performance
 
 - If building the TurboJPEG Java wrapper, JDK or OpenJDK 1.5 or later is
@@ -47,13 +48,48 @@ Build Requirements
   <http://www.java.com>.
 
 
+### Windows
+
+- Microsoft Visual C++ 2005 or later
+
+  If you don't already have Visual C++, then the easiest way to get it is by
+  installing the
+  [Windows SDK](http://msdn.microsoft.com/en-us/windows/bb980924.aspx).
+  The Windows SDK includes both 32-bit and 64-bit Visual C++ compilers and
+  everything necessary to build libjpeg-turbo.
+
+  * You can also use Microsoft Visual Studio Express/Community Edition, which
+    is a free download.  (NOTE: versions prior to 2012 can only be used to
+    build 32-bit code.)
+  * If you intend to build libjpeg-turbo from the command line, then add the
+    appropriate compiler and SDK directories to the `INCLUDE`, `LIB`, and
+    `PATH` environment variables.  This is generally accomplished by
+    executing `vcvars32.bat` or `vcvars64.bat` and `SetEnv.cmd`.
+    `vcvars32.bat` and `vcvars64.bat` are part of Visual C++ and are located in
+    the same directory as the compiler.  `SetEnv.cmd` is part of the Windows
+    SDK.  You can pass optional arguments to `SetEnv.cmd` to specify a 32-bit
+    or 64-bit build environment.
+
+   ... OR ...
+
+- MinGW
+
+  [MSYS2](http://msys2.github.io/) or [tdm-gcc](http://tdm-gcc.tdragon.net/)
+  recommended if building on a Windows machine.  Both distributions install a
+  Start Menu link that can be used to launch a command prompt with the
+  appropriate compiler paths automatically set.
+
+- If building the TurboJPEG Java wrapper, JDK 1.5 or later is required.  This
+  can be downloaded from <http://www.java.com>.
+
+
 Out-of-Tree Builds
 ------------------
 
 Binary objects, libraries, and executables are generated in the directory from
-which `configure` is executed (the "binary directory"), and this directory need
-not necessarily be the same as the libjpeg-turbo source directory.  You can
-create multiple independent binary directories, in which different versions of
+which CMake is executed (the "binary directory"), and this directory need not
+necessarily be the same as the libjpeg-turbo source directory.  You can create
+multiple independent binary directories, in which different versions of
 libjpeg-turbo can be built from the same source tree using different compilers
 or settings.  In the sections below, *{build_directory}* refers to the binary
 directory, whereas *{source_directory}* refers to the libjpeg-turbo source
@@ -63,20 +99,22 @@ directory.  For in-tree builds, these directories are the same.
 Build Procedure
 ---------------
 
+NOTE: The build procedures below assume that CMake is invoked from the command
+line, but all of these procedures can be adapted to the CMake GUI as
+well.
+
+
+### Un*x
+
 The following procedure will build libjpeg-turbo on Unix and Unix-like systems.
 (On Solaris, this generates a 32-bit build.  See "Build Recipes" below for
 64-bit build instructions.)
 
-    cd {source_directory}
-    autoreconf -fiv
     cd {build_directory}
-    sh {source_directory}/configure [additional configure flags]
+    cmake -G"Unix Makefiles" [additional CMake flags] {source_directory}
     make
 
-NOTE: Running autoreconf in the source directory is not necessary if building
-libjpeg-turbo from one of the official release tarballs.
-
-This will generate the following files under **.libs/**:
+This will generate the following files under *{build_directory}*:
 
 **libjpeg.a**<br>
 Static link library for the libjpeg API
@@ -100,8 +138,8 @@ Import library for the libjpeg API
 **libturbojpeg.a**<br>
 Static link library for the TurboJPEG API
 
-**libturbojpeg.so.0.1.0** (Linux, Unix)<br>
-**libturbojpeg.0.1.0.dylib** (Mac)<br>
+**libturbojpeg.so.0.2.0** (Linux, Unix)<br>
+**libturbojpeg.0.2.0.dylib** (Mac)<br>
 **cygturbojpeg-0.dll** (Cygwin)<br>
 Shared library for the TurboJPEG API
 
@@ -113,146 +151,236 @@ Development symlink for the TurboJPEG API
 Import library for the TurboJPEG API
 
 
-### libjpeg v7 or v8 API/ABI Emulation
+### Visual C++ (Command Line)
 
-Add `--with-jpeg7` to the `configure` command line to build a version of
-libjpeg-turbo that is API/ABI-compatible with libjpeg v7.  Add `--with-jpeg8`
-to the `configure` command to build a version of libjpeg-turbo that is
-API/ABI-compatible with libjpeg v8.  See [README.md](README.md) for more
-information about libjpeg v7 and v8 emulation.
+    cd {build_directory}
+    cmake -G"NMake Makefiles" -DCMAKE_BUILD_TYPE=Release [additional CMake flags] {source_directory}
+    nmake
 
+This will build either a 32-bit or a 64-bit version of libjpeg-turbo, depending
+on which version of **cl.exe** is in the `PATH`.
 
-### In-Memory Source/Destination Managers
+The following files will be generated under *{build_directory}*:
 
-When using libjpeg v6b or v7 API/ABI emulation, add `--without-mem-srcdst` to
-the `configure` command line to build a version of libjpeg-turbo that lacks the
-`jpeg_mem_src()` and `jpeg_mem_dest()` functions.  These functions were not
-part of the original libjpeg v6b and v7 APIs, so removing them ensures strict
-conformance with those APIs.  See [README.md](README.md) for more information.
+**jpeg-static.lib**<br>
+Static link library for the libjpeg API
 
+**jpeg{version}.dll**<br>
+DLL for the libjpeg API
 
-### Arithmetic Coding Support
+**jpeg.lib**<br>
+Import library for the libjpeg API
 
-Since the patent on arithmetic coding has expired, this functionality has been
-included in this release of libjpeg-turbo.  libjpeg-turbo's implementation is
-based on the implementation in libjpeg v8, but it works when emulating libjpeg
-v7 or v6b as well.  The default is to enable both arithmetic encoding and
-decoding, but those who have philosophical objections to arithmetic coding can
-add `--without-arith-enc` or `--without-arith-dec` to the `configure` command
-line to disable encoding or decoding (respectively.)
+**turbojpeg-static.lib**<br>
+Static link library for the TurboJPEG API
 
+**turbojpeg.dll**<br>
+DLL for the TurboJPEG API
 
-### TurboJPEG Java Wrapper
+**turbojpeg.lib**<br>
+Import library for the TurboJPEG API
 
-Add `--with-java` to the `configure` command line to incorporate an optional
-Java Native Interface (JNI) wrapper into the TurboJPEG shared library and build
-the Java front-end classes to support it.  This allows the TurboJPEG shared
-library to be used directly from Java applications.  See
-[java/README](java/README) for more details.
+*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or
+v8 emulation is enabled.
 
-You can set the `JAVAC`, `JAR`, and `JAVA` configure variables to specify
-alternate commands for javac, jar, and java (respectively.)  You can also
-set the `JAVACFLAGS` configure variable to specify arguments that should be
-passed to the Java compiler when building the TurboJPEG classes, and
-`JNI_CFLAGS` to specify arguments that should be passed to the C compiler when
-building the JNI wrapper.  Run `configure --help` for more details.
 
+### Visual C++ (IDE)
 
-Build Recipes
--------------
+Choose the appropriate CMake generator option for your version of Visual Studio
+(run `cmake` with no arguments for a list of available generators.)  For
+instance:
 
+    cd {build_directory}
+    cmake -G"Visual Studio 10" [additional CMake flags] {source_directory}
 
-### 32-bit Build on 64-bit Linux
+NOTE: Add "Win64" to the generator name (for example, "Visual Studio 10 Win64")
+to build a 64-bit version of libjpeg-turbo.  A separate build directory must be
+used for 32-bit and 64-bit builds.
 
-Add
+You can then open **ALL_BUILD.vcproj** in Visual Studio and build one of the
+configurations in that project ("Debug", "Release", etc.) to generate a full
+build of libjpeg-turbo.
 
-    --host i686-pc-linux-gnu CFLAGS='-O3 -m32' LDFLAGS=-m32
+This will generate the following files under *{build_directory}*:
 
-to the `configure` command line.
+**{configuration}/jpeg-static.lib**<br>
+Static link library for the libjpeg API
 
+**{configuration}/jpeg{version}.dll**<br>
+DLL for the libjpeg API
 
-### 64-bit Build on 64-bit OS X
+**{configuration}/jpeg.lib**<br>
+Import library for the libjpeg API
 
-Add
+**{configuration}/turbojpeg-static.lib**<br>
+Static link library for the TurboJPEG API
 
-    --host x86_64-apple-darwin NASM=/opt/local/bin/nasm
+**{configuration}/turbojpeg.dll**<br>
+DLL for the TurboJPEG API
 
-to the `configure` command line.  NASM 2.07 or later from MacPorts or Homebrew
-must be installed.  If using Homebrew, then replace `/opt/local` with
-`/usr/local`.
+**{configuration}/turbojpeg.lib**<br>
+Import library for the TurboJPEG API
 
+*{configuration}* is Debug, Release, RelWithDebInfo, or MinSizeRel, depending
+on the configuration you built in the IDE, and *{version}* is 62, 7, or 8,
+depending on whether libjpeg v6b (default), v7, or v8 emulation is enabled.
 
-### 32-bit Build on 64-bit OS X
 
-Add
+### MinGW
 
-    --host i686-apple-darwin CFLAGS='-O3 -m32' LDFLAGS=-m32
+NOTE: This assumes that you are building on a Windows machine using the MSYS
+environment.  If you are cross-compiling on a Un*x platform (including Mac and
+Cygwin), then see "Build Recipes" below.
 
-to the `configure` command line.
+    cd {build_directory}
+    cmake -G"MSYS Makefiles" [additional CMake flags] {source_directory}
+    make
 
+This will generate the following files under *{build_directory}*:
 
-### 64-bit Backward-Compatible Build on 64-bit OS X
+**libjpeg.a**<br>
+Static link library for the libjpeg API
 
-Add
+**libjpeg-{version}.dll**<br>
+DLL for the libjpeg API
 
-    --host x86_64-apple-darwin NASM=/opt/local/bin/nasm \
-      CFLAGS='-mmacosx-version-min=10.5 -O3' \
-      LDFLAGS='-mmacosx-version-min=10.5'
+**libjpeg.dll.a**<br>
+Import library for the libjpeg API
 
-to the `configure` command line.  NASM 2.07 or later from MacPorts or Homebrew
-must be installed.  If using Homebrew, then replace `/opt/local` with
-`/usr/local`.
+**libturbojpeg.a**<br>
+Static link library for the TurboJPEG API
 
+**libturbojpeg.dll**<br>
+DLL for the TurboJPEG API
 
-### 32-bit Backward-Compatible Build on OS X
+**libturbojpeg.dll.a**<br>
+Import library for the TurboJPEG API
+
+*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or
+v8 emulation is enabled.
+
+
+### Debug Build
+
+Add `-DCMAKE_BUILD_TYPE=Debug` to the CMake command line.  Or, if building
+with NMake, remove `-DCMAKE_BUILD_TYPE=Release` (Debug builds are the default
+with NMake.)
 
-Add
 
-    --host i686-apple-darwin \
-      CFLAGS='-mmacosx-version-min=10.5 -O3 -m32' \
-      LDFLAGS='-mmacosx-version-min=10.5 -m32'
+### libjpeg v7 or v8 API/ABI Emulation
 
-to the `configure` command line.
+Add `-DWITH_JPEG7=1` to the CMake command line to build a version of
+libjpeg-turbo that is API/ABI-compatible with libjpeg v7.  Add `-DWITH_JPEG8=1`
+to the CMake command line to build a version of libjpeg-turbo that is
+API/ABI-compatible with libjpeg v8.  See [README.md](README.md) for more
+information about libjpeg v7 and v8 emulation.
+
+
+### In-Memory Source/Destination Managers
+
+When using libjpeg v6b or v7 API/ABI emulation, add `-DWITH_MEM_SRCDST=0` to
+the CMake command line to build a version of libjpeg-turbo that lacks the
+`jpeg_mem_src()` and `jpeg_mem_dest()` functions.  These functions were not
+part of the original libjpeg v6b and v7 APIs, so removing them ensures strict
+conformance with those APIs.  See [README.md](README.md) for more information.
+
+
+### Arithmetic Coding Support
+
+Since the patent on arithmetic coding has expired, this functionality has been
+included in this release of libjpeg-turbo.  libjpeg-turbo's implementation is
+based on the implementation in libjpeg v8, but it works when emulating libjpeg
+v7 or v6b as well.  The default is to enable both arithmetic encoding and
+decoding, but those who have philosophical objections to arithmetic coding can
+add `-DWITH_ARITH_ENC=0` or `-DWITH_ARITH_DEC=0` to the CMake command line to
+disable encoding or decoding (respectively.)
 
 
-### 64-bit Build on 64-bit Solaris
+### TurboJPEG Java Wrapper
 
-Add
+Add `-DWITH_JAVA=1` to the CMake command line to incorporate an optional Java
+Native Interface (JNI) wrapper into the TurboJPEG shared library and build the
+Java front-end classes to support it.  This allows the TurboJPEG shared library
+to be used directly from Java applications.  See [java/README](java/README) for
+more details.
 
-    --host x86_64-pc-solaris CFLAGS='-O3 -m64' LDFLAGS=-m64
+If Java is not in your `PATH`, or if you wish to use an alternate JDK to
+build/test libjpeg-turbo, then (prior to running CMake) set the `JAVA_HOME`
+environment variable to the location of the JDK that you wish to use.  The
+`Java_JAVAC_EXECUTABLE`, `Java_JAVA_EXECUTABLE`, and `Java_JAR_EXECUTABLE`
+CMake variables can also be used to specify alternate commands or locations for
+javac, jar, and java (respectively.)  You can also set the
+`CMAKE_JAVA_COMPILE_FLAGS` CMake variable or the `JAVAFLAGS` environment
+variable to specify arguments that should be passed to the Java compiler when
+building the TurboJPEG classes, and the `JAVAARGS` CMake variable to specify
+arguments that should be passed to the JRE when running the TurboJPEG Java unit
+tests.
 
-to the `configure` command line.
 
+Build Recipes
+-------------
 
-### 32-bit Build on 64-bit FreeBSD
 
-Add
+### 32-bit Build on 64-bit Linux/Unix/Mac
 
-    --host i386-unknown-freebsd CFLAGS='-O3 -m32' LDFLAGS=-m32
+Use export/setenv to set the following environment variables before running
+CMake:
 
-to the `configure` command line.  NASM 2.07 or later from FreeBSD ports must be
-installed.
+    CFLAGS=-m32
+    LDFLAGS=-m32
 
 
-### Oracle Solaris Studio
+### 64-bit Build on Solaris
 
-Add
+Use export/setenv to set the following environment variables before running
+CMake:
 
-    CC=cc
+    CFLAGS=-m64
+    LDFLAGS=-m64
 
-to the `configure` command line.  libjpeg-turbo will automatically be built
-with the maximum optimization level (-xO5) unless you override `CFLAGS`.
 
-To build a 64-bit version of libjpeg-turbo using Oracle Solaris Studio, add
+### Other Compilers
 
-    --host x86_64-pc-solaris CC=cc CFLAGS='-xO5 -m64' LDFLAGS=-m64
+On Un*x systems, prior to running CMake, you can set the `CC` environment
+variable to the command used to invoke the C compiler.
 
-to the `configure` command line.
 
+### 32-bit MinGW Build on Un*x (including Mac and Cygwin)
 
-### MinGW Build on Cygwin
+Create a file called **toolchain.cmake** under *{build_directory}*, with the
+following contents:
 
-Use CMake (see recipes below)
+    set(CMAKE_SYSTEM_NAME Windows)
+    set(CMAKE_SYSTEM_PROCESSOR X86)
+    set(CMAKE_C_COMPILER {mingw_binary_path}/i686-w64-mingw32-gcc)
+    set(CMAKE_RC_COMPILER {mingw_binary_path}/i686-w64-mingw32-windres)
+
+*{mingw\_binary\_path}* is the directory under which the MinGW binaries are
+located (usually **/usr/bin**.)  Next, execute the following commands:
+
+    cd {build_directory}
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      [additional CMake flags] {source_directory}
+    make
+
+
+### 64-bit MinGW Build on Un*x (including Mac and Cygwin)
+
+Create a file called **toolchain.cmake** under *{build_directory}*, with the
+following contents:
+
+    set(CMAKE_SYSTEM_NAME Windows)
+    set(CMAKE_SYSTEM_PROCESSOR AMD64)
+    set(CMAKE_C_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-gcc)
+    set(CMAKE_RC_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-windres)
+
+*{mingw\_binary\_path}* is the directory under which the MinGW binaries are
+located (usually **/usr/bin**.)  Next, execute the following commands:
+
+    cd {build_directory}
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      [additional CMake flags] {source_directory}
+    make
 
 
 Building libjpeg-turbo for iOS
@@ -283,13 +411,18 @@ iPhone 3GS-4S/iPad 1st-3rd Generation and newer:
 
     IOS_PLATFORMDIR=/Developer/Platforms/iPhoneOS.platform
     IOS_SYSROOT=($IOS_PLATFORMDIR/Developer/SDKs/iPhoneOS*.sdk)
+    export CFLAGS="-mfloat-abi=softfp -march=armv7 -mcpu=cortex-a8 -mtune=cortex-a8 -mfpu=neon -miphoneos-version-min=3.0"
 
-    export host_alias=arm-apple-darwin10
-    export CC=${IOS_PLATFORMDIR}/Developer/usr/bin/arm-apple-darwin10-llvm-gcc-4.2
-    export CFLAGS="-mfloat-abi=softfp -isysroot ${IOS_SYSROOT[0]} -O3 -march=armv7 -mcpu=cortex-a8 -mtune=cortex-a8 -mfpu=neon -miphoneos-version-min=3.0"
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Darwin)
+    set(CMAKE_SYSTEM_PROCESSOR arm)
+    set(CMAKE_C_COMPILER ${IOS_PLATFORMDIR}/Developer/usr/bin/arm-apple-darwin10-llvm-gcc-4.2)
+    EOF
 
     cd {build_directory}
-    sh {source_directory}/configure [additional configure flags]
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_OSX_SYSROOT=${IOS_SYSROOT[0]} \
+      [additional CMake flags] {source_directory}
     make
 
 #### Xcode 4.3-4.6 (LLVM-GCC)
@@ -302,14 +435,19 @@ Same as above, but replace the first line with:
 
     IOS_PLATFORMDIR=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
     IOS_SYSROOT=($IOS_PLATFORMDIR/Developer/SDKs/iPhoneOS*.sdk)
+    export CFLAGS="--mfloat-abi=softfp -arch armv7 -miphoneos-version-min=3.0"
+    export ASMFLAGS="-no-integrated-as"
 
-    export host_alias=arm-apple-darwin10
-    export CC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
-    export CFLAGS="-mfloat-abi=softfp -isysroot ${IOS_SYSROOT[0]} -O3 -arch armv7 -miphoneos-version-min=3.0"
-    export CCASFLAGS="$CFLAGS -no-integrated-as"
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Darwin)
+    set(CMAKE_SYSTEM_PROCESSOR arm)
+    set(CMAKE_C_COMPILER /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang)
+    EOF
 
     cd {build_directory}
-    sh {source_directory}/configure [additional configure flags]
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_OSX_SYSROOT=${IOS_SYSROOT[0]} \
+      [additional CMake flags] {source_directory}
     make
 
 
@@ -324,13 +462,18 @@ iPhone 5/iPad 4th Generation and newer:
 
     IOS_PLATFORMDIR=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
     IOS_SYSROOT=($IOS_PLATFORMDIR/Developer/SDKs/iPhoneOS*.sdk)
+    export CFLAGS="-Wall -mfloat-abi=softfp -march=armv7s -mcpu=swift -mtune=swift -mfpu=neon -miphoneos-version-min=6.0"
 
-    export host_alias=arm-apple-darwin10
-    export CC=${IOS_PLATFORMDIR}/Developer/usr/bin/arm-apple-darwin10-llvm-gcc-4.2
-    export CFLAGS="-mfloat-abi=softfp -isysroot ${IOS_SYSROOT[0]} -O3 -march=armv7s -mcpu=swift -mtune=swift -mfpu=neon -miphoneos-version-min=6.0"
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Darwin)
+    set(CMAKE_SYSTEM_PROCESSOR arm)
+    set(CMAKE_C_COMPILER ${IOS_PLATFORMDIR}/Developer/usr/bin/arm-apple-darwin10-llvm-gcc-4.2)
+    EOF
 
     cd {build_directory}
-    sh {source_directory}/configure [additional configure flags]
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_OSX_SYSROOT=${IOS_SYSROOT[0]} \
+      [additional CMake flags] {source_directory}
     make
 
 #### Xcode 5 and later (Clang)
@@ -338,7 +481,7 @@ iPhone 5/iPad 4th Generation and newer:
 Same as the ARMv7 build procedure for Xcode 5 and later, except replace the
 compiler flags as follows:
 
-    export CFLAGS="-mfloat-abi=softfp -isysroot ${IOS_SYSROOT[0]} -O3 -arch armv7s -miphoneos-version-min=6.0"
+    export CFLAGS="-Wall -mfloat-abi=softfp -arch armv7s -miphoneos-version-min=6.0"
 
 
 ### ARMv8 (64-bit)
@@ -350,13 +493,18 @@ iPhone 5S/iPad Mini 2/iPad Air and newer.
 
     IOS_PLATFORMDIR=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform
     IOS_SYSROOT=($IOS_PLATFORMDIR/Developer/SDKs/iPhoneOS*.sdk)
+    export CFLAGS="-Wall -arch arm64 -miphoneos-version-min=7.0 -funwind-tables"
 
-    export host_alias=aarch64-apple-darwin
-    export CC=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
-    export CFLAGS="-isysroot ${IOS_SYSROOT[0]} -O3 -arch arm64 -miphoneos-version-min=7.0 -funwind-tables"
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Darwin)
+    set(CMAKE_SYSTEM_PROCESSOR aarch64)
+    set(CMAKE_C_COMPILER /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang)
+    EOF
 
     cd {build_directory}
-    sh {source_directory}/configure [additional configure flags]
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_OSX_SYSROOT=${IOS_SYSROOT[0]} \
+      [additional CMake flags] {source_directory}
     make
 
 Once built, lipo can be used to combine the ARMv7, v7s, and/or v8 variants into
@@ -367,7 +515,7 @@ Building libjpeg-turbo for Android
 ----------------------------------
 
 Building libjpeg-turbo for Android platforms requires the
-[Android NDK](https://developer.android.com/tools/sdk/ndk) and autotools.
+[Android NDK](https://developer.android.com/tools/sdk/ndk).
 
 
 ### ARMv7 (32-bit)
@@ -387,23 +535,21 @@ needs.
     # It should not be necessary to modify the rest
     HOST=arm-linux-androideabi
     SYSROOT=${NDK_PATH}/platforms/android-${ANDROID_VERSION}/arch-arm
-    ANDROID_CFLAGS="-march=armv7-a -mfloat-abi=softfp -fprefetch-loop-arrays \
-      --sysroot=${SYSROOT}"
-
+    export CFLAGS="-march=armv7-a -mfloat-abi=softfp -fprefetch-loop-arrays --sysroot=${SYSROOT}"
+    export LDFLAGS=-pie
     TOOLCHAIN=${NDK_PATH}/toolchains/${HOST}-${TOOLCHAIN_VERSION}/prebuilt/${BUILD_PLATFORM}
-    export CPP=${TOOLCHAIN}/bin/${HOST}-cpp
-    export AR=${TOOLCHAIN}/bin/${HOST}-ar
-    export NM=${TOOLCHAIN}/bin/${HOST}-nm
-    export CC=${TOOLCHAIN}/bin/${HOST}-gcc
-    export LD=${TOOLCHAIN}/bin/${HOST}-ld
-    export RANLIB=${TOOLCHAIN}/bin/${HOST}-ranlib
-    export OBJDUMP=${TOOLCHAIN}/bin/${HOST}-objdump
-    export STRIP=${TOOLCHAIN}/bin/${HOST}-strip
+
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Linux)
+    set(CMAKE_SYSTEM_PROCESSOR arm)
+    set(CMAKE_C_COMPILER ${TOOLCHAIN}/bin/${HOST}-gcc)
+    set(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN}/${HOST})
+    EOF
+
     cd {build_directory}
-    sh {source_directory}/configure --host=${HOST} \
-      CFLAGS="${ANDROID_CFLAGS} -O3 -fPIE" \
-      CPPFLAGS="${ANDROID_CFLAGS}" \
-      LDFLAGS="${ANDROID_CFLAGS} -pie" --with-simd ${1+"$@"}
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_POSITION_INDEPENDENT_CODE=1 \
+      [additional CMake flags] {source_directory}
     make
 
 
@@ -424,22 +570,21 @@ needs.
     # It should not be necessary to modify the rest
     HOST=aarch64-linux-android
     SYSROOT=${NDK_PATH}/platforms/android-${ANDROID_VERSION}/arch-arm64
-    ANDROID_CFLAGS="--sysroot=${SYSROOT}"
-
+    export CFLAGS="--sysroot=${SYSROOT}"
+    export LDFLAGS=-pie
     TOOLCHAIN=${NDK_PATH}/toolchains/${HOST}-${TOOLCHAIN_VERSION}/prebuilt/${BUILD_PLATFORM}
-    export CPP=${TOOLCHAIN}/bin/${HOST}-cpp
-    export AR=${TOOLCHAIN}/bin/${HOST}-ar
-    export NM=${TOOLCHAIN}/bin/${HOST}-nm
-    export CC=${TOOLCHAIN}/bin/${HOST}-gcc
-    export LD=${TOOLCHAIN}/bin/${HOST}-ld
-    export RANLIB=${TOOLCHAIN}/bin/${HOST}-ranlib
-    export OBJDUMP=${TOOLCHAIN}/bin/${HOST}-objdump
-    export STRIP=${TOOLCHAIN}/bin/${HOST}-strip
+
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Linux)
+    set(CMAKE_SYSTEM_PROCESSOR aarch64)
+    set(CMAKE_C_COMPILER ${TOOLCHAIN}/bin/${HOST}-gcc)
+    set(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN}/${HOST})
+    EOF
+
     cd {build_directory}
-    sh {source_directory}/configure --host=${HOST} \
-      CFLAGS="${ANDROID_CFLAGS} -O3 -fPIE" \
-      CPPFLAGS="${ANDROID_CFLAGS}" \
-      LDFLAGS="${ANDROID_CFLAGS} -pie" --with-simd ${1+"$@"}
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_POSITION_INDEPENDENT_CODE=1 \
+      [additional CMake flags] {source_directory}
     make
 
 
@@ -460,22 +605,21 @@ needs.
     # It should not be necessary to modify the rest
     HOST=i686-linux-android
     SYSROOT=${NDK_PATH}/platforms/android-${ANDROID_VERSION}/arch-x86
-    ANDROID_CFLAGS="--sysroot=${SYSROOT}"
-
+    export CFLAGS="--sysroot=${SYSROOT}"
+    export LDFLAGS=-pie
     TOOLCHAIN=${NDK_PATH}/toolchains/x86-${TOOLCHAIN_VERSION}/prebuilt/${BUILD_PLATFORM}
-    export CPP=${TOOLCHAIN}/bin/${HOST}-cpp
-    export AR=${TOOLCHAIN}/bin/${HOST}-ar
-    export NM=${TOOLCHAIN}/bin/${HOST}-nm
-    export CC=${TOOLCHAIN}/bin/${HOST}-gcc
-    export LD=${TOOLCHAIN}/bin/${HOST}-ld
-    export RANLIB=${TOOLCHAIN}/bin/${HOST}-ranlib
-    export OBJDUMP=${TOOLCHAIN}/bin/${HOST}-objdump
-    export STRIP=${TOOLCHAIN}/bin/${HOST}-strip
+
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Linux)
+    set(CMAKE_SYSTEM_PROCESSOR i386)
+    set(CMAKE_C_COMPILER ${TOOLCHAIN}/bin/${HOST}-gcc)
+    set(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN}/${HOST})
+    EOF
+
     cd {build_directory}
-    sh {source_directory}/configure --host=${HOST} \
-      CFLAGS="${ANDROID_CFLAGS} -O3 -fPIE" \
-      CPPFLAGS="${ANDROID_CFLAGS}" \
-      LDFLAGS="${ANDROID_CFLAGS} -pie" --with-simd ${1+"$@"}
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_POSITION_INDEPENDENT_CODE=1 \
+      [additional CMake flags] {source_directory}
     make
 
 
@@ -496,322 +640,49 @@ needs.
     # It should not be necessary to modify the rest
     HOST=x86_64-linux-android
     SYSROOT=${NDK_PATH}/platforms/android-${ANDROID_VERSION}/arch-x86_64
-    ANDROID_CFLAGS="--sysroot=${SYSROOT}"
-
+    export CFLAGS="--sysroot=${SYSROOT}"
+    export LDFLAGS=-pie
     TOOLCHAIN=${NDK_PATH}/toolchains/x86_64-${TOOLCHAIN_VERSION}/prebuilt/${BUILD_PLATFORM}
-    export CPP=${TOOLCHAIN}/bin/${HOST}-cpp
-    export AR=${TOOLCHAIN}/bin/${HOST}-ar
-    export NM=${TOOLCHAIN}/bin/${HOST}-nm
-    export CC=${TOOLCHAIN}/bin/${HOST}-gcc
-    export LD=${TOOLCHAIN}/bin/${HOST}-ld
-    export RANLIB=${TOOLCHAIN}/bin/${HOST}-ranlib
-    export OBJDUMP=${TOOLCHAIN}/bin/${HOST}-objdump
-    export STRIP=${TOOLCHAIN}/bin/${HOST}-strip
-    cd {build_directory}
-    sh {source_directory}/configure --host=${HOST} \
-      CFLAGS="${ANDROID_CFLAGS} -O3 -fPIE" \
-      CPPFLAGS="${ANDROID_CFLAGS}" \
-      LDFLAGS="${ANDROID_CFLAGS} -pie" --with-simd ${1+"$@"}
-    make
-
-
-If building for Android 4.0.x (API level < 16) or earlier, remove `-fPIE` from
-`CFLAGS` and `-pie` from `LDFLAGS`.
-
-
-Installing libjpeg-turbo
-------------------------
-
-To install libjpeg-turbo after it is built, replace `make` in the build
-instructions with `make install`.
-
-The `--prefix` argument to configure (or the `prefix` configure variable) can
-be used to specify an installation directory of your choosing.  If you don't
-specify an installation directory, then the default is to install libjpeg-turbo
-under **/opt/libjpeg-turbo** and to place the libraries in
-**/opt/libjpeg-turbo/lib32** (32-bit) or **/opt/libjpeg-turbo/lib64** (64-bit.)
-
-The `bindir`, `datadir`, `docdir`, `includedir`, `libdir`, and `mandir`
-configure variables allow a finer degree of control over where specific files in
-the libjpeg-turbo distribution should be installed.  These variables can either
-be specified at configure time or passed as arguments to `make install`.
-
-
-Windows (Visual C++ or MinGW)
-=============================
-
-
-Build Requirements
-------------------
-
-- [CMake](http://www.cmake.org) v2.8.11 or later
-
-- [NASM](http://www.nasm.us) or [YASM](http://yasm.tortall.net)
-  * If using NASM, 0.98 or later is required for an x86 build.
-  * If using NASM, 2.05 or later is required for an x86-64 build.
-  * **nasm.exe**/**yasm.exe** should be in your `PATH`.
-
-- Microsoft Visual C++ 2005 or later
-
-  If you don't already have Visual C++, then the easiest way to get it is by
-  installing the
-  [Windows SDK](http://msdn.microsoft.com/en-us/windows/bb980924.aspx).
-  The Windows SDK includes both 32-bit and 64-bit Visual C++ compilers and
-  everything necessary to build libjpeg-turbo.
-
-  * You can also use Microsoft Visual Studio Express/Community Edition, which
-    is a free download.  (NOTE: versions prior to 2012 can only be used to
-    build 32-bit code.)
-  * If you intend to build libjpeg-turbo from the command line, then add the
-    appropriate compiler and SDK directories to the `INCLUDE`, `LIB`, and
-    `PATH` environment variables.  This is generally accomplished by
-    executing `vcvars32.bat` or `vcvars64.bat` and `SetEnv.cmd`.
-    `vcvars32.bat` and `vcvars64.bat` are part of Visual C++ and are located in
-    the same directory as the compiler.  `SetEnv.cmd` is part of the Windows
-    SDK.  You can pass optional arguments to `SetEnv.cmd` to specify a 32-bit
-    or 64-bit build environment.
-
-   ... OR ...
-
-- MinGW
-
-  [MSYS2](http://msys2.github.io/) or [tdm-gcc](http://tdm-gcc.tdragon.net/)
-  recommended if building on a Windows machine.  Both distributions install a
-  Start Menu link that can be used to launch a command prompt with the
-  appropriate compiler paths automatically set.
-
-- If building the TurboJPEG Java wrapper, JDK 1.5 or later is required.  This
-  can be downloaded from <http://www.java.com>.
-
-
-Out-of-Tree Builds
-------------------
-
-Binary objects, libraries, and executables are generated in the directory from
-which CMake is executed (the "binary directory"), and this directory need not
-necessarily be the same as the libjpeg-turbo source directory.  You can create
-multiple independent binary directories, in which different versions of
-libjpeg-turbo can be built from the same source tree using different compilers
-or settings.  In the sections below, *{build_directory}* refers to the binary
-directory, whereas *{source_directory}* refers to the libjpeg-turbo source
-directory.  For in-tree builds, these directories are the same.
-
-
-Build Procedure
----------------
-
-NOTE: The build procedures below assume that CMake is invoked from the command
-line, but all of these procedures can be adapted to the CMake GUI as
-well.
-
-
-### Visual C++ (Command Line)
-
-    cd {build_directory}
-    cmake -G"NMake Makefiles" -DCMAKE_BUILD_TYPE=Release [additional CMake flags] {source_directory}
-    nmake
-
-This will build either a 32-bit or a 64-bit version of libjpeg-turbo, depending
-on which version of **cl.exe** is in the `PATH`.
-
-The following files will be generated under *{build_directory}*:
 
-**jpeg-static.lib**<br>
-Static link library for the libjpeg API
-
-**sharedlib/jpeg{version}.dll**<br>
-DLL for the libjpeg API
-
-**sharedlib/jpeg.lib**<br>
-Import library for the libjpeg API
-
-**turbojpeg-static.lib**<br>
-Static link library for the TurboJPEG API
-
-**turbojpeg.dll**<br>
-DLL for the TurboJPEG API
-
-**turbojpeg.lib**<br>
-Import library for the TurboJPEG API
-
-*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or
-v8 emulation is enabled.
-
-
-### Visual C++ (IDE)
-
-Choose the appropriate CMake generator option for your version of Visual Studio
-(run `cmake` with no arguments for a list of available generators.)  For
-instance:
+    cat <<EOF >toolchain.cmake
+    set(CMAKE_SYSTEM_NAME Linux)
+    set(CMAKE_SYSTEM_PROCESSOR x86_64)
+    set(CMAKE_C_COMPILER ${TOOLCHAIN}/bin/${HOST}-gcc)
+    set(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN}/${HOST})
+    EOF
 
     cd {build_directory}
-    cmake -G"Visual Studio 10" [additional CMake flags] {source_directory}
-
-NOTE: Add "Win64" to the generator name (for example, "Visual Studio 10
-Win64") to build a 64-bit version of libjpeg-turbo.  A separate build directory
-must be used for 32-bit and 64-bit builds.
-
-You can then open **ALL_BUILD.vcproj** in Visual Studio and build one of the
-configurations in that project ("Debug", "Release", etc.) to generate a full
-build of libjpeg-turbo.
-
-This will generate the following files under *{build_directory}*:
-
-**{configuration}/jpeg-static.lib**<br>
-Static link library for the libjpeg API
-
-**sharedlib/{configuration}/jpeg{version}.dll**<br>
-DLL for the libjpeg API
-
-**sharedlib/{configuration}/jpeg.lib**<br>
-Import library for the libjpeg API
-
-**{configuration}/turbojpeg-static.lib**<br>
-Static link library for the TurboJPEG API
-
-**{configuration}/turbojpeg.dll**<br>
-DLL for the TurboJPEG API
-
-**{configuration}/turbojpeg.lib**<br>
-Import library for the TurboJPEG API
-
-*{configuration}* is Debug, Release, RelWithDebInfo, or MinSizeRel, depending
-on the configuration you built in the IDE, and *{version}* is 62, 7, or 8,
-depending on whether libjpeg v6b (default), v7, or v8 emulation is enabled.
-
-
-### MinGW
-
-NOTE: This assumes that you are building on a Windows machine using the MSYS
-environment.  If you are cross-compiling on a Un*x platform (including Mac and
-Cygwin), then see "Build Recipes" below.
-
-    cd {build_directory}
-    cmake -G"MSYS Makefiles" [additional CMake flags] {source_directory}
+    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
+      -DCMAKE_POSITION_INDEPENDENT_CODE=1 \
+      [additional CMake flags] {source_directory}
     make
 
-This will generate the following files under *{build_directory}*:
-
-**libjpeg.a**<br>
-Static link library for the libjpeg API
-
-**sharedlib/libjpeg-{version}.dll**<br>
-DLL for the libjpeg API
-
-**sharedlib/libjpeg.dll.a**<br>
-Import library for the libjpeg API
-
-**libturbojpeg.a**<br>
-Static link library for the TurboJPEG API
-
-**libturbojpeg.dll**<br>
-DLL for the TurboJPEG API
-
-**libturbojpeg.dll.a**<br>
-Import library for the TurboJPEG API
-
-*{version}* is 62, 7, or 8, depending on whether libjpeg v6b (default), v7, or
-v8 emulation is enabled.
-
 
-### Debug Build
+If building for Android 4.0.x (API level < 16) or earlier, remove
+`-DCMAKE_POSITION_INDEPENDENT_CODE=1` from the CMake arguments and `-pie` from
+`LDFLAGS`.
 
-Add `-DCMAKE_BUILD_TYPE=Debug` to the CMake command line.  Or, if building
-with NMake, remove `-DCMAKE_BUILD_TYPE=Release` (Debug builds are the default
-with NMake.)
 
+Advanced CMake Options
+----------------------
 
-### libjpeg v7 or v8 API/ABI Emulation
+To list and configure other CMake options not specifically mentioned in this
+guide, run
 
-Add `-DWITH_JPEG7=1` to the CMake command line to build a version of
-libjpeg-turbo that is API/ABI-compatible with libjpeg v7.  Add `-DWITH_JPEG8=1`
-to the CMake command line to build a version of libjpeg-turbo that is
-API/ABI-compatible with libjpeg v8.  See [README.md](README.md) for more
-information about libjpeg v7 and v8 emulation.
+    ccmake {source_directory}
 
+or
 
-### In-Memory Source/Destination Managers
-
-When using libjpeg v6b or v7 API/ABI emulation, add `-DWITH_MEM_SRCDST=0` to
-the CMake command line to build a version of libjpeg-turbo that lacks the
-`jpeg_mem_src()` and `jpeg_mem_dest()` functions.  These functions were not
-part of the original libjpeg v6b and v7 APIs, so removing them ensures strict
-conformance with those APIs.  See [README.md](README.md) for more information.
+    cmake-gui {source_directory}
 
-
-### Arithmetic Coding Support
-
-Since the patent on arithmetic coding has expired, this functionality has been
-included in this release of libjpeg-turbo.  libjpeg-turbo's implementation is
-based on the implementation in libjpeg v8, but it works when emulating libjpeg
-v7 or v6b as well.  The default is to enable both arithmetic encoding and
-decoding, but those who have philosophical objections to arithmetic coding can
-add `-DWITH_ARITH_ENC=0` or `-DWITH_ARITH_DEC=0` to the CMake command line to
-disable encoding or decoding (respectively.)
-
-
-### TurboJPEG Java Wrapper
-
-Add `-DWITH_JAVA=1` to the CMake command line to incorporate an optional Java
-Native Interface (JNI) wrapper into the TurboJPEG shared library and build the
-Java front-end classes to support it.  This allows the TurboJPEG shared library
-to be used directly from Java applications.  See [java/README](java/README) for
-more details.
-
-If Java is not in your `PATH`, or if you wish to use an alternate JDK to
-build/test libjpeg-turbo, then (prior to running CMake) set the `JAVA_HOME`
-environment variable to the location of the JDK that you wish to use.  The
-`Java_JAVAC_EXECUTABLE`, `Java_JAVA_EXECUTABLE`, and `Java_JAR_EXECUTABLE`
-CMake variables can also be used to specify alternate commands or locations for
-javac, jar, and java (respectively.)  You can also set the `JAVACFLAGS` CMake
-variable to specify arguments that should be passed to the Java compiler when
-building the TurboJPEG classes.
-
-
-Build Recipes
--------------
-
-
-### 32-bit MinGW Build on Un*x (including Mac and Cygwin)
-
-Create a file called **toolchain.cmake** under *{build_directory}*, with the
-following contents:
-
-    set(CMAKE_SYSTEM_NAME Windows)
-    set(CMAKE_SYSTEM_PROCESSOR X86)
-    set(CMAKE_C_COMPILER {mingw_binary_path}/i686-w64-mingw32-gcc)
-    set(CMAKE_RC_COMPILER {mingw_binary_path}/i686-w64-mingw32-windres)
-
-*{mingw\_binary\_path}* is the directory under which the MinGW binaries are
-located (usually **/usr/bin**.)  Next, execute the following commands:
-
-    cd {build_directory}
-    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
-      [additional CMake flags] {source_directory}
-    make
-
-
-### 64-bit MinGW Build on Un*x (including Mac and Cygwin)
-
-Create a file called **toolchain.cmake** under *{build_directory}*, with the
-following contents:
-
-    set(CMAKE_SYSTEM_NAME Windows)
-    set(CMAKE_SYSTEM_PROCESSOR AMD64)
-    set(CMAKE_C_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-gcc)
-    set(CMAKE_RC_COMPILER {mingw_binary_path}/x86_64-w64-mingw32-windres)
-
-*{mingw\_binary\_path}* is the directory under which the MinGW binaries are
-located (usually **/usr/bin**.)  Next, execute the following commands:
-
-    cd {build_directory}
-    cmake -G"Unix Makefiles" -DCMAKE_TOOLCHAIN_FILE=toolchain.cmake \
-      [additional CMake flags] {source_directory}
-    make
+from the build directory after initially configuring the build.  CCMake is a
+text-based interactive version of CMake, and CMake-GUI is a GUI version.  Both
+will display all variables that are relevant to the libjpeg-turbo build, their
+current values, and a help string describing what they do.
 
 
 Installing libjpeg-turbo
-------------------------
+========================
 
 You can use the build system to install libjpeg-turbo (as opposed to creating
 an installer package.)  To do this, run `make install` or `nmake install`
@@ -835,6 +706,37 @@ MinGW 32-bit build
 **c:\libjpeg-turbo-gcc64**<br>
 MinGW 64-bit build
 
+**/opt/libjpeg-turbo**<br>
+Un*x
+
+The default value of `CMAKE_INSTALL_PREFIX` causes the libjpeg-turbo files to
+be installed with a directory structure resembling that of the official
+libjpeg-turbo binary packages.  Changing the value of `CMAKE_INSTALL_PREFIX`
+(for instance, to **/usr/local**) causes the libjpeg-turbo files to be
+installed with a directory structure that conforms to GNU standards.
+
+The `CMAKE_INSTALL_BINDIR`, `CMAKE_INSTALL_DATAROOTDIR`,
+`CMAKE_INSTALL_DOCDIR`, `CMAKE_INSTALL_INCLUDEDIR`, `CMAKE_INSTALL_JAVADIR`,
+`CMAKE_INSTALL_LIBDIR`, and `CMAKE_INSTALL_MANDIR` CMake variables allow a
+finer degree of control over where specific files in the libjpeg-turbo
+distribution should be installed.  These directory variables can either be
+specified as absolute paths or as paths relative to `CMAKE_INSTALL_PREFIX` (for
+instance, setting `CMAKE_INSTALL_DOCDIR` to **doc** would cause the
+documentation to be installed in **${CMAKE\_INSTALL\_PREFIX}/doc**.)  If a
+directory variable contains the name of another directory variable in angle
+brackets, then its final value will depend on the final value of that other
+variable.  For instance, the default value of `CMAKE_INSTALL_MANDIR` is
+**\<CMAKE\_INSTALL\_DATAROOTDIR\>/man**.
+
+NOTE: If setting one of these directory variables to a relative path using the
+CMake command line, you must specify that the variable is of type `PATH`.
+For example:
+
+    cmake -G"{generator type}" -DCMAKE_INSTALL_LIBDIR:PATH=lib {source_directory}
+
+Otherwise, CMake will assume that the path is relative to the build directory
+rather than the install directory.
+
 
 Creating Distribution Packages
 ==============================
@@ -871,40 +773,35 @@ installing Xcode 3.2.6 (with the "Unix Development" option) on OS X 10.6.
 Packages built in this manner can be installed on OS X 10.5 and later, but they
 must be built on OS X 10.6 or later.
 
-    make udmg [BUILDDIR32={32-bit build directory}]
-
-On 64-bit OS X systems, this creates a Mac package/disk image that contains
-universal i386/x86-64 binaries.  You should first configure a 32-bit
-out-of-tree build of libjpeg-turbo, then configure a 64-bit out-of-tree build,
-then run `make udmg` from the 64-bit build directory.  The build system will
-look for the 32-bit build under *{source_directory}*/osxx86 by default, but you
-can override this by setting the `BUILDDIR32` variable on the make command line
-as shown above.
-
-    make iosdmg [BUILDDIR32={32-bit build directory}] \
-      [BUILDDIRARMV7={ARMv7 build directory}] \
-      [BUILDDIRARMV7S={ARMv7s build directory}] \
-      [BUILDDIRARMV8={ARMv8 build directory}]
-
-This creates a Mac package/disk image in which the libjpeg-turbo libraries
-contain ARM architectures necessary to build iOS applications.  If building on
-an x86-64 system, the binaries will also contain the i386 architecture, as with
-`make udmg` above.  You should first configure ARMv7, ARMv7s, and/or ARMv8
-out-of-tree builds of libjpeg-turbo (see "Building libjpeg-turbo for iOS"
-above.)  If you are building an x86-64 version of libjpeg-turbo, you should
-configure a 32-bit out-of-tree build as well.  Next, build libjpeg-turbo as you
-would normally, using an out-of-tree build.  When it is built, run `make
-iosdmg` from the build directory.  The build system will look for the ARMv7
-build under *{source_directory}*/iosarmv7 by default, the ARMv7s build under
-*{source_directory}*/iosarmv7s by default, the ARMv8 build under
-*{source_directory}*/iosarmv8 by default, and (if applicable) the 32-bit build
-under *{source_directory}*/osxx86 by default, but you can override this by
-setting the `BUILDDIR32`, `BUILDDIRARMV7`, `BUILDDIRARMV7S`, and/or
-`BUILDDIRARMV8` variables on the `make` command line as shown above.
-
-NOTE: If including an ARMv8 build in the package, then you may need to use
-Xcode's version of lipo instead of the operating system's.  To do this, pass
-an argument of `LIPO="xcrun lipo"` on the make command line.
+    make udmg
+
+This creates a Mac package/disk image that contains universal x86-64/i386/ARM
+binaries.  The following CMake variables control which architectures are
+included in the universal binaries.  Setting any of these variables to an empty
+string excludes that architecture from the package.
+
+* `OSX_32BIT_BUILD`: Directory containing an i386 (32-bit) Mac build of
+  libjpeg-turbo (default: *{source_directory}*/osxx86)
+* `IOS_ARMV7_BUILD`: Directory containing an ARMv7 (32-bit) iOS build of
+  libjpeg-turbo (default: *{source_directory}*/iosarmv7)
+* `IOS_ARMV7S_BUILD`: Directory containing an ARMv7s (32-bit) iOS build of
+  libjpeg-turbo (default: *{source_directory}*/iosarmv7s)
+* `IOS_ARMV8_BUILD`: Directory containing an ARMv8 (64-bit) iOS build of
+  libjpeg-turbo (default: *{source_directory}*/iosarmv8)
+
+You should first use CMake to configure i386, ARMv7, ARMv7s, and/or ARMv8
+sub-builds of libjpeg-turbo (see "Build Recipes" and "Building libjpeg-turbo
+for iOS" above) in build directories that match those specified in the
+aforementioned CMake variables.  Next, configure the primary build of
+libjpeg-turbo as an out-of-tree build, and build it.  Once the primary build
+has been built, run `make udmg` from the build directory.  The packaging system
+will build the sub-builds, use lipo to combine them into a single set of
+universal binaries, then package the universal binaries in the same manner as
+`make dmg`.
+
+
+Cygwin
+------
 
     make cygwinpkg
 
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 131b437..a2a4573 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,15 +1,7 @@
-#
-# Setup
-#
-
-cmake_minimum_required(VERSION 2.8.11)
-# Use LINK_INTERFACE_LIBRARIES instead of INTERFACE_LINK_LIBRARIES
-if(POLICY CMP0022)
-  cmake_policy(SET CMP0022 OLD)
-endif()
+cmake_minimum_required(VERSION 2.8.12)
 
 project(libjpeg-turbo C)
-set(VERSION 1.5.2)
+set(VERSION 1.5.80)
 string(REPLACE "." ";" VERSION_TRIPLET ${VERSION})
 list(GET VERSION_TRIPLET 0 VERSION_MAJOR)
 list(GET VERSION_TRIPLET 1 VERSION_MINOR)
@@ -29,116 +21,281 @@ pad_number(VERSION_MINOR 3)
 pad_number(VERSION_REVISION 3)
 set(LIBJPEG_TURBO_VERSION_NUMBER ${VERSION_MAJOR}${VERSION_MINOR}${VERSION_REVISION})
 
-if(NOT WIN32)
-  message(FATAL_ERROR "Platform not supported by this build system.  Use autotools instead.")
-endif()
-
-string(TIMESTAMP BUILD "%Y%m%d")
+string(TIMESTAMP DEFAULT_BUILD "%Y%m%d")
+set(BUILD ${DEFAULT_BUILD} CACHE STRING "Build string (default: ${DEFAULT_BUILD})")
 
-# This does nothing except when using MinGW.  CMAKE_BUILD_TYPE has no meaning
-# in Visual Studio, and it always defaults to Debug when using NMake.
+# NOTE: On Windows, this does nothing except when using MinGW or Cygwin.
+# CMAKE_BUILD_TYPE has no meaning in Visual Studio, and it always defaults to
+# Debug when using NMake.
 if(NOT CMAKE_BUILD_TYPE)
   set(CMAKE_BUILD_TYPE Release)
 endif()
-
 message(STATUS "CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}")
 
-# This only works if building from the command line.  There is currently no way
-# to set a variable's value based on the build type when using Visual Studio.
-if(CMAKE_BUILD_TYPE STREQUAL "Debug")
-  set(BUILD "${BUILD}d")
+message(STATUS "VERSION = ${VERSION}, BUILD = ${BUILD}")
+
+# Detect CPU type and whether we're building 64-bit or 32-bit code
+math(EXPR BITS "${CMAKE_SIZEOF_VOID_P} * 8")
+string(TOLOWER ${CMAKE_SYSTEM_PROCESSOR} CMAKE_SYSTEM_PROCESSOR_LC)
+if(CMAKE_SYSTEM_PROCESSOR_LC MATCHES "x86_64" OR
+  CMAKE_SYSTEM_PROCESSOR_LC MATCHES "amd64" OR
+  CMAKE_SYSTEM_PROCESSOR_LC MATCHES "i[0-9]86" OR
+  CMAKE_SYSTEM_PROCESSOR_LC MATCHES "x86" OR
+  CMAKE_SYSTEM_PROCESSOR_LC MATCHES "ia32")
+  if(BITS EQUAL 64)
+    set(CPU_TYPE x86_64)
+  else()
+    set(CPU_TYPE i386)
+  endif()
+  if(NOT CMAKE_SYSTEM_PROCESSOR STREQUAL ${CPU_TYPE})
+    set(CMAKE_SYSTEM_PROCESSOR ${CPU_TYPE})
+  endif()
+elseif(CMAKE_SYSTEM_PROCESSOR_LC STREQUAL "aarch64" OR
+  CMAKE_SYSTEM_PROCESSOR_LC MATCHES "arm*64*")
+  set(CPU_TYPE arm64)
+elseif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES "arm*")
+  set(CPU_TYPE arm)
+elseif(CMAKE_SYSTEM_PROCESSOR_LC MATCHES "ppc*" OR
+  CMAKE_SYSTEM_PROCESSOR_LC MATCHES "powerpc*")
+  set(CPU_TYPE powerpc)
+else()
+  set(CPU_TYPE ${CMAKE_SYSTEM_PROCESSOR_LC})
 endif()
+message(STATUS "${BITS}-bit build (${CPU_TYPE})")
 
-message(STATUS "VERSION = ${VERSION}, BUILD = ${BUILD}")
 
-option(WITH_SIMD "Include SIMD extensions" TRUE)
-option(WITH_ARITH_ENC "Include arithmetic encoding support when emulating the libjpeg v6b API/ABI" TRUE)
+###############################################################################
+# INSTALL DIRECTORIES
+###############################################################################
+
+if(WIN32)
+  if(MSVC)
+    set(CMAKE_INSTALL_DEFAULT_PREFIX "c:/${CMAKE_PROJECT_NAME}")
+  else()
+    set(CMAKE_INSTALL_DEFAULT_PREFIX "c:/${CMAKE_PROJECT_NAME}-gcc")
+  endif()
+  if(BITS EQUAL 64)
+    set(CMAKE_INSTALL_DEFAULT_PREFIX "${CMAKE_INSTALL_DEFAULT_PREFIX}64")
+  endif()
+else()
+  set(CMAKE_INSTALL_DEFAULT_PREFIX /opt/${CMAKE_PROJECT_NAME})
+endif()
+if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
+  set(CMAKE_INSTALL_PREFIX "${CMAKE_INSTALL_DEFAULT_PREFIX}" CACHE PATH
+    "Directory into which to install ${CMAKE_PROJECT_NAME} (default: ${CMAKE_INSTALL_DEFAULT_PREFIX})"
+    FORCE)
+endif()
+message(STATUS "CMAKE_INSTALL_PREFIX = ${CMAKE_INSTALL_PREFIX}")
+
+# When the prefix is /opt/${CMAKE_PROJECT_NAME}, we assume that an "official"
+# build is being created, and thus we install things into specific locations.
+
+if(CMAKE_INSTALL_PREFIX STREQUAL "${CMAKE_INSTALL_DEFAULT_PREFIX}")
+  set(CMAKE_INSTALL_DEFAULT_DATAROOTDIR "")
+  set(CMAKE_INSTALL_DEFAULT_DOCDIR "<CMAKE_INSTALL_DATAROOTDIR>/doc")
+  set(CMAKE_INSTALL_DEFAULT_JAVADIR "<CMAKE_INSTALL_DATAROOTDIR>/classes")
+  if(UNIX AND NOT APPLE)
+    if(BITS EQUAL 64)
+      set(CMAKE_INSTALL_DEFAULT_LIBDIR "lib64")
+    else()
+      set(CMAKE_INSTALL_DEFAULT_LIBDIR "lib32")
+    endif()
+  endif()
+endif()
+
+include(cmakescripts/GNUInstallDirs.cmake)
+
+set(CMAKE_INSTALL_RPATH ${CMAKE_INSTALL_FULL_LIBDIR})
+
+macro(report_directory var)
+  if(CMAKE_INSTALL_${var} STREQUAL CMAKE_INSTALL_FULL_${var})
+    message(STATUS "CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}}")
+  else()
+    message(STATUS "CMAKE_INSTALL_${var} = ${CMAKE_INSTALL_${var}} (${CMAKE_INSTALL_FULL_${var}})")
+  endif()
+  mark_as_advanced(CLEAR CMAKE_INSTALL_${var})
+endmacro()
+
+set(DIRLIST "BINDIR;DATAROOTDIR;DOCDIR;INCLUDEDIR;LIBDIR")
+if(UNIX)
+  list(APPEND DIRLIST "MANDIR")
+endif()
+foreach(dir ${DIRLIST})
+  report_directory(${dir})
+endforeach()
+
+
+###############################################################################
+# CONFIGURATION OPTIONS
+###############################################################################
+
+macro(boolean_number var)
+  if(${var})
+    set(${var} 1)
+  else()
+    set(${var} 0)
+  endif()
+endmacro()
+
+option(ENABLE_SHARED "Build shared libraries" TRUE)
+boolean_number(ENABLE_SHARED)
+option(ENABLE_STATIC "Build static libraries" TRUE)
+boolean_number(ENABLE_STATIC)
+option(REQUIRE_SIMD "Generate a fatal error if SIMD extensions are not available for this platform (default is to fall back to a non-SIMD build)" FALSE)
+boolean_number(REQUIRE_SIMD)
+option(WITH_12BIT "Encode/decode JPEG images with 12-bit samples (implies WITH_ARITH_DEC=0 WITH_ARITH_ENC=0 WITH_JAVA=0 WITH_SIMD=0 WITH_TURBOJPEG=0 )" FALSE)
+boolean_number(WITH_12BIT)
 option(WITH_ARITH_DEC "Include arithmetic decoding support when emulating the libjpeg v6b API/ABI" TRUE)
-option(WITH_JPEG7 "Emulate libjpeg v7 API/ABI (this makes libjpeg-turbo backward incompatible with libjpeg v6b)" FALSE)
-option(WITH_JPEG8 "Emulate libjpeg v8 API/ABI (this makes libjpeg-turbo backward incompatible with libjpeg v6b)" FALSE)
+boolean_number(WITH_ARITH_DEC)
+option(WITH_ARITH_ENC "Include arithmetic encoding support when emulating the libjpeg v6b API/ABI" TRUE)
+boolean_number(WITH_ARITH_ENC)
+option(WITH_JAVA "Build Java wrapper for the TurboJPEG API library (implies ENABLE_SHARED=1)" FALSE)
+boolean_number(WITH_JAVA)
+option(WITH_JPEG7 "Emulate libjpeg v7 API/ABI (this makes ${CMAKE_PROJECT_NAME} backward-incompatible with libjpeg v6b)" FALSE)
+boolean_number(WITH_JPEG7)
+option(WITH_JPEG8 "Emulate libjpeg v8 API/ABI (this makes ${CMAKE_PROJECT_NAME} backward-incompatible with libjpeg v6b)" FALSE)
+boolean_number(WITH_JPEG8)
 option(WITH_MEM_SRCDST "Include in-memory source/destination manager functions when emulating the libjpeg v6b or v7 API/ABI" TRUE)
-option(WITH_TURBOJPEG "Include the TurboJPEG wrapper library and associated test programs" TRUE)
-option(WITH_JAVA "Build Java wrapper for the TurboJPEG library" FALSE)
-option(WITH_12BIT "Encode/decode JPEG images with 12-bit samples (implies WITH_SIMD=0 WITH_TURBOJPEG=0 WITH_ARITH_ENC=0 WITH_ARITH_DEC=0)" FALSE)
-option(ENABLE_STATIC "Build static libraries" TRUE)
-option(ENABLE_SHARED "Build shared libraries" TRUE)
+boolean_number(WITH_MEM_SRCDST)
+option(WITH_SIMD "Include SIMD extensions, if available for this platform" TRUE)
+boolean_number(WITH_SIMD)
+option(WITH_TURBOJPEG "Include the TurboJPEG API library and associated test programs" TRUE)
+boolean_number(WITH_TURBOJPEG)
+
+macro(report_option var desc)
+  if(${var})
+    message(STATUS "${desc} enabled (${var} = ${${var}})")
+  else()
+    message(STATUS "${desc} disabled (${var} = ${${var}})")
+  endif()
+endmacro()
+
+if(WITH_JAVA)
+  set(ENABLE_SHARED 1)
+endif()
+
+# Explicitly setting CMAKE_POSITION_INDEPENDENT_CODE=FALSE disables PIC for all
+# targets, which will cause the shared library builds to fail.  Thus, if shared
+# libraries are enabled and CMAKE_POSITION_INDEPENDENT_CODE is explicitly set
+# to FALSE, we need to unset it, thus restoring the default behavior
+# (automatically using PIC for shared library targets.)
+if(DEFINED CMAKE_POSITION_INDEPENDENT_CODE AND
+  NOT CMAKE_POSITION_INDEPENDENT_CODE AND ENABLE_SHARED)
+  unset(CMAKE_POSITION_INDEPENDENT_CODE CACHE)
+endif()
+
+report_option(ENABLE_SHARED "Shared libraries")
+report_option(ENABLE_STATIC "Static libraries")
 
 if(WITH_12BIT)
-  set(WITH_SIMD FALSE)
-  set(WITH_TURBOJPEG FALSE)
-  set(WITH_JAVA FALSE)
-  set(WITH_ARITH_ENC FALSE)
-  set(WITH_ARITH_DEC FALSE)
+  set(WITH_ARITH_DEC 0)
+  set(WITH_ARITH_ENC 0)
+  set(WITH_JAVA 0)
+  set(WITH_SIMD 0)
+  set(WITH_TURBOJPEG 0)
   set(BITS_IN_JSAMPLE 12)
-  message(STATUS "12-bit JPEG support enabled")
 else()
   set(BITS_IN_JSAMPLE 8)
 endif()
+report_option(WITH_12BIT "12-bit JPEG support")
 
 if(WITH_JPEG8 OR WITH_JPEG7)
   set(WITH_ARITH_ENC 1)
   set(WITH_ARITH_DEC 1)
 endif()
 if(WITH_JPEG8)
-  set(WITH_MEM_SRCDST 1)
+  set(WITH_MEM_SRCDST 0)
+endif()
+
+if(WITH_ARITH_DEC)
+  set(D_ARITH_CODING_SUPPORTED 1)
+endif()
+if(NOT WITH_12BIT)
+  report_option(WITH_ARITH_DEC "Arithmetic decoding support")
 endif()
 
 if(WITH_ARITH_ENC)
   set(C_ARITH_CODING_SUPPORTED 1)
-  message(STATUS "Arithmetic encoding support enabled")
-else()
-  message(STATUS "Arithmetic encoding support disabled")
 endif()
-
-if(WITH_ARITH_DEC)
-  set(D_ARITH_CODING_SUPPORTED 1)
-  message(STATUS "Arithmetic decoding support enabled")
-else()
-  message(STATUS "Arithmetic decoding support disabled")
+if(NOT WITH_12BIT)
+  report_option(WITH_ARITH_ENC "Arithmetic encoding support")
 endif()
 
-if(WITH_TURBOJPEG)
-  message(STATUS "TurboJPEG C wrapper enabled")
-else()
-  message(STATUS "TurboJPEG C wrapper disabled")
+if(NOT WITH_12BIT)
+  report_option(WITH_TURBOJPEG "TurboJPEG API library")
+  report_option(WITH_JAVA "TurboJPEG Java wrapper")
 endif()
 
-if(WITH_JAVA)
-  message(STATUS "TurboJPEG Java wrapper enabled")
-else()
-  message(STATUS "TurboJPEG Java wrapper disabled")
+if(WITH_MEM_SRCDST)
+  set(MEM_SRCDST_SUPPORTED 1)
+  set(MEM_SRCDST_FUNCTIONS "global:  jpeg_mem_dest;  jpeg_mem_src;")
+endif()
+if(NOT WITH_JPEG8)
+  report_option(WITH_MEM_SRCDST "In-memory source/destination managers")
 endif()
 
-set(SO_AGE 0)
+set(SO_AGE 2)
 if(WITH_MEM_SRCDST)
-  set(SO_AGE 1)
+  set(SO_AGE 3)
 endif()
 
-set(JPEG_LIB_VERSION 62)
-set(DLL_VERSION ${JPEG_LIB_VERSION})
-set(FULLVERSION ${DLL_VERSION}.${SO_AGE}.0)
 if(WITH_JPEG8)
   set(JPEG_LIB_VERSION 80)
-  set(DLL_VERSION 8)
-  set(FULLVERSION ${DLL_VERSION}.0.2)
-  message(STATUS "Emulating libjpeg v8 API/ABI")
 elseif(WITH_JPEG7)
   set(JPEG_LIB_VERSION 70)
-  set(DLL_VERSION 7)
-  set(FULLVERSION ${DLL_VERSION}.${SO_AGE}.0)
-  message(STATUS "Emulating libjpeg v7 API/ABI")
-endif(WITH_JPEG8)
+else()
+  set(JPEG_LIB_VERSION 62)
+endif()
 
-if(WITH_MEM_SRCDST)
-  set(MEM_SRCDST_SUPPORTED 1)
-  message(STATUS "In-memory source/destination managers enabled")
+math(EXPR JPEG_LIB_VERSION_DIV10 "${JPEG_LIB_VERSION} / 10")
+math(EXPR JPEG_LIB_VERSION_MOD10 "${JPEG_LIB_VERSION} % 10")
+if(JPEG_LIB_VERSION STREQUAL "62")
+  set(DEFAULT_SO_MAJOR_VERSION ${JPEG_LIB_VERSION})
+else()
+  set(DEFAULT_SO_MAJOR_VERSION ${JPEG_LIB_VERSION_DIV10})
+endif()
+if(JPEG_LIB_VERSION STREQUAL "80")
+  set(DEFAULT_SO_MINOR_VERSION 2)
 else()
-  message(STATUS "In-memory source/destination managers disabled")
+  set(DEFAULT_SO_MINOR_VERSION 0)
+endif()
+
+# This causes SO_MAJOR_VERSION/SO_MINOR_VERSION to reset to defaults if
+# WITH_JPEG7 or WITH_JPEG8 has changed.
+if((DEFINED WITH_JPEG7_INT AND NOT WITH_JPEG7 EQUAL WITH_JPEG7_INT) OR
+  (DEFINED WITH_JPEG8_INT AND NOT WITH_JPEG8 EQUAL WITH_JPEG8_INT))
+  set(FORCE_SO_VERSION "FORCE")
 endif()
+set(WITH_JPEG7_INT ${WITH_JPEG7} CACHE INTERNAL "")
+set(WITH_JPEG8_INT ${WITH_JPEG8} CACHE INTERNAL "")
+
+set(SO_MAJOR_VERSION ${DEFAULT_SO_MAJOR_VERSION} CACHE STRING
+  "Major version of the libjpeg API shared library (default: ${DEFAULT_SO_MAJOR_VERSION})"
+  ${FORCE_SO_VERSION})
+set(SO_MINOR_VERSION ${DEFAULT_SO_MINOR_VERSION} CACHE STRING
+  "Minor version of the libjpeg API shared library (default: ${DEFAULT_SO_MINOR_VERSION})"
+  ${FORCE_SO_VERSION})
+
+set(JPEG_LIB_VERSION_DECIMAL "${JPEG_LIB_VERSION_DIV10}.${JPEG_LIB_VERSION_MOD10}")
+message(STATUS "Emulating libjpeg API/ABI v${JPEG_LIB_VERSION_DECIMAL} (WITH_JPEG7 = ${WITH_JPEG7}, WITH_JPEG8 = ${WITH_JPEG8})")
+message(STATUS "libjpeg API shared library version = ${SO_MAJOR_VERSION}.${SO_AGE}.${SO_MINOR_VERSION}")
+
+# Because the TurboJPEG API library uses versioned symbols and changes the
+# names of functions whenever they are modified in a backward-incompatible
+# manner, it is always backward-ABI-compatible with itself, so the major and
+# minor SO versions don't change.  However, we increase the middle number (the
+# SO "age") whenever functions are added to the API.
+set(TURBOJPEG_SO_MAJOR_VERSION 0)
+set(TURBOJPEG_SO_VERSION 0.2.0)
+
+
+###############################################################################
+# COMPILER SETTINGS
+###############################################################################
 
 if(MSVC)
   option(WITH_CRT_DLL
-    "Link all libjpeg-turbo libraries and executables with the C run-time DLL (msvcr*.dll) instead of the static C run-time library (libcmt*.lib.)  The default is to use the C run-time DLL only with the libraries and executables that need it."
+    "Link all ${CMAKE_PROJECT_NAME} libraries and executables with the C run-time DLL (msvcr*.dll) instead of the static C run-time library (libcmt*.lib.)  The default is to use the C run-time DLL only with the libraries and executables that need it."
     FALSE)
   if(NOT WITH_CRT_DLL)
     # Use the static C library for all build types
@@ -149,45 +306,32 @@ if(MSVC)
       endif()
     endforeach()
   endif()
-  add_definitions(-W3 -wd4996)
-endif()
-
-# Detect whether compiler is 64-bit
-if(MSVC AND CMAKE_CL_64)
-  set(SIMD_X86_64 1)
-  set(64BIT 1)
-elseif(CMAKE_SIZEOF_VOID_P MATCHES 8)
-  set(SIMD_X86_64 1)
-  set(64BIT 1)
+  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /W3 /wd4996")
 endif()
 
-if(64BIT)
-  message(STATUS "64-bit build")
-else()
-  message(STATUS "32-bit build")
+if(CMAKE_COMPILER_IS_GNUCC OR CMAKE_C_COMPILER_ID STREQUAL "Clang")
+  # Use the maximum optimization level for release builds
+  foreach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO)
+    if(${var} MATCHES "-O2")
+      string(REGEX REPLACE "-O2" "-O3" ${var} "${${var}}")
+    endif()
+  endforeach()
 endif()
 
-if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
-  if(MSVC)
-    set(CMAKE_INSTALL_PREFIX_DEFAULT ${CMAKE_PROJECT_NAME})
-  else()
-    set(CMAKE_INSTALL_PREFIX_DEFAULT ${CMAKE_PROJECT_NAME}-gcc)
-  endif()
-  if(64BIT)
-    set(CMAKE_INSTALL_PREFIX_DEFAULT ${CMAKE_INSTALL_PREFIX_DEFAULT}64)
+if(CMAKE_SYSTEM_NAME STREQUAL "SunOS")
+  if(CMAKE_C_COMPILER_ID MATCHES "SunPro")
+    # Use the maximum optimization level for release builds
+    foreach(var CMAKE_C_FLAGS_RELEASE CMAKE_C_FLAGS_RELWITHDEBINFO)
+      if(${var} MATCHES "-xO3")
+        string(REGEX REPLACE "-xO3" "-xO5" ${var} "${${var}}")
+      endif()
+      if(${var} MATCHES "-xO2")
+        string(REGEX REPLACE "-xO2" "-xO5" ${var} "${${var}}")
+      endif()
+    endforeach()
   endif()
-  set(CMAKE_INSTALL_PREFIX "c:/${CMAKE_INSTALL_PREFIX_DEFAULT}" CACHE PATH
-    "Directory into which to install libjpeg-turbo (default: c:/${CMAKE_INSTALL_PREFIX_DEFAULT})"
-    FORCE)
 endif()
 
-message(STATUS "Install directory = ${CMAKE_INSTALL_PREFIX}")
-
-configure_file(win/jconfig.h.in jconfig.h)
-configure_file(win/jconfigint.h.in jconfigint.h)
-
-include_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_SOURCE_DIR})
-
 string(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)
 
 set(EFFECTIVE_C_FLAGS "${CMAKE_C_FLAGS} ${CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE_UC}}")
@@ -196,26 +340,161 @@ message(STATUS "Compiler flags = ${EFFECTIVE_C_FLAGS}")
 set(EFFECTIVE_LD_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${CMAKE_EXE_LINKER_FLAGS_${CMAKE_BUILD_TYPE_UC}}")
 message(STATUS "Linker flags = ${EFFECTIVE_LD_FLAGS}")
 
-if(WITH_JAVA)
-  find_package(Java)
-  find_package(JNI)
-  if(DEFINED JAVACFLAGS)
-    message(STATUS "Java compiler flags = ${JAVACFLAGS}")
+include(CheckCSourceCompiles)
+
+if(UNIX)
+  # Check for headers
+  include(CheckIncludeFiles)
+  check_include_files(locale.h HAVE_LOCALE_H)
+  check_include_files(stddef.h HAVE_STDDEF_H)
+  check_include_files(stdlib.h HAVE_STDLIB_H)
+  check_include_files(sys/types.h NEED_SYS_TYPES_H)
+
+  # Check for functions
+  include(CheckFunctionExists)
+  check_function_exists(memset HAVE_MEMSET)
+  check_function_exists(memcpy HAVE_MEMCPY)
+  if(NOT HAVE_MEMSET AND NOT HAVE_MEMCPY)
+    set(NEED_BSD_STRINGS 1)
+  endif()
+
+  # Check for types
+  include(CheckTypeSize)
+  check_type_size("unsigned char" UNSIGNED_CHAR)
+  check_type_size("unsigned short" UNSIGNED_SHORT)
+  check_type_size("size_t" SIZE_T)
+
+  # Check for compiler features
+  check_c_source_compiles("int main(void) { typedef struct undefined_structure *undef_struct_ptr; }"
+    INCOMPLETE_TYPES)
+  if(INCOMPLETE_TYPES)
+    message(STATUS "Compiler supports pointers to undefined structures.")
+  else()
+    set(INCOMPLETE_TYPES_BROKEN 1)
+    message(STATUS "Compiler does not support pointers to undefined structures.")
+  endif()
+
+  if(CMAKE_CROSSCOMPILING)
+    set(RIGHT_SHIFT_IS_UNSIGNED 0)
+  else()
+    include(CheckCSourceRuns)
+    check_c_source_runs("
+      #include <stdio.h>
+      #include <stdlib.h>
+      int is_shifting_signed (long arg) {
+        long res = arg >> 4;
+        if (res == -0x7F7E80CL)
+          return 1; /* right shift is signed */
+        /* see if unsigned-shift hack will fix it. */
+        /* we can't just test exact value since it depends on width of long... */
+        res |= (~0L) << (32-4);
+        if (res == -0x7F7E80CL)
+          return 0; /* right shift is unsigned */
+        printf(\"Right shift isn't acting as I expect it to.\\\\n\");
+        printf(\"I fear the JPEG software will not work at all.\\\\n\\\\n\");
+        return 0; /* try it with unsigned anyway */
+      }
+      int main (void) {
+        exit(is_shifting_signed(-0x7F7E80B1L));
+      }" RIGHT_SHIFT_IS_UNSIGNED)
+  endif()
+
+  if(CMAKE_CROSSCOMPILING)
+    set(__CHAR_UNSIGNED__ 0)
+  else()
+    check_c_source_runs("int main(void) { return ((char) -1 < 0); }"
+      __CHAR_UNSIGNED__)
   endif()
 endif()
 
+if(MSVC)
+  set(INLINE_OPTIONS "__inline;inline")
+else()
+  set(INLINE_OPTIONS "__inline__;inline")
+endif()
+option(FORCE_INLINE "Force function inlining" TRUE)
+boolean_number(FORCE_INLINE)
+if(FORCE_INLINE)
+  if(MSVC)
+    list(INSERT INLINE_OPTIONS 0 "__forceinline")
+  else()
+    list(INSERT INLINE_OPTIONS 0 "inline __attribute__((always_inline))")
+    list(INSERT INLINE_OPTIONS 0 "__inline__ __attribute__((always_inline))")
+  endif()
+endif()
+foreach(inline ${INLINE_OPTIONS})
+  check_c_source_compiles("${inline} static void foo(void) {} int main(void) { foo(); }"
+    INLINE_WORKS)
+  if(INLINE_WORKS)
+    set(INLINE ${inline})
+    break()
+  endif()
+endforeach()
+if(NOT INLINE_WORKS)
+  message(FATAL_ERROR "Could not determine how to inline functions.")
+endif()
+message(STATUS "INLINE = ${INLINE} (FORCE_INLINE = ${FORCE_INLINE})")
+
+if(UNIX AND NOT APPLE)
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map "VERS_1 { global: *; };")
+  set(CMAKE_REQUIRED_FLAGS
+    "-Wl,--version-script,${CMAKE_CURRENT_BINARY_DIR}/conftest.map")
+  check_c_source_compiles("int main(void) { return 0; }" HAVE_VERSION_SCRIPT)
+  set(CMAKE_REQUIRED_FLAGS)
+  file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map)
+  if(HAVE_VERSION_SCRIPT)
+    message(STATUS "Linker supports GNU-style version scripts")
+    set(MAPFLAG "-Wl,--version-script,")
+    set(TJMAPFLAG "-Wl,--version-script,")
+  else()
+    message(STATUS "Linker does not support GNU-style version scripts")
+    if(CMAKE_SYSTEM_NAME STREQUAL "SunOS")
+      # The Solaris linker doesn't like our version script for the libjpeg API
+      # library, but the version script for the TurboJPEG API library should
+      # still work.
+      file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map
+        "VERS_1 { global: foo;  local: *; }; VERS_2 { global: foo2; } VERS_1;")
+      set(CMAKE_REQUIRED_FLAGS "-Wl,-M,${CMAKE_CURRENT_BINARY_DIR}/conftest.map")
+      check_c_source_compiles("void foo() {} void foo2() {} int main(void) { return 0; }"
+        HAVE_MAPFILE)
+      set(CMAKE_REQUIRED_FLAGS)
+      file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/conftest.map)
+      if(HAVE_MAPFILE)
+        message(STATUS "Linker supports mapfiles")
+        set(TJMAPFLAG "-Wl,-M,")
+      else()
+        message(STATUS "Linker does not support mapfiles")
+      endif()
+    endif()
+  endif()
+endif()
 
-#
-# Targets
-#
+# Generate files
+if(WIN32)
+  configure_file(win/jconfig.h.in jconfig.h)
+else()
+  configure_file(jconfig.h.in jconfig.h)
+endif()
+configure_file(jconfigint.h.in jconfigint.h)
+if(UNIX)
+  configure_file(libjpeg.map.in libjpeg.map)
+endif()
+
+# Include directories and compiler definitions
+include_directories(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR})
+
+
+###############################################################################
+# TARGETS
+###############################################################################
 
 set(JPEG_SOURCES jcapimin.c jcapistd.c jccoefct.c jccolor.c jcdctmgr.c jchuff.c
-  jcinit.c jcmainct.c jcmarker.c jcmaster.c jcomapi.c jcparam.c jcphuff.c
-  jcprepct.c jcsample.c jctrans.c jdapimin.c jdapistd.c jdatadst.c jdatasrc.c
-  jdcoefct.c jdcolor.c jddctmgr.c jdhuff.c jdinput.c jdmainct.c jdmarker.c
-  jdmaster.c jdmerge.c jdphuff.c jdpostct.c jdsample.c jdtrans.c jerror.c
-  jfdctflt.c jfdctfst.c jfdctint.c jidctflt.c jidctfst.c jidctint.c jidctred.c
-  jquant1.c jquant2.c jutils.c jmemmgr.c jmemnobs.c)
+  jcicc.c jcinit.c jcmainct.c jcmarker.c jcmaster.c jcomapi.c jcparam.c
+  jcphuff.c jcprepct.c jcsample.c jctrans.c jdapimin.c jdapistd.c jdatadst.c
+  jdatasrc.c jdcoefct.c jdcolor.c jddctmgr.c jdhuff.c jdicc.c jdinput.c
+  jdmainct.c jdmarker.c jdmaster.c jdmerge.c jdphuff.c jdpostct.c jdsample.c
+  jdtrans.c jerror.c jfdctflt.c jfdctfst.c jfdctint.c jidctflt.c jidctfst.c
+  jidctint.c jidctred.c jquant1.c jquant2.c jutils.c jmemmgr.c jmemnobs.c)
 
 if(WITH_ARITH_ENC OR WITH_ARITH_DEC)
   set(JPEG_SOURCES ${JPEG_SOURCES} jaricom.c)
@@ -230,74 +509,81 @@ if(WITH_ARITH_DEC)
 endif()
 
 if(WITH_SIMD)
-  add_definitions(-DWITH_SIMD)
   add_subdirectory(simd)
-  if(SIMD_X86_64)
-    set(JPEG_SOURCES ${JPEG_SOURCES} simd/jsimd_x86_64.c)
-  else()
-    set(JPEG_SOURCES ${JPEG_SOURCES} simd/jsimd_i386.c)
+elseif(NOT WITH_12BIT)
+  message(STATUS "SIMD extensions: None (WITH_SIMD = ${WITH_SIMD})")
+endif()
+if(WITH_SIMD)
+  message(STATUS "SIMD extensions: ${CPU_TYPE} (WITH_SIMD = ${WITH_SIMD})")
+  if(MSVC_IDE)
+    set_source_files_properties(${SIMD_OBJS} PROPERTIES GENERATED 1)
   endif()
-  # This tells CMake that the "source" files haven't been generated yet
-  set_source_files_properties(${SIMD_OBJS} PROPERTIES GENERATED 1)
 else()
-  set(JPEG_SOURCES ${JPEG_SOURCES} jsimd_none.c)
-  message(STATUS "Not using SIMD acceleration")
+  add_library(simd OBJECT jsimd_none.c)
 endif()
 
 if(WITH_JAVA)
   add_subdirectory(java)
-  set(ENABLE_SHARED TRUE)
 endif()
 
 if(ENABLE_SHARED)
   add_subdirectory(sharedlib)
 endif()
 
-if(ENABLE_STATIC OR WITH_TURBOJPEG)
-  add_library(jpeg-static STATIC ${JPEG_SOURCES} ${SIMD_OBJS})
+if(ENABLE_STATIC)
+  add_library(jpeg-static STATIC ${JPEG_SOURCES} $<TARGET_OBJECTS:simd>
+    ${SIMD_OBJS})
   if(NOT MSVC)
     set_target_properties(jpeg-static PROPERTIES OUTPUT_NAME jpeg)
   endif()
-  if(WITH_SIMD)
-    add_dependencies(jpeg-static simd)
-  endif()
 endif()
 
 if(WITH_TURBOJPEG)
-  set(TURBOJPEG_SOURCES turbojpeg.c transupp.c jdatadst-tj.c jdatasrc-tj.c)
-  if(WITH_JAVA)
-    set(TURBOJPEG_SOURCES ${TURBOJPEG_SOURCES} turbojpeg-jni.c)
-    include_directories(${JAVA_INCLUDE_PATH} ${JAVA_INCLUDE_PATH2})
-  endif()
-
   if(ENABLE_SHARED)
+    set(TURBOJPEG_SOURCES ${JPEG_SOURCES} $<TARGET_OBJECTS:simd> ${SIMD_OBJS}
+      turbojpeg.c transupp.c jdatadst-tj.c jdatasrc-tj.c)
+    set(TJMAPFILE ${CMAKE_CURRENT_SOURCE_DIR}/turbojpeg-mapfile)
+    if(WITH_JAVA)
+      set(TURBOJPEG_SOURCES ${TURBOJPEG_SOURCES} turbojpeg-jni.c)
+      include_directories(${JAVA_INCLUDE_PATH} ${JAVA_INCLUDE_PATH2})
+      set(TJMAPFILE ${CMAKE_CURRENT_SOURCE_DIR}/turbojpeg-mapfile.jni)
+    endif()
     add_library(turbojpeg SHARED ${TURBOJPEG_SOURCES})
-    set_target_properties(turbojpeg PROPERTIES DEFINE_SYMBOL DLLDEFINE)
+    if(WIN32)
+      set_target_properties(turbojpeg PROPERTIES DEFINE_SYMBOL DLLDEFINE)
+    endif()
     if(MINGW)
       set_target_properties(turbojpeg PROPERTIES LINK_FLAGS -Wl,--kill-at)
     endif()
-    target_link_libraries(turbojpeg jpeg-static)
-    set_target_properties(turbojpeg PROPERTIES LINK_INTERFACE_LIBRARIES "")
+    if(APPLE)
+      set_target_properties(turbojpeg PROPERTIES MACOSX_RPATH 1)
+    endif()
+    set_target_properties(turbojpeg PROPERTIES
+      SOVERSION ${TURBOJPEG_SO_MAJOR_VERSION} VERSION ${TURBOJPEG_SO_VERSION})
+    if(TJMAPFLAG)
+      set_target_properties(turbojpeg PROPERTIES
+        LINK_FLAGS "${TJMAPFLAG}${TJMAPFILE}")
+    endif()
 
     add_executable(tjunittest tjunittest.c tjutil.c)
     target_link_libraries(tjunittest turbojpeg)
 
     add_executable(tjbench tjbench.c bmp.c tjutil.c rdbmp.c rdppm.c wrbmp.c
       wrppm.c)
-    target_link_libraries(tjbench turbojpeg jpeg-static)
+    target_link_libraries(tjbench turbojpeg jpeg)
+    if(UNIX)
+      target_link_libraries(tjbench m)
+    endif()
     set_property(TARGET tjbench PROPERTY COMPILE_FLAGS
       "-DBMP_SUPPORTED -DPPM_SUPPORTED")
   endif()
 
   if(ENABLE_STATIC)
-    add_library(turbojpeg-static STATIC ${JPEG_SOURCES} ${SIMD_OBJS}
-      turbojpeg.c transupp.c jdatadst-tj.c jdatasrc-tj.c)
+    add_library(turbojpeg-static STATIC ${JPEG_SOURCES} $<TARGET_OBJECTS:simd>
+      ${SIMD_OBJS} turbojpeg.c transupp.c jdatadst-tj.c jdatasrc-tj.c)
     if(NOT MSVC)
       set_target_properties(turbojpeg-static PROPERTIES OUTPUT_NAME turbojpeg)
     endif()
-    if(WITH_SIMD)
-      add_dependencies(turbojpeg-static simd)
-    endif()
 
     add_executable(tjunittest-static tjunittest.c tjutil.c)
     target_link_libraries(tjunittest-static turbojpeg-static)
@@ -305,15 +591,21 @@ if(WITH_TURBOJPEG)
     add_executable(tjbench-static tjbench.c bmp.c tjutil.c rdbmp.c rdppm.c
       wrbmp.c wrppm.c)
     target_link_libraries(tjbench-static turbojpeg-static jpeg-static)
+    if(UNIX)
+      target_link_libraries(tjbench-static m)
+    endif()
     set_property(TARGET tjbench-static PROPERTY COMPILE_FLAGS
       "-DBMP_SUPPORTED -DPPM_SUPPORTED")
   endif()
 endif()
 
+if(WIN32)
+  set(USE_SETMODE "-DUSE_SETMODE")
+endif()
 if(WITH_12BIT)
-  set(COMPILE_FLAGS "-DGIF_SUPPORTED -DPPM_SUPPORTED -DUSE_SETMODE")
+  set(COMPILE_FLAGS "-DGIF_SUPPORTED -DPPM_SUPPORTED ${USE_SETMODE}")
 else()
-  set(COMPILE_FLAGS "-DBMP_SUPPORTED -DGIF_SUPPORTED -DPPM_SUPPORTED -DTARGA_SUPPORTED -DUSE_SETMODE")
+  set(COMPILE_FLAGS "-DBMP_SUPPORTED -DGIF_SUPPORTED -DPPM_SUPPORTED -DTARGA_SUPPORTED ${USE_SETMODE}")
   set(CJPEG_BMP_SOURCES rdbmp.c rdtarga.c)
   set(DJPEG_BMP_SOURCES wrbmp.c wrtarga.c)
 endif()
@@ -331,7 +623,7 @@ if(ENABLE_STATIC)
 
   add_executable(jpegtran-static jpegtran.c cdjpeg.c rdswitch.c transupp.c)
   target_link_libraries(jpegtran-static jpeg-static)
-  set_property(TARGET jpegtran-static PROPERTY COMPILE_FLAGS "-DUSE_SETMODE")
+  set_property(TARGET jpegtran-static PROPERTY COMPILE_FLAGS "${USE_SETMODE}")
 endif()
 
 add_executable(rdjpgcom rdjpgcom.c)
@@ -339,9 +631,9 @@ add_executable(rdjpgcom rdjpgcom.c)
 add_executable(wrjpgcom wrjpgcom.c)
 
 
-#
-# Tests
-#
+###############################################################################
+# TESTS
+###############################################################################
 
 add_subdirectory(md5)
 
@@ -355,7 +647,8 @@ enable_testing()
 
 if(WITH_12BIT)
   set(TESTORIG testorig12.jpg)
-  set(MD5_JPEG_RGB_ISLOW 9620f424569594bb9242b48498ad801f)
+  set(MD5_JPEG_RGB_ISLOW 9d7369207c520d37f2c1cbfcb82b2964)
+  set(MD5_JPEG_RGB_ISLOW2 a00bd20d8ae49684640ef7177d2e0b64)
   set(MD5_PPM_RGB_ISLOW f3301d2219783b8b3d942b7239fa50c0)
   set(MD5_JPEG_422_IFAST_OPT 7322e3bd2f127f7de4b40d4480ce60e4)
   set(MD5_PPM_422_IFAST 79807fa552899e66a04708f533e16950)
@@ -367,20 +660,20 @@ if(WITH_12BIT)
   set(MD5_PPM_GRAY_ISLOW 7213c10af507ad467da5578ca5ee1fca)
   set(MD5_PPM_GRAY_ISLOW_RGB e96ee81c30a6ed422d466338bd3de65d)
   set(MD5_JPEG_420S_IFAST_OPT 7af8e60be4d9c227ec63ac9b6630855e)
-  if(64BIT)
-    # Windows/x64 uses SSE for floating point
-    set(MD5_JPEG_3x2_FLOAT_PROG a8c17daf77b457725ec929e215b603f8)
-    set(MD5_PPM_3x2_FLOAT 42876ab9e5c2f76a87d08db5fbd57956)
-  else()
-    # Windows/x86 uses the 387 FPU for floating point
-    if(MSVC)
-      set(MD5_JPEG_3x2_FLOAT_PROG e27840755870fa849872e58aa0cd1400)
-      set(MD5_PPM_3x2_FLOAT 6c2880b83bb1aa41dfe330e7a9768690)
-    else()
-      set(MD5_JPEG_3x2_FLOAT_PROG bc6dbbefac2872f6b9d6c4a0ae60c3c0)
-      set(MD5_PPM_3x2_FLOAT f58119ee294198ac9b4a9f5645a34266)
-    endif()
-  endif()
+
+  set(MD5_JPEG_3x2_FLOAT_PROG_SSE a8c17daf77b457725ec929e215b603f8)
+  set(MD5_PPM_3x2_FLOAT_SSE 42876ab9e5c2f76a87d08db5fbd57956)
+  set(MD5_JPEG_3x2_FLOAT_PROG_32BIT a8c17daf77b457725ec929e215b603f8)
+  set(MD5_PPM_3x2_FLOAT_32BIT ${MD5_PPM_3x2_FLOAT_SSE})
+  set(MD5_JPEG_3x2_FLOAT_PROG_64BIT ${MD5_JPEG_3x2_FLOAT_PROG_32BIT})
+  set(MD5_PPM_3x2_FLOAT_64BIT ${MD5_PPM_3x2_FLOAT_SSE})
+  set(MD5_JPEG_3x2_FLOAT_PROG_387 bc6dbbefac2872f6b9d6c4a0ae60c3c0)
+  set(MD5_PPM_3x2_FLOAT_387 bcc5723c61560463ac60f772e742d092)
+  set(MD5_JPEG_3x2_FLOAT_PROG_MSVC e27840755870fa849872e58aa0cd1400)
+  set(MD5_PPM_3x2_FLOAT_MSVC 6c2880b83bb1aa41dfe330e7a9768690)
+
+  set(MD5_JPEG_3x2_IFAST_PROG 1396cc2b7185cfe943d408c9d305339e)
+  set(MD5_PPM_3x2_IFAST 3975985ef6eeb0a2cdc58daa651ccc00)
   set(MD5_PPM_420M_ISLOW_2_1 4ca6be2a6f326ff9eaab63e70a8259c0)
   set(MD5_PPM_420M_ISLOW_15_8 12aa9f9534c1b3d7ba047322226365eb)
   set(MD5_PPM_420M_ISLOW_13_8 f7e22817c7b25e1393e4ec101e9d4e96)
@@ -400,7 +693,8 @@ if(WITH_12BIT)
   set(MD5_JPEG_CROP cdb35ff4b4519392690ea040c56ea99c)
 else()
   set(TESTORIG testorig.jpg)
-  set(MD5_JPEG_RGB_ISLOW 768e970dd57b340ff1b83c9d3d47c77b)
+  set(MD5_JPEG_RGB_ISLOW 1d44a406f61da743b5fd31c0a9abdca3)
+  set(MD5_JPEG_RGB_ISLOW2 31d121e57b6c2934c890a7fc7763bcd4)
   set(MD5_PPM_RGB_ISLOW 00a257f5393fef8821f2b88ac7421291)
   set(MD5_BMP_RGB_ISLOW_565 f07d2e75073e4bb10f6c6f4d36e2e3be)
   set(MD5_BMP_RGB_ISLOW_565D 4cfa0928ef3e6bb626d7728c924cfda4)
@@ -418,23 +712,20 @@ else()
   set(MD5_BMP_GRAY_ISLOW_565 12f78118e56a2f48b966f792fedf23cc)
   set(MD5_BMP_GRAY_ISLOW_565D bdbbd616441a24354c98553df5dc82db)
   set(MD5_JPEG_420S_IFAST_OPT 388708217ac46273ca33086b22827ed8)
-  if(WITH_SIMD)
-    set(MD5_JPEG_3x2_FLOAT_PROG 343e3f8caf8af5986ebaf0bdc13b5c71)
-    set(MD5_PPM_3x2_FLOAT 1a75f36e5904d6fc3a85a43da9ad89bb)
-  else()
-    if(64BIT)
-      set(MD5_JPEG_3x2_FLOAT_PROG 9bca803d2042bd1eb03819e2bf92b3e5)
-      set(MD5_PPM_3x2_FLOAT f6bfab038438ed8f5522fbd33595dcdc)
-    else()
-      if(MSVC)
-        set(MD5_JPEG_3x2_FLOAT_PROG 7999ce9cd0ee9b6c7043b7351ab7639d)
-        set(MD5_PPM_3x2_FLOAT 28cdc448a6b75e97892f0e0f8d4b21f3)
-      else()
-        set(MD5_JPEG_3x2_FLOAT_PROG 1657664a410e0822c924b54f6f65e6e9)
-        set(MD5_PPM_3x2_FLOAT cb0a1f027f3d2917c902b5640214e025)
-      endif()
-    endif()
-  endif()
+
+  set(MD5_JPEG_3x2_FLOAT_PROG_SSE 343e3f8caf8af5986ebaf0bdc13b5c71)
+  set(MD5_PPM_3x2_FLOAT_SSE 1a75f36e5904d6fc3a85a43da9ad89bb)
+  set(MD5_JPEG_3x2_FLOAT_PROG_32BIT 9bca803d2042bd1eb03819e2bf92b3e5)
+  set(MD5_PPM_3x2_FLOAT_32BIT f6bfab038438ed8f5522fbd33595dcdc)
+  set(MD5_JPEG_3x2_FLOAT_PROG_64BIT ${MD5_JPEG_3x2_FLOAT_PROG_32BIT})
+  set(MD5_PPM_3x2_FLOAT_64BIT 0e917a34193ef976b679a6b069b1be26)
+  set(MD5_JPEG_3x2_FLOAT_PROG_387 1657664a410e0822c924b54f6f65e6e9)
+  set(MD5_PPM_3x2_FLOAT_387 cb0a1f027f3d2917c902b5640214e025)
+  set(MD5_JPEG_3x2_FLOAT_PROG_MSVC 7999ce9cd0ee9b6c7043b7351ab7639d)
+  set(MD5_PPM_3x2_FLOAT_MSVC 28cdc448a6b75e97892f0e0f8d4b21f3)
+
+  set(MD5_JPEG_3x2_IFAST_PROG 1ee5d2c1a77f2da495f993c8c7cceca5)
+  set(MD5_PPM_3x2_IFAST fd283664b3b49127984af0a7f118fccd)
   set(MD5_JPEG_420_ISLOW_ARI e986fb0a637a8d833d96e8a6d6d84ea1)
   set(MD5_JPEG_444_ISLOW_PROGARI 0a8f1c8f66e113c3cf635df0a475a617)
   set(MD5_PPM_420M_IFAST_ARI 72b59a99bcf1de24c5b27d151bde2437)
@@ -468,27 +759,27 @@ endif()
 
 if(WITH_JAVA)
   add_test(TJUnitTest
-    ${JAVA_RUNTIME} -cp java/${OBJDIR}turbojpeg.jar
+    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar
       -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}
       TJUnitTest)
   add_test(TJUnitTest-yuv
-    ${JAVA_RUNTIME} -cp java/${OBJDIR}turbojpeg.jar
+    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar
       -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}
       TJUnitTest -yuv)
   add_test(TJUnitTest-yuv-nopad
-    ${JAVA_RUNTIME} -cp java/${OBJDIR}turbojpeg.jar
+    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar
       -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}
       TJUnitTest -yuv -noyuvpad)
   add_test(TJUnitTest-bi
-    ${JAVA_RUNTIME} -cp java/${OBJDIR}turbojpeg.jar
+    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar
       -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}
       TJUnitTest -bi)
   add_test(TJUnitTest-bi-yuv
-    ${JAVA_RUNTIME} -cp java/${OBJDIR}turbojpeg.jar
+    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar
       -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}
       TJUnitTest -bi -yuv)
   add_test(TJUnitTest-bi-yuv-nopad
-    ${JAVA_RUNTIME} -cp java/${OBJDIR}turbojpeg.jar
+    ${Java_JAVA_EXECUTABLE} ${JAVAARGS} -cp java/turbojpeg.jar
       -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}/${OBJDIR}
       TJUnitTest -bi -yuv -noyuvpad)
 endif()
@@ -501,214 +792,324 @@ if(ENABLE_STATIC)
   set(TEST_LIBTYPES ${TEST_LIBTYPES} static)
 endif()
 
-set(TESTIMAGES ${CMAKE_SOURCE_DIR}/testimages)
+set(TESTIMAGES ${CMAKE_CURRENT_SOURCE_DIR}/testimages)
 set(MD5CMP ${CMAKE_CURRENT_BINARY_DIR}/md5/md5cmp)
 if(CMAKE_CROSSCOMPILING)
   file(RELATIVE_PATH TESTIMAGES ${CMAKE_CURRENT_BINARY_DIR} ${TESTIMAGES})
   file(RELATIVE_PATH MD5CMP ${CMAKE_CURRENT_BINARY_DIR} ${MD5CMP})
 endif()
 
+# The output of the floating point DCT/IDCT algorithms differs depending on the
+# type of floating point math used, so the FLOATTEST CMake variable must be
+# set in order to tell the testing system which floating point results it
+# should expect:
+#
+# sse = validate against the expected results from the libjpeg-turbo SSE SIMD
+#       extensions
+# 32bit = validate against the expected results from the C code when running on
+#         a 32-bit FPU (or when SSE is being used for floating point math,
+#         which is generally the default with x86-64 compilers)
+# 64bit = validate against the expected results from the C code when running
+#         on a 64-bit FPU
+# 387 = validate against the expected results from the C code when the 387 FPU
+#       is being used for floating point math (which is generally the default
+#       with x86 compilers)
+# msvc = validate against the expected results from the C code when compiled
+#        with a 32-bit version of Visual C++
+
+if(CPU_TYPE STREQUAL "x86_64" OR CPU_TYPE STREQUAL "i386")
+  if(WITH_SIMD)
+    set(DEFAULT_FLOATTEST sse)
+  elseif(CPU_TYPE STREQUAL "x86_64")
+    set(DEFAULT_FLOATTEST 32bit)
+  elseif(CPU_TYPE STREQUAL "i386" AND MSVC)
+    set(DEFAULT_FLOATTEST msvc)
+  endif()
+else()
+  if(BITS EQUAL 64)
+    set(DEFAULT_FLOATTEST 64bit)
+  elseif(BITS EQUAL 32)
+    set(DEFAULT_FLOATTEST 32bit)
+  endif()
+endif()
+
+# This causes FLOATTEST to reset to the default value if WITH_SIMD has
+# changed.
+if(DEFINED WITH_SIMD_INT AND NOT WITH_SIMD EQUAL WITH_SIMD_INT)
+  set(FORCE_FLOATTEST "FORCE")
+endif()
+set(WITH_SIMD_INT ${WITH_SIMD} CACHE INTERNAL "")
+set(FLOATTEST ${DEFAULT_FLOATTEST} CACHE STRING
+  "The type of floating point math used by the floating point DCT/IDCT algorithms.  This tells the testing system which numerical results it should expect from those tests.  [sse = libjpeg-turbo x86/x86-64 SIMD extensions, 32bit = generic 32-bit FPU or SSE, 64bit = generic 64-bit FPU, 387 = 387 FPU, msvc = 32-bit Visual Studio] (default = ${DEFAULT_FLOATTEST})"
+  ${FORCE_FLOATTEST})
+message(STATUS "FLOATTEST = ${FLOATTEST}")
+
+if(FLOATTEST)
+  string(TOUPPER ${FLOATTEST} FLOATTEST_UC)
+  string(TOLOWER ${FLOATTEST} FLOATTEST)
+  if(NOT FLOATTEST STREQUAL "sse" AND NOT FLOATTEST STREQUAL "32bit" AND
+    NOT FLOATTEST STREQUAL "64bit" AND NOT FLOATTEST STREQUAL "387" AND
+    NOT FLOATTEST STREQUAL "msvc")
+    message(FATAL_ERROR "\"${FLOATTEST}\" is not a valid value for FLOATTEST.")
+  endif()
+endif()
+
 foreach(libtype ${TEST_LIBTYPES})
-  if(libtype STREQUAL "shared")
-    set(dir sharedlib/)
-  else()
-    set(dir "")
+  if(libtype STREQUAL "static")
     set(suffix -static)
   endif()
   if(WITH_TURBOJPEG)
-    add_test(tjunittest${suffix} tjunittest${suffix})
-    add_test(tjunittest${suffix}-alloc tjunittest${suffix} -alloc)
-    add_test(tjunittest${suffix}-yuv tjunittest${suffix} -yuv)
-    add_test(tjunittest${suffix}-yuv-alloc tjunittest${suffix} -yuv -alloc)
-    add_test(tjunittest${suffix}-yuv-nopad tjunittest${suffix} -yuv -noyuvpad)
+    add_test(tjunittest-${libtype} tjunittest${suffix})
+    add_test(tjunittest-${libtype}-alloc tjunittest${suffix} -alloc)
+    add_test(tjunittest-${libtype}-yuv tjunittest${suffix} -yuv)
+    add_test(tjunittest-${libtype}-yuv-alloc tjunittest${suffix} -yuv -alloc)
+    add_test(tjunittest-${libtype}-yuv-nopad tjunittest${suffix} -yuv -noyuvpad)
+
+    set(MD5_PPM_GRAY_TILE 89d3ca21213d9d864b50b4e4e7de4ca6)
+    set(MD5_PPM_420_8x8_TILE 847fceab15c5b7b911cb986cf0f71de3)
+    set(MD5_PPM_420_16x16_TILE ca45552a93687e078f7137cc4126a7b0)
+    set(MD5_PPM_420_32x32_TILE d8676f1d6b68df358353bba9844f4a00)
+    set(MD5_PPM_420_64x64_TILE 4e4c1a3d7ea4bace4f868bcbe83b7050)
+    set(MD5_PPM_420_128x128_TILE f24c3429c52265832beab9df72a0ceae)
+    set(MD5_PPM_420M_8x8_TILE bc25320e1f4c31ce2e610e43e9fd173c)
+    set(MD5_PPM_420M_TILE 75ffdf14602258c5c189522af57fa605)
+    set(MD5_PPM_422_8x8_TILE d83dacd9fc73b0a6f10c09acad64eb1e)
+    set(MD5_PPM_422_16x16_TILE 35077fb610d72dd743b1eb0cbcfe10fb)
+    set(MD5_PPM_422_32x32_TILE e6902ed8a449ecc0f0d6f2bf945f65f7)
+    set(MD5_PPM_422_64x64_TILE 2b4502a8f316cedbde1da7bce3d2231e)
+    set(MD5_PPM_422_128x128_TILE f0b5617d578f5e13c8eee215d64d4877)
+    set(MD5_PPM_422M_8x8_TILE 828941d7f41cd6283abd6beffb7fd51d)
+    set(MD5_PPM_422M_TILE e877ae1324c4a280b95376f7f018172f)
+    set(MD5_PPM_444_TILE 7964e41e67cfb8d0a587c0aa4798f9c3)
+
+    # Test compressing from/decompressing to an arbitrary subregion of a larger
+    # image buffer
+    add_test(tjbench-${libtype}-tile-cp
+      ${CMAKE_COMMAND} -E copy_if_different ${TESTIMAGES}/testorig.ppm
+        testout_tile.ppm)
+    add_test(tjbench-${libtype}-tile
+      tjbench${suffix} testout_tile.ppm 95 -rgb -quiet -tile -benchtime 0.01
+        -warmup 0)
+    set_tests_properties(tjbench-${libtype}-tile
+      PROPERTIES DEPENDS tjbench-${libtype}-tile-cp)
+
+    foreach(tile 8 16 32 64 128)
+      add_test(tjbench-${libtype}-tile-gray-${tile}x${tile}-cmp
+        ${MD5CMP} ${MD5_PPM_GRAY_TILE}
+          testout_tile_GRAY_Q95_${tile}x${tile}.ppm)
+      foreach(subsamp 420 422)
+        add_test(tjbench-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp
+          ${MD5CMP} ${MD5_PPM_${subsamp}_${tile}x${tile}_TILE}
+            testout_tile_${subsamp}_Q95_${tile}x${tile}.ppm)
+      endforeach()
+      add_test(tjbench-${libtype}-tile-444-${tile}x${tile}-cmp
+        ${MD5CMP} ${MD5_PPM_444_TILE}
+          testout_tile_444_Q95_${tile}x${tile}.ppm)
+      foreach(subsamp gray 420 422 444)
+        set_tests_properties(tjbench-${libtype}-tile-${subsamp}-${tile}x${tile}-cmp
+          PROPERTIES DEPENDS tjbench-${libtype}-tile)
+      endforeach()
+    endforeach()
+
+    add_test(tjbench-${libtype}-tilem-cp
+      ${CMAKE_COMMAND} -E copy_if_different ${TESTIMAGES}/testorig.ppm
+        testout_tilem.ppm)
+    add_test(tjbench-${libtype}-tilem
+      tjbench${suffix} testout_tilem.ppm 95 -rgb -fastupsample -quiet -tile
+        -benchtime 0.01 -warmup 0)
+    set_tests_properties(tjbench-${libtype}-tilem
+      PROPERTIES DEPENDS tjbench-${libtype}-tilem-cp)
+
+    add_test(tjbench-${libtype}-tile-420m-8x8-cmp
+      ${MD5CMP} ${MD5_PPM_420M_8x8_TILE} testout_tilem_420_Q95_8x8.ppm)
+    add_test(tjbench-${libtype}-tile-422m-8x8-cmp
+      ${MD5CMP} ${MD5_PPM_422M_8x8_TILE} testout_tilem_422_Q95_8x8.ppm)
+    foreach(tile 16 32 64 128)
+      foreach(subsamp 420 422)
+        add_test(tjbench-${libtype}-tile-${subsamp}m-${tile}x${tile}-cmp
+          ${MD5CMP} ${MD5_PPM_${subsamp}M_TILE}
+            testout_tilem_${subsamp}_Q95_${tile}x${tile}.ppm)
+      endforeach()
+    endforeach()
+    foreach(tile 8 16 32 64 128)
+      foreach(subsamp 420 422)
+        set_tests_properties(tjbench-${libtype}-tile-${subsamp}m-${tile}x${tile}-cmp
+          PROPERTIES DEPENDS tjbench-${libtype}-tilem)
+      endforeach()
+    endforeach()
   endif()
 
-  # These tests are carefully chosen to provide full coverage of as many of the
-  # underlying algorithms as possible (including all of the SIMD-accelerated
-  # ones.)
+  # These tests are carefully crafted to provide full coverage of as many of
+  # the underlying algorithms as possible (including all of the
+  # SIMD-accelerated ones.)
+
+  macro(add_bittest PROG NAME ARGS OUTFILE INFILE MD5SUM)
+    add_test(${PROG}-${libtype}-${NAME}
+      ${PROG}${suffix} ${ARGS} -outfile ${OUTFILE} ${INFILE})
+    add_test(${PROG}-${libtype}-${NAME}-cmp
+      ${MD5CMP} ${MD5SUM} ${OUTFILE})
+    set_tests_properties(${PROG}-${libtype}-${NAME}-cmp PROPERTIES
+      DEPENDS ${PROG}-${libtype}-${NAME})
+    if(${ARGC} GREATER 6)
+      set(DEPENDS ${ARGN})
+      set_tests_properties(${PROG}-${libtype}-${NAME} PROPERTIES
+        DEPENDS ${DEPENDS})
+    endif()
+  endmacro()
 
   # CC: null  SAMP: fullsize  FDCT: islow  ENT: huff
-  add_test(cjpeg${suffix}-rgb-islow
-    ${dir}cjpeg${suffix} -rgb -dct int
-      -outfile testout_rgb_islow.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(cjpeg${suffix}-rgb-islow-cmp
-    ${MD5CMP} ${MD5_JPEG_RGB_ISLOW} testout_rgb_islow.jpg)
+  add_bittest(cjpeg rgb-islow "-rgb;-dct;int;-icc;${TESTIMAGES}/test1.icc"
+    testout_rgb_islow.jpg ${TESTIMAGES}/testorig.ppm
+    ${MD5_JPEG_RGB_ISLOW})
 
   # CC: null  SAMP: fullsize  IDCT: islow  ENT: huff
-  add_test(djpeg${suffix}-rgb-islow
-    ${dir}djpeg${suffix} -dct int -ppm
-      -outfile testout_rgb_islow.ppm testout_rgb_islow.jpg)
-  add_test(djpeg${suffix}-rgb-islow-cmp
-    ${MD5CMP} ${MD5_PPM_RGB_ISLOW} testout_rgb_islow.ppm)
+  add_bittest(djpeg rgb-islow "-dct;int;-ppm;-icc;testout_rgb_islow.icc"
+    testout_rgb_islow.ppm testout_rgb_islow.jpg
+    ${MD5_PPM_RGB_ISLOW} cjpeg-${libtype}-rgb-islow)
+
+  add_test(djpeg-${libtype}-rgb-islow-icc-cmp
+    ${MD5CMP} b06a39d730129122e85c1363ed1bbc9e testout_rgb_islow.icc)
+
+  add_bittest(jpegtran icc "-copy;all;-icc;${TESTIMAGES}/test2.icc"
+    testout_rgb_islow2.jpg testout_rgb_islow.jpg ${MD5_JPEG_RGB_ISLOW2})
 
   if(NOT WITH_12BIT)
     # CC: RGB->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-rgb-islow-565
-      ${dir}djpeg${suffix} -dct int -rgb565 -dither none -bmp
-        -outfile testout_rgb_islow_565.bmp testout_rgb_islow.jpg)
-    add_test(djpeg${suffix}-rgb-islow-565-cmp
-      ${MD5CMP} ${MD5_BMP_RGB_ISLOW_565} testout_rgb_islow_565.bmp)
+    add_bittest(djpeg rgb-islow-565 "-dct;int;-rgb565;-dither;none;-bmp"
+      testout_rgb_islow_565.bmp testout_rgb_islow.jpg
+      ${MD5_BMP_RGB_ISLOW_565} cjpeg-${libtype}-rgb-islow)
 
     # CC: RGB->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-rgb-islow-565D
-      ${dir}djpeg${suffix} -dct int -rgb565 -bmp
-        -outfile testout_rgb_islow_565D.bmp testout_rgb_islow.jpg)
-    add_test(djpeg${suffix}-rgb-islow-565D-cmp
-      ${MD5CMP} ${MD5_BMP_RGB_ISLOW_565D} testout_rgb_islow_565D.bmp)
+    add_bittest(djpeg rgb-islow-565D "-dct;int;-rgb565;-bmp"
+      testout_rgb_islow_565D.bmp testout_rgb_islow.jpg
+      ${MD5_BMP_RGB_ISLOW_565D} cjpeg-${libtype}-rgb-islow)
   endif()
 
   # CC: RGB->YCC  SAMP: fullsize/h2v1  FDCT: ifast  ENT: 2-pass huff
-  add_test(cjpeg${suffix}-422-ifast-opt
-    ${dir}cjpeg${suffix} -sample 2x1 -dct fast -opt
-      -outfile testout_422_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(cjpeg${suffix}-422-ifast-opt-cmp
-    ${MD5CMP} ${MD5_JPEG_422_IFAST_OPT} testout_422_ifast_opt.jpg)
+  add_bittest(cjpeg 422-ifast-opt "-sample;2x1;-dct;fast;-opt"
+    testout_422_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm
+    ${MD5_JPEG_422_IFAST_OPT})
 
   # CC: YCC->RGB  SAMP: fullsize/h2v1 fancy  IDCT: ifast  ENT: huff
-  add_test(djpeg${suffix}-422-ifast
-    ${dir}djpeg${suffix} -dct fast
-      -outfile testout_422_ifast.ppm testout_422_ifast_opt.jpg)
-  add_test(djpeg${suffix}-422-ifast-cmp
-    ${MD5CMP} ${MD5_PPM_422_IFAST} testout_422_ifast.ppm)
+  add_bittest(djpeg 422-ifast "-dct;fast"
+    testout_422_ifast.ppm testout_422_ifast_opt.jpg
+    ${MD5_PPM_422_IFAST} cjpeg-${libtype}-422-ifast-opt)
 
   # CC: YCC->RGB  SAMP: h2v1 merged  IDCT: ifast  ENT: huff
-  add_test(djpeg${suffix}-422m-ifast
-    ${dir}djpeg${suffix} -dct fast -nosmooth
-      -outfile testout_422m_ifast.ppm testout_422_ifast_opt.jpg)
-  add_test(djpeg${suffix}-422m-ifast-cmp
-    ${MD5CMP} ${MD5_PPM_422M_IFAST} testout_422m_ifast.ppm)
+  add_bittest(djpeg 422m-ifast "-dct;fast;-nosmooth"
+    testout_422m_ifast.ppm testout_422_ifast_opt.jpg
+    ${MD5_PPM_422M_IFAST} cjpeg-${libtype}-422-ifast-opt)
 
   if(NOT WITH_12BIT)
     # CC: YCC->RGB565  SAMP: h2v1 merged  IDCT: ifast  ENT: huff
-    add_test(djpeg${suffix}-422m-ifast-565
-      ${dir}djpeg${suffix} -dct int -nosmooth -rgb565 -dither none -bmp
-        -outfile testout_422m_ifast_565.bmp testout_422_ifast_opt.jpg)
-    add_test(djpeg${suffix}-422m-ifast-565-cmp
-      ${MD5CMP} ${MD5_BMP_422M_IFAST_565} testout_422m_ifast_565.bmp)
+    add_bittest(djpeg 422m-ifast-565
+      "-dct;int;-nosmooth;-rgb565;-dither;none;-bmp"
+      testout_422m_ifast_565.bmp testout_422_ifast_opt.jpg
+      ${MD5_BMP_422M_IFAST_565} cjpeg-${libtype}-422-ifast-opt)
 
     # CC: YCC->RGB565 (dithered)  SAMP: h2v1 merged  IDCT: ifast  ENT: huff
-    add_test(djpeg${suffix}-422m-ifast-565D
-      ${dir}djpeg${suffix} -dct int -nosmooth -rgb565 -bmp
-        -outfile testout_422m_ifast_565D.bmp testout_422_ifast_opt.jpg)
-    add_test(djpeg${suffix}-422m-ifast-565D-cmp
-      ${MD5CMP} ${MD5_BMP_422M_IFAST_565D} testout_422m_ifast_565D.bmp)
+    add_bittest(djpeg 422m-ifast-565D "-dct;int;-nosmooth;-rgb565;-bmp"
+      testout_422m_ifast_565D.bmp testout_422_ifast_opt.jpg
+      ${MD5_BMP_422M_IFAST_565D} cjpeg-${libtype}-422-ifast-opt)
   endif()
 
   # CC: RGB->YCC  SAMP: fullsize/h2v2  FDCT: ifast  ENT: prog huff
-  add_test(cjpeg${suffix}-420-q100-ifast-prog
-    ${dir}cjpeg${suffix} -sample 2x2 -quality 100 -dct fast -prog
-      -outfile testout_420_q100_ifast_prog.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(cjpeg${suffix}-420-q100-ifast-prog-cmp
-    ${MD5CMP} ${MD5_JPEG_420_IFAST_Q100_PROG} testout_420_q100_ifast_prog.jpg)
+  add_bittest(cjpeg 420-q100-ifast-prog
+    "-sample;2x2;-quality;100;-dct;fast;-prog"
+    testout_420_q100_ifast_prog.jpg ${TESTIMAGES}/testorig.ppm
+    ${MD5_JPEG_420_IFAST_Q100_PROG})
 
   # CC: YCC->RGB  SAMP: fullsize/h2v2 fancy  IDCT: ifast  ENT: prog huff
-  add_test(djpeg${suffix}-420-q100-ifast-prog
-    ${dir}djpeg${suffix} -dct fast
-      -outfile testout_420_q100_ifast.ppm testout_420_q100_ifast_prog.jpg)
-  add_test(djpeg${suffix}-420-q100-ifast-prog-cmp
-    ${MD5CMP} ${MD5_PPM_420_Q100_IFAST} testout_420_q100_ifast.ppm)
+  add_bittest(djpeg 420-q100-ifast-prog "-dct;fast"
+    testout_420_q100_ifast.ppm testout_420_q100_ifast_prog.jpg
+    ${MD5_PPM_420_Q100_IFAST} cjpeg-${libtype}-420-q100-ifast-prog)
 
   # CC: YCC->RGB  SAMP: h2v2 merged  IDCT: ifast  ENT: prog huff
-  add_test(djpeg${suffix}-420m-q100-ifast-prog
-    ${dir}djpeg${suffix} -dct fast -nosmooth
-      -outfile testout_420m_q100_ifast.ppm testout_420_q100_ifast_prog.jpg)
-  add_test(djpeg${suffix}-420m-q100-ifast-prog-cmp
-    ${MD5CMP} ${MD5_PPM_420M_Q100_IFAST} testout_420m_q100_ifast.ppm)
+  add_bittest(djpeg 420m-q100-ifast-prog "-dct;fast;-nosmooth"
+    testout_420m_q100_ifast.ppm testout_420_q100_ifast_prog.jpg
+    ${MD5_PPM_420M_Q100_IFAST} cjpeg-${libtype}-420-q100-ifast-prog)
 
   # CC: RGB->Gray  SAMP: fullsize  FDCT: islow  ENT: huff
-  add_test(cjpeg${suffix}-gray-islow
-    ${dir}cjpeg${suffix} -gray -dct int
-      -outfile testout_gray_islow.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(cjpeg${suffix}-gray-islow-cmp
-    ${MD5CMP} ${MD5_JPEG_GRAY_ISLOW} testout_gray_islow.jpg)
+  add_bittest(cjpeg gray-islow "-gray;-dct;int"
+    testout_gray_islow.jpg ${TESTIMAGES}/testorig.ppm
+    ${MD5_JPEG_GRAY_ISLOW})
 
   # CC: Gray->Gray  SAMP: fullsize  IDCT: islow  ENT: huff
-  add_test(djpeg${suffix}-gray-islow
-    ${dir}djpeg${suffix} -dct int
-      -outfile testout_gray_islow.ppm testout_gray_islow.jpg)
-  add_test(djpeg${suffix}-gray-islow-cmp
-    ${MD5CMP} ${MD5_PPM_GRAY_ISLOW} testout_gray_islow.ppm)
+  add_bittest(djpeg gray-islow "-dct;int"
+    testout_gray_islow.ppm testout_gray_islow.jpg
+    ${MD5_PPM_GRAY_ISLOW} cjpeg-${libtype}-gray-islow)
 
   # CC: Gray->RGB  SAMP: fullsize  IDCT: islow  ENT: huff
-  add_test(djpeg${suffix}-gray-islow-rgb
-    ${dir}djpeg${suffix} -dct int -rgb
-      -outfile testout_gray_islow_rgb.ppm testout_gray_islow.jpg)
-  add_test(djpeg${suffix}-gray-islow-rgb-cmp
-    ${MD5CMP} ${MD5_PPM_GRAY_ISLOW_RGB} testout_gray_islow_rgb.ppm)
+  add_bittest(djpeg gray-islow-rgb "-dct;int;-rgb"
+    testout_gray_islow_rgb.ppm testout_gray_islow.jpg
+    ${MD5_PPM_GRAY_ISLOW_RGB} cjpeg-${libtype}-gray-islow)
 
   if(NOT WITH_12BIT)
     # CC: Gray->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-gray-islow-565
-      ${dir}djpeg${suffix} -dct int -rgb565 -dither none -bmp
-        -outfile testout_gray_islow_565.bmp testout_gray_islow.jpg)
-    add_test(djpeg${suffix}-gray-islow-565-cmp
-      ${MD5CMP} ${MD5_BMP_GRAY_ISLOW_565} testout_gray_islow_565.bmp)
+    add_bittest(djpeg gray-islow-565 "-dct;int;-rgb565;-dither;none;-bmp"
+      testout_gray_islow_565.bmp testout_gray_islow.jpg
+      ${MD5_BMP_GRAY_ISLOW_565} cjpeg-${libtype}-gray-islow)
 
     # CC: Gray->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-gray-islow-565D
-      ${dir}djpeg${suffix} -dct int -rgb565 -bmp
-        -outfile testout_gray_islow_565D.bmp testout_gray_islow.jpg)
-    add_test(djpeg${suffix}-gray-islow-565D-cmp
-      ${MD5CMP} ${MD5_BMP_GRAY_ISLOW_565D} testout_gray_islow_565D.bmp)
+    add_bittest(djpeg gray-islow-565D "-dct;int;-rgb565;-bmp"
+      testout_gray_islow_565D.bmp testout_gray_islow.jpg
+      ${MD5_BMP_GRAY_ISLOW_565D} cjpeg-${libtype}-gray-islow)
   endif()
 
   # CC: RGB->YCC  SAMP: fullsize smooth/h2v2 smooth  FDCT: islow
   # ENT: 2-pass huff
-  add_test(cjpeg${suffix}-420s-ifast-opt
-    ${dir}cjpeg${suffix} -sample 2x2 -smooth 1 -dct int -opt
-      -outfile testout_420s_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(cjpeg${suffix}-420s-ifast-opt-cmp
-    ${MD5CMP} ${MD5_JPEG_420S_IFAST_OPT} testout_420s_ifast_opt.jpg)
-
-  # CC: RGB->YCC  SAMP: fullsize/int  FDCT: float  ENT: prog huff
-  add_test(cjpeg${suffix}-3x2-float-prog
-    ${dir}cjpeg${suffix} -sample 3x2 -dct float -prog
-      -outfile testout_3x2_float_prog.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(cjpeg${suffix}-3x2-float-prog-cmp
-    ${MD5CMP} ${MD5_JPEG_3x2_FLOAT_PROG} testout_3x2_float_prog.jpg)
-
-  # CC: YCC->RGB  SAMP: fullsize/int  IDCT: float  ENT: prog huff
-  add_test(djpeg${suffix}-3x2-float-prog
-    ${dir}djpeg${suffix} -dct float
-      -outfile testout_3x2_float.ppm testout_3x2_float_prog.jpg)
-  add_test(djpeg${suffix}-3x2-float-prog-cmp
-    ${MD5CMP} ${MD5_PPM_3x2_FLOAT} testout_3x2_float.ppm)
+  add_bittest(cjpeg 420s-ifast-opt "-sample;2x2;-smooth;1;-dct;int;-opt"
+    testout_420s_ifast_opt.jpg ${TESTIMAGES}/testorig.ppm
+    ${MD5_JPEG_420S_IFAST_OPT})
+
+  if(FLOATTEST)
+    # CC: RGB->YCC  SAMP: fullsize/int  FDCT: float  ENT: prog huff
+    add_bittest(cjpeg 3x2-float-prog "-sample;3x2;-dct;float;-prog"
+      testout_3x2_float_prog.jpg ${TESTIMAGES}/testorig.ppm
+      ${MD5_JPEG_3x2_FLOAT_PROG_${FLOATTEST_UC}})
+
+    # CC: YCC->RGB  SAMP: fullsize/int  IDCT: float  ENT: prog huff
+    add_bittest(djpeg 3x2-float-prog "-dct;float"
+      testout_3x2_float.ppm testout_3x2_float_prog.jpg
+      ${MD5_PPM_3x2_FLOAT_${FLOATTEST_UC}} cjpeg-${libtype}-3x2-float-prog)
+  endif()
+
+    # CC: RGB->YCC  SAMP: fullsize/int  FDCT: ifast  ENT: prog huff
+  add_bittest(cjpeg 3x2-ifast-prog "-sample;3x2;-dct;fast;-prog"
+    testout_3x2_ifast_prog.jpg ${TESTIMAGES}/testorig.ppm
+    ${MD5_JPEG_3x2_IFAST_PROG})
+
+  # CC: YCC->RGB  SAMP: fullsize/int  IDCT: ifast  ENT: prog huff
+  add_bittest(djpeg 3x2-ifast-prog "-dct;fast"
+    testout_3x2_ifast.ppm testout_3x2_ifast_prog.jpg
+    ${MD5_PPM_3x2_IFAST} cjpeg-${libtype}-3x2-ifast-prog)
 
   if(WITH_ARITH_ENC)
     # CC: YCC->RGB  SAMP: fullsize/h2v2  FDCT: islow  ENT: arith
-    add_test(cjpeg${suffix}-420-islow-ari
-      ${dir}cjpeg${suffix} -dct int -arithmetic
-        -outfile testout_420_islow_ari.jpg ${TESTIMAGES}/testorig.ppm)
-    add_test(cjpeg${suffix}-420-islow-ari-cmp
-      ${MD5CMP} ${MD5_JPEG_420_ISLOW_ARI} testout_420_islow_ari.jpg)
-
-    add_test(jpegtran${suffix}-420-islow-ari
-      ${dir}jpegtran${suffix} -arithmetic
-        -outfile testout_420_islow_ari.jpg ${TESTIMAGES}/testimgint.jpg)
-    add_test(jpegtran${suffix}-420-islow-ari-cmp
-      ${MD5CMP} ${MD5_JPEG_420_ISLOW_ARI} testout_420_islow_ari.jpg)
+    add_bittest(cjpeg 420-islow-ari "-dct;int;-arithmetic"
+      testout_420_islow_ari.jpg ${TESTIMAGES}/testorig.ppm
+      ${MD5_JPEG_420_ISLOW_ARI})
+
+    add_bittest(jpegtran 420-islow-ari "-arithmetic"
+      testout_420_islow_ari2.jpg ${TESTIMAGES}/testimgint.jpg
+      ${MD5_JPEG_420_ISLOW_ARI})
 
     # CC: YCC->RGB  SAMP: fullsize  FDCT: islow  ENT: prog arith
-    add_test(cjpeg${suffix}-444-islow-progari
-      ${dir}cjpeg${suffix} -sample 1x1 -dct int -prog -arithmetic
-        -outfile testout_444_islow_progari.jpg ${TESTIMAGES}/testorig.ppm)
-    add_test(cjpeg${suffix}-444-islow-progari-cmp
-      ${MD5CMP} ${MD5_JPEG_444_ISLOW_PROGARI} testout_444_islow_progari.jpg)
+    add_bittest(cjpeg 444-islow-progari
+      "-sample;1x1;-dct;int;-prog;-arithmetic"
+      testout_444_islow_progari.jpg ${TESTIMAGES}/testorig.ppm
+      ${MD5_JPEG_444_ISLOW_PROGARI})
   endif()
 
   if(WITH_ARITH_DEC)
     # CC: RGB->YCC  SAMP: h2v2 merged  IDCT: ifast  ENT: arith
-    add_test(djpeg${suffix}-420m-ifast-ari
-      ${dir}djpeg${suffix} -fast -ppm
-        -outfile testout_420m_ifast_ari.ppm ${TESTIMAGES}/testimgari.jpg)
-    add_test(djpeg${suffix}-420m-ifast-ari-cmp
-      ${MD5CMP} ${MD5_PPM_420M_IFAST_ARI} testout_420m_ifast_ari.ppm)
+    add_bittest(djpeg 420m-ifast-ari "-fast;-ppm"
+      testout_420m_ifast_ari.ppm ${TESTIMAGES}/testimgari.jpg
+      ${MD5_PPM_420M_IFAST_ARI})
 
-    add_test(jpegtran${suffix}-420-islow
-      ${dir}jpegtran${suffix}
-        -outfile testout_420_islow.jpg ${TESTIMAGES}/testimgari.jpg)
-    add_test(jpegtran${suffix}-420-islow-cmp
-      ${MD5CMP} ${MD5_JPEG_420_ISLOW} testout_420_islow.jpg)
+    add_bittest(jpegtran 420-islow ""
+      testout_420_islow.jpg ${TESTIMAGES}/testimgari.jpg
+      ${MD5_JPEG_420_ISLOW})
   endif()
 
   # 2/1--   CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 16x16 islow  ENT: huff
@@ -732,231 +1133,205 @@ foreach(libtype ${TEST_LIBTYPES})
   #         ENT: huff
   foreach(scale 2_1 15_8 13_8 11_8 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8)
     string(REGEX REPLACE "_" "/" scalearg ${scale})
-    add_test(djpeg${suffix}-420m-islow-${scale}
-      ${dir}djpeg${suffix} -dct int -scale ${scalearg} -nosmooth -ppm
-        -outfile testout_420m_islow_${scale}.ppm ${TESTIMAGES}/${TESTORIG})
-    add_test(djpeg${suffix}-420m-islow-${scale}-cmp
-      ${MD5CMP} ${MD5_PPM_420M_ISLOW_${scale}} testout_420m_islow_${scale}.ppm)
+    add_bittest(djpeg 420m-islow-${scale}
+      "-dct;int;-scale;${scalearg};-nosmooth;-ppm"
+      testout_420m_islow_${scale}.ppm ${TESTIMAGES}/${TESTORIG}
+      ${MD5_PPM_420M_ISLOW_${scale}})
   endforeach()
 
   if(NOT WITH_12BIT)
     # CC: YCC->RGB (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-420-islow-256
-      ${dir}djpeg${suffix} -dct int -colors 256 -bmp
-        -outfile testout_420_islow_256.bmp ${TESTIMAGES}/${TESTORIG})
-    add_test(djpeg${suffix}-420-islow-256-cmp
-      ${MD5CMP} ${MD5_BMP_420_ISLOW_256} testout_420_islow_256.bmp)
+    add_bittest(djpeg 420-islow-256 "-dct;int;-colors;256;-bmp"
+      testout_420_islow_256.bmp ${TESTIMAGES}/${TESTORIG}
+      ${MD5_BMP_420_ISLOW_256})
 
     # CC: YCC->RGB565  SAMP: h2v2 fancy  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-420-islow-565
-      ${dir}djpeg${suffix} -dct int -rgb565 -dither none -bmp
-        -outfile testout_420_islow_565.bmp ${TESTIMAGES}/${TESTORIG})
-    add_test(djpeg${suffix}-420-islow-565-cmp
-      ${MD5CMP} ${MD5_BMP_420_ISLOW_565} testout_420_islow_565.bmp)
+    add_bittest(djpeg 420-islow-565 "-dct;int;-rgb565;-dither;none;-bmp"
+      testout_420_islow_565.bmp ${TESTIMAGES}/${TESTORIG}
+      ${MD5_BMP_420_ISLOW_565})
 
     # CC: YCC->RGB565 (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-420-islow-565D
-      ${dir}djpeg${suffix} -dct int -rgb565 -bmp
-        -outfile testout_420_islow_565D.bmp ${TESTIMAGES}/${TESTORIG})
-    add_test(djpeg${suffix}-420-islow-565D-cmp
-      ${MD5CMP} ${MD5_BMP_420_ISLOW_565D} testout_420_islow_565D.bmp)
+    add_bittest(djpeg 420-islow-565D "-dct;int;-rgb565;-bmp"
+      testout_420_islow_565D.bmp ${TESTIMAGES}/${TESTORIG}
+      ${MD5_BMP_420_ISLOW_565D})
 
     # CC: YCC->RGB565  SAMP: h2v2 merged  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-420m-islow-565
-      ${dir}djpeg${suffix} -dct int -nosmooth -rgb565 -dither none -bmp
-        -outfile testout_420m_islow_565.bmp ${TESTIMAGES}/${TESTORIG})
-    add_test(djpeg${suffix}-420m-islow-565-cmp
-      ${MD5CMP} ${MD5_BMP_420M_ISLOW_565} testout_420m_islow_565.bmp)
+    add_bittest(djpeg 420m-islow-565
+      "-dct;int;-nosmooth;-rgb565;-dither;none;-bmp"
+      testout_420m_islow_565.bmp ${TESTIMAGES}/${TESTORIG}
+      ${MD5_BMP_420M_ISLOW_565})
 
     # CC: YCC->RGB565 (dithered)  SAMP: h2v2 merged  IDCT: islow  ENT: huff
-    add_test(djpeg${suffix}-420m-islow-565D
-      ${dir}djpeg${suffix} -dct int -nosmooth -rgb565 -bmp
-        -outfile testout_420m_islow_565D.bmp ${TESTIMAGES}/${TESTORIG})
-    add_test(djpeg${suffix}-420m-islow-565D-cmp
-      ${MD5CMP} ${MD5_BMP_420M_ISLOW_565D} testout_420m_islow_565D.bmp)
+    add_bittest(djpeg 420m-islow-565D "-dct;int;-nosmooth;-rgb565;-bmp"
+      testout_420m_islow_565D.bmp ${TESTIMAGES}/${TESTORIG}
+      ${MD5_BMP_420M_ISLOW_565D})
   endif()
 
   # Partial decode tests.  These tests are designed to cover all of the
   # possible code paths in jpeg_skip_scanlines().
 
   # Context rows: Yes  Intra-iMCU row: Yes  iMCU row prefetch: No   ENT: huff
-  add_test(djpeg${suffix}-420-islow-skip15_31
-    ${dir}djpeg${suffix} -dct int -skip 15,31 -ppm
-      -outfile testout_420_islow_skip15,31.ppm ${TESTIMAGES}/${TESTORIG})
-  add_test(djpeg${suffix}-420-islow-skip15_31-cmp
-    ${MD5CMP} ${MD5_PPM_420_ISLOW_SKIP15_31} testout_420_islow_skip15,31.ppm)
+  add_bittest(djpeg 420-islow-skip15_31 "-dct;int;-skip;15,31;-ppm"
+    testout_420_islow_skip15,31.ppm ${TESTIMAGES}/${TESTORIG}
+    ${MD5_PPM_420_ISLOW_SKIP15_31})
 
   # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: Yes  ENT: arith
   if(WITH_ARITH_DEC)
-    add_test(djpeg${suffix}-420-islow-ari-skip16_139
-      ${dir}djpeg${suffix} -dct int -skip 16,139 -ppm
-        -outfile testout_420_islow_ari_skip16,139.ppm
-        ${TESTIMAGES}/testimgari.jpg)
-    add_test(djpeg${suffix}-420-islow-ari_skip16_139-cmp
-      ${MD5CMP} ${MD5_PPM_420_ISLOW_ARI_SKIP16_139}
-        testout_420_islow_ari_skip16,139.ppm)
+    add_bittest(djpeg 420-islow-ari-skip16_139 "-dct;int;-skip;16,139;-ppm"
+      testout_420_islow_ari_skip16,139.ppm ${TESTIMAGES}/testimgari.jpg
+      ${MD5_PPM_420_ISLOW_ARI_SKIP16_139})
   endif()
 
   # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No   ENT: prog huff
-  add_test(cjpeg${suffix}-420-islow-prog
-    ${dir}cjpeg${suffix} -dct int -prog
+  add_test(cjpeg-${libtype}-420-islow-prog
+    cjpeg${suffix} -dct int -prog
       -outfile testout_420_islow_prog.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(djpeg${suffix}-420-islow-prog-crop62x62_71_71
-    ${dir}djpeg${suffix} -dct int -crop 62x62+71+71 -ppm
-      -outfile testout_420_islow_prog_crop62x62,71,71.ppm
-      testout_420_islow_prog.jpg)
-  add_test(djpeg${suffix}-420-islow-prog-crop62x62_71_71-cmp
-    ${MD5CMP} ${MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71}
-      testout_420_islow_prog_crop62x62,71,71.ppm)
+  add_bittest(djpeg 420-islow-prog-crop62x62_71_71
+    "-dct;int;-crop;62x62+71+71;-ppm"
+    testout_420_islow_prog_crop62x62,71,71.ppm testout_420_islow_prog.jpg
+    ${MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71} cjpeg-${libtype}-420-islow-prog)
 
   # Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No   ENT: arith
   if(WITH_ARITH_DEC)
-    add_test(djpeg${suffix}-420-islow-ari-crop53x53_4_4
-      ${dir}djpeg${suffix} -dct int -crop 53x53+4+4 -ppm
-        -outfile testout_420_islow_ari_crop53x53,4,4.ppm
-        ${TESTIMAGES}/testimgari.jpg)
-    add_test(djpeg${suffix}-420-islow-ari-crop53x53_4_4-cmp
-      ${MD5CMP} ${MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4}
-        testout_420_islow_ari_crop53x53,4,4.ppm)
+    add_bittest(djpeg 420-islow-ari-crop53x53_4_4
+      "-dct;int;-crop;53x53+4+4;-ppm"
+      testout_420_islow_ari_crop53x53,4,4.ppm ${TESTIMAGES}/testimgari.jpg
+      ${MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4})
   endif()
 
   # Context rows: No   Intra-iMCU row: Yes  ENT: huff
-  add_test(cjpeg${suffix}-444-islow
-    ${dir}cjpeg${suffix} -dct int -sample 1x1
+  add_test(cjpeg-${libtype}-444-islow
+    cjpeg${suffix} -dct int -sample 1x1
       -outfile testout_444_islow.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(djpeg${suffix}-444-islow-skip1_6
-    ${dir}djpeg${suffix} -dct int -skip 1,6 -ppm
-      -outfile testout_444_islow_skip1,6.ppm testout_444_islow.jpg)
-  add_test(djpeg${suffix}-444-islow-skip1_6-cmp
-    ${MD5CMP} ${MD5_PPM_444_ISLOW_SKIP1_6} testout_444_islow_skip1,6.ppm)
+  add_bittest(djpeg 444-islow-skip1_6 "-dct;int;-skip;1,6;-ppm"
+    testout_444_islow_skip1,6.ppm testout_444_islow.jpg
+    ${MD5_PPM_444_ISLOW_SKIP1_6} cjpeg-${libtype}-444-islow)
 
   # Context rows: No   Intra-iMCU row: No   ENT: prog huff
-  add_test(cjpeg${suffix}-444-islow-prog
-    ${dir}cjpeg${suffix} -dct int -prog -sample 1x1
+  add_test(cjpeg-${libtype}-444-islow-prog
+    cjpeg${suffix} -dct int -prog -sample 1x1
       -outfile testout_444_islow_prog.jpg ${TESTIMAGES}/testorig.ppm)
-  add_test(djpeg${suffix}-444-islow-prog-crop98x98_13_13
-    ${dir}djpeg${suffix} -dct int -crop 98x98+13+13 -ppm
-      -outfile testout_444_islow_prog_crop98x98,13,13.ppm
-      testout_444_islow_prog.jpg)
-  add_test(djpeg${suffix}-444-islow-prog_crop98x98_13_13-cmp
-    ${MD5CMP} ${MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13}
-      testout_444_islow_prog_crop98x98,13,13.ppm)
+  add_bittest(djpeg 444-islow-prog-crop98x98_13_13
+    "-dct;int;-crop;98x98+13+13;-ppm"
+    testout_444_islow_prog_crop98x98,13,13.ppm testout_444_islow_prog.jpg
+    ${MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13} cjpeg-${libtype}-444-islow-prog)
 
   # Context rows: No   Intra-iMCU row: No   ENT: arith
   if(WITH_ARITH_ENC)
-    add_test(cjpeg${suffix}-444-islow-ari
-      ${dir}cjpeg${suffix} -dct int -arithmetic -sample 1x1
+    add_test(cjpeg-${libtype}-444-islow-ari
+      cjpeg${suffix} -dct int -arithmetic -sample 1x1
         -outfile testout_444_islow_ari.jpg ${TESTIMAGES}/testorig.ppm)
     if(WITH_ARITH_DEC)
-      add_test(djpeg${suffix}-444-islow-ari-crop37x37_0_0
-        ${dir}djpeg${suffix} -dct int -crop 37x37+0+0 -ppm
-          -outfile testout_444_islow_ari_crop37x37,0,0.ppm
-          testout_444_islow_ari.jpg)
-      add_test(djpeg${suffix}-444-islow-ari-crop37x37_0_0-cmp
-        ${MD5CMP} ${MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0}
-          testout_444_islow_ari_crop37x37,0,0.ppm)
+      add_bittest(djpeg 444-islow-ari-crop37x37_0_0
+        "-dct;int;-crop;37x37+0+0;-ppm"
+        testout_444_islow_ari_crop37x37,0,0.ppm testout_444_islow_ari.jpg
+        ${MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0} cjpeg-${libtype}-444-islow-ari)
     endif()
   endif()
 
-  add_test(jpegtran${suffix}-crop
-    ${dir}jpegtran${suffix} -crop 120x90+20+50 -transpose -perfect
-      -outfile testout_crop.jpg ${TESTIMAGES}/${TESTORIG})
-  add_test(jpegtran${suffix}-crop-cmp
-    ${MD5CMP} ${MD5_JPEG_CROP} testout_crop.jpg)
+  add_bittest(jpegtran crop "-crop;120x90+20+50;-transpose;-perfect"
+    testout_crop.jpg ${TESTIMAGES}/${TESTORIG}
+    ${MD5_JPEG_CROP})
 
 endforeach()
 
 add_custom_target(testclean COMMAND ${CMAKE_COMMAND} -P
-  ${CMAKE_SOURCE_DIR}/cmakescripts/testclean.cmake)
-
-
-#
-# Installer
-#
-
-if(MSVC)
-  set(INST_PLATFORM "Visual C++")
-  set(INST_NAME ${CMAKE_PROJECT_NAME}-${VERSION}-vc)
-  set(INST_REG_NAME ${CMAKE_PROJECT_NAME})
-elseif(MINGW)
-  set(INST_PLATFORM GCC)
-  set(INST_NAME ${CMAKE_PROJECT_NAME}-${VERSION}-gcc)
-  set(INST_REG_NAME ${CMAKE_PROJECT_NAME}-gcc)
-  set(INST_DEFS -DGCC)
-endif()
+  ${CMAKE_CURRENT_SOURCE_DIR}/cmakescripts/testclean.cmake)
 
-if(64BIT)
-  set(INST_PLATFORM "${INST_PLATFORM} 64-bit")
-  set(INST_NAME ${INST_NAME}64)
-  set(INST_REG_NAME ${INST_DIR}64)
-  set(INST_DEFS ${INST_DEFS} -DWIN64)
-endif()
-
-if(WITH_JAVA)
-  set(INST_DEFS ${INST_DEFS} -DJAVA)
-endif()
-
-if(MSVC_IDE)
-  set(INST_DEFS ${INST_DEFS} "-DBUILDDIR=${CMAKE_CFG_INTDIR}\\")
-else()
-  set(INST_DEFS ${INST_DEFS} "-DBUILDDIR=")
+if(WITH_TURBOJPEG)
+  configure_file(tjbenchtest.in tjbenchtest @ONLY)
+  if(WITH_JAVA)
+    configure_file(tjbenchtest.java.in tjbenchtest.java @ONLY)
+    configure_file(tjexampletest.in tjexampletest @ONLY)
+    add_custom_target(tjtest
+      echo ./tjbenchtest COMMAND ./tjbenchtest
+      COMMAND echo ./tjbenchtest -alloc COMMAND ./tjbenchtest -alloc
+      COMMAND echo ./tjbenchtest -yuv COMMAND ./tjbenchtest -yuv
+      COMMAND echo ./tjbenchtest -yuv -alloc COMMAND ./tjbenchtest -yuv -alloc
+      COMMAND echo ./tjbenchtest.java COMMAND ./tjbenchtest.java
+      COMMAND echo ./tjbenchtest.java -yuv COMMAND ./tjbenchtest.java -yuv
+      COMMAND echo ./tjexampletest COMMAND ./tjexampletest
+      DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest
+        ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest.java
+        ${CMAKE_CURRENT_BINARY_DIR}/tjexampletest)
+  else()
+    add_custom_target(tjtest
+      echo ./tjbenchtest COMMAND ./tjbenchtest
+      COMMAND echo ./tjbenchtest -alloc COMMAND ./tjbenchtest -alloc
+      COMMAND echo ./tjbenchtest -yuv COMMAND ./tjbenchtest -yuv
+      COMMAND echo ./tjbenchtest -yuv -alloc COMMAND ./tjbenchtest -yuv -alloc
+      DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/tjbenchtest)
+  endif()
 endif()
 
-STRING(REGEX REPLACE "/" "\\\\" INST_DIR ${CMAKE_INSTALL_PREFIX})
 
-configure_file(release/libjpeg-turbo.nsi.in libjpeg-turbo.nsi @ONLY)
+###############################################################################
+# INSTALLATION
+###############################################################################
 
-if(WITH_JAVA)
-  set(JAVA_DEPEND java)
+if(WIN32)
+  set(EXE ".exe")
 endif()
-add_custom_target(installer
-  makensis -nocd ${INST_DEFS} libjpeg-turbo.nsi
-  DEPENDS jpeg jpeg-static turbojpeg turbojpeg-static rdjpgcom wrjpgcom
-    cjpeg djpeg jpegtran tjbench ${JAVA_DEPEND}
-  SOURCES libjpeg-turbo.nsi)
 
 if(WITH_TURBOJPEG)
   if(ENABLE_SHARED)
     install(TARGETS turbojpeg tjbench
-      ARCHIVE DESTINATION lib
-      LIBRARY DESTINATION lib
-      RUNTIME DESTINATION bin)
+      ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+      LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+      RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
   endif()
   if(ENABLE_STATIC)
-    install(TARGETS turbojpeg-static ARCHIVE DESTINATION lib)
+    install(TARGETS turbojpeg-static ARCHIVE
+      DESTINATION ${CMAKE_INSTALL_LIBDIR})
     if(NOT ENABLE_SHARED)
-      install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/tjbench-static.exe
-        DESTINATION bin RENAME tjbench.exe)
+      install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/tjbench-static${EXE}
+        DESTINATION ${CMAKE_INSTALL_BINDIR} RENAME tjbench${EXE})
     endif()
   endif()
-  install(FILES ${CMAKE_SOURCE_DIR}/turbojpeg.h DESTINATION include)
+  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/turbojpeg.h
+    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
 endif()
 
 if(ENABLE_STATIC)
-  install(TARGETS jpeg-static ARCHIVE DESTINATION lib)
+  install(TARGETS jpeg-static ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
   if(NOT ENABLE_SHARED)
-    install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/cjpeg-static.exe
-      DESTINATION bin RENAME cjpeg.exe)
-    install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/djpeg-static.exe
-      DESTINATION bin RENAME djpeg.exe)
-    install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/jpegtran-static.exe
-      DESTINATION bin RENAME jpegtran.exe)
+    install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/cjpeg-static${EXE}
+      DESTINATION ${CMAKE_INSTALL_BINDIR} RENAME cjpeg${EXE})
+    install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/djpeg-static${EXE}
+      DESTINATION ${CMAKE_INSTALL_BINDIR} RENAME djpeg${EXE})
+    install(PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/jpegtran-static${EXE}
+      DESTINATION ${CMAKE_INSTALL_BINDIR} RENAME jpegtran${EXE})
   endif()
 endif()
 
-install(TARGETS rdjpgcom wrjpgcom RUNTIME DESTINATION bin)
+install(TARGETS rdjpgcom wrjpgcom RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
+
+install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/README.ijg
+  ${CMAKE_CURRENT_SOURCE_DIR}/README.md ${CMAKE_CURRENT_SOURCE_DIR}/example.c
+  ${CMAKE_CURRENT_SOURCE_DIR}/libjpeg.txt
+  ${CMAKE_CURRENT_SOURCE_DIR}/structure.txt
+  ${CMAKE_CURRENT_SOURCE_DIR}/usage.txt ${CMAKE_CURRENT_SOURCE_DIR}/wizard.txt
+  ${CMAKE_CURRENT_SOURCE_DIR}/LICENSE.md DESTINATION ${CMAKE_INSTALL_DOCDIR})
+
+if(UNIX)
+  install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/cjpeg.1
+    ${CMAKE_CURRENT_SOURCE_DIR}/djpeg.1 ${CMAKE_CURRENT_SOURCE_DIR}/jpegtran.1
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdjpgcom.1
+    ${CMAKE_CURRENT_SOURCE_DIR}/wrjpgcom.1
+    DESTINATION ${CMAKE_INSTALL_MANDIR}/man1)
+  install(FILES ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/libjpeg.pc
+    ${CMAKE_CURRENT_BINARY_DIR}/pkgscripts/libturbojpeg.pc
+    DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
+endif()
 
-install(FILES ${CMAKE_SOURCE_DIR}/README.ijg ${CMAKE_SOURCE_DIR}/README.md
-  ${CMAKE_SOURCE_DIR}/example.c ${CMAKE_SOURCE_DIR}/libjpeg.txt
-  ${CMAKE_SOURCE_DIR}/structure.txt ${CMAKE_SOURCE_DIR}/usage.txt
-  ${CMAKE_SOURCE_DIR}/wizard.txt
-  DESTINATION doc)
+install(FILES ${CMAKE_CURRENT_BINARY_DIR}/jconfig.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/jerror.h ${CMAKE_CURRENT_SOURCE_DIR}/jmorecfg.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/jpeglib.h
+  DESTINATION ${CMAKE_INSTALL_INCLUDEDIR})
 
-install(FILES ${CMAKE_BINARY_DIR}/jconfig.h ${CMAKE_SOURCE_DIR}/jerror.h
-  ${CMAKE_SOURCE_DIR}/jmorecfg.h ${CMAKE_SOURCE_DIR}/jpeglib.h
-  DESTINATION include)
+include(cmakescripts/BuildPackages.cmake)
 
-configure_file("${CMAKE_SOURCE_DIR}/cmakescripts/cmake_uninstall.cmake.in"
+configure_file("${CMAKE_CURRENT_SOURCE_DIR}/cmakescripts/cmake_uninstall.cmake.in"
   "cmake_uninstall.cmake" IMMEDIATE @ONLY)
 
 add_custom_target(uninstall COMMAND ${CMAKE_COMMAND} -P cmake_uninstall.cmake)
diff --git a/ChangeLog.md b/ChangeLog.md
index d694787..ab1e769 100644
--- a/ChangeLog.md
+++ b/ChangeLog.md
@@ -1,3 +1,71 @@
+1.6 pre-beta
+============
+
+### Significant changes relative to 1.5.2:
+
+1. Added AVX2 SIMD implementations of the colorspace conversion, chroma
+downsampling and upsampling, and integer quantization algorithms.  This speeds
+up the compression of RGB images by approximately 10-20% when using 64-bit code
+and 8-16% when using 32-bit code, and the decompression of RGB images by
+approximately 6-15% when using 64-bit code and 4-12% when using 32-bit code.
+(As tested on a 3 GHz Intel Core i7.  Actual mileage may vary.)
+
+2. Overhauled the build system to use CMake on all platforms, and removed the
+autotools-based build system.  This decision resulted from extensive
+discussions within the libjpeg-turbo community.  libjpeg-turbo traditionally
+used CMake only for Windows builds, but there was an increasing amount of
+demand to extend CMake support to other platforms.  However, because of the
+unique nature of our code base (the need to support different assemblers on
+each platform, the need for Java support, etc.), providing dual build systems
+as other OSS imaging libraries do (including libpng and libtiff) would have
+created a maintenance burden.  The use of CMake greatly simplifies some aspects
+of our build system, owing to CMake's built-in support for various assemblers,
+Java, and unit testing, as well as generally fewer quirks that have to be
+worked around in order to implement our packaging system.  Eliminating
+autotools puts our project slightly at odds with the traditional practices of
+the OSS community, since most "system libraries" tend to be built with
+autotools, but it is believed that the benefits of this move outweigh the
+risks.  In addition to providing a unified build environment, switching to
+CMake allows for the use of various build tools and IDEs that aren't supported
+under autotools, including XCode, Ninja, and Eclipse.  It also eliminates the
+need to install autotools via MacPorts/Homebrew on OS X and allows
+libjpeg-turbo to be configured without the use of a terminal/command prompt.
+Extensive testing was conducted to ensure that all features provided by the
+autotools-based build system are provided by the new build system.
+
+3. The libjpeg API in this version of libjpeg-turbo now includes two additional
+functions, `jpeg_read_icc_profile()` and `jpeg_write_icc_profile()`, that can
+be used to extract ICC profile data from a JPEG file while decompressing or to
+embed ICC profile data in a JPEG file while compressing or transforming.  This
+eliminates the need for downstream projects, such as color management libraries
+and browsers, to include their own glueware for accomplishing this.
+
+4. Improved error handling in the TurboJPEG API library:
+
+     - Introduced a new function (`tjGetErrorStr2()`) in the TurboJPEG C API
+that allows compression/decompression/transform error messages to be retrieved
+in a thread-safe manner.  Retrieving error messages from global functions, such
+as `tjInitCompress()` or `tjBufSize()`, is still thread-unsafe, but since those
+functions will only throw errors if passed an invalid argument or if a memory
+allocation failure occurs, thread safety is not as much of a concern.
+     - Introduced a new function (`tjGetErrorCode()`) in the TurboJPEG C API
+and a new method (`TJException.getErrorCode()`) in the TurboJPEG Java API that
+can be used to determine the severity of the last
+compression/decompression/transform error.  This allows applications to
+choose whether to ignore warnings (non-fatal errors) from the underlying
+libjpeg API or to treat them as fatal.
+     - Introduced a new flag (`TJFLAG_STOPONWARNING` in the TurboJPEG C API and
+`TJ.FLAG_STOPONWARNING` in the TurboJPEG Java API) that causes the library to
+immediately halt a compression/decompression/transform operation if it
+encounters a warning from the underlying libjpeg API (the default behavior is
+to allow the operation to complete unless a fatal error is encountered.)
+
+5. Introduced a new flag in the TurboJPEG C and Java APIs (`TJFLAG_PROGRESSIVE`
+and `TJ.FLAG_PROGRESSIVE`, respectively) that causes the library to use
+progressive entropy coding in JPEG images generated by compression and
+transform operations.
+
+
 1.5.2
 =====
 
diff --git a/LICENSE.md b/LICENSE.md
index 0572390..8dfc045 100644
--- a/LICENSE.md
+++ b/LICENSE.md
@@ -11,7 +11,8 @@ libjpeg-turbo is covered by three compatible BSD-style open source licenses:
 
 - The Modified (3-clause) BSD License, which is listed below
 
-  This license covers the TurboJPEG API library and associated programs.
+  This license covers the TurboJPEG API library and associated programs, as
+  well as the build system.
 
 - The zlib License, which is listed below
 
diff --git a/Makefile.am b/Makefile.am
deleted file mode 100644
index eb099ea..0000000
--- a/Makefile.am
+++ /dev/null
@@ -1,792 +0,0 @@
-lib_LTLIBRARIES = libjpeg.la
-libjpeg_la_LDFLAGS = -version-info ${LIBTOOL_CURRENT}:${SO_MINOR_VERSION}:${SO_AGE} -no-undefined
-include_HEADERS = jerror.h jmorecfg.h jpeglib.h
-
-if WITH_TURBOJPEG
-lib_LTLIBRARIES += libturbojpeg.la
-libturbojpeg_la_LDFLAGS = -version-info 1:0:1 -no-undefined
-include_HEADERS += turbojpeg.h
-endif
-
-nodist_include_HEADERS = jconfig.h
-
-pkgconfigdir = $(libdir)/pkgconfig
-pkgconfig_DATA = pkgscripts/libjpeg.pc
-if WITH_TURBOJPEG
-pkgconfig_DATA += pkgscripts/libturbojpeg.pc
-endif
-
-HDRS = jchuff.h jdct.h jdhuff.h jerror.h jinclude.h jmemsys.h jmorecfg.h \
-	jpegint.h jpeglib.h jversion.h jsimd.h jsimddct.h jpegcomp.h \
-	jpeg_nbits_table.h
-
-libjpeg_la_SOURCES = $(HDRS) jcapimin.c jcapistd.c jccoefct.c jccolor.c \
-	jcdctmgr.c jchuff.c jcinit.c jcmainct.c jcmarker.c jcmaster.c \
-	jcomapi.c jcparam.c jcphuff.c jcprepct.c jcsample.c jctrans.c \
-	jdapimin.c jdapistd.c jdatadst.c jdatasrc.c jdcoefct.c jdcolor.c \
-	jddctmgr.c jdhuff.c jdinput.c jdmainct.c jdmarker.c jdmaster.c \
-	jdmerge.c jdphuff.c jdpostct.c jdsample.c jdtrans.c jerror.c \
-	jfdctflt.c jfdctfst.c jfdctint.c jidctflt.c jidctfst.c jidctint.c \
-	jidctred.c jquant1.c jquant2.c jutils.c jmemmgr.c jmemnobs.c
-
-if WITH_ARITH
-libjpeg_la_SOURCES += jaricom.c
-endif
-
-if WITH_ARITH_ENC
-libjpeg_la_SOURCES += jcarith.c
-endif
-
-if WITH_ARITH_DEC
-libjpeg_la_SOURCES += jdarith.c
-endif
-
-
-SUBDIRS = java
-
-
-if WITH_TURBOJPEG
-
-libturbojpeg_la_SOURCES = $(libjpeg_la_SOURCES) turbojpeg.c turbojpeg.h \
-	transupp.c transupp.h jdatadst-tj.c jdatasrc-tj.c
-
-if WITH_JAVA
-
-libturbojpeg_la_SOURCES += turbojpeg-jni.c
-libturbojpeg_la_CFLAGS = ${JNI_CFLAGS}
-TJMAPFILE = turbojpeg-mapfile.jni
-
-else
-
-TJMAPFILE = turbojpeg-mapfile
-
-endif
-
-libturbojpeg_la_SOURCES += $(TJMAPFILE)
-
-if VERSION_SCRIPT
-libturbojpeg_la_LDFLAGS += $(VERSION_SCRIPT_FLAG)$(srcdir)/$(TJMAPFILE)
-endif
-
-endif
-
-
-if VERSION_SCRIPT
-libjpeg_la_LDFLAGS += $(VERSION_SCRIPT_FLAG)libjpeg.map
-endif
-
-
-if WITH_SIMD
-
-SUBDIRS += simd
-libjpeg_la_LIBADD = simd/libsimd.la
-libturbojpeg_la_LIBADD = simd/libsimd.la
-
-else
-
-libjpeg_la_SOURCES += jsimd_none.c
-
-endif
-
-
-bin_PROGRAMS = cjpeg djpeg jpegtran rdjpgcom wrjpgcom
-noinst_PROGRAMS = jcstest
-
-
-if WITH_TURBOJPEG
-
-bin_PROGRAMS += tjbench
-
-noinst_PROGRAMS += tjunittest
-
-tjbench_SOURCES = tjbench.c bmp.h bmp.c tjutil.h tjutil.c rdbmp.c rdppm.c \
-	wrbmp.c wrppm.c
-
-tjbench_LDADD = libturbojpeg.la libjpeg.la -lm
-
-tjbench_CFLAGS = -DBMP_SUPPORTED -DPPM_SUPPORTED
-
-tjunittest_SOURCES = tjunittest.c tjutil.h tjutil.c
-
-tjunittest_LDADD = libturbojpeg.la
-
-endif
-
-
-cjpeg_SOURCES = cdjpeg.h cderror.h cdjpeg.c cjpeg.c rdgif.c rdppm.c rdswitch.c
-if WITH_12BIT
-else
-cjpeg_SOURCES += rdbmp.c rdtarga.c
-endif
-
-cjpeg_LDADD = libjpeg.la
-
-cjpeg_CFLAGS = -DGIF_SUPPORTED -DPPM_SUPPORTED
-if WITH_12BIT
-else
-cjpeg_CFLAGS += -DBMP_SUPPORTED -DTARGA_SUPPORTED
-endif
-
-djpeg_SOURCES = cdjpeg.h cderror.h cdjpeg.c djpeg.c rdcolmap.c rdswitch.c \
-	wrgif.c wrppm.c
-if WITH_12BIT
-else
-djpeg_SOURCES += wrbmp.c wrtarga.c
-endif
-
-djpeg_LDADD = libjpeg.la
-
-djpeg_CFLAGS = -DGIF_SUPPORTED -DPPM_SUPPORTED
-if WITH_12BIT
-else
-djpeg_CFLAGS += -DBMP_SUPPORTED -DTARGA_SUPPORTED
-endif
-
-jpegtran_SOURCES = jpegtran.c rdswitch.c cdjpeg.c transupp.c transupp.h
-
-jpegtran_LDADD = libjpeg.la
-
-rdjpgcom_SOURCES = rdjpgcom.c
-
-rdjpgcom_LDADD = libjpeg.la
-
-wrjpgcom_SOURCES = wrjpgcom.c
-
-wrjpgcom_LDADD = libjpeg.la
-
-jcstest_SOURCES = jcstest.c
-
-jcstest_LDADD = libjpeg.la
-
-dist_man1_MANS = cjpeg.1 djpeg.1 jpegtran.1 rdjpgcom.1 wrjpgcom.1
-
-DOCS= coderules.txt jconfig.txt change.log rdrle.c wrrle.c BUILDING.md \
-	ChangeLog.md
-
-dist_doc_DATA = README.ijg README.md libjpeg.txt structure.txt usage.txt \
-	wizard.txt LICENSE.md
-
-exampledir = $(docdir)
-dist_example_DATA = example.c
-
-
-EXTRA_DIST = win release $(DOCS) testimages CMakeLists.txt \
-	sharedlib/CMakeLists.txt cmakescripts libjpeg.map.in doc doxygen.config \
-	doxygen-extra.css jccolext.c jdcolext.c jdcol565.c jdmrgext.c jdmrg565.c \
-	jstdhuff.c jdcoefct.h jdmainct.h jdmaster.h jdsample.h wrppm.h \
-	md5/CMakeLists.txt
-
-dist-hook:
-	rm -rf `find $(distdir) -name .svn`
-
-
-SUBDIRS += md5
-
-if WITH_12BIT
-
-TESTORIG = testorig12.jpg
-MD5_JPEG_RGB_ISLOW = 9620f424569594bb9242b48498ad801f
-MD5_PPM_RGB_ISLOW = f3301d2219783b8b3d942b7239fa50c0
-MD5_JPEG_422_IFAST_OPT = 7322e3bd2f127f7de4b40d4480ce60e4
-MD5_PPM_422_IFAST = 79807fa552899e66a04708f533e16950
-MD5_PPM_422M_IFAST = 07737bfe8a7c1c87aaa393a0098d16b0
-MD5_JPEG_420_IFAST_Q100_PROG = a1da220b5604081863a504297ed59e55
-MD5_PPM_420_Q100_IFAST = 1b3730122709f53d007255e8dfd3305e
-MD5_PPM_420M_Q100_IFAST = 980a1a3c5bf9510022869d30b7d26566
-MD5_JPEG_GRAY_ISLOW = 235c90707b16e2e069f37c888b2636d9
-MD5_PPM_GRAY_ISLOW = 7213c10af507ad467da5578ca5ee1fca
-MD5_PPM_GRAY_ISLOW_RGB = e96ee81c30a6ed422d466338bd3de65d
-MD5_JPEG_420S_IFAST_OPT = 7af8e60be4d9c227ec63ac9b6630855e
-MD5_JPEG_3x2_FLOAT_PROG_SSE = a8c17daf77b457725ec929e215b603f8
-MD5_PPM_3x2_FLOAT_SSE = 42876ab9e5c2f76a87d08db5fbd57956
-MD5_JPEG_3x2_FLOAT_PROG_32BIT = a8c17daf77b457725ec929e215b603f8
-MD5_PPM_3x2_FLOAT_32BIT = 42876ab9e5c2f76a87d08db5fbd57956
-MD5_PPM_3x2_FLOAT_64BIT = d6fbc71153b3d8ded484dbc17c7b9cf4
-MD5_JPEG_3x2_FLOAT_PROG_387 = bc6dbbefac2872f6b9d6c4a0ae60c3c0
-MD5_PPM_3x2_FLOAT_387 = bcc5723c61560463ac60f772e742d092
-MD5_JPEG_3x2_IFAST_PROG = 1396cc2b7185cfe943d408c9d305339e
-MD5_PPM_3x2_IFAST = 3975985ef6eeb0a2cdc58daa651ccc00
-MD5_PPM_420M_ISLOW_2_1 = 4ca6be2a6f326ff9eaab63e70a8259c0
-MD5_PPM_420M_ISLOW_15_8 = 12aa9f9534c1b3d7ba047322226365eb
-MD5_PPM_420M_ISLOW_13_8 = f7e22817c7b25e1393e4ec101e9d4e96
-MD5_PPM_420M_ISLOW_11_8 = 800a16f9f4dc9b293197bfe11be10a82
-MD5_PPM_420M_ISLOW_9_8 = 06b7a92a9bc69f4dc36ec40f1937d55c
-MD5_PPM_420M_ISLOW_7_8 = 3ec444a14a4ab4eab88ffc49c48eca43
-MD5_PPM_420M_ISLOW_3_4 = 3e726b7ea872445b19437d1c1d4f0d93
-MD5_PPM_420M_ISLOW_5_8 = a8a771abdc94301d20ffac119b2caccd
-MD5_PPM_420M_ISLOW_1_2 = b419124dd5568b085787234866102866
-MD5_PPM_420M_ISLOW_3_8 = 343d19015531b7bbe746124127244fa8
-MD5_PPM_420M_ISLOW_1_4 = 35fd59d866e44659edfa3c18db2a3edb
-MD5_PPM_420M_ISLOW_1_8 = ccaed48ac0aedefda5d4abe4013f4ad7
-MD5_PPM_420_ISLOW_SKIP15_31 = 86664cd9dc956536409e44e244d20a97
-MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = 452a21656115a163029cfba5c04fa76a
-MD5_PPM_444_ISLOW_SKIP1_6 = ef63901f71ef7a75cd78253fc0914f84
-MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = 15b173fb5872d9575572fbcc1b05956f
-MD5_JPEG_CROP = cdb35ff4b4519392690ea040c56ea99c
-
-else
-
-TESTORIG = testorig.jpg
-MD5_JPEG_RGB_ISLOW = 768e970dd57b340ff1b83c9d3d47c77b
-MD5_PPM_RGB_ISLOW = 00a257f5393fef8821f2b88ac7421291
-MD5_BMP_RGB_ISLOW_565 = f07d2e75073e4bb10f6c6f4d36e2e3be
-MD5_BMP_RGB_ISLOW_565D = 4cfa0928ef3e6bb626d7728c924cfda4
-MD5_JPEG_422_IFAST_OPT = 2540287b79d913f91665e660303ab2c8
-MD5_PPM_422_IFAST = 35bd6b3f833bad23de82acea847129fa
-MD5_PPM_422M_IFAST = 8dbc65323d62cca7c91ba02dd1cfa81d
-MD5_BMP_422M_IFAST_565 = 3294bd4d9a1f2b3d08ea6020d0db7065
-MD5_BMP_422M_IFAST_565D = da98c9c7b6039511be4a79a878a9abc1
-MD5_JPEG_420_IFAST_Q100_PROG = 990cbe0329c882420a2094da7e5adade
-MD5_PPM_420_Q100_IFAST = 5a732542015c278ff43635e473a8a294
-MD5_PPM_420M_Q100_IFAST = ff692ee9323a3b424894862557c092f1
-MD5_JPEG_GRAY_ISLOW = 72b51f894b8f4a10b3ee3066770aa38d
-MD5_PPM_GRAY_ISLOW = 8d3596c56eace32f205deccc229aa5ed
-MD5_PPM_GRAY_ISLOW_RGB = 116424ac07b79e5e801f00508eab48ec
-MD5_BMP_GRAY_ISLOW_565 = 12f78118e56a2f48b966f792fedf23cc
-MD5_BMP_GRAY_ISLOW_565D = bdbbd616441a24354c98553df5dc82db
-MD5_JPEG_420S_IFAST_OPT = 388708217ac46273ca33086b22827ed8
-# See README.md for more details on why this next bit is necessary.
-MD5_JPEG_3x2_FLOAT_PROG_SSE = 343e3f8caf8af5986ebaf0bdc13b5c71
-MD5_PPM_3x2_FLOAT_SSE = 1a75f36e5904d6fc3a85a43da9ad89bb
-MD5_JPEG_3x2_FLOAT_PROG_32BIT = 9bca803d2042bd1eb03819e2bf92b3e5
-MD5_PPM_3x2_FLOAT_32BIT = f6bfab038438ed8f5522fbd33595dcdc
-MD5_PPM_3x2_FLOAT_64BIT = 0e917a34193ef976b679a6b069b1be26
-MD5_JPEG_3x2_FLOAT_PROG_387 = 1657664a410e0822c924b54f6f65e6e9
-MD5_PPM_3x2_FLOAT_387 = cb0a1f027f3d2917c902b5640214e025
-MD5_JPEG_3x2_IFAST_PROG = 1ee5d2c1a77f2da495f993c8c7cceca5
-MD5_PPM_3x2_IFAST = fd283664b3b49127984af0a7f118fccd
-MD5_JPEG_420_ISLOW_ARI = e986fb0a637a8d833d96e8a6d6d84ea1
-MD5_JPEG_444_ISLOW_PROGARI = 0a8f1c8f66e113c3cf635df0a475a617
-MD5_PPM_420M_IFAST_ARI = 72b59a99bcf1de24c5b27d151bde2437
-MD5_JPEG_420_ISLOW = 9a68f56bc76e466aa7e52f415d0f4a5f
-MD5_PPM_420M_ISLOW_2_1 = 9f9de8c0612f8d06869b960b05abf9c9
-MD5_PPM_420M_ISLOW_15_8 = b6875bc070720b899566cc06459b63b7
-MD5_PPM_420M_ISLOW_13_8 = bc3452573c8152f6ae552939ee19f82f
-MD5_PPM_420M_ISLOW_11_8 = d8cc73c0aaacd4556569b59437ba00a5
-MD5_PPM_420M_ISLOW_9_8 = d25e61bc7eac0002f5b393aa223747b6
-MD5_PPM_420M_ISLOW_7_8 = ddb564b7c74a09494016d6cd7502a946
-MD5_PPM_420M_ISLOW_3_4 = 8ed8e68808c3fbc4ea764fc9d2968646
-MD5_PPM_420M_ISLOW_5_8 = a3363274999da2366a024efae6d16c9b
-MD5_PPM_420M_ISLOW_1_2 = e692a315cea26b988c8e8b29a5dbcd81
-MD5_PPM_420M_ISLOW_3_8 = 79eca9175652ced755155c90e785a996
-MD5_PPM_420M_ISLOW_1_4 = 79cd778f8bf1a117690052cacdd54eca
-MD5_PPM_420M_ISLOW_1_8 = 391b3d4aca640c8567d6f8745eb2142f
-MD5_BMP_420_ISLOW_256 = 4980185e3776e89bd931736e1cddeee6
-MD5_BMP_420_ISLOW_565 = bf9d13e16c4923b92e1faa604d7922cb
-MD5_BMP_420_ISLOW_565D = 6bde71526acc44bcff76f696df8638d2
-MD5_BMP_420M_ISLOW_565 = 8dc0185245353cfa32ad97027342216f
-MD5_BMP_420M_ISLOW_565D =d1be3a3339166255e76fa50a0d70d73e
-MD5_PPM_420_ISLOW_SKIP15_31 = c4c65c1e43d7275cd50328a61e6534f0
-MD5_PPM_420_ISLOW_ARI_SKIP16_139 = 087c6b123db16ac00cb88c5b590bb74a
-MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71 = 26eb36ccc7d1f0cb80cdabb0ac8b5d99
-MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4 = 886c6775af22370257122f8b16207e6d
-MD5_PPM_444_ISLOW_SKIP1_6 = 5606f86874cf26b8fcee1117a0a436a6
-MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13 = db87dc7ce26bcdc7a6b56239ce2b9d6c
-MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0 = cb57b32bd6d03e35432362f7bf184b6d
-MD5_JPEG_CROP = b4197f377e621c4e9b1d20471432610d
-
-endif
-
-.PHONY: test
-test: tjquicktest tjbittest bittest
-
-if CROSS_COMPILING
-tjquicktest: testclean
-else
-tjquicktest: testclean all
-endif
-
-if WITH_TURBOJPEG
-if WITH_JAVA
-	$(JAVA) -cp java/turbojpeg.jar -Djava.library.path=.libs TJUnitTest
-	$(JAVA) -cp java/turbojpeg.jar -Djava.library.path=.libs TJUnitTest -bi
-	$(JAVA) -cp java/turbojpeg.jar -Djava.library.path=.libs TJUnitTest -yuv
-	$(JAVA) -cp java/turbojpeg.jar -Djava.library.path=.libs TJUnitTest -yuv -noyuvpad
-	$(JAVA) -cp java/turbojpeg.jar -Djava.library.path=.libs TJUnitTest -yuv -bi
-	$(JAVA) -cp java/turbojpeg.jar -Djava.library.path=.libs TJUnitTest -yuv -bi -noyuvpad
-endif
-	./tjunittest
-	./tjunittest -alloc
-	./tjunittest -yuv
-	./tjunittest -yuv -alloc
-	./tjunittest -yuv -noyuvpad
-endif
-	echo GREAT SUCCESS!
-
-if CROSS_COMPILING
-tjbittest: testclean
-else
-tjbittest: testclean all
-endif
-
-if WITH_TURBOJPEG
-
-MD5_PPM_GRAY_TILE = 89d3ca21213d9d864b50b4e4e7de4ca6
-MD5_PPM_420_8x8_TILE = 847fceab15c5b7b911cb986cf0f71de3
-MD5_PPM_420_16x16_TILE = ca45552a93687e078f7137cc4126a7b0
-MD5_PPM_420_32x32_TILE = d8676f1d6b68df358353bba9844f4a00
-MD5_PPM_420_64x64_TILE = 4e4c1a3d7ea4bace4f868bcbe83b7050
-MD5_PPM_420_128x128_TILE = f24c3429c52265832beab9df72a0ceae
-MD5_PPM_420M_8x8_TILE = bc25320e1f4c31ce2e610e43e9fd173c
-MD5_PPM_420M_TILE = 75ffdf14602258c5c189522af57fa605
-MD5_PPM_422_8x8_TILE = d83dacd9fc73b0a6f10c09acad64eb1e
-MD5_PPM_422_16x16_TILE = 35077fb610d72dd743b1eb0cbcfe10fb
-MD5_PPM_422_32x32_TILE = e6902ed8a449ecc0f0d6f2bf945f65f7
-MD5_PPM_422_64x64_TILE = 2b4502a8f316cedbde1da7bce3d2231e
-MD5_PPM_422_128x128_TILE = f0b5617d578f5e13c8eee215d64d4877
-MD5_PPM_422M_8x8_TILE = 828941d7f41cd6283abd6beffb7fd51d
-MD5_PPM_422M_TILE = e877ae1324c4a280b95376f7f018172f
-MD5_PPM_444_TILE = 7964e41e67cfb8d0a587c0aa4798f9c3
-
-# Test compressing from/decompressing to an arbitrary subregion of a larger
-# image buffer
-	cp $(srcdir)/testimages/testorig.ppm testout_tile.ppm
-	./tjbench testout_tile.ppm 95 -rgb -quiet -tile -benchtime 0.01 -warmup 0 >/dev/null 2>&1
-	for i in 8 16 32 64 128; do \
-		md5/md5cmp $(MD5_PPM_GRAY_TILE) testout_tile_GRAY_Q95_$$i\x$$i.ppm; \
-	done
-	md5/md5cmp $(MD5_PPM_420_8x8_TILE) testout_tile_420_Q95_8x8.ppm
-	md5/md5cmp $(MD5_PPM_420_16x16_TILE) testout_tile_420_Q95_16x16.ppm
-	md5/md5cmp $(MD5_PPM_420_32x32_TILE) testout_tile_420_Q95_32x32.ppm
-	md5/md5cmp $(MD5_PPM_420_64x64_TILE) testout_tile_420_Q95_64x64.ppm
-	md5/md5cmp $(MD5_PPM_420_128x128_TILE) testout_tile_420_Q95_128x128.ppm
-	md5/md5cmp $(MD5_PPM_422_8x8_TILE) testout_tile_422_Q95_8x8.ppm
-	md5/md5cmp $(MD5_PPM_422_16x16_TILE) testout_tile_422_Q95_16x16.ppm
-	md5/md5cmp $(MD5_PPM_422_32x32_TILE) testout_tile_422_Q95_32x32.ppm
-	md5/md5cmp $(MD5_PPM_422_64x64_TILE) testout_tile_422_Q95_64x64.ppm
-	md5/md5cmp $(MD5_PPM_422_128x128_TILE) testout_tile_422_Q95_128x128.ppm
-	for i in 8 16 32 64 128; do \
-		md5/md5cmp $(MD5_PPM_444_TILE) testout_tile_444_Q95_$$i\x$$i.ppm; \
-	done
-	rm -f testout_tile_GRAY_* testout_tile_420_* testout_tile_422_* testout_tile_444_*
-
-	./tjbench testout_tile.ppm 95 -rgb -fastupsample -quiet -tile -benchtime 0.01 -warmup 0 >/dev/null 2>&1
-	md5/md5cmp $(MD5_PPM_420M_8x8_TILE) testout_tile_420_Q95_8x8.ppm
-	for i in 16 32 64 128; do \
-		md5/md5cmp $(MD5_PPM_420M_TILE) testout_tile_420_Q95_$$i\x$$i.ppm; \
-	done
-	md5/md5cmp $(MD5_PPM_422M_8x8_TILE) testout_tile_422_Q95_8x8.ppm
-	for i in 16 32 64 128; do \
-		md5/md5cmp $(MD5_PPM_422M_TILE) testout_tile_422_Q95_$$i\x$$i.ppm; \
-	done
-	rm -f testout_tile_GRAY_* testout_tile_420_* testout_tile_422_* testout_tile_444_* testout_tile.ppm
-	echo GREAT SUCCESS!
-
-endif
-
-if CROSS_COMPILING
-bittest: testclean
-else
-bittest: testclean all
-endif
-
-# These tests are carefully crafted to provide full coverage of as many of the
-# underlying algorithms as possible (including all of the SIMD-accelerated
-# ones.)
-
-# CC: null  SAMP: fullsize  FDCT: islow  ENT: huff
-	./cjpeg -rgb -dct int -outfile testout_rgb_islow.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_RGB_ISLOW) testout_rgb_islow.jpg
-# CC: null  SAMP: fullsize  IDCT: islow  ENT: huff
-	./djpeg -dct int -ppm -outfile testout_rgb_islow.ppm testout_rgb_islow.jpg
-	md5/md5cmp $(MD5_PPM_RGB_ISLOW) testout_rgb_islow.ppm
-	rm -f testout_rgb_islow.ppm
-if WITH_12BIT
-	rm -f testout_rgb_islow.jpg
-else
-# CC: RGB->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff
-	./djpeg -dct int -rgb565 -dither none -bmp -outfile testout_rgb_islow_565.bmp testout_rgb_islow.jpg
-	md5/md5cmp $(MD5_BMP_RGB_ISLOW_565) testout_rgb_islow_565.bmp
-	rm -f testout_rgb_islow_565.bmp
-# CC: RGB->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff
-	./djpeg -dct int -rgb565 -bmp -outfile testout_rgb_islow_565D.bmp testout_rgb_islow.jpg
-	md5/md5cmp $(MD5_BMP_RGB_ISLOW_565D) testout_rgb_islow_565D.bmp
-	rm -f testout_rgb_islow_565D.bmp testout_rgb_islow.jpg
-endif
-
-# CC: RGB->YCC  SAMP: fullsize/h2v1  FDCT: ifast  ENT: 2-pass huff
-	./cjpeg -sample 2x1 -dct fast -opt -outfile testout_422_ifast_opt.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_422_IFAST_OPT) testout_422_ifast_opt.jpg
-# CC: YCC->RGB  SAMP: fullsize/h2v1 fancy  IDCT: ifast  ENT: huff
-	./djpeg -dct fast -outfile testout_422_ifast.ppm testout_422_ifast_opt.jpg
-	md5/md5cmp $(MD5_PPM_422_IFAST) testout_422_ifast.ppm
-	rm -f testout_422_ifast.ppm
-# CC: YCC->RGB  SAMP: h2v1 merged  IDCT: ifast  ENT: huff
-	./djpeg -dct fast -nosmooth -outfile testout_422m_ifast.ppm testout_422_ifast_opt.jpg
-	md5/md5cmp $(MD5_PPM_422M_IFAST) testout_422m_ifast.ppm
-	rm -f testout_422m_ifast.ppm
-if WITH_12BIT
-	rm -f testout_422_ifast_opt.jpg
-else
-# CC: YCC->RGB565  SAMP: h2v1 merged  IDCT: ifast  ENT: huff
-	./djpeg -dct int -nosmooth -rgb565 -dither none -bmp -outfile testout_422m_ifast_565.bmp testout_422_ifast_opt.jpg
-	md5/md5cmp $(MD5_BMP_422M_IFAST_565) testout_422m_ifast_565.bmp
-	rm -f testout_422m_ifast_565.bmp
-# CC: YCC->RGB565 (dithered)  SAMP: h2v1 merged  IDCT: ifast  ENT: huff
-	./djpeg -dct int -nosmooth -rgb565 -bmp -outfile testout_422m_ifast_565D.bmp testout_422_ifast_opt.jpg
-	md5/md5cmp $(MD5_BMP_422M_IFAST_565D) testout_422m_ifast_565D.bmp
-	rm -f testout_422m_ifast_565D.bmp testout_422_ifast_opt.jpg
-endif
-
-# CC: RGB->YCC  SAMP: fullsize/h2v2  FDCT: ifast  ENT: prog huff
-	./cjpeg -sample 2x2 -quality 100 -dct fast -prog -outfile testout_420_q100_ifast_prog.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_420_IFAST_Q100_PROG) testout_420_q100_ifast_prog.jpg
-# CC: YCC->RGB  SAMP: fullsize/h2v2 fancy  IDCT: ifast  ENT: prog huff
-	./djpeg -dct fast -outfile testout_420_q100_ifast.ppm testout_420_q100_ifast_prog.jpg
-	md5/md5cmp $(MD5_PPM_420_Q100_IFAST) testout_420_q100_ifast.ppm
-	rm -f testout_420_q100_ifast.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: ifast  ENT: prog huff
-	./djpeg -dct fast -nosmooth -outfile testout_420m_q100_ifast.ppm testout_420_q100_ifast_prog.jpg
-	md5/md5cmp $(MD5_PPM_420M_Q100_IFAST) testout_420m_q100_ifast.ppm
-	rm -f testout_420m_q100_ifast.ppm testout_420_q100_ifast_prog.jpg
-
-# CC: RGB->Gray  SAMP: fullsize  FDCT: islow  ENT: huff
-	./cjpeg -gray -dct int -outfile testout_gray_islow.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_GRAY_ISLOW) testout_gray_islow.jpg
-# CC: Gray->Gray  SAMP: fullsize  IDCT: islow  ENT: huff
-	./djpeg -dct int -outfile testout_gray_islow.ppm testout_gray_islow.jpg
-	md5/md5cmp $(MD5_PPM_GRAY_ISLOW) testout_gray_islow.ppm
-	rm -f testout_gray_islow.ppm
-# CC: Gray->RGB  SAMP: fullsize  IDCT: islow  ENT: huff
-	./djpeg -dct int -rgb -outfile testout_gray_islow_rgb.ppm testout_gray_islow.jpg
-	md5/md5cmp $(MD5_PPM_GRAY_ISLOW_RGB) testout_gray_islow_rgb.ppm
-	rm -f testout_gray_islow_rgb.ppm
-if WITH_12BIT
-	rm -f testout_gray_islow.jpg
-else
-# CC: Gray->RGB565  SAMP: fullsize  IDCT: islow  ENT: huff
-	./djpeg -dct int -rgb565 -dither none -bmp -outfile testout_gray_islow_565.bmp testout_gray_islow.jpg
-	md5/md5cmp $(MD5_BMP_GRAY_ISLOW_565) testout_gray_islow_565.bmp
-	rm -f testout_gray_islow_565.bmp
-# CC: Gray->RGB565 (dithered)  SAMP: fullsize  IDCT: islow  ENT: huff
-	./djpeg -dct int -rgb565 -bmp -outfile testout_gray_islow_565D.bmp testout_gray_islow.jpg
-	md5/md5cmp $(MD5_BMP_GRAY_ISLOW_565D) testout_gray_islow_565D.bmp
-	rm -f testout_gray_islow_565D.bmp testout_gray_islow.jpg
-endif
-
-# CC: RGB->YCC  SAMP: fullsize smooth/h2v2 smooth  FDCT: islow
-# ENT: 2-pass huff
-	./cjpeg -sample 2x2 -smooth 1 -dct int -opt -outfile testout_420s_ifast_opt.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_420S_IFAST_OPT) testout_420s_ifast_opt.jpg
-	rm -f testout_420s_ifast_opt.jpg
-
-# The output of the floating point tests is not validated by default, because
-# the output differs depending on the type of floating point math used, and
-# this is only deterministic if the DCT/IDCT are implemented using SIMD
-# instructions on a particular platform.  Pass one of the following on the make
-# command line to validate the floating point tests against one of the expected
-# results:
-#
-# FLOATTEST=sse  validate against the expected results from the libjpeg-turbo
-#                SSE SIMD extensions
-# FLOATTEST=32bit  validate against the expected results from the C code
-#                  when running on a 32-bit FPU (or when SSE is being used for
-#                  floating point math, which is generally the default with
-#                  x86-64 compilers)
-# FLOATTEST=64bit  validate against the exepected results from the C code
-#                  when running on a 64-bit FPU
-# FLOATTEST=387  validate against the expected results from the C code when
-#                the 387 FPU is being used for floating point math (which is
-#                generally the default with x86 compilers)
-
-# CC: RGB->YCC  SAMP: fullsize/int  FDCT: float  ENT: prog huff
-	./cjpeg -sample 3x2 -dct float -prog -outfile testout_3x2_float_prog.jpg $(srcdir)/testimages/testorig.ppm
-	if [ "${FLOATTEST}" = "sse" ]; then \
-		md5/md5cmp $(MD5_JPEG_3x2_FLOAT_PROG_SSE) testout_3x2_float_prog.jpg; \
-	elif [ "${FLOATTEST}" = "32bit" -o "${FLOATTEST}" = "64bit" ]; then \
-		md5/md5cmp $(MD5_JPEG_3x2_FLOAT_PROG_32BIT) testout_3x2_float_prog.jpg; \
-	elif [ "${FLOATTEST}" = "387" ]; then \
-		md5/md5cmp $(MD5_JPEG_3x2_FLOAT_PROG_387) testout_3x2_float_prog.jpg; \
-	fi
-# CC: YCC->RGB  SAMP: fullsize/int  IDCT: float  ENT: prog huff
-	./djpeg -dct float -outfile testout_3x2_float.ppm testout_3x2_float_prog.jpg
-	if [ "${FLOATTEST}" = "sse" ]; then \
-		md5/md5cmp $(MD5_PPM_3x2_FLOAT_SSE) testout_3x2_float.ppm; \
-	elif [ "${FLOATTEST}" = "32bit" ]; then \
-		md5/md5cmp $(MD5_PPM_3x2_FLOAT_32BIT) testout_3x2_float.ppm; \
-	elif [ "${FLOATTEST}" = "64bit" ]; then \
-		md5/md5cmp $(MD5_PPM_3x2_FLOAT_64BIT) testout_3x2_float.ppm; \
-	elif [ "${FLOATTEST}" = "387" ]; then \
-		md5/md5cmp $(MD5_PPM_3x2_FLOAT_387) testout_3x2_float.ppm; \
-	fi
-	rm -f testout_3x2_float.ppm testout_3x2_float_prog.jpg
-
-# CC: RGB->YCC  SAMP: fullsize/int  FDCT: ifast  ENT: prog huff
-	./cjpeg -sample 3x2 -dct fast -prog -outfile testout_3x2_ifast_prog.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_3x2_IFAST_PROG) testout_3x2_ifast_prog.jpg
-# CC: YCC->RGB  SAMP: fullsize/int  IDCT: ifast  ENT: prog huff
-	./djpeg -dct fast -outfile testout_3x2_ifast.ppm testout_3x2_ifast_prog.jpg
-	md5/md5cmp $(MD5_PPM_3x2_IFAST) testout_3x2_ifast.ppm
-	rm -f testout_3x2_ifast.ppm testout_3x2_ifast_prog.jpg
-
-if WITH_ARITH_ENC
-# CC: YCC->RGB  SAMP: fullsize/h2v2  FDCT: islow  ENT: arith
-	./cjpeg -dct int -arithmetic -outfile testout_420_islow_ari.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_420_ISLOW_ARI) testout_420_islow_ari.jpg
-	rm -f testout_420_islow_ari.jpg
-	./jpegtran -arithmetic -outfile testout_420_islow_ari.jpg $(srcdir)/testimages/testimgint.jpg
-	md5/md5cmp $(MD5_JPEG_420_ISLOW_ARI) testout_420_islow_ari.jpg
-	rm -f testout_420_islow_ari.jpg
-# CC: YCC->RGB  SAMP: fullsize  FDCT: islow  ENT: prog arith
-	./cjpeg -sample 1x1 -dct int -prog -arithmetic -outfile testout_444_islow_progari.jpg $(srcdir)/testimages/testorig.ppm
-	md5/md5cmp $(MD5_JPEG_444_ISLOW_PROGARI) testout_444_islow_progari.jpg
-	rm -f testout_444_islow_progari.jpg
-endif
-if WITH_ARITH_DEC
-# CC: RGB->YCC  SAMP: h2v2 merged  IDCT: ifast  ENT: arith
-	./djpeg -fast -ppm -outfile testout_420m_ifast_ari.ppm $(srcdir)/testimages/testimgari.jpg
-	md5/md5cmp $(MD5_PPM_420M_IFAST_ARI) testout_420m_ifast_ari.ppm
-	rm -f testout_420m_ifast_ari.ppm
-	./jpegtran -outfile testout_420_islow.jpg $(srcdir)/testimages/testimgari.jpg
-	md5/md5cmp $(MD5_JPEG_420_ISLOW) testout_420_islow.jpg
-	rm -f testout_420_islow.jpg
-endif
-
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 16x16 islow  ENT: huff
-	./djpeg -dct int -scale 2/1 -nosmooth -ppm -outfile testout_420m_islow_2_1.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_2_1) testout_420m_islow_2_1.ppm
-	rm -f testout_420m_islow_2_1.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 15x15 islow  ENT: huff
-	./djpeg -dct int -scale 15/8 -nosmooth -ppm -outfile testout_420m_islow_15_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_15_8) testout_420m_islow_15_8.ppm
-	rm -f testout_420m_islow_15_8.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 13x13 islow  ENT: huff
-	./djpeg -dct int -scale 13/8 -nosmooth -ppm -outfile testout_420m_islow_13_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_13_8) testout_420m_islow_13_8.ppm
-	rm -f testout_420m_islow_13_8.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 11x11 islow  ENT: huff
-	./djpeg -dct int -scale 11/8 -nosmooth -ppm -outfile testout_420m_islow_11_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_11_8) testout_420m_islow_11_8.ppm
-	rm -f testout_420m_islow_11_8.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 9x9 islow  ENT: huff
-	./djpeg -dct int -scale 9/8 -nosmooth -ppm -outfile testout_420m_islow_9_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_9_8) testout_420m_islow_9_8.ppm
-	rm -f testout_420m_islow_9_8.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 7x7 islow/14x14 islow  ENT: huff
-	./djpeg -dct int -scale 7/8 -nosmooth -ppm -outfile testout_420m_islow_7_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_7_8) testout_420m_islow_7_8.ppm
-	rm -f testout_420m_islow_7_8.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 6x6 islow/12x12 islow  ENT: huff
-	./djpeg -dct int -scale 3/4 -nosmooth -ppm -outfile testout_420m_islow_3_4.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_3_4) testout_420m_islow_3_4.ppm
-	rm -f testout_420m_islow_3_4.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 5x5 islow/10x10 islow  ENT: huff
-	./djpeg -dct int -scale 5/8 -nosmooth -ppm -outfile testout_420m_islow_5_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_5_8) testout_420m_islow_5_8.ppm
-	rm -f testout_420m_islow_5_8.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 4x4 islow/8x8 islow  ENT: huff
-	./djpeg -dct int -scale 1/2 -nosmooth -ppm -outfile testout_420m_islow_1_2.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_1_2) testout_420m_islow_1_2.ppm
-	rm -f testout_420m_islow_1_2.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 3x3 islow/6x6 islow  ENT: huff
-	./djpeg -dct int -scale 3/8 -nosmooth -ppm -outfile testout_420m_islow_3_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_3_8) testout_420m_islow_3_8.ppm
-	rm -f testout_420m_islow_3_8.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 2x2 islow/4x4 islow  ENT: huff
-	./djpeg -dct int -scale 1/4 -nosmooth -ppm -outfile testout_420m_islow_1_4.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_1_4) testout_420m_islow_1_4.ppm
-	rm -f testout_420m_islow_1_4.ppm
-# CC: YCC->RGB  SAMP: h2v2 merged  IDCT: 1x1 islow/2x2 islow  ENT: huff
-	./djpeg -dct int -scale 1/8 -nosmooth -ppm -outfile testout_420m_islow_1_8.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420M_ISLOW_1_8) testout_420m_islow_1_8.ppm
-	rm -f testout_420m_islow_1_8.ppm
-if WITH_12BIT
-else
-# CC: YCC->RGB (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff
-	./djpeg -dct int -colors 256 -bmp -outfile testout_420_islow_256.bmp $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_BMP_420_ISLOW_256) testout_420_islow_256.bmp
-	rm -f testout_420_islow_256.bmp
-# CC: YCC->RGB565  SAMP: h2v2 fancy  IDCT: islow  ENT: huff
-	./djpeg -dct int -rgb565 -dither none -bmp -outfile testout_420_islow_565.bmp $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_BMP_420_ISLOW_565) testout_420_islow_565.bmp
-	rm -f testout_420_islow_565.bmp
-# CC: YCC->RGB565 (dithered)  SAMP: h2v2 fancy  IDCT: islow  ENT: huff
-	./djpeg -dct int -rgb565 -bmp -outfile testout_420_islow_565D.bmp $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_BMP_420_ISLOW_565D) testout_420_islow_565D.bmp
-	rm -f testout_420_islow_565D.bmp
-# CC: YCC->RGB565  SAMP: h2v2 merged  IDCT: islow  ENT: huff
-	./djpeg -dct int -nosmooth -rgb565 -dither none -bmp -outfile testout_420m_islow_565.bmp $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_BMP_420M_ISLOW_565) testout_420m_islow_565.bmp
-	rm -f testout_420m_islow_565.bmp
-# CC: YCC->RGB565 (dithered)  SAMP: h2v2 merged  IDCT: islow  ENT: huff
-	./djpeg -dct int -nosmooth -rgb565 -bmp -outfile testout_420m_islow_565D.bmp $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_BMP_420M_ISLOW_565D) testout_420m_islow_565D.bmp
-	rm -f testout_420m_islow_565D.bmp
-endif
-
-# Partial decode tests.  These tests are designed to cover all of the possible
-# code paths in jpeg_skip_scanlines().
-
-# Context rows: Yes  Intra-iMCU row: Yes  iMCU row prefetch: No   ENT: huff
-	./djpeg -dct int -skip 15,31 -ppm -outfile testout_420_islow_skip15,31.ppm $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_PPM_420_ISLOW_SKIP15_31) testout_420_islow_skip15,31.ppm
-	rm -f testout_420_islow_skip15,31.ppm
-# Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: Yes  ENT: arith
-if WITH_ARITH_DEC
-	./djpeg -dct int -skip 16,139 -ppm -outfile testout_420_islow_ari_skip16,139.ppm $(srcdir)/testimages/testimgari.jpg
-	md5/md5cmp $(MD5_PPM_420_ISLOW_ARI_SKIP16_139) testout_420_islow_ari_skip16,139.ppm
-	rm -f testout_420_islow_ari_skip16,139.ppm
-endif
-# Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No   ENT: prog huff
-	./cjpeg -dct int -prog -outfile testout_420_islow_prog.jpg $(srcdir)/testimages/testorig.ppm
-	./djpeg -dct int -crop 62x62+71+71 -ppm -outfile testout_420_islow_prog_crop62x62,71,71.ppm testout_420_islow_prog.jpg
-	md5/md5cmp $(MD5_PPM_420_ISLOW_PROG_CROP62x62_71_71) testout_420_islow_prog_crop62x62,71,71.ppm
-	rm -f testout_420_islow_prog_crop62x62,71,71.ppm testout_420_islow_prog.jpg
-# Context rows: Yes  Intra-iMCU row: No   iMCU row prefetch: No   ENT: arith
-if WITH_ARITH_DEC
-	./djpeg -dct int -crop 53x53+4+4 -ppm -outfile testout_420_islow_ari_crop53x53,4,4.ppm $(srcdir)/testimages/testimgari.jpg
-	md5/md5cmp $(MD5_PPM_420_ISLOW_ARI_CROP53x53_4_4) testout_420_islow_ari_crop53x53,4,4.ppm
-	rm -f testout_420_islow_ari_crop53x53,4,4.ppm
-endif
-# Context rows: No   Intra-iMCU row: Yes  ENT: huff
-	./cjpeg -dct int -sample 1x1 -outfile testout_444_islow.jpg $(srcdir)/testimages/testorig.ppm
-	./djpeg -dct int -skip 1,6 -ppm -outfile testout_444_islow_skip1,6.ppm testout_444_islow.jpg
-	md5/md5cmp $(MD5_PPM_444_ISLOW_SKIP1_6) testout_444_islow_skip1,6.ppm
-	rm -f testout_444_islow_skip1,6.ppm testout_444_islow.jpg
-# Context rows: No   Intra-iMCU row: No   ENT: prog huff
-	./cjpeg -dct int -prog -sample 1x1 -outfile testout_444_islow_prog.jpg $(srcdir)/testimages/testorig.ppm
-	./djpeg -dct int -crop 98x98+13+13 -ppm -outfile testout_444_islow_prog_crop98x98,13,13.ppm testout_444_islow_prog.jpg
-	md5/md5cmp $(MD5_PPM_444_ISLOW_PROG_CROP98x98_13_13) testout_444_islow_prog_crop98x98,13,13.ppm
-	rm -f testout_444_islow_prog_crop98x98,13,13.ppm testout_444_islow_prog.jpg
-# Context rows: No   Intra-iMCU row: No   ENT: arith
-if WITH_ARITH_ENC
-	./cjpeg -dct int -arithmetic -sample 1x1 -outfile testout_444_islow_ari.jpg $(srcdir)/testimages/testorig.ppm
-if WITH_ARITH_DEC
-	./djpeg -dct int -crop 37x37+0+0 -ppm -outfile testout_444_islow_ari_crop37x37,0,0.ppm testout_444_islow_ari.jpg
-	md5/md5cmp $(MD5_PPM_444_ISLOW_ARI_CROP37x37_0_0) testout_444_islow_ari_crop37x37,0,0.ppm
-	rm -f testout_444_islow_ari_crop37x37,0,0.ppm
-endif
-	rm -f testout_444_islow_ari.jpg
-endif
-
-	./jpegtran -crop 120x90+20+50 -transpose -perfect -outfile testout_crop.jpg $(srcdir)/testimages/$(TESTORIG)
-	md5/md5cmp $(MD5_JPEG_CROP) testout_crop.jpg
-	rm -f testout_crop.jpg
-	echo GREAT SUCCESS!
-
-
-testclean:
-	rm -f testout*
-	rm -f *_GRAY_*.bmp
-	rm -f *_GRAY_*.png
-	rm -f *_GRAY_*.ppm
-	rm -f *_GRAY_*.jpg
-	rm -f *_GRAY.yuv
-	rm -f *_420_*.bmp
-	rm -f *_420_*.png
-	rm -f *_420_*.ppm
-	rm -f *_420_*.jpg
-	rm -f *_420.yuv
-	rm -f *_422_*.bmp
-	rm -f *_422_*.png
-	rm -f *_422_*.ppm
-	rm -f *_422_*.jpg
-	rm -f *_422.yuv
-	rm -f *_444_*.bmp
-	rm -f *_444_*.png
-	rm -f *_444_*.ppm
-	rm -f *_444_*.jpg
-	rm -f *_444.yuv
-	rm -f *_440_*.bmp
-	rm -f *_440_*.png
-	rm -f *_440_*.ppm
-	rm -f *_440_*.jpg
-	rm -f *_440.yuv
-	rm -f *_411_*.bmp
-	rm -f *_411_*.png
-	rm -f *_411_*.ppm
-	rm -f *_411_*.jpg
-	rm -f *_411.yuv
-
-
-tjtest:
-	sh ./tjbenchtest
-	sh ./tjbenchtest -alloc
-	sh ./tjbenchtest -yuv
-	sh ./tjbenchtest -yuv -alloc
-if WITH_JAVA
-	sh ./tjbenchtest.java
-	sh ./tjbenchtest.java -yuv
-endif
-
-
-pkgscripts/libjpeg-turbo.spec: pkgscripts/libjpeg-turbo.spec.tmpl
-	cat pkgscripts/libjpeg-turbo.spec.tmpl | sed s@%{__prefix}@$(prefix)@g | \
-		sed s@%{__bindir}@$(bindir)@g | sed s@%{__datadir}@$(datadir)@g | \
-		sed s@%{__docdir}@$(docdir)@g | sed s@%{__includedir}@$(includedir)@g | \
-		sed s@%{__libdir}@$(libdir)@g | sed s@%{__mandir}@$(mandir)@g \
-		> pkgscripts/libjpeg-turbo.spec
-
-rpm: all pkgscripts/libjpeg-turbo.spec
-	TMPDIR=`mktemp -d /tmp/${PACKAGE_NAME}-build.XXXXXX`; \
-	mkdir -p $$TMPDIR/RPMS; \
-	ln -fs `pwd` $$TMPDIR/BUILD; \
-	rm -f ${PKGNAME}-${VERSION}.${RPMARCH}.rpm; \
-	rpmbuild -bb --define "_blddir $$TMPDIR/buildroot"  \
-		--define "_topdir $$TMPDIR" \
-		--target ${RPMARCH} pkgscripts/libjpeg-turbo.spec; \
-	cp $$TMPDIR/RPMS/${RPMARCH}/${PKGNAME}-${VERSION}-${BUILD}.${RPMARCH}.rpm \
-		${PKGNAME}-${VERSION}.${RPMARCH}.rpm; \
-	rm -rf $$TMPDIR
-
-srpm: dist-gzip pkgscripts/libjpeg-turbo.spec
-	TMPDIR=`mktemp -d /tmp/${PACKAGE_NAME}-build.XXXXXX`; \
-	mkdir -p $$TMPDIR/RPMS; \
-	mkdir -p $$TMPDIR/SRPMS; \
-	mkdir -p $$TMPDIR/BUILD; \
-	mkdir -p $$TMPDIR/SOURCES; \
-	mkdir -p $$TMPDIR/SPECS; \
-	rm -f ${PKGNAME}-${VERSION}.src.rpm; \
-	cp ${PACKAGE_NAME}-${VERSION}.tar.gz $$TMPDIR/SOURCES; \
-	cat pkgscripts/libjpeg-turbo.spec | sed s/%{_blddir}/%{_tmppath}/g \
-		| sed s/#--\>//g \
-		> $$TMPDIR/SPECS/libjpeg-turbo.spec; \
-	rpmbuild -bs --define "_topdir $$TMPDIR" $$TMPDIR/SPECS/libjpeg-turbo.spec; \
-	cp $$TMPDIR/SRPMS/${PKGNAME}-${VERSION}-${BUILD}.src.rpm \
-		${PKGNAME}-${VERSION}.src.rpm; \
-	rm -rf $$TMPDIR
-
-pkgscripts/makedpkg: pkgscripts/makedpkg.tmpl
-	cat pkgscripts/makedpkg.tmpl | sed s@%{__prefix}@$(prefix)@g | \
-		sed s@%{__docdir}@$(docdir)@g | sed s@%{__libdir}@$(libdir)@g \
-		> pkgscripts/makedpkg
-
-deb: all pkgscripts/makedpkg
-	sh pkgscripts/makedpkg
-
-pkgscripts/uninstall: pkgscripts/uninstall.tmpl
-	cat pkgscripts/uninstall.tmpl | sed s@%{__prefix}@$(prefix)@g | \
-		sed s@%{__bindir}@$(bindir)@g | sed s@%{__datadir}@$(datadir)@g | \
-		sed s@%{__includedir}@$(includedir)@g | sed s@%{__libdir}@$(libdir)@g | \
-		sed s@%{__mandir}@$(mandir)@g > pkgscripts/uninstall
-
-pkgscripts/makemacpkg: pkgscripts/makemacpkg.tmpl
-	cat pkgscripts/makemacpkg.tmpl | sed s@%{__prefix}@$(prefix)@g | \
-		sed s@%{__bindir}@$(bindir)@g | sed s@%{__docdir}@$(docdir)@g | \
-		sed s@%{__libdir}@$(libdir)@g > pkgscripts/makemacpkg
-
-if X86_64
-
-udmg: all pkgscripts/makemacpkg pkgscripts/uninstall
-	sh pkgscripts/makemacpkg -build32 ${BUILDDIR32}
-
-iosdmg: all pkgscripts/makemacpkg pkgscripts/uninstall
-	sh pkgscripts/makemacpkg -build32 ${BUILDDIR32} -buildarmv7 ${BUILDDIRARMV7} -buildarmv7s ${BUILDDIRARMV7S} -buildarmv8 ${BUILDDIRARMV8} -lipo "${LIPO}"
-
-else
-
-iosdmg: all pkgscripts/makemacpkg pkgscripts/uninstall
-	sh pkgscripts/makemacpkg -buildarmv7 ${BUILDDIRARMV7} -buildarmv7s ${BUILDDIRARMV7S} -buildarmv8 ${BUILDDIRARMV8} -lipo "${LIPO}"
-
-endif
-
-dmg: all pkgscripts/makemacpkg pkgscripts/uninstall
-	sh pkgscripts/makemacpkg
-
-pkgscripts/makecygwinpkg: pkgscripts/makecygwinpkg.tmpl
-	cat pkgscripts/makecygwinpkg.tmpl | sed s@%{__prefix}@$(prefix)@g | \
-		sed s@%{__docdir}@$(docdir)@g | sed s@%{__libdir}@$(libdir)@g \
-		> pkgscripts/makecygwinpkg
-
-cygwinpkg: all pkgscripts/makecygwinpkg
-	sh pkgscripts/makecygwinpkg
diff --git a/README.ijg b/README.ijg
index 9c450ce..d9d81b8 100644
--- a/README.ijg
+++ b/README.ijg
@@ -159,12 +159,6 @@ commercial products, provided that all warranty or liability claims are
 assumed by the product vendor.
 
 
-The Unix configuration script "configure" was produced with GNU Autoconf.
-It is copyright by the Free Software Foundation but is freely distributable.
-The same holds for its supporting scripts (config.guess, config.sub,
-ltmain.sh).  Another support script, install-sh, is copyright by X Consortium
-but is also freely distributable.
-
 The IJG distribution formerly included code to read and write GIF files.
 To avoid entanglement with the Unisys LZW patent (now expired), GIF reading
 support has been removed altogether, and the GIF writer has been simplified
diff --git a/README.md b/README.md
index 74e6eac..d54feb7 100755
--- a/README.md
+++ b/README.md
@@ -2,8 +2,8 @@ Background
 ==========
 
 libjpeg-turbo is a JPEG image codec that uses SIMD instructions (MMX, SSE2,
-NEON, AltiVec) to accelerate baseline JPEG compression and decompression on
-x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is
+AVX2, NEON, AltiVec) to accelerate baseline JPEG compression and decompression
+on x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is
 generally 2-6x as fast as libjpeg, all else being equal.  On other types of
 systems, libjpeg-turbo can still outperform libjpeg by a significant amount, by
 virtue of its highly-optimized Huffman coding routines.  In many cases, the
diff --git a/acinclude.m4 b/acinclude.m4
deleted file mode 100644
index 2c90762..0000000
--- a/acinclude.m4
+++ /dev/null
@@ -1,254 +0,0 @@
-# AC_PROG_NASM
-# --------------------------
-# Check that NASM exists and determine flags
-AC_DEFUN([AC_PROG_NASM],[
-
-AC_ARG_VAR(NASM, [NASM command (used to build the x86/x86-64 SIMD code)])
-if test "x$NASM" = "x"; then
-  AC_CHECK_PROGS(NASM, [nasm nasmw yasm])
-  test -z "$NASM" && AC_MSG_ERROR([no nasm (Netwide Assembler) found])
-fi
-
-AC_MSG_CHECKING([for object file format of host system])
-case "$host_os" in
-  cygwin* | mingw* | pw32* | interix*)
-    case "$host_cpu" in
-      x86_64)
-        objfmt='Win64-COFF'
-        ;;
-      *)
-        objfmt='Win32-COFF'
-        ;;
-    esac
-  ;;
-  msdosdjgpp* | go32*)
-    objfmt='COFF'
-  ;;
-  os2-emx*)			# not tested
-    objfmt='MSOMF'		# obj
-  ;;
-  linux*coff* | linux*oldld*)
-    objfmt='COFF'		# ???
-  ;;
-  linux*aout*)
-    objfmt='a.out'
-  ;;
-  linux*)
-    case "$host_cpu" in
-      x86_64)
-        objfmt='ELF64'
-        ;;
-      *)
-        objfmt='ELF'
-        ;;
-    esac
-  ;;
-  kfreebsd* | freebsd* | netbsd* | openbsd*)
-    if echo __ELF__ | $CC -E - | grep __ELF__ > /dev/null; then
-      objfmt='BSD-a.out'
-    else
-      case "$host_cpu" in
-        x86_64 | amd64)
-          objfmt='ELF64'
-          ;;
-        *)
-          objfmt='ELF'
-          ;;
-      esac
-    fi
-  ;;
-  solaris* | sunos* | sysv* | sco*)
-    case "$host_cpu" in
-      x86_64)
-        objfmt='ELF64'
-        ;;
-      *)
-        objfmt='ELF'
-        ;;
-    esac
-  ;;
-  darwin* | rhapsody* | nextstep* | openstep* | macos*)
-    case "$host_cpu" in
-      x86_64)
-        objfmt='Mach-O64'
-        ;;
-      *)
-        objfmt='Mach-O'
-        ;;
-    esac
-  ;;
-  *)
-    objfmt='ELF ?'
-  ;;
-esac
-
-AC_MSG_RESULT([$objfmt])
-if test "$objfmt" = 'ELF ?'; then
-  objfmt='ELF'
-  AC_MSG_WARN([unexpected host system. assumed that the format is $objfmt.])
-fi
-
-AC_MSG_CHECKING([for object file format specifier (NAFLAGS) ])
-case "$objfmt" in
-  MSOMF)      NAFLAGS='-fobj -DOBJ32';;
-  Win32-COFF) NAFLAGS='-fwin32 -DWIN32';;
-  Win64-COFF) NAFLAGS='-fwin64 -DWIN64 -D__x86_64__';;
-  COFF)       NAFLAGS='-fcoff -DCOFF';;
-  a.out)      NAFLAGS='-faout -DAOUT';;
-  BSD-a.out)  NAFLAGS='-faoutb -DAOUT';;
-  ELF)        NAFLAGS='-felf -DELF';;
-  ELF64)      NAFLAGS='-felf64 -DELF -D__x86_64__';;
-  RDF)        NAFLAGS='-frdf -DRDF';;
-  Mach-O)     NAFLAGS='-fmacho -DMACHO';;
-  Mach-O64)   NAFLAGS='-fmacho64 -DMACHO -D__x86_64__';;
-esac
-AC_MSG_RESULT([$NAFLAGS])
-AC_SUBST([NAFLAGS])
-
-AC_MSG_CHECKING([whether the assembler ($NASM $NAFLAGS) works])
-cat > conftest.asm <<EOF
-[%line __oline__ "configure"
-        section .text
-        global  _main,main
-_main:
-main:   xor     eax,eax
-        ret
-]EOF
-try_nasm='$NASM $NAFLAGS -o conftest.o conftest.asm'
-if AC_TRY_EVAL(try_nasm) && test -s conftest.o; then
-  AC_MSG_RESULT(yes)
-else
-  echo "configure: failed program was:" >&AC_FD_CC
-  cat conftest.asm >&AC_FD_CC
-  rm -rf conftest*
-  AC_MSG_RESULT(no)
-  AC_MSG_ERROR([installation or configuration problem: assembler cannot create object files.])
-fi
-
-AC_MSG_CHECKING([whether the linker accepts assembler output])
-try_nasm='${CC-cc} -o conftest${ac_exeext} $LDFLAGS conftest.o $LIBS 1>&AC_FD_CC'
-if AC_TRY_EVAL(try_nasm) && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  AC_MSG_RESULT(yes)
-else
-  rm -rf conftest*
-  AC_MSG_RESULT(no)
-  AC_MSG_ERROR([configuration problem: maybe object file format mismatch.])
-fi
-
-])
-
-# AC_CHECK_COMPATIBLE_ARM_ASSEMBLER_IFELSE
-# --------------------------
-# Test whether the assembler is suitable and supports NEON instructions
-AC_DEFUN([AC_CHECK_COMPATIBLE_ARM_ASSEMBLER_IFELSE],[
-  ac_good_gnu_arm_assembler=no
-  ac_save_CC="$CC"
-  ac_save_CFLAGS="$CFLAGS"
-  CFLAGS="$CCASFLAGS -x assembler-with-cpp"
-  CC="$CCAS"
-  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
-    .text
-    .fpu neon
-    .arch armv7a
-    .object_arch armv4
-    .arm
-    pld [r0]
-    vmovn.u16 d0, q0]])], ac_good_gnu_arm_assembler=yes)
-
-  ac_use_gas_preprocessor=no
-  if test "x$ac_good_gnu_arm_assembler" = "xno" ; then
-    CC="gas-preprocessor.pl $CCAS"
-    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
-      .text
-      .fpu neon
-      .arch armv7a
-      .object_arch armv4
-      .arm
-      pld [r0]
-      vmovn.u16 d0, q0]])], ac_use_gas_preprocessor=yes)
-  fi
-  CFLAGS="$ac_save_CFLAGS"
-  CC="$ac_save_CC"
-
-  if test "x$ac_use_gas_preprocessor" = "xyes" ; then
-    CCAS="gas-preprocessor.pl $CCAS"
-    AC_SUBST([CCAS])
-    ac_good_gnu_arm_assembler=yes
-  fi
-
-  if test "x$ac_good_gnu_arm_assembler" = "xyes" ; then
-    $1
-  else
-    $2
-  fi
-])
-
-# AC_CHECK_COMPATIBLE_MIPSEL_ASSEMBLER_IFELSE
-# --------------------------
-# Test whether the assembler is suitable and supports MIPS instructions
-AC_DEFUN([AC_CHECK_COMPATIBLE_MIPS_ASSEMBLER_IFELSE],[
-  have_mips_dspr2=no
-  ac_save_CFLAGS="$CFLAGS"
-  CFLAGS="$CCASFLAGS -mdspr2"
-
-  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
-
-  int main ()
-  {
-    int c = 0, a = 0, b = 0;
-    __asm__ __volatile__ (
-        "precr.qb.ph %[c], %[a], %[b]          \n\t"
-        : [c] "=r" (c)
-        : [a] "r" (a), [b] "r" (b)
-    );
-    return c;
-  }
-  ]])], have_mips_dspr2=yes)
-  CFLAGS=$ac_save_CFLAGS
-
-  if test "x$have_mips_dspr2" = "xyes" ; then
-    $1
-  else
-    $2
-  fi
-])
-
-AC_DEFUN([AC_CHECK_COMPATIBLE_ARM64_ASSEMBLER_IFELSE],[
-  ac_good_gnu_arm_assembler=no
-  ac_save_CC="$CC"
-  ac_save_CFLAGS="$CFLAGS"
-  CFLAGS="$CCASFLAGS -x assembler-with-cpp"
-  CC="$CCAS"
-  AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
-    .text
-    MYVAR .req x0
-    movi v0.16b, #100
-    mov MYVAR, #100
-    .unreq MYVAR]])], ac_good_gnu_arm_assembler=yes)
-
-  ac_use_gas_preprocessor=no
-  if test "x$ac_good_gnu_arm_assembler" = "xno" ; then
-    CC="gas-preprocessor.pl $CCAS"
-    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
-      .text
-      MYVAR .req x0
-      movi v0.16b, #100
-      mov MYVAR, #100
-      .unreq MYVAR]])], ac_use_gas_preprocessor=yes)
-  fi
-  CFLAGS="$ac_save_CFLAGS"
-  CC="$ac_save_CC"
-
-  if test "x$ac_use_gas_preprocessor" = "xyes" ; then
-    CCAS="gas-preprocessor.pl $CCAS"
-    AC_SUBST([CCAS])
-    ac_good_gnu_arm_assembler=yes
-  fi
-
-  if test "x$ac_good_gnu_arm_assembler" = "xyes" ; then
-    $1
-  else
-    $2
-  fi
-])
diff --git a/appveyor.yml b/appveyor.yml
index 4f2d6cc..0acc329 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -16,11 +16,11 @@ install:
 
       set MSYSTEM=MINGW32
 
-      bash -c "pacman --noconfirm -S autoconf automake libtool zip"
+      bash -c "pacman --noconfirm -S zip"
 
       mklink /d "%ProgramData%\Oracle\Java32" "c:\Program Files (x86)\Java\jdk1.6.0"
 
-      git clone --depth=1 https://github.com/libjpeg-turbo/buildscripts.git c:/buildscripts
+      git clone --depth=1 https://github.com/libjpeg-turbo/buildscripts.git -b %APPVEYOR_REPO_BRANCH% c:/buildscripts
 
 build_script:
   - cmd: >-
diff --git a/cjpeg.1 b/cjpeg.1
index 283fc81..557b0b0 100644
--- a/cjpeg.1
+++ b/cjpeg.1
@@ -187,6 +187,9 @@ method may also give different results on different machines due to varying
 roundoff behavior, whereas the integer methods should give the same results on
 all machines.
 .TP
+.BI \-icc " file"
+Embed ICC color management profile contained in the specified file.
+.TP
 .BI \-restart " N"
 Emit a JPEG restart marker every N MCU rows, or every N MCU blocks if "B" is
 attached to the number.
diff --git a/cjpeg.c b/cjpeg.c
index 9d282b8..da9af73 100644
--- a/cjpeg.c
+++ b/cjpeg.c
@@ -31,6 +31,11 @@
 #include "jversion.h"           /* for version message */
 #include "jconfigint.h"
 
+#ifndef HAVE_STDLIB_H           /* <stdlib.h> should declare malloc(),free() */
+extern void *malloc (size_t size);
+extern void free (void *ptr);
+#endif
+
 #ifdef USE_CCOMMAND             /* command-line reader for Macintosh */
 #ifdef __MWERKS__
 #include <SIOUX.h>              /* Metrowerks needs this */
@@ -139,6 +144,7 @@ select_file_type (j_compress_ptr cinfo, FILE *infile)
 
 
 static const char *progname;    /* program name for error messages */
+static char *icc_filename;      /* for -icc switch */
 static char *outfilename;       /* for -outfile switch */
 boolean memdst;                 /* for -memdst switch */
 
@@ -184,6 +190,7 @@ usage (void)
   fprintf(stderr, "  -dct float     Use floating-point DCT method%s\n",
           (JDCT_DEFAULT == JDCT_FLOAT ? " (default)" : ""));
 #endif
+  fprintf(stderr, "  -icc FILE      Embed ICC profile contained in FILE\n");
   fprintf(stderr, "  -restart N     Set restart interval in rows, or in blocks with B\n");
 #ifdef INPUT_SMOOTHING_SUPPORTED
   fprintf(stderr, "  -smooth N      Smooth dithered input (N=1..100 is strength)\n");
@@ -234,6 +241,7 @@ parse_switches (j_compress_ptr cinfo, int argc, char **argv,
   force_baseline = FALSE;       /* by default, allow 16-bit quantizers */
   simple_progressive = FALSE;
   is_targa = FALSE;
+  icc_filename = NULL;
   outfilename = NULL;
   memdst = FALSE;
   cinfo->err->trace_level = 0;
@@ -307,6 +315,12 @@ parse_switches (j_compress_ptr cinfo, int argc, char **argv,
       /* Force an RGB JPEG file to be generated. */
       jpeg_set_colorspace(cinfo, JCS_RGB);
 
+    } else if (keymatch(arg, "icc", 1)) {
+      /* Set ICC filename. */
+      if (++argn >= argc)       /* advance to next argument */
+        usage();
+      icc_filename = argv[argn];
+
     } else if (keymatch(arg, "maxmemory", 3)) {
       /* Maximum memory in Kb (or Mb with 'm'). */
       long lval;
@@ -496,6 +510,9 @@ main (int argc, char **argv)
   int file_index;
   cjpeg_source_ptr src_mgr;
   FILE *input_file;
+  FILE *icc_file;
+  JOCTET *icc_profile = NULL;
+  long icc_len = 0;
   FILE *output_file = NULL;
   unsigned char *outbuffer = NULL;
   unsigned long outsize = 0;
@@ -583,6 +600,33 @@ main (int argc, char **argv)
     output_file = write_stdout();
   }
 
+  if (icc_filename != NULL) {
+    if ((icc_file = fopen(icc_filename, READ_BINARY)) == NULL) {
+      fprintf(stderr, "%s: can't open %s\n", progname, icc_filename);
+      exit(EXIT_FAILURE);
+    }
+    if (fseek(icc_file, 0, SEEK_END) < 0 ||
+        (icc_len = ftell(icc_file)) < 1 ||
+        fseek(icc_file, 0, SEEK_SET) < 0) {
+      fprintf(stderr, "%s: can't determine size of %s\n", progname,
+              icc_filename);
+      exit(EXIT_FAILURE);
+    }
+    if ((icc_profile = (JOCTET *)malloc(icc_len)) == NULL) {
+      fprintf(stderr, "%s: can't allocate memory for ICC profile\n", progname);
+      fclose(icc_file);
+      exit(EXIT_FAILURE);
+    }
+    if (fread(icc_profile, icc_len, 1, icc_file) < 1) {
+      fprintf(stderr, "%s: can't read ICC profile from %s\n", progname,
+              icc_filename);
+      free(icc_profile);
+      fclose(icc_file);
+      exit(EXIT_FAILURE);
+    }
+    fclose(icc_file);
+  }
+
 #ifdef PROGRESS_REPORT
   start_progress_monitor((j_common_ptr) &cinfo, &progress);
 #endif
@@ -611,6 +655,9 @@ main (int argc, char **argv)
   /* Start compressor */
   jpeg_start_compress(&cinfo, TRUE);
 
+  if (icc_profile != NULL)
+    jpeg_write_icc_profile(&cinfo, icc_profile, (unsigned int)icc_len);
+
   /* Process data */
   while (cinfo.next_scanline < cinfo.image_height) {
     num_scanlines = (*src_mgr->get_pixel_rows) (&cinfo, src_mgr);
@@ -638,6 +685,9 @@ main (int argc, char **argv)
       free(outbuffer);
   }
 
+  if (icc_profile != NULL)
+    free(icc_profile);
+
   /* All done. */
   exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
   return 0;                     /* suppress no-return-value warnings */
diff --git a/cmakescripts/BuildPackages.cmake b/cmakescripts/BuildPackages.cmake
new file mode 100644
index 0000000..d9bb520
--- /dev/null
+++ b/cmakescripts/BuildPackages.cmake
@@ -0,0 +1,172 @@
+# This file is included from the top-level CMakeLists.txt.  We just store it
+# here to avoid cluttering up that file.
+
+set(PKGNAME ${CMAKE_PROJECT_NAME} CACHE STRING
+  "Distribution package name (default: ${CMAKE_PROJECT_NAME})")
+set(PKGVENDOR "The ${CMAKE_PROJECT_NAME} Project" CACHE STRING
+  "Vendor name to be included in distribution package descriptions (default: The ${CMAKE_PROJECT_NAME} Project)")
+set(PKGURL "http://www.${CMAKE_PROJECT_NAME}.org" CACHE STRING
+  "URL of project web site to be included in distribution package descriptions (default: http://www.${CMAKE_PROJECT_NAME}.org)")
+set(PKGEMAIL "information@${CMAKE_PROJECT_NAME}.org" CACHE STRING
+  "E-mail of project maintainer to be included in distribution package descriptions (default: information@${CMAKE_PROJECT_NAME}.org")
+set(PKGID "com.${CMAKE_PROJECT_NAME}.${PKGNAME}" CACHE STRING
+  "Globally unique package identifier (reverse DNS notation) (default: com.${CMAKE_PROJECT_NAME}.${PKGNAME})")
+
+
+###############################################################################
+# Linux RPM and DEB
+###############################################################################
+
+if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
+
+set(RPMARCH ${CMAKE_SYSTEM_PROCESSOR})
+if(CPU_TYPE STREQUAL "x86_64")
+  set(DEBARCH amd64)
+elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "armv7*")
+  set(DEBARCH armhf)
+elseif(CPU_TYPE STREQUAL "arm64")
+  set(DEBARCH ${CPU_TYPE})
+elseif(CPU_TYPE STREQUAL "arm")
+  set(DEBARCH armel)
+else()
+  set(DEBARCH ${CMAKE_SYSTEM_PROCESSOR})
+endif()
+message(STATUS "RPM architecture = ${RPMARCH}, DEB architecture = ${DEBARCH}")
+
+# Re-set CMAKE_POSITION_INDEPENDENT_CODE so that the RPM spec file works
+# properly
+boolean_number(CMAKE_POSITION_INDEPENDENT_CODE)
+
+configure_file(release/makerpm.in pkgscripts/makerpm)
+configure_file(release/rpm.spec.in pkgscripts/rpm.spec @ONLY)
+
+add_custom_target(rpm sh pkgscripts/makerpm
+  SOURCES pkgscripts/makerpm)
+
+configure_file(release/makesrpm.in pkgscripts/makesrpm)
+
+add_custom_target(srpm sh pkgscripts/makesrpm
+  SOURCES pkgscripts/makesrpm
+  DEPENDS dist)
+
+configure_file(release/makedpkg.in pkgscripts/makedpkg)
+configure_file(release/deb-control.in pkgscripts/deb-control)
+
+add_custom_target(deb sh pkgscripts/makedpkg
+  SOURCES pkgscripts/makedpkg)
+
+endif() # Linux
+
+
+###############################################################################
+# Windows installer (NullSoft Installer)
+###############################################################################
+
+if(WIN32)
+
+if(MSVC)
+  set(INST_PLATFORM "Visual C++")
+  set(INST_NAME ${CMAKE_PROJECT_NAME}-${VERSION}-vc)
+  set(INST_REG_NAME ${CMAKE_PROJECT_NAME})
+elseif(MINGW)
+  set(INST_PLATFORM GCC)
+  set(INST_NAME ${CMAKE_PROJECT_NAME}-${VERSION}-gcc)
+  set(INST_REG_NAME ${CMAKE_PROJECT_NAME}-gcc)
+  set(INST_DEFS -DGCC)
+endif()
+
+if(BITS EQUAL 64)
+  set(INST_PLATFORM "${INST_PLATFORM} 64-bit")
+  set(INST_NAME ${INST_NAME}64)
+  set(INST_REG_NAME ${INST_DIR}64)
+  set(INST_DEFS ${INST_DEFS} -DWIN64)
+endif()
+
+if(WITH_JAVA)
+  set(INST_DEFS ${INST_DEFS} -DJAVA)
+endif()
+
+if(MSVC_IDE)
+  set(INST_DEFS ${INST_DEFS} "-DBUILDDIR=${CMAKE_CFG_INTDIR}\\")
+else()
+  set(INST_DEFS ${INST_DEFS} "-DBUILDDIR=")
+endif()
+
+string(REGEX REPLACE "/" "\\\\" INST_DIR ${CMAKE_INSTALL_PREFIX})
+
+configure_file(release/installer.nsi.in installer.nsi @ONLY)
+
+if(WITH_JAVA)
+  set(JAVA_DEPEND turbojpeg-java)
+endif()
+add_custom_target(installer
+  makensis -nocd ${INST_DEFS} installer.nsi
+  DEPENDS jpeg jpeg-static turbojpeg turbojpeg-static rdjpgcom wrjpgcom
+    cjpeg djpeg jpegtran tjbench ${JAVA_DEPEND}
+  SOURCES installer.nsi)
+
+endif() # WIN32
+
+
+###############################################################################
+# Cygwin Package
+###############################################################################
+
+if(CYGWIN)
+
+configure_file(release/makecygwinpkg.in pkgscripts/makecygwinpkg)
+
+add_custom_target(cygwinpkg sh pkgscripts/makecygwinpkg)
+
+endif() # CYGWIN
+
+
+###############################################################################
+# Mac DMG
+###############################################################################
+
+if(APPLE)
+
+set(DEFAULT_OSX_32BIT_BUILD ${CMAKE_SOURCE_DIR}/osxx86)
+set(OSX_32BIT_BUILD ${DEFAULT_OSX_32BIT_BUILD} CACHE PATH
+  "Directory containing 32-bit (i386) Mac build to include in universal binaries (default: ${DEFAULT_OSX_32BIT_BUILD})")
+set(DEFAULT_IOS_ARMV7_BUILD ${CMAKE_SOURCE_DIR}/iosarmv7)
+set(IOS_ARMV7_BUILD ${DEFAULT_IOS_ARMV7_BUILD} CACHE PATH
+  "Directory containing ARMv7 iOS build to include in universal binaries (default: ${DEFAULT_IOS_ARMV7_BUILD})")
+set(DEFAULT_IOS_ARMV7S_BUILD ${CMAKE_SOURCE_DIR}/iosarmv7s)
+set(IOS_ARMV7S_BUILD ${DEFAULT_IOS_ARMV7S_BUILD} CACHE PATH
+  "Directory containing ARMv7s iOS build to include in universal binaries (default: ${DEFAULT_IOS_ARMV7S_BUILD})")
+set(DEFAULT_IOS_ARMV8_BUILD ${CMAKE_SOURCE_DIR}/iosarmv8)
+set(IOS_ARMV8_BUILD ${DEFAULT_IOS_ARMV8_BUILD} CACHE PATH
+  "Directory containing ARMv8 iOS build to include in universal binaries (default: ${DEFAULT_IOS_ARMV8_BUILD})")
+
+configure_file(release/makemacpkg.in pkgscripts/makemacpkg)
+configure_file(release/Distribution.xml.in pkgscripts/Distribution.xml)
+configure_file(release/uninstall.in pkgscripts/uninstall)
+
+add_custom_target(dmg sh pkgscripts/makemacpkg
+  SOURCES pkgscripts/makemacpkg)
+
+add_custom_target(udmg sh pkgscripts/makemacpkg universal
+  SOURCES pkgscripts/makemacpkg)
+
+endif() # APPLE
+
+
+###############################################################################
+# Generic
+###############################################################################
+
+add_custom_target(dist
+  COMMAND git archive --prefix=${CMAKE_PROJECT_NAME}-${VERSION}/ HEAD |
+    gzip > ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_PROJECT_NAME}-${VERSION}.tar.gz
+    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})
+
+configure_file(release/maketarball.in pkgscripts/maketarball)
+
+add_custom_target(tarball sh pkgscripts/maketarball
+  SOURCES pkgscripts/maketarball)
+
+configure_file(release/libjpeg.pc.in pkgscripts/libjpeg.pc @ONLY)
+
+configure_file(release/libturbojpeg.pc.in pkgscripts/libturbojpeg.pc @ONLY)
diff --git a/cmakescripts/GNUInstallDirs.cmake b/cmakescripts/GNUInstallDirs.cmake
new file mode 100644
index 0000000..ef564bb
--- /dev/null
+++ b/cmakescripts/GNUInstallDirs.cmake
@@ -0,0 +1,416 @@
+#.rst:
+# GNUInstallDirs
+# --------------
+#
+# Define GNU standard installation directories
+#
+# Provides install directory variables as defined by the
+# `GNU Coding Standards`_.
+#
+# .. _`GNU Coding Standards`: https://www.gnu.org/prep/standards/html_node/Directory-Variables.html
+#
+# Result Variables
+# ^^^^^^^^^^^^^^^^
+#
+# Inclusion of this module defines the following variables:
+#
+# ``CMAKE_INSTALL_<dir>``
+#
+#   Destination for files of a given type.  This value may be passed to
+#   the ``DESTINATION`` options of :command:`install` commands for the
+#   corresponding file type.
+#
+# ``CMAKE_INSTALL_FULL_<dir>``
+#
+#   The absolute path generated from the corresponding ``CMAKE_INSTALL_<dir>``
+#   value.  If the value is not already an absolute path, an absolute path
+#   is constructed typically by prepending the value of the
+#   :variable:`CMAKE_INSTALL_PREFIX` variable.  However, there are some
+#   `special cases`_ as documented below.
+#
+# where ``<dir>`` is one of:
+#
+# ``BINDIR``
+#   user executables (``bin``)
+# ``SBINDIR``
+#   system admin executables (``sbin``)
+# ``LIBEXECDIR``
+#   program executables (``libexec``)
+# ``SYSCONFDIR``
+#   read-only single-machine data (``etc``)
+# ``SHAREDSTATEDIR``
+#   modifiable architecture-independent data (``com``)
+# ``LOCALSTATEDIR``
+#   modifiable single-machine data (``var``)
+# ``LIBDIR``
+#   object code libraries (``lib`` or ``lib64``
+#   or ``lib/<multiarch-tuple>`` on Debian)
+# ``INCLUDEDIR``
+#   C header files (``include``)
+# ``OLDINCLUDEDIR``
+#   C header files for non-gcc (``/usr/include``)
+# ``DATAROOTDIR``
+#   read-only architecture-independent data root (``share``)
+# ``DATADIR``
+#   read-only architecture-independent data (``DATAROOTDIR``)
+# ``INFODIR``
+#   info documentation (``DATAROOTDIR/info``)
+# ``LOCALEDIR``
+#   locale-dependent data (``DATAROOTDIR/locale``)
+# ``MANDIR``
+#   man documentation (``DATAROOTDIR/man``)
+# ``DOCDIR``
+#   documentation root (``DATAROOTDIR/doc/PROJECT_NAME``)
+#
+# If the includer does not define a value the above-shown default will be
+# used and the value will appear in the cache for editing by the user.
+#
+# Special Cases
+# ^^^^^^^^^^^^^
+#
+# The following values of :variable:`CMAKE_INSTALL_PREFIX` are special:
+#
+# ``/``
+#
+#   For ``<dir>`` other than the ``SYSCONFDIR`` and ``LOCALSTATEDIR``,
+#   the value of ``CMAKE_INSTALL_<dir>`` is prefixed with ``usr/`` if
+#   it is not user-specified as an absolute path.  For example, the
+#   ``INCLUDEDIR`` value ``include`` becomes ``usr/include``.
+#   This is required by the `GNU Coding Standards`_, which state:
+#
+#     When building the complete GNU system, the prefix will be empty
+#     and ``/usr`` will be a symbolic link to ``/``.
+#
+# ``/usr``
+#
+#   For ``<dir>`` equal to ``SYSCONFDIR`` or ``LOCALSTATEDIR``, the
+#   ``CMAKE_INSTALL_FULL_<dir>`` is computed by prepending just ``/``
+#   to the value of ``CMAKE_INSTALL_<dir>`` if it is not user-specified
+#   as an absolute path.  For example, the ``SYSCONFDIR`` value ``etc``
+#   becomes ``/etc``.  This is required by the `GNU Coding Standards`_.
+#
+# ``/opt/...``
+#
+#   For ``<dir>`` equal to ``SYSCONFDIR`` or ``LOCALSTATEDIR``, the
+#   ``CMAKE_INSTALL_FULL_<dir>`` is computed by *appending* the prefix
+#   to the value of ``CMAKE_INSTALL_<dir>`` if it is not user-specified
+#   as an absolute path.  For example, the ``SYSCONFDIR`` value ``etc``
+#   becomes ``/etc/opt/...``.  This is defined by the
+#   `Filesystem Hierarchy Standard`_.
+#
+# .. _`Filesystem Hierarchy Standard`: https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html
+#
+# Macros
+# ^^^^^^
+#
+# .. command:: GNUInstallDirs_get_absolute_install_dir
+#
+#   ::
+#
+#     GNUInstallDirs_get_absolute_install_dir(absvar var)
+#
+#   Set the given variable ``absvar`` to the absolute path contained
+#   within the variable ``var``.  This is to allow the computation of an
+#   absolute path, accounting for all the special cases documented
+#   above.  While this macro is used to compute the various
+#   ``CMAKE_INSTALL_FULL_<dir>`` variables, it is exposed publicly to
+#   allow users who create additional path variables to also compute
+#   absolute paths where necessary, using the same logic.
+
+#=============================================================================
+# Copyright 2016 D. R. Commander
+# Copyright 2016 Dmitry Marakasov
+# Copyright 2016 Roger Leigh
+# Copyright 2015 Alex Turbov
+# Copyright 2014 Rolf Eike Beer
+# Copyright 2014 Daniele E. Domenichelli
+# Copyright 2013 Dimitri John Ledkov
+# Copyright 2011 Alex Neundorf
+# Copyright 2011 Eric NOULARD
+# Copyright 2011, 2013-2015 Kitware, Inc.
+# Copyright 2011 Nikita Krupen'ko
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# * Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+#
+# * Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+#
+# * Neither the names of Kitware, Inc., the Insight Software Consortium,
+#   nor the names of their contributors may be used to endorse or promote
+#   products derived from this software without specific prior written
+#   permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#=============================================================================
+
+# Installation directories
+#
+
+macro(GNUInstallDirs_set_install_dir var docstring)
+  # If CMAKE_INSTALL_PREFIX changes and CMAKE_INSTALL_*DIR is still set to the
+  # default value, then modify it accordingly.  This presumes that the default
+  # value may change based on the prefix.
+
+  set(_GNUInstallDirs_CMAKE_INSTALL_FORCE_${var} "")
+  if(NOT DEFINED CMAKE_INSTALL_${var})
+    set(_GNUInstallDirs_CMAKE_INSTALL_DEFAULT_${var} 1 CACHE INTERNAL
+      "CMAKE_INSTALL_${var} has default value")
+  elseif(DEFINED _GNUInstallDirs_CMAKE_INSTALL_LAST_DEFAULT_${var} AND
+    NOT "${_GNUInstallDirs_CMAKE_INSTALL_LAST_DEFAULT_${var}}" STREQUAL
+      "${CMAKE_INSTALL_DEFAULT_${var}}" AND
+    _GNUInstallDirs_CMAKE_INSTALL_DEFAULT_${var} AND
+    "${_GNUInstallDirs_CMAKE_INSTALL_LAST_${var}}" STREQUAL
+      "${CMAKE_INSTALL_${var}}")
+    set(_GNUInstallDirs_CMAKE_INSTALL_FORCE_${var} "FORCE")
+  endif()
+
+  set(CMAKE_INSTALL_${var} "${CMAKE_INSTALL_DEFAULT_${var}}" CACHE PATH
+    "${docstring} (Default: ${CMAKE_INSTALL_DEFAULT_${var}})"
+    ${_GNUInstallDirs_CMAKE_INSTALL_FORCE_${var}})
+
+  if(NOT "${CMAKE_INSTALL_${var}}" STREQUAL "${CMAKE_INSTALL_DEFAULT_${var}}")
+    unset(_GNUInstallDirs_CMAKE_INSTALL_DEFAULT_${var} CACHE)
+  endif()
+
+  # Save for next run
+  set(_GNUInstallDirs_CMAKE_INSTALL_LAST_${var} "${CMAKE_INSTALL_${var}}"
+    CACHE INTERNAL "CMAKE_INSTALL_${var} during last run")
+  set(_GNUInstallDirs_CMAKE_INSTALL_LAST_DEFAULT_${var}
+    "${CMAKE_INSTALL_DEFAULT_${var}}" CACHE INTERNAL
+    "CMAKE_INSTALL_DEFAULT_${var} during last run")
+endmacro()
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_BINDIR)
+  set(CMAKE_INSTALL_DEFAULT_BINDIR "bin")
+endif()
+GNUInstallDirs_set_install_dir(BINDIR
+  "Directory into which user executables should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_SBINDIR)
+  set(CMAKE_INSTALL_DEFAULT_SBINDIR "sbin")
+endif()
+GNUInstallDirs_set_install_dir(SBINDIR
+  "Directory into which system admin executables should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_LIBEXECDIR)
+  set(CMAKE_INSTALL_DEFAULT_LIBEXECDIR "libexec")
+endif()
+GNUInstallDirs_set_install_dir(LIBEXECDIR
+  "Directory under which executables run by other programs should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_SYSCONFDIR)
+  set(CMAKE_INSTALL_DEFAULT_SYSCONFDIR "etc")
+endif()
+GNUInstallDirs_set_install_dir(SYSCONFDIR
+  "Directory into which machine-specific read-only ASCII data and configuration files should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_SHAREDSTATEDIR)
+  set(CMAKE_INSTALL_DEFAULT_SHAREDSTATEDIR "com")
+endif()
+GNUInstallDirs_set_install_dir(SHAREDSTATEDIR
+  "Directory into which architecture-independent run-time-modifiable data files should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_LOCALSTATEDIR)
+  set(CMAKE_INSTALL_DEFAULT_LOCALSTATEDIR "var")
+endif()
+GNUInstallDirs_set_install_dir(LOCALSTATEDIR
+  "Directory into which machine-specific run-time-modifiable data files should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_LIBDIR)
+  set(CMAKE_INSTALL_DEFAULT_LIBDIR "lib")
+  # Override this default 'lib' with 'lib64' iff:
+  #  - we are on Linux system but NOT cross-compiling
+  #  - we are NOT on debian
+  #  - we are on a 64 bits system
+  # reason is: amd64 ABI: http://www.x86-64.org/documentation/abi.pdf
+  # For Debian with multiarch, use 'lib/${CMAKE_LIBRARY_ARCHITECTURE}' if
+  # CMAKE_LIBRARY_ARCHITECTURE is set (which contains e.g. "i386-linux-gnu"
+  # and CMAKE_INSTALL_PREFIX is "/usr"
+  # See http://wiki.debian.org/Multiarch
+  if(CMAKE_SYSTEM_NAME MATCHES "^(Linux|kFreeBSD|GNU)$"
+      AND NOT CMAKE_CROSSCOMPILING)
+    if (EXISTS "/etc/debian_version") # is this a debian system ?
+      if(CMAKE_LIBRARY_ARCHITECTURE)
+        if("${CMAKE_INSTALL_PREFIX}" MATCHES "^/usr/?$")
+          set(CMAKE_INSTALL_DEFAULT_LIBDIR "lib/${CMAKE_LIBRARY_ARCHITECTURE}")
+        endif()
+      endif()
+    else() # not debian, rely on CMAKE_SIZEOF_VOID_P:
+      if(NOT DEFINED CMAKE_SIZEOF_VOID_P)
+        message(AUTHOR_WARNING
+          "Unable to determine default CMAKE_INSTALL_LIBDIR directory because no target architecture is known. "
+          "Please enable at least one language before including GNUInstallDirs.")
+      else()
+        if("${CMAKE_SIZEOF_VOID_P}" EQUAL "8")
+          set(CMAKE_INSTALL_DEFAULT_LIBDIR "lib64")
+        endif()
+      endif()
+    endif()
+  endif()
+endif()
+GNUInstallDirs_set_install_dir(LIBDIR
+  "Directory into which object files and object code libraries should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_INCLUDEDIR)
+  set(CMAKE_INSTALL_DEFAULT_INCLUDEDIR "include")
+endif()
+GNUInstallDirs_set_install_dir(INCLUDEDIR
+  "Directory into which C header files should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_OLDINCLUDEDIR)
+  set(CMAKE_INSTALL_DEFAULT_OLDINCLUDEDIR "/usr/include")
+endif()
+GNUInstallDirs_set_install_dir(OLDINCLUDEDIR
+  PATH "Directory into which C header files for non-GCC compilers should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_DATAROOTDIR)
+  set(CMAKE_INSTALL_DEFAULT_DATAROOTDIR "share")
+endif()
+GNUInstallDirs_set_install_dir(DATAROOTDIR
+  "The root of the directory tree for read-only architecture-independent data files")
+
+#-----------------------------------------------------------------------------
+# Values whose defaults are relative to DATAROOTDIR.  Store empty values in
+# the cache and store the defaults in local variables if the cache values are
+# not set explicitly.  This auto-updates the defaults as DATAROOTDIR changes.
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_DATADIR)
+  set(CMAKE_INSTALL_DEFAULT_DATADIR "<CMAKE_INSTALL_DATAROOTDIR>")
+endif()
+GNUInstallDirs_set_install_dir(DATADIR
+  "The directory under which read-only architecture-independent data files should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_INFODIR)
+  if(CMAKE_SYSTEM_NAME MATCHES "^(.*BSD|DragonFly)$")
+    set(CMAKE_INSTALL_DEFAULT_INFODIR "info")
+  else()
+    set(CMAKE_INSTALL_DEFAULT_INFODIR "<CMAKE_INSTALL_DATAROOTDIR>/info")
+  endif()
+endif()
+GNUInstallDirs_set_install_dir(INFODIR
+  "The directory into which info documentation files should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_MANDIR)
+  if(CMAKE_SYSTEM_NAME MATCHES "^(.*BSD|DragonFly)$")
+    set(CMAKE_INSTALL_DEFAULT_MANDIR "man")
+  else()
+    set(CMAKE_INSTALL_DEFAULT_MANDIR "<CMAKE_INSTALL_DATAROOTDIR>/man")
+  endif()
+endif()
+GNUInstallDirs_set_install_dir(MANDIR
+  "The directory under which man pages should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_LOCALEDIR)
+  set(CMAKE_INSTALL_DEFAULT_LOCALEDIR "<CMAKE_INSTALL_DATAROOTDIR>/locale")
+endif()
+GNUInstallDirs_set_install_dir(LOCALEDIR
+  "The directory under which locale-specific message catalogs should be installed")
+
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_DOCDIR)
+  set(CMAKE_INSTALL_DEFAULT_DOCDIR "<CMAKE_INSTALL_DATAROOTDIR>/doc/${PROJECT_NAME}")
+endif()
+GNUInstallDirs_set_install_dir(DOCDIR
+  "The directory into which documentation files (other than info files) should be installed")
+
+#-----------------------------------------------------------------------------
+
+mark_as_advanced(
+  CMAKE_INSTALL_BINDIR
+  CMAKE_INSTALL_SBINDIR
+  CMAKE_INSTALL_LIBEXECDIR
+  CMAKE_INSTALL_SYSCONFDIR
+  CMAKE_INSTALL_SHAREDSTATEDIR
+  CMAKE_INSTALL_LOCALSTATEDIR
+  CMAKE_INSTALL_LIBDIR
+  CMAKE_INSTALL_INCLUDEDIR
+  CMAKE_INSTALL_OLDINCLUDEDIR
+  CMAKE_INSTALL_DATAROOTDIR
+  CMAKE_INSTALL_DATADIR
+  CMAKE_INSTALL_INFODIR
+  CMAKE_INSTALL_LOCALEDIR
+  CMAKE_INSTALL_MANDIR
+  CMAKE_INSTALL_DOCDIR
+  )
+
+macro(GNUInstallDirs_get_absolute_install_dir absvar var)
+  string(REGEX REPLACE "[<>]" "@" ${var} "${${var}}")
+  # Handle the specific case of an empty CMAKE_INSTALL_DATAROOTDIR
+  if(NOT CMAKE_INSTALL_DATAROOTDIR AND
+    ${var} MATCHES "\@CMAKE_INSTALL_DATAROOTDIR\@/")
+    string(CONFIGURE "${${var}}" ${var} @ONLY)
+    string(REGEX REPLACE "^/" "" ${var} "${${var}}")
+  else()
+    string(CONFIGURE "${${var}}" ${var} @ONLY)
+  endif()
+  if(NOT IS_ABSOLUTE "${${var}}")
+    # Handle special cases:
+    # - CMAKE_INSTALL_PREFIX == /
+    # - CMAKE_INSTALL_PREFIX == /usr
+    # - CMAKE_INSTALL_PREFIX == /opt/...
+    if("${CMAKE_INSTALL_PREFIX}" STREQUAL "/")
+      if("${dir}" STREQUAL "SYSCONFDIR" OR "${dir}" STREQUAL "LOCALSTATEDIR")
+        set(${absvar} "/${${var}}")
+      else()
+        if (NOT "${${var}}" MATCHES "^usr/")
+          set(${var} "usr/${${var}}")
+        endif()
+        set(${absvar} "/${${var}}")
+      endif()
+    elseif("${CMAKE_INSTALL_PREFIX}" MATCHES "^/usr/?$")
+      if("${dir}" STREQUAL "SYSCONFDIR" OR "${dir}" STREQUAL "LOCALSTATEDIR")
+        set(${absvar} "/${${var}}")
+      else()
+        set(${absvar} "${CMAKE_INSTALL_PREFIX}/${${var}}")
+      endif()
+    elseif("${CMAKE_INSTALL_PREFIX}" MATCHES "^/opt/.*")
+      if("${dir}" STREQUAL "SYSCONFDIR" OR "${dir}" STREQUAL "LOCALSTATEDIR")
+        set(${absvar} "/${${var}}${CMAKE_INSTALL_PREFIX}")
+      else()
+        set(${absvar} "${CMAKE_INSTALL_PREFIX}/${${var}}")
+      endif()
+    else()
+      set(${absvar} "${CMAKE_INSTALL_PREFIX}/${${var}}")
+    endif()
+  else()
+    set(${absvar} "${${var}}")
+  endif()
+  string(REGEX REPLACE "/$" "" ${absvar} "${${absvar}}")
+endmacro()
+
+# Result directories
+#
+foreach(dir
+    BINDIR
+    SBINDIR
+    LIBEXECDIR
+    SYSCONFDIR
+    SHAREDSTATEDIR
+    LOCALSTATEDIR
+    LIBDIR
+    INCLUDEDIR
+    OLDINCLUDEDIR
+    DATAROOTDIR
+    DATADIR
+    INFODIR
+    LOCALEDIR
+    MANDIR
+    DOCDIR
+    )
+  GNUInstallDirs_get_absolute_install_dir(CMAKE_INSTALL_FULL_${dir} CMAKE_INSTALL_${dir})
+endforeach()
diff --git a/cmakescripts/cmake_uninstall.cmake.in b/cmakescripts/cmake_uninstall.cmake.in
index b35d100..6726a0d 100644
--- a/cmakescripts/cmake_uninstall.cmake.in
+++ b/cmakescripts/cmake_uninstall.cmake.in
@@ -1,10 +1,10 @@
 # This code is from the CMake FAQ
 
-if (NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
-  message(FATAL_ERROR "Cannot find install manifest: \"@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt\"")
-endif(NOT EXISTS "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt")
+if (NOT EXISTS "@CMAKE_BINARY_DIR@/install_manifest.txt")
+  message(FATAL_ERROR "Cannot find install manifest: \"@CMAKE_BINARY_DIR@/install_manifest.txt\"")
+endif(NOT EXISTS "@CMAKE_BINARY_DIR@/install_manifest.txt")
 
-file(READ "@CMAKE_CURRENT_BINARY_DIR@/install_manifest.txt" files)
+file(READ "@CMAKE_BINARY_DIR@/install_manifest.txt" files)
 string(REGEX REPLACE "\n" ";" files "${files}")
 list(REVERSE files)
 foreach (file ${files})
diff --git a/configure.ac b/configure.ac
deleted file mode 100644
index 5766b87..0000000
--- a/configure.ac
+++ /dev/null
@@ -1,611 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_PREREQ([2.56])
-AC_INIT([libjpeg-turbo], [1.5.2])
-
-AM_INIT_AUTOMAKE([-Wall foreign dist-bzip2])
-AC_PREFIX_DEFAULT(/opt/libjpeg-turbo)
-
-m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
-
-# Checks for programs.
-SAVED_CFLAGS=${CFLAGS}
-SAVED_CPPFLAGS=${CPPFLAGS}
-AC_PROG_CPP
-AC_PROG_CC
-m4_ifdef([AM_PROG_AR], [AM_PROG_AR])
-AM_PROG_AS
-AM_PROG_CC_C_O
-AC_PROG_INSTALL
-AC_PROG_LIBTOOL
-AC_PROG_LN_S
-
-AC_ARG_WITH([build-date], [Use custom build string to enable reproducible builds (default: YYMMDD)],
-  [BUILD="$with_build_date"],
-  [BUILD=`date +%Y%m%d`])
-
-PKG_PROG_PKG_CONFIG
-
-# When the prefix is /opt/libjpeg-turbo, we assume that an "official" binary is
-# being created, and thus we install things into specific locations.
-
-old_prefix=${prefix}
-if test "x$prefix" = "xNONE" -a "x$ac_default_prefix" != "x"; then
-  prefix=$ac_default_prefix
-fi
-DATADIR=`eval echo ${datadir}`
-DATADIR=`eval echo $DATADIR`
-if test "$DATADIR" = "/opt/libjpeg-turbo/share"; then
-  datadir='${prefix}'
-fi
-DATADIR=`eval echo ${datarootdir}`
-DATADIR=`eval echo $DATADIR`
-if test "$DATADIR" = "/opt/libjpeg-turbo/share"; then
-  datarootdir='${prefix}'
-fi
-DOCDIR=`eval echo ${docdir}`
-DOCDIR=`eval echo $DOCDIR`
-if test "$DOCDIR" = "/opt/libjpeg-turbo/doc/libjpeg-turbo"; then
-  docdir='${datadir}/doc'
-fi
-
-old_exec_prefix=${exec_prefix}
-if test "x$exec_prefix" = "xNONE"; then
-  exec_prefix=${prefix}
-fi
-
-AC_CHECK_SIZEOF(size_t)
-
-if test "x${libdir}" = 'x${exec_prefix}/lib' -o "x${libdir}" = 'x${prefix}/lib'; then
-  LIBDIR=`eval echo ${libdir}`
-  LIBDIR=`eval echo $LIBDIR`
-  if test "$LIBDIR" = "/opt/libjpeg-turbo/lib"; then
-    case $host_os in
-      darwin*)
-        ;;
-      *)
-        if test "${ac_cv_sizeof_size_t}" = "8"; then
-          libdir='${exec_prefix}/lib64'
-        elif test "${ac_cv_sizeof_size_t}" = "4"; then
-          libdir='${exec_prefix}/lib32'
-        fi
-        ;;
-    esac
-  fi
-fi
-exec_prefix=${old_exec_prefix}
-prefix=${old_prefix}
-
-# Check whether compiler supports pointers to undefined structures
-AC_MSG_CHECKING(whether compiler supports pointers to undefined structures)
-AC_TRY_COMPILE([ typedef struct undefined_structure *undef_struct_ptr; ], ,
-  AC_MSG_RESULT(yes),
-  [AC_MSG_RESULT(no)
-   AC_DEFINE([INCOMPLETE_TYPES_BROKEN], [1],
-     [Compiler does not support pointers to undefined structures.])])
-
-if test "x${GCC}" = "xyes"; then
-  if test "x${SAVED_CFLAGS}" = "x"; then
-    CFLAGS=-O3
-  fi
-  if test "x${SAVED_CPPFLAGS}" = "x"; then
-    CPPFLAGS=-Wall
-  fi
-fi
-
-AC_CHECK_DECL([__SUNPRO_C], [SUNCC="yes"], [SUNCC="no"])
-if test "x${SUNCC}" = "xyes"; then
-  if test "x${SAVED_CFLAGS}" = "x"; then
-    CFLAGS=-xO5
-  fi
-fi
-
-# Checks for libraries.
-
-# Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS([stddef.h stdlib.h locale.h string.h])
-AC_CHECK_HEADER([sys/types.h],
-  AC_DEFINE([NEED_SYS_TYPES_H], 1, [Define if you need to include <sys/types.h> to get size_t.]))
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_C_CHAR_UNSIGNED
-AC_C_INLINE
-AC_TYPE_SIZE_T
-AC_CHECK_TYPES([unsigned char, unsigned short])
-
-AC_MSG_CHECKING([if right shift is signed])
-AC_TRY_RUN(
-  [#include <stdio.h>
-   int is_shifting_signed (long arg) {
-     long res = arg >> 4;
-
-     if (res == -0x7F7E80CL)
-       return 1; /* right shift is signed */
-
-     /* see if unsigned-shift hack will fix it. */
-     /* we can't just test exact value since it depends on width of long... */
-     res |= (~0L) << (32-4);
-     if (res == -0x7F7E80CL)
-       return 0; /* right shift is unsigned */
-
-     printf("Right shift isn't acting as I expect it to.\n");
-     printf("I fear the JPEG software will not work at all.\n\n");
-     return 0; /* try it with unsigned anyway */
-   }
-   int main (void) {
-     exit(is_shifting_signed(-0x7F7E80B1L));
-   }],
-  [AC_MSG_RESULT(no)
-   AC_DEFINE([RIGHT_SHIFT_IS_UNSIGNED], 1,
-     [Define if your (broken) compiler shifts signed values as if they were unsigned.])],
-  [AC_MSG_RESULT(yes)],
-  [AC_MSG_RESULT(Assuming that right shift is signed on target machine.)])
-
-# Checks for library functions.
-AC_CHECK_FUNCS([memset memcpy], [],
-  [AC_DEFINE([NEED_BSD_STRINGS], 1,
-     [Define if you have BSD-like bzero and bcopy in <strings.h> rather than memset/memcpy in <string.h>.])])
-
-AC_MSG_CHECKING([libjpeg API version])
-AC_ARG_VAR(JPEG_LIB_VERSION, [libjpeg API version (62, 70, or 80)])
-if test "x$JPEG_LIB_VERSION" = "x"; then
-  AC_ARG_WITH([jpeg7],
-    AC_HELP_STRING([--with-jpeg7],
-      [Emulate libjpeg v7 API/ABI (this makes libjpeg-turbo backward incompatible with libjpeg v6b.)]))
-  AC_ARG_WITH([jpeg8],
-    AC_HELP_STRING([--with-jpeg8],
-      [Emulate libjpeg v8 API/ABI (this makes libjpeg-turbo backward incompatible with libjpeg v6b.)]))
-  if test "x${with_jpeg8}" = "xyes"; then
-    JPEG_LIB_VERSION=80
-  else
-    if test "x${with_jpeg7}" = "xyes"; then
-      JPEG_LIB_VERSION=70
-    else
-      JPEG_LIB_VERSION=62
-    fi
-  fi
-fi
-JPEG_LIB_VERSION_DECIMAL=`expr $JPEG_LIB_VERSION / 10`.`expr $JPEG_LIB_VERSION % 10`
-AC_SUBST(JPEG_LIB_VERSION_DECIMAL)
-AC_MSG_RESULT([$JPEG_LIB_VERSION_DECIMAL])
-AC_DEFINE_UNQUOTED(JPEG_LIB_VERSION, [$JPEG_LIB_VERSION],
-  [libjpeg API version])
-
-AC_ARG_VAR(SO_MAJOR_VERSION,
-  [Major version of the libjpeg-turbo shared library (default is determined by the API version)])
-AC_ARG_VAR(SO_MINOR_VERSION,
-  [Minor version of the libjpeg-turbo shared library (default is determined by the API version)])
-if test "x$SO_MAJOR_VERSION" = "x"; then
-  case "$JPEG_LIB_VERSION" in
-    62)  SO_MAJOR_VERSION=$JPEG_LIB_VERSION ;;
-    *)   SO_MAJOR_VERSION=`expr $JPEG_LIB_VERSION / 10` ;;
-  esac
-fi
-if test "x$SO_MINOR_VERSION" = "x"; then
-  case "$JPEG_LIB_VERSION" in
-    80)  SO_MINOR_VERSION=2 ;;
-    *)   SO_MINOR_VERSION=0 ;;
-  esac
-fi
-
-RPM_CONFIG_ARGS=
-
-# Memory source/destination managers
-SO_AGE=1
-MEM_SRCDST_FUNCTIONS=
-if test "x${with_jpeg8}" != "xyes"; then
-  AC_MSG_CHECKING([whether to include in-memory source/destination managers])
-  AC_ARG_WITH([mem-srcdst],
-    AC_HELP_STRING([--without-mem-srcdst],
-      [Do not include in-memory source/destination manager functions when emulating the libjpeg v6b or v7 API/ABI]))
-  if test "x$with_mem_srcdst" != "xno"; then
-    AC_MSG_RESULT(yes)
-    AC_DEFINE([MEM_SRCDST_SUPPORTED], [1],
-      [Support in-memory source/destination managers])
-    SO_AGE=2
-    MEM_SRCDST_FUNCTIONS="global:  jpeg_mem_dest;  jpeg_mem_src;";
-  else
-    AC_MSG_RESULT(no)
-    RPM_CONFIG_ARGS="$RPM_CONFIG_ARGS --without-mem-srcdst"
-  fi
-fi
-
-AC_MSG_CHECKING([libjpeg shared library version])
-AC_MSG_RESULT([$SO_MAJOR_VERSION.$SO_AGE.$SO_MINOR_VERSION])
-LIBTOOL_CURRENT=`expr $SO_MAJOR_VERSION + $SO_AGE`
-AC_SUBST(LIBTOOL_CURRENT)
-AC_SUBST(SO_MAJOR_VERSION)
-AC_SUBST(SO_MINOR_VERSION)
-AC_SUBST(SO_AGE)
-AC_SUBST(MEM_SRCDST_FUNCTIONS)
-
-AC_DEFINE_UNQUOTED(LIBJPEG_TURBO_VERSION, [$VERSION], [libjpeg-turbo version])
-
-m4_define(version_triplet,m4_split(AC_PACKAGE_VERSION,[[.]]))
-m4_define(version_major,m4_car(m4_shiftn(1,[],version_triplet)))
-m4_define(version_minor,m4_car(m4_shiftn(2,[],version_triplet)))
-m4_define(version_revision,m4_car(m4_shiftn(3,[],version_triplet)))
-VERSION_MAJOR=version_major
-VERSION_MINOR=version_minor
-VERSION_REVISION=version_revision
-LIBJPEG_TURBO_VERSION_NUMBER=`printf "%d%03d%03d" $VERSION_MAJOR $VERSION_MINOR $VERSION_REVISION`
-AC_DEFINE_UNQUOTED(LIBJPEG_TURBO_VERSION_NUMBER, [$LIBJPEG_TURBO_VERSION_NUMBER], [libjpeg-turbo version in integer form])
-
-VERSION_SCRIPT=yes
-AC_ARG_ENABLE([ld-version-script],
-  AS_HELP_STRING([--disable-ld-version-script],
-    [Disable linker version script for libjpeg-turbo (default is to use linker version script if the linker supports it)]),
-  [VERSION_SCRIPT=$enableval], [])
-
-AC_MSG_CHECKING([whether the linker supports version scripts])
-SAVED_LDFLAGS="$LDFLAGS"
-LDFLAGS="$LDFLAGS -Wl,--version-script,conftest.map"
-cat > conftest.map <<EOF
-VERS_1 {
-  global: *;
-};
-EOF
-AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
-  [VERSION_SCRIPT_FLAG=-Wl,--version-script,;
-   AC_MSG_RESULT([yes (GNU style)])],
-  [])
-if test "x$VERSION_SCRIPT_FLAG" = "x"; then
-  LDFLAGS="$SAVED_LDFLAGS -Wl,-M,conftest.map"
-  AC_LINK_IFELSE([AC_LANG_PROGRAM([], [])],
-    [VERSION_SCRIPT_FLAG=-Wl,-M,;
-     AC_MSG_RESULT([yes (Sun style)])],
-    [])
-fi
-if test "x$VERSION_SCRIPT_FLAG" = "x"; then
-  VERSION_SCRIPT=no
-  AC_MSG_RESULT(no)
-fi
-LDFLAGS="$SAVED_LDFLAGS"
-
-AC_MSG_CHECKING([whether to use version script when building libjpeg-turbo])
-AC_MSG_RESULT($VERSION_SCRIPT)
-
-AM_CONDITIONAL(VERSION_SCRIPT, test "x$VERSION_SCRIPT" = "xyes")
-AC_SUBST(VERSION_SCRIPT_FLAG)
-
-# Check for non-broken inline under various spellings
-AC_MSG_CHECKING(for inline)
-ljt_cv_inline=""
-AC_TRY_COMPILE(, [} inline __attribute__((always_inline)) int foo() { return 0; }
-int bar() { return foo();], ljt_cv_inline="inline __attribute__((always_inline))",
-AC_TRY_COMPILE(, [} __inline__ int foo() { return 0; }
-int bar() { return foo();], ljt_cv_inline="__inline__",
-AC_TRY_COMPILE(, [} __inline int foo() { return 0; }
-int bar() { return foo();], ljt_cv_inline="__inline",
-AC_TRY_COMPILE(, [} inline int foo() { return 0; }
-int bar() { return foo();], ljt_cv_inline="inline"))))
-AC_MSG_RESULT($ljt_cv_inline)
-AC_DEFINE_UNQUOTED([INLINE],[$ljt_cv_inline],[How to obtain function inlining.])
-
-# Arithmetic coding support
-AC_MSG_CHECKING([whether to include arithmetic encoding support])
-AC_ARG_WITH([arith-enc],
-  AC_HELP_STRING([--without-arith-enc],
-    [Do not include arithmetic encoding support when emulating the libjpeg v6b API/ABI]))
-if test "x$with_12bit" = "xyes"; then
-  with_arith_enc=no
-fi
-if test "x${with_jpeg8}" = "xyes" -o "x${with_jpeg7}" = "xyes"; then
-  with_arith_enc=yes
-fi
-if test "x$with_arith_enc" = "xno"; then
-  AC_MSG_RESULT(no)
-  RPM_CONFIG_ARGS="$RPM_CONFIG_ARGS --without-arith-enc"
-else
-  AC_DEFINE([C_ARITH_CODING_SUPPORTED], [1], [Support arithmetic encoding])
-  AC_MSG_RESULT(yes)
-fi
-AM_CONDITIONAL([WITH_ARITH_ENC], [test "x$with_arith_enc" != "xno"])
-
-AC_MSG_CHECKING([whether to include arithmetic decoding support])
-AC_ARG_WITH([arith-dec],
-  AC_HELP_STRING([--without-arith-dec],
-    [Do not include arithmetic decoding support when emulating the libjpeg v6b API/ABI]))
-if test "x$with_12bit" = "xyes"; then
-  with_arith_dec=no
-fi
-if test "x${with_jpeg8}" = "xyes" -o "x${with_jpeg7}" = "xyes"; then
-  with_arith_dec=yes
-fi
-if test "x$with_arith_dec" = "xno"; then
-  AC_MSG_RESULT(no)
-  RPM_CONFIG_ARGS="$RPM_CONFIG_ARGS --without-arith-dec"
-else
-  AC_DEFINE([D_ARITH_CODING_SUPPORTED], [1], [Support arithmetic decoding])
-  AC_MSG_RESULT(yes)
-fi
-AM_CONDITIONAL([WITH_ARITH_DEC], [test "x$with_arith_dec" != "xno"])
-
-AM_CONDITIONAL([WITH_ARITH],
-  [test "x$with_arith_dec" != "xno" -o "x$with_arith_enc" != "xno"])
-
-# 12-bit component support
-AC_MSG_CHECKING([whether to use 12-bit samples])
-AC_ARG_WITH([12bit],
-  AC_HELP_STRING([--with-12bit], [Encode/decode JPEG images with 12-bit samples (implies --without-simd --without-turbojpeg --without-arith-dec --without-arith-enc)]))
-if test "x$with_12bit" = "xyes"; then
-  AC_DEFINE([BITS_IN_JSAMPLE], [12], [use 8 or 12])
-  AC_MSG_RESULT(yes)
-else
-  AC_MSG_RESULT(no)
-fi
-AM_CONDITIONAL([WITH_12BIT], [test "x$with_12bit" = "xyes"])
-
-# TurboJPEG support
-AC_MSG_CHECKING([whether to build TurboJPEG C wrapper])
-AC_ARG_WITH([turbojpeg],
-  AC_HELP_STRING([--without-turbojpeg],
-    [Do not include the TurboJPEG wrapper library and associated test programs]))
-if test "x$with_12bit" = "xyes"; then
-  with_turbojpeg=no
-fi
-if test "x$with_turbojpeg" = "xno"; then
-  AC_MSG_RESULT(no)
-  RPM_CONFIG_ARGS="$RPM_CONFIG_ARGS --without-turbojpeg"
-else
-  AC_MSG_RESULT(yes)
-fi
-
-# Java support
-AC_ARG_VAR(JAVAC, [Java compiler command (default: javac)])
-if test "x$JAVAC" = "x"; then
-  JAVAC=javac
-fi
-AC_SUBST(JAVAC)
-AC_ARG_VAR(JAVACFLAGS, [Java compiler flags])
-AC_SUBST(JAVACFLAGS)
-AC_ARG_VAR(JAR, [Java archive command (default: jar)])
-if test "x$JAR" = "x"; then
-  JAR=jar
-fi
-AC_SUBST(JAR)
-AC_ARG_VAR(JAVA, [Java runtime command (default: java)])
-if test "x$JAVA" = "x"; then
-  JAVA=java
-fi
-AC_SUBST(JAVA)
-AC_ARG_VAR(JNI_CFLAGS,
-  [C compiler flags needed to include jni.h (default: -I/System/Library/Frameworks/JavaVM.framework/Headers on OS X, '-I/usr/java/include -I/usr/java/include/solaris' on Solaris, and '-I/usr/java/default/include -I/usr/java/default/include/linux' on Linux)])
-
-AC_MSG_CHECKING([whether to build TurboJPEG Java wrapper])
-AC_ARG_WITH([java],
-  AC_HELP_STRING([--with-java], [Build Java wrapper for the TurboJPEG library]))
-if test "x$with_12bit" = "xyes" -o "x$with_turbojpeg" = "xno"; then
-  with_java=no
-fi
-
-WITH_JAVA=0
-if test "x$with_java" = "xyes"; then
-  AC_MSG_RESULT(yes)
-
-  case $host_os in
-    darwin*)
-      DEFAULT_JNI_CFLAGS=-I/System/Library/Frameworks/JavaVM.framework/Headers
-      ;;
-    solaris*)
-      DEFAULT_JNI_CFLAGS='-I/usr/java/include -I/usr/java/include/solaris'
-      ;;
-    linux*)
-      DEFAULT_JNI_CFLAGS='-I/usr/java/default/include -I/usr/java/default/include/linux'
-      ;;
-  esac
-  if test "x$JNI_CFLAGS" = "x"; then
-    JNI_CFLAGS=$DEFAULT_JNI_CFLAGS
-  fi
-
-  SAVE_CPPFLAGS=${CPPFLAGS}
-  CPPFLAGS="${CPPFLAGS} ${JNI_CFLAGS}"
-  AC_CHECK_HEADERS([jni.h], [DUMMY=1],
-    [AC_MSG_ERROR([Could not find JNI header file])])
-  CPPFLAGS=${SAVE_CPPFLAGS}
-  AC_SUBST(JNI_CFLAGS)
-
-  RPM_CONFIG_ARGS="$RPM_CONFIG_ARGS --with-java"
-  JAVA_RPM_CONTENTS_1='%dir %{_datadir}/classes'
-  JAVA_RPM_CONTENTS_2=%{_datadir}/classes/turbojpeg.jar
-  WITH_JAVA=1
-else
-  AC_MSG_RESULT(no)
-fi
-AM_CONDITIONAL([WITH_JAVA], [test "x$with_java" = "xyes"])
-AC_SUBST(WITH_JAVA)
-AC_SUBST(JAVA_RPM_CONTENTS_1)
-AC_SUBST(JAVA_RPM_CONTENTS_2)
-
-# optionally force using gas-preprocessor.pl for compatibility testing
-AC_ARG_WITH([gas-preprocessor],
-  AC_HELP_STRING([--with-gas-preprocessor],
-    [Force using gas-preprocessor.pl on ARM.]))
-if test "x${with_gas_preprocessor}" = "xyes"; then
-  case $host_os in
-    darwin*)
-      CCAS="gas-preprocessor.pl -fix-unreq $CC"
-      ;;
-    *)
-      CCAS="gas-preprocessor.pl -no-fix-unreq $CC"
-      ;;
-  esac
-  AC_SUBST([CCAS])
-fi
-
-# SIMD is optional
-AC_ARG_WITH([simd],
-  AC_HELP_STRING([--without-simd], [Do not include SIMD extensions]))
-if test "x$with_12bit" = "xyes"; then
-  with_simd=no
-fi
-if test "x${with_simd}" != "xno"; then
-  require_simd=no
-  if test "x${with_simd}" = "xyes"; then
-    require_simd=yes
-  fi
-  # Check if we're on a supported CPU
-  AC_MSG_CHECKING([if we have SIMD optimisations for cpu type])
-  case "$host_cpu" in
-    x86_64 | amd64)
-      AC_MSG_RESULT([yes (x86_64)])
-      AC_PROG_NASM
-      simd_arch=x86_64
-      ;;
-    i*86 | x86 | ia32)
-      AC_MSG_RESULT([yes (i386)])
-      AC_PROG_NASM
-      simd_arch=i386
-      ;;
-    arm*)
-      AC_MSG_RESULT([yes (arm)])
-      AC_MSG_CHECKING([if the assembler is GNU-compatible and can be used])
-      AC_CHECK_COMPATIBLE_ARM_ASSEMBLER_IFELSE(
-        [if test "x$ac_use_gas_preprocessor" = "xyes"; then
-           AC_MSG_RESULT([yes (with gas-preprocessor)])
-         else
-           AC_MSG_RESULT([yes])
-         fi
-         simd_arch=arm],
-        [AC_MSG_RESULT([no])
-         with_simd=no])
-      if test "x${with_simd}" = "xno"; then
-        if test "x${require_simd}" = "xyes"; then
-          AC_MSG_ERROR([SIMD support can't be enabled.])
-        else
-          AC_MSG_WARN([SIMD support can't be enabled.  Performance will suffer.])
-        fi
-      fi
-      ;;
-    aarch64*)
-      AC_MSG_RESULT([yes (arm64)])
-      AC_MSG_CHECKING([if the assembler is GNU-compatible and can be used])
-      AC_CHECK_COMPATIBLE_ARM64_ASSEMBLER_IFELSE(
-        [if test "x$ac_use_gas_preprocessor" = "xyes"; then
-           AC_MSG_RESULT([yes (with gas-preprocessor)])
-         else
-           AC_MSG_RESULT([yes])
-         fi
-         simd_arch=aarch64],
-        [AC_MSG_RESULT([no])
-         with_simd=no])
-      if test "x${with_simd}" = "xno"; then
-        if test "x${require_simd}" = "xyes"; then
-          AC_MSG_ERROR([SIMD support can't be enabled.])
-        else
-          AC_MSG_WARN([SIMD support can't be enabled.  Performance will suffer.])
-        fi
-      fi
-      ;;
-    mips*)
-      AC_MSG_RESULT([yes (mips)])
-      AC_MSG_CHECKING([if the assembler is GNU-compatible and can be used])
-      AC_CHECK_COMPATIBLE_MIPS_ASSEMBLER_IFELSE(
-        [AC_MSG_RESULT([yes])
-         simd_arch=mips],
-        [AC_MSG_RESULT([no])
-         with_simd=no])
-      if test "x${with_simd}" = "xno"; then
-        if test "x${require_simd}" = "xyes"; then
-          AC_MSG_ERROR([SIMD support can't be enabled.])
-        else
-          AC_MSG_WARN([SIMD support can't be enabled.  Performance will suffer.])
-        fi
-      fi
-      ;;
-    powerpc*)
-      AC_MSG_RESULT([yes (powerpc)])
-      simd_arch=powerpc
-      ;;
-    *)
-      AC_MSG_RESULT([no ("$host_cpu")])
-      with_simd=no;
-      if test "x${require_simd}" = "xyes"; then
-        AC_MSG_ERROR([SIMD support not available for this CPU.])
-      else
-        AC_MSG_WARN([SIMD support not available for this CPU.  Performance will suffer.])
-      fi
-      ;;
-  esac
-
-  if test "x${with_simd}" != "xno"; then
-    AC_DEFINE([WITH_SIMD], [1], [Use accelerated SIMD routines.])
-  fi
-else
-  RPM_CONFIG_ARGS="$RPM_CONFIG_ARGS --without-simd"
-fi
-
-AM_CONDITIONAL([WITH_SIMD], [test "x$with_simd" != "xno"])
-AM_CONDITIONAL([WITH_SSE_FLOAT_DCT], [test "x$simd_arch" = "xx86_64" -o "x$simd_arch" = "xi386"])
-AM_CONDITIONAL([SIMD_I386], [test "x$simd_arch" = "xi386"])
-AM_CONDITIONAL([SIMD_X86_64], [test "x$simd_arch" = "xx86_64"])
-AM_CONDITIONAL([SIMD_ARM], [test "x$simd_arch" = "xarm"])
-AM_CONDITIONAL([SIMD_ARM_64], [test "x$simd_arch" = "xaarch64"])
-AM_CONDITIONAL([SIMD_MIPS], [test "x$simd_arch" = "xmips"])
-AM_CONDITIONAL([SIMD_POWERPC], [test "x$simd_arch" = "xpowerpc"])
-AM_CONDITIONAL([X86_64], [test "x$host_cpu" = "xx86_64" -o "x$host_cpu" = "xamd64"])
-AM_CONDITIONAL([WITH_TURBOJPEG], [test "x$with_turbojpeg" != "xno"])
-AM_CONDITIONAL([CROSS_COMPILING], [test "x$cross_compiling" = "xyes"])
-
-AC_ARG_VAR(PKGNAME, [distribution package name (default: libjpeg-turbo)])
-if test "x$PKGNAME" = "x"; then
-  PKGNAME=$PACKAGE_NAME
-fi
-AC_SUBST(PKGNAME)
-
-case "$host_cpu" in
-  x86_64)
-    RPMARCH=x86_64
-    DEBARCH=amd64
-    ;;
-  i*86 | x86 | ia32)
-    RPMARCH=i386
-    DEBARCH=i386
-    ;;
-  *)
-    RPMARCH=`uname -m`
-    DEBARCH=$RPMARCH
-    ;;
-esac
-
-if test "${docdir}" = ""; then
-  docdir=${datadir}/doc
-  AC_SUBST(docdir)
-fi
-
-AC_SUBST(RPMARCH)
-AC_SUBST(RPM_CONFIG_ARGS)
-AC_SUBST(DEBARCH)
-AC_SUBST(BUILD)
-AC_DEFINE_UNQUOTED([BUILD], "$BUILD", [libjpeg-turbo build number])
-
-# NOTE: autoheader automatically modifies the input file of the first
-# invocation of AC_CONFIG_HEADERS, so we put config.h first to prevent
-# jconfig.h.in from being clobbered.  config.h is used only internally, whereas
-# jconfig.h contains macros that are relevant to external programs (macros that
-# specify which features were built into the library.)
-AC_CONFIG_HEADERS([config.h])
-AC_CONFIG_HEADERS([jconfig.h])
-AC_CONFIG_HEADERS([jconfigint.h])
-AC_CONFIG_FILES([pkgscripts/libjpeg-turbo.spec.tmpl:release/libjpeg-turbo.spec.in])
-AC_CONFIG_FILES([pkgscripts/makecygwinpkg.tmpl:release/makecygwinpkg.in])
-AC_CONFIG_FILES([pkgscripts/makedpkg.tmpl:release/makedpkg.in])
-AC_CONFIG_FILES([pkgscripts/makemacpkg.tmpl:release/makemacpkg.in])
-AC_CONFIG_FILES([pkgscripts/uninstall.tmpl:release/uninstall.in])
-AC_CONFIG_FILES([pkgscripts/libjpeg.pc:release/libjpeg.pc.in])
-AC_CONFIG_FILES([pkgscripts/libturbojpeg.pc:release/libturbojpeg.pc.in])
-if test "x$with_turbojpeg" != "xno"; then
-  AC_CONFIG_FILES([tjbenchtest])
-fi
-if test "x$with_java" = "xyes"; then
-  AC_CONFIG_FILES([tjbenchtest.java])
-  AC_CONFIG_FILES([tjexampletest])
-fi
-AC_CONFIG_FILES([libjpeg.map])
-AC_CONFIG_FILES([Makefile simd/Makefile])
-AC_CONFIG_FILES([java/Makefile])
-AC_CONFIG_FILES([md5/Makefile])
-AC_OUTPUT
diff --git a/djpeg.1 b/djpeg.1
index b1e7f76..1b13b7e 100644
--- a/djpeg.1
+++ b/djpeg.1
@@ -1,4 +1,4 @@
-.TH DJPEG 1 "18 March 2017"
+TH DJPEG 1 "18 March 2017"
 .SH NAME
 djpeg \- decompress a JPEG file to an image file
 .SH SYNOPSIS
@@ -157,6 +157,9 @@ Ordered dither is only available in
 .B \-onepass
 mode.
 .TP
+.BI \-icc " file"
+Extract ICC color management profile to the specified file.
+.TP
 .BI \-map " file"
 Quantize to the colors used in the specified image file.  This is useful for
 producing multiple files with identical color maps, or for forcing a
diff --git a/djpeg.c b/djpeg.c
index 54cd525..53a8009 100644
--- a/djpeg.c
+++ b/djpeg.c
@@ -5,7 +5,7 @@
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * Modified 2013 by Guido Vollbeding.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2010-2011, 2013-2016, D. R. Commander.
+ * Copyright (C) 2010-2011, 2013-2017, D. R. Commander.
  * Copyright (C) 2015, Google, Inc.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
@@ -33,6 +33,10 @@
 #include "jconfigint.h"
 #include "wrppm.h"
 
+#ifndef HAVE_STDLIB_H           /* <stdlib.h> should declare free() */
+extern void free (void *ptr);
+#endif
+
 #include <ctype.h>              /* to declare isprint() */
 
 #ifdef USE_CCOMMAND             /* command-line reader for Macintosh */
@@ -90,6 +94,7 @@ static IMAGE_FORMATS requested_fmt;
 
 
 static const char *progname;    /* program name for error messages */
+static char *icc_filename;      /* for -icc switch */
 static char *outfilename;       /* for -outfile switch */
 boolean memsrc;                 /* for -memsrc switch */
 boolean skip, crop;
@@ -158,6 +163,7 @@ usage (void)
   fprintf(stderr, "  -dither fs     Use F-S dithering (default)\n");
   fprintf(stderr, "  -dither none   Don't use dithering in quantization\n");
   fprintf(stderr, "  -dither ordered  Use ordered dither (medium speed, quality)\n");
+  fprintf(stderr, "  -icc FILE      Extract ICC profile to FILE\n");
 #ifdef QUANT_2PASS_SUPPORTED
   fprintf(stderr, "  -map FILE      Map to colors used in named image file\n");
 #endif
@@ -196,6 +202,7 @@ parse_switches (j_decompress_ptr cinfo, int argc, char **argv,
 
   /* Set up default JPEG parameters. */
   requested_fmt = DEFAULT_FMT;  /* set default output file format */
+  icc_filename = NULL;
   outfilename = NULL;
   memsrc = FALSE;
   skip = FALSE;
@@ -303,6 +310,13 @@ parse_switches (j_decompress_ptr cinfo, int argc, char **argv,
       /* Force RGB565 output. */
       cinfo->out_color_space = JCS_RGB565;
 
+    } else if (keymatch(arg, "icc", 1)) {
+      /* Set ICC filename. */
+      if (++argn >= argc)       /* advance to next argument */
+        usage();
+      icc_filename = argv[argn];
+      jpeg_save_markers(cinfo, JPEG_APP0 + 2, 0xFFFF);
+
     } else if (keymatch(arg, "map", 3)) {
       /* Quantize to a color map taken from an input file. */
       if (++argn >= argc)       /* advance to next argument */
@@ -754,6 +768,29 @@ main (int argc, char **argv)
   progress.pub.completed_passes = progress.pub.total_passes;
 #endif
 
+  if (icc_filename != NULL) {
+    FILE *icc_file;
+    JOCTET *icc_profile;
+    unsigned int icc_len;
+
+    if ((icc_file = fopen(icc_filename, WRITE_BINARY)) == NULL) {
+      fprintf(stderr, "%s: can't open %s\n", progname, icc_filename);
+      exit(EXIT_FAILURE);
+    }
+    if (jpeg_read_icc_profile(&cinfo, &icc_profile, &icc_len)) {
+      if (fwrite(icc_profile, icc_len, 1, icc_file) < 1) {
+        fprintf(stderr, "%s: can't read ICC profile from %s\n", progname,
+                icc_filename);
+        free(icc_profile);
+        fclose(icc_file);
+        exit(EXIT_FAILURE);
+      }
+      free(icc_profile);
+      fclose(icc_file);
+    } else if (cinfo.err->msg_code != JWRN_BOGUS_ICC)
+      fprintf(stderr, "%s: no ICC profile data in JPEG file\n", progname);
+  }
+
   /* Finish decompression and release memory.
    * I must do it in this order because output module has allocated memory
    * of lifespan JPOOL_IMAGE; it needs to finish before releasing memory.
diff --git a/doc/html/annotated.html b/doc/html/annotated.html
index d0b0e1e..8172f55 100644
--- a/doc/html/annotated.html
+++ b/doc/html/annotated.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/classes.html b/doc/html/classes.html
index 275e96d..bc23e51 100644
--- a/doc/html/classes.html
+++ b/doc/html/classes.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/functions.html b/doc/html/functions.html
index 31d78f5..570debd 100644
--- a/doc/html/functions.html
+++ b/doc/html/functions.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/functions_vars.html b/doc/html/functions_vars.html
index 8373eac..7d45f87 100644
--- a/doc/html/functions_vars.html
+++ b/doc/html/functions_vars.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/group___turbo_j_p_e_g.html b/doc/html/group___turbo_j_p_e_g.html
index 8d7626d..3246eaa 100644
--- a/doc/html/group___turbo_j_p_e_g.html
+++ b/doc/html/group___turbo_j_p_e_g.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
@@ -128,6 +128,15 @@ Macros</h2></td></tr>
 <tr class="memitem:gacb233cfd722d66d1ccbf48a7de81f0e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0">TJFLAG_ACCURATEDCT</a></td></tr>
 <tr class="memdesc:gacb233cfd722d66d1ccbf48a7de81f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the most accurate DCT/IDCT algorithm available in the underlying codec.  <a href="#gacb233cfd722d66d1ccbf48a7de81f0e0">More...</a><br/></td></tr>
 <tr class="separator:gacb233cfd722d66d1ccbf48a7de81f0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga519cfa4ef6c18d9e5b455fdf59306a3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga519cfa4ef6c18d9e5b455fdf59306a3a">TJFLAG_STOPONWARNING</a></td></tr>
+<tr class="memdesc:ga519cfa4ef6c18d9e5b455fdf59306a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Immediately discontinue the current compression/decompression/transform operation if the underlying codec throws a warning (non-fatal error).  <a href="#ga519cfa4ef6c18d9e5b455fdf59306a3a">More...</a><br/></td></tr>
+<tr class="separator:ga519cfa4ef6c18d9e5b455fdf59306a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga43b426750b46190a25d34a67ef76df1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga43b426750b46190a25d34a67ef76df1b">TJFLAG_PROGRESSIVE</a></td></tr>
+<tr class="memdesc:ga43b426750b46190a25d34a67ef76df1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use progressive entropy coding in JPEG images generated by the compression and transform functions.  <a href="#ga43b426750b46190a25d34a67ef76df1b">More...</a><br/></td></tr>
+<tr class="separator:ga43b426750b46190a25d34a67ef76df1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga79bde1b4a3e2351e00887e47781b966e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga79bde1b4a3e2351e00887e47781b966e">TJ_NUMERR</a></td></tr>
+<tr class="memdesc:ga79bde1b4a3e2351e00887e47781b966e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of error codes.  <a href="#ga79bde1b4a3e2351e00887e47781b966e">More...</a><br/></td></tr>
+<tr class="separator:ga79bde1b4a3e2351e00887e47781b966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga0f6dbd18adf38b7d46ac547f0f4d562c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga0f6dbd18adf38b7d46ac547f0f4d562c">TJ_NUMXOP</a></td></tr>
 <tr class="memdesc:ga0f6dbd18adf38b7d46ac547f0f4d562c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of transform operations.  <a href="#ga0f6dbd18adf38b7d46ac547f0f4d562c">More...</a><br/></td></tr>
 <tr class="separator:ga0f6dbd18adf38b7d46ac547f0f4d562c"><td class="memSeparator" colspan="2">&#160;</td></tr>
@@ -206,6 +215,11 @@ Enumerations</h2></td></tr>
  }</td></tr>
 <tr class="memdesc:ga4f83ad3368e0e29d1957be0efa7c3720"><td class="mdescLeft">&#160;</td><td class="mdescRight">JPEG colorspaces.  <a href="group___turbo_j_p_e_g.html#ga4f83ad3368e0e29d1957be0efa7c3720">More...</a><br/></td></tr>
 <tr class="separator:ga4f83ad3368e0e29d1957be0efa7c3720"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:gafbc17cfa57d0d5d11fea35ac025950fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe">TJERR</a> { <a class="el" href="group___turbo_j_p_e_g.html#ggafbc17cfa57d0d5d11fea35ac025950fea342dd6e2aedb47bb257b4e7568329b59">TJERR_WARNING</a>, 
+<a class="el" href="group___turbo_j_p_e_g.html#ggafbc17cfa57d0d5d11fea35ac025950feafc9cceeada13122b09e4851e3788039a">TJERR_FATAL</a>
+ }</td></tr>
+<tr class="memdesc:gafbc17cfa57d0d5d11fea35ac025950fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes.  <a href="group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe">More...</a><br/></td></tr>
+<tr class="separator:gafbc17cfa57d0d5d11fea35ac025950fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
 <tr class="memitem:ga2de531af4e7e6c4f124908376b354866"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga2de531af4e7e6c4f124908376b354866">TJXOP</a> { <br/>
 &#160;&#160;<a class="el" href="group___turbo_j_p_e_g.html#gga2de531af4e7e6c4f124908376b354866aad88c0366cd3f7d0eac9d7a3fa1c2c27">TJXOP_NONE</a>, 
 <a class="el" href="group___turbo_j_p_e_g.html#gga2de531af4e7e6c4f124908376b354866aa0df69776caa30f0fa28e26332d311ce">TJXOP_HFLIP</a>, 
@@ -295,9 +309,12 @@ Functions</h2></td></tr>
 <tr class="memitem:ga8c4a1231dc06a450514c835f6471f137"><td class="memItemLeft" align="right" valign="top">DLLEXPORT void DLLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga8c4a1231dc06a450514c835f6471f137">tjFree</a> (unsigned char *buffer)</td></tr>
 <tr class="memdesc:ga8c4a1231dc06a450514c835f6471f137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free an image buffer previously allocated by TurboJPEG.  <a href="#ga8c4a1231dc06a450514c835f6471f137">More...</a><br/></td></tr>
 <tr class="separator:ga8c4a1231dc06a450514c835f6471f137"><td class="memSeparator" colspan="2">&#160;</td></tr>
-<tr class="memitem:ga9af79c908ec131b1ae8d52fe40375abf"><td class="memItemLeft" align="right" valign="top">DLLEXPORT char *DLLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf">tjGetErrorStr</a> (void)</td></tr>
-<tr class="memdesc:ga9af79c908ec131b1ae8d52fe40375abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descriptive error message explaining why the last command failed.  <a href="#ga9af79c908ec131b1ae8d52fe40375abf">More...</a><br/></td></tr>
-<tr class="separator:ga9af79c908ec131b1ae8d52fe40375abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga94a235bd4f1088f61ad87b4eadb64c9c"><td class="memItemLeft" align="right" valign="top">DLLEXPORT char *DLLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c">tjGetErrorStr2</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle)</td></tr>
+<tr class="memdesc:ga94a235bd4f1088f61ad87b4eadb64c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a descriptive error message explaining why the last command failed.  <a href="#ga94a235bd4f1088f61ad87b4eadb64c9c">More...</a><br/></td></tr>
+<tr class="separator:ga94a235bd4f1088f61ad87b4eadb64c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
+<tr class="memitem:ga0be00a62bd1be897f170fa1fed5fb4cb"><td class="memItemLeft" align="right" valign="top">DLLEXPORT int DLLCALL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb">tjGetErrorCode</a> (<a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a> handle)</td></tr>
+<tr class="memdesc:ga0be00a62bd1be897f170fa1fed5fb4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a code indicating the severity of the last error.  <a href="#ga0be00a62bd1be897f170fa1fed5fb4cb">More...</a><br/></td></tr>
+<tr class="separator:ga0be00a62bd1be897f170fa1fed5fb4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
 </table><table class="memberdecls">
 <tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
 Variables</h2></td></tr>
@@ -341,6 +358,20 @@ Variables</h2></td></tr>
 
 <p>The number of JPEG colorspaces. </p>
 
+</div>
+</div>
+<a class="anchor" id="ga79bde1b4a3e2351e00887e47781b966e"></a>
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">#define TJ_NUMERR</td>
+        </tr>
+      </table>
+</div><div class="memdoc">
+
+<p>The number of error codes. </p>
+
 </div>
 </div>
 <a class="anchor" id="ga7010a4402f54a45ba822ad8675a4655e"></a>
@@ -457,6 +488,36 @@ Variables</h2></td></tr>
 <p>Disable buffer (re)allocation. </p>
 <p>If passed to one of the JPEG compression or transform functions, this flag will cause those functions to generate an error if the JPEG image buffer is invalid or too small rather than attempting to allocate or reallocate that buffer. This reproduces the behavior of earlier versions of TurboJPEG. </p>
 
+</div>
+</div>
+<a class="anchor" id="ga43b426750b46190a25d34a67ef76df1b"></a>
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">#define TJFLAG_PROGRESSIVE</td>
+        </tr>
+      </table>
+</div><div class="memdoc">
+
+<p>Use progressive entropy coding in JPEG images generated by the compression and transform functions. </p>
+<p>Progressive entropy coding will generally improve compression relative to baseline entropy coding (the default), but it will reduce compression and decompression performance considerably. </p>
+
+</div>
+</div>
+<a class="anchor" id="ga519cfa4ef6c18d9e5b455fdf59306a3a"></a>
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">#define TJFLAG_STOPONWARNING</td>
+        </tr>
+      </table>
+</div><div class="memdoc">
+
+<p>Immediately discontinue the current compression/decompression/transform operation if the underlying codec throws a warning (non-fatal error). </p>
+<p>The default behavior is to allow the operation to complete unless a fatal error is encountered. </p>
+
 </div>
 </div>
 <a class="anchor" id="ga0aba955473315e405295d978f0c16511"></a>
@@ -642,6 +703,28 @@ Variables</h2></td></tr>
 </td></tr>
 </table>
 
+</div>
+</div>
+<a class="anchor" id="gafbc17cfa57d0d5d11fea35ac025950fe"></a>
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">enum <a class="el" href="group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe">TJERR</a></td>
+        </tr>
+      </table>
+</div><div class="memdoc">
+
+<p>Error codes. </p>
+<table class="fieldtable">
+<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggafbc17cfa57d0d5d11fea35ac025950fea342dd6e2aedb47bb257b4e7568329b59"></a>TJERR_WARNING</em>&nbsp;</td><td class="fielddoc">
+<p>The error was non-fatal and recoverable, but the image may still be corrupt. </p>
+</td></tr>
+<tr><td class="fieldname"><em><a class="anchor" id="ggafbc17cfa57d0d5d11fea35ac025950feafc9cceeada13122b09e4851e3788039a"></a>TJERR_FATAL</em>&nbsp;</td><td class="fielddoc">
+<p>The error was fatal and non-recoverable. </p>
+</td></tr>
+</table>
+
 </div>
 </div>
 <a class="anchor" id="gac916144e26c3817ac514e64ae5d12e2a"></a>
@@ -1018,7 +1101,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1115,7 +1198,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1212,7 +1295,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1305,7 +1388,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1398,7 +1481,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1483,7 +1566,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1554,7 +1637,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1633,7 +1716,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1712,7 +1795,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1737,7 +1820,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1830,7 +1913,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1923,7 +2006,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -1953,21 +2036,53 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 
 </div>
 </div>
-<a class="anchor" id="ga9af79c908ec131b1ae8d52fe40375abf"></a>
+<a class="anchor" id="ga0be00a62bd1be897f170fa1fed5fb4cb"></a>
 <div class="memitem">
 <div class="memproto">
       <table class="memname">
         <tr>
-          <td class="memname">DLLEXPORT char* DLLCALL tjGetErrorStr </td>
+          <td class="memname">DLLEXPORT int DLLCALL tjGetErrorCode </td>
           <td>(</td>
-          <td class="paramtype">void&#160;</td>
-          <td class="paramname"></td><td>)</td>
+          <td class="paramtype"><a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a>&#160;</td>
+          <td class="paramname"><em>handle</em></td><td>)</td>
+          <td></td>
+        </tr>
+      </table>
+</div><div class="memdoc">
+
+<p>Returns a code indicating the severity of the last error. </p>
+<p>See <a class="el" href="group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe">Error codes</a>.</p>
+<dl class="params"><dt>Parameters</dt><dd>
+  <table class="params">
+    <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG compressor, decompressor or transformer instance</td></tr>
+  </table>
+  </dd>
+</dl>
+<dl class="section return"><dt>Returns</dt><dd>a code indicating the severity of the last error. See <a class="el" href="group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe">Error codes</a>. </dd></dl>
+
+</div>
+</div>
+<a class="anchor" id="ga94a235bd4f1088f61ad87b4eadb64c9c"></a>
+<div class="memitem">
+<div class="memproto">
+      <table class="memname">
+        <tr>
+          <td class="memname">DLLEXPORT char* DLLCALL tjGetErrorStr2 </td>
+          <td>(</td>
+          <td class="paramtype"><a class="el" href="group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763">tjhandle</a>&#160;</td>
+          <td class="paramname"><em>handle</em></td><td>)</td>
           <td></td>
         </tr>
       </table>
 </div><div class="memdoc">
 
 <p>Returns a descriptive error message explaining why the last command failed. </p>
+<dl class="params"><dt>Parameters</dt><dd>
+  <table class="params">
+    <tr><td class="paramname">handle</td><td>a handle to a TurboJPEG compressor, decompressor, or transformer instance, or NULL if the error was generated by a global function (but note that retrieving the error message for a global function is not thread-safe.)</td></tr>
+  </table>
+  </dd>
+</dl>
 <dl class="section return"><dt>Returns</dt><dd>a descriptive error message explaining why the last command failed. </dd></dl>
 
 </div>
@@ -1993,7 +2108,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>a pointer to a list of fractional scaling factors, or NULL if an error is encountered (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>a pointer to a list of fractional scaling factors, or NULL if an error is encountered (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -2012,7 +2127,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 </div><div class="memdoc">
 
 <p>Create a TurboJPEG compressor instance. </p>
-<dl class="section return"><dt>Returns</dt><dd>a handle to the newly-created instance, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>a handle to the newly-created instance, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -2031,7 +2146,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 </div><div class="memdoc">
 
 <p>Create a TurboJPEG decompressor instance. </p>
-<dl class="section return"><dt>Returns</dt><dd>a handle to the newly-created instance, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>a handle to the newly-created instance, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -2050,7 +2165,7 @@ If you choose option 1, <code>*jpegSize</code> should be set to the size of your
 </div><div class="memdoc">
 
 <p>Create a new TurboJPEG transformer instance. </p>
-<dl class="section return"><dt>Returns</dt><dd>a handle to the newly-created instance, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>a handle to the newly-created instance, or NULL if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a>.) </dd></dl>
 
 </div>
 </div>
@@ -2279,7 +2394,7 @@ If you choose option 1, <code>dstSizes[i]</code> should be set to the size of yo
   </table>
   </dd>
 </dl>
-<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr()</a>.) </dd></dl>
+<dl class="section return"><dt>Returns</dt><dd>0 if successful, or -1 if an error occurred (see <a class="el" href="group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c" title="Returns a descriptive error message explaining why the last command failed.">tjGetErrorStr2()</a> and <a class="el" href="group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb" title="Returns a code indicating the severity of the last error.">tjGetErrorCode()</a>.) </dd></dl>
 
 </div>
 </div>
diff --git a/doc/html/index.html b/doc/html/index.html
index 3cc1b3e..6b27f31 100644
--- a/doc/html/index.html
+++ b/doc/html/index.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/modules.html b/doc/html/modules.html
index 8e6f815..8b38151 100644
--- a/doc/html/modules.html
+++ b/doc/html/modules.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/search/all_74.js b/doc/html/search/all_74.js
index 444aaef..d56e332 100644
--- a/doc/html/search/all_74.js
+++ b/doc/html/search/all_74.js
@@ -1,6 +1,7 @@
 var searchData=
 [
   ['tj_5fnumcs',['TJ_NUMCS',['../group___turbo_j_p_e_g.html#ga39f57a6fb02d9cf32e7b6890099b5a71',1,'turbojpeg.h']]],
+  ['tj_5fnumerr',['TJ_NUMERR',['../group___turbo_j_p_e_g.html#ga79bde1b4a3e2351e00887e47781b966e',1,'turbojpeg.h']]],
   ['tj_5fnumpf',['TJ_NUMPF',['../group___turbo_j_p_e_g.html#ga7010a4402f54a45ba822ad8675a4655e',1,'turbojpeg.h']]],
   ['tj_5fnumsamp',['TJ_NUMSAMP',['../group___turbo_j_p_e_g.html#ga5ef3d169162ce77ce348e292a0b7477c',1,'turbojpeg.h']]],
   ['tj_5fnumxop',['TJ_NUMXOP',['../group___turbo_j_p_e_g.html#ga0f6dbd18adf38b7d46ac547f0f4d562c',1,'turbojpeg.h']]],
@@ -26,13 +27,19 @@ var searchData=
   ['tjdestroy',['tjDestroy',['../group___turbo_j_p_e_g.html#ga674adee917b95ad4a896f1ba39e12540',1,'turbojpeg.h']]],
   ['tjencodeyuv3',['tjEncodeYUV3',['../group___turbo_j_p_e_g.html#gaabe05acd734990053ad1294b5ef239aa',1,'turbojpeg.h']]],
   ['tjencodeyuvplanes',['tjEncodeYUVPlanes',['../group___turbo_j_p_e_g.html#ga8a65ed3bd12df57c219d46afbc9008f1',1,'turbojpeg.h']]],
+  ['tjerr',['TJERR',['../group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe',1,'turbojpeg.h']]],
+  ['tjerr_5ffatal',['TJERR_FATAL',['../group___turbo_j_p_e_g.html#ggafbc17cfa57d0d5d11fea35ac025950feafc9cceeada13122b09e4851e3788039a',1,'turbojpeg.h']]],
+  ['tjerr_5fwarning',['TJERR_WARNING',['../group___turbo_j_p_e_g.html#ggafbc17cfa57d0d5d11fea35ac025950fea342dd6e2aedb47bb257b4e7568329b59',1,'turbojpeg.h']]],
   ['tjflag_5faccuratedct',['TJFLAG_ACCURATEDCT',['../group___turbo_j_p_e_g.html#gacb233cfd722d66d1ccbf48a7de81f0e0',1,'turbojpeg.h']]],
   ['tjflag_5fbottomup',['TJFLAG_BOTTOMUP',['../group___turbo_j_p_e_g.html#ga72ecf4ebe6eb702d3c6f5ca27455e1ec',1,'turbojpeg.h']]],
   ['tjflag_5ffastdct',['TJFLAG_FASTDCT',['../group___turbo_j_p_e_g.html#gaabce235db80d3f698b27f36cbd453da2',1,'turbojpeg.h']]],
   ['tjflag_5ffastupsample',['TJFLAG_FASTUPSAMPLE',['../group___turbo_j_p_e_g.html#ga4ee4506c81177a06f77e2504a22efd2d',1,'turbojpeg.h']]],
   ['tjflag_5fnorealloc',['TJFLAG_NOREALLOC',['../group___turbo_j_p_e_g.html#ga8808d403c68b62aaa58a4c1e58e98963',1,'turbojpeg.h']]],
+  ['tjflag_5fprogressive',['TJFLAG_PROGRESSIVE',['../group___turbo_j_p_e_g.html#ga43b426750b46190a25d34a67ef76df1b',1,'turbojpeg.h']]],
+  ['tjflag_5fstoponwarning',['TJFLAG_STOPONWARNING',['../group___turbo_j_p_e_g.html#ga519cfa4ef6c18d9e5b455fdf59306a3a',1,'turbojpeg.h']]],
   ['tjfree',['tjFree',['../group___turbo_j_p_e_g.html#ga8c4a1231dc06a450514c835f6471f137',1,'turbojpeg.h']]],
-  ['tjgeterrorstr',['tjGetErrorStr',['../group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf',1,'turbojpeg.h']]],
+  ['tjgeterrorcode',['tjGetErrorCode',['../group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb',1,'turbojpeg.h']]],
+  ['tjgeterrorstr2',['tjGetErrorStr2',['../group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c',1,'turbojpeg.h']]],
   ['tjgetscalingfactors',['tjGetScalingFactors',['../group___turbo_j_p_e_g.html#ga6449044b9af402999ccf52f401333be8',1,'turbojpeg.h']]],
   ['tjgreenoffset',['tjGreenOffset',['../group___turbo_j_p_e_g.html#ga82d6e35da441112a411da41923c0ba2f',1,'turbojpeg.h']]],
   ['tjhandle',['tjhandle',['../group___turbo_j_p_e_g.html#ga758d2634ecb4949de7815cba621f5763',1,'turbojpeg.h']]],
diff --git a/doc/html/search/enums_74.js b/doc/html/search/enums_74.js
index 276aa24..19c20cf 100644
--- a/doc/html/search/enums_74.js
+++ b/doc/html/search/enums_74.js
@@ -1,6 +1,7 @@
 var searchData=
 [
   ['tjcs',['TJCS',['../group___turbo_j_p_e_g.html#ga4f83ad3368e0e29d1957be0efa7c3720',1,'turbojpeg.h']]],
+  ['tjerr',['TJERR',['../group___turbo_j_p_e_g.html#gafbc17cfa57d0d5d11fea35ac025950fe',1,'turbojpeg.h']]],
   ['tjpf',['TJPF',['../group___turbo_j_p_e_g.html#gac916144e26c3817ac514e64ae5d12e2a',1,'turbojpeg.h']]],
   ['tjsamp',['TJSAMP',['../group___turbo_j_p_e_g.html#ga1d047060ea80bb9820d540bb928e9074',1,'turbojpeg.h']]],
   ['tjxop',['TJXOP',['../group___turbo_j_p_e_g.html#ga2de531af4e7e6c4f124908376b354866',1,'turbojpeg.h']]]
diff --git a/doc/html/search/enumvalues_74.js b/doc/html/search/enumvalues_74.js
index 7dc2f8d..799f9ac 100644
--- a/doc/html/search/enumvalues_74.js
+++ b/doc/html/search/enumvalues_74.js
@@ -5,6 +5,8 @@ var searchData=
   ['tjcs_5frgb',['TJCS_RGB',['../group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a677cb7ccb85c4038ac41964a2e09e555',1,'turbojpeg.h']]],
   ['tjcs_5fycbcr',['TJCS_YCbCr',['../group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a7389b8f65bb387ffedce3efd0d78ec75',1,'turbojpeg.h']]],
   ['tjcs_5fycck',['TJCS_YCCK',['../group___turbo_j_p_e_g.html#gga4f83ad3368e0e29d1957be0efa7c3720a53839e0fe867b76b58d16b0a1a7c598e',1,'turbojpeg.h']]],
+  ['tjerr_5ffatal',['TJERR_FATAL',['../group___turbo_j_p_e_g.html#ggafbc17cfa57d0d5d11fea35ac025950feafc9cceeada13122b09e4851e3788039a',1,'turbojpeg.h']]],
+  ['tjerr_5fwarning',['TJERR_WARNING',['../group___turbo_j_p_e_g.html#ggafbc17cfa57d0d5d11fea35ac025950fea342dd6e2aedb47bb257b4e7568329b59',1,'turbojpeg.h']]],
   ['tjpf_5fabgr',['TJPF_ABGR',['../group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aa1ba1a7f1631dbeaa49a0a85fc4a40081',1,'turbojpeg.h']]],
   ['tjpf_5fargb',['TJPF_ARGB',['../group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aae8f846ed9d9de99b6e1dfe448848765c',1,'turbojpeg.h']]],
   ['tjpf_5fbgr',['TJPF_BGR',['../group___turbo_j_p_e_g.html#ggac916144e26c3817ac514e64ae5d12e2aab10624437fb8ef495a0b153e65749839',1,'turbojpeg.h']]],
diff --git a/doc/html/search/functions_74.js b/doc/html/search/functions_74.js
index 69410b0..d2164bb 100644
--- a/doc/html/search/functions_74.js
+++ b/doc/html/search/functions_74.js
@@ -16,7 +16,8 @@ var searchData=
   ['tjencodeyuv3',['tjEncodeYUV3',['../group___turbo_j_p_e_g.html#gaabe05acd734990053ad1294b5ef239aa',1,'turbojpeg.h']]],
   ['tjencodeyuvplanes',['tjEncodeYUVPlanes',['../group___turbo_j_p_e_g.html#ga8a65ed3bd12df57c219d46afbc9008f1',1,'turbojpeg.h']]],
   ['tjfree',['tjFree',['../group___turbo_j_p_e_g.html#ga8c4a1231dc06a450514c835f6471f137',1,'turbojpeg.h']]],
-  ['tjgeterrorstr',['tjGetErrorStr',['../group___turbo_j_p_e_g.html#ga9af79c908ec131b1ae8d52fe40375abf',1,'turbojpeg.h']]],
+  ['tjgeterrorcode',['tjGetErrorCode',['../group___turbo_j_p_e_g.html#ga0be00a62bd1be897f170fa1fed5fb4cb',1,'turbojpeg.h']]],
+  ['tjgeterrorstr2',['tjGetErrorStr2',['../group___turbo_j_p_e_g.html#ga94a235bd4f1088f61ad87b4eadb64c9c',1,'turbojpeg.h']]],
   ['tjgetscalingfactors',['tjGetScalingFactors',['../group___turbo_j_p_e_g.html#ga6449044b9af402999ccf52f401333be8',1,'turbojpeg.h']]],
   ['tjinitcompress',['tjInitCompress',['../group___turbo_j_p_e_g.html#ga3d10c47fbe4a2489a2b30c931551d01a',1,'turbojpeg.h']]],
   ['tjinitdecompress',['tjInitDecompress',['../group___turbo_j_p_e_g.html#gae5408179d041e2a2f7199c8283cf649e',1,'turbojpeg.h']]],
diff --git a/doc/html/structtjregion.html b/doc/html/structtjregion.html
index af2a473..36c0afa 100644
--- a/doc/html/structtjregion.html
+++ b/doc/html/structtjregion.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/structtjscalingfactor.html b/doc/html/structtjscalingfactor.html
index 3bb50f5..2f54900 100644
--- a/doc/html/structtjscalingfactor.html
+++ b/doc/html/structtjscalingfactor.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doc/html/structtjtransform.html b/doc/html/structtjtransform.html
index 9fd97f7..d9536a3 100644
--- a/doc/html/structtjtransform.html
+++ b/doc/html/structtjtransform.html
@@ -24,7 +24,7 @@
  <tr style="height: 56px;">
   <td style="padding-left: 0.5em;">
    <div id="projectname">TurboJPEG
-   &#160;<span id="projectnumber">1.5</span>
+   &#160;<span id="projectnumber">1.6</span>
    </div>
   </td>
  </tr>
diff --git a/doxygen.config b/doxygen.config
index 1723123..2f2ab66 100644
--- a/doxygen.config
+++ b/doxygen.config
@@ -1,5 +1,5 @@
 PROJECT_NAME = TurboJPEG
-PROJECT_NUMBER = 1.5
+PROJECT_NUMBER = 1.6
 OUTPUT_DIRECTORY = doc/
 USE_WINDOWS_ENCODING = NO
 OPTIMIZE_OUTPUT_FOR_C = YES
diff --git a/java/CMakeLists.txt b/java/CMakeLists.txt
index 0af8ae1..75a0b24 100644
--- a/java/CMakeLists.txt
+++ b/java/CMakeLists.txt
@@ -1,57 +1,78 @@
-set(JAR_FILE turbojpeg.jar)
-set(MANIFEST_FILE ${CMAKE_CURRENT_SOURCE_DIR}/MANIFEST.MF)
-
-set(JAVA_CLASSNAMES org/libjpegturbo/turbojpeg/TJ
-  org/libjpegturbo/turbojpeg/TJCompressor
-  org/libjpegturbo/turbojpeg/TJCustomFilter
-  org/libjpegturbo/turbojpeg/TJDecompressor
-  org/libjpegturbo/turbojpeg/TJException
-  org/libjpegturbo/turbojpeg/TJScalingFactor
-  org/libjpegturbo/turbojpeg/TJTransform
-  org/libjpegturbo/turbojpeg/TJTransformer
-  org/libjpegturbo/turbojpeg/YUVImage
-  TJUnitTest
-  TJExample
-  TJBench)
-
-if(MSVC_IDE)
-  set(OBJDIR "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}")
-else()
-  set(OBJDIR ${CMAKE_CURRENT_BINARY_DIR})
+find_package(Java REQUIRED)
+find_package(JNI REQUIRED)
+
+# Allow the Java compiler flags to be set using an environment variable
+if(NOT DEFINED CMAKE_JAVA_COMPILE_FLAGS AND DEFINED ENV{JAVAFLAGS})
+  set(CMAKE_JAVA_COMPILE_FLAGS $ENV{JAVAFLAGS})
 endif()
 
+include(UseJava)
+
+set(CMAKE_JAVA_COMPILE_FLAGS "${CMAKE_JAVA_COMPILE_FLAGS} -J-Dfile.encoding=UTF8")
+message(STATUS "CMAKE_JAVA_COMPILE_FLAGS = ${CMAKE_JAVA_COMPILE_FLAGS}")
+string(REGEX REPLACE " " ";" CMAKE_JAVA_COMPILE_FLAGS "${CMAKE_JAVA_COMPILE_FLAGS}")
+
+set(JAVAARGS "" CACHE STRING "Additional arguments to pass to java when running unit tests (example: -d32)")
+message(STATUS "JAVAARGS = ${JAVAARGS}")
+
+set(JAVA_SOURCES org/libjpegturbo/turbojpeg/TJ.java
+  org/libjpegturbo/turbojpeg/TJCompressor.java
+  org/libjpegturbo/turbojpeg/TJCustomFilter.java
+  org/libjpegturbo/turbojpeg/TJDecompressor.java
+  org/libjpegturbo/turbojpeg/TJException.java
+  org/libjpegturbo/turbojpeg/TJScalingFactor.java
+  org/libjpegturbo/turbojpeg/TJTransform.java
+  org/libjpegturbo/turbojpeg/TJTransformer.java
+  org/libjpegturbo/turbojpeg/YUVImage.java
+  TJUnitTest.java
+  TJExample.java
+  TJBench.java)
+
 set(TURBOJPEG_DLL_NAME "turbojpeg")
 if(MINGW)
   set(TURBOJPEG_DLL_NAME "libturbojpeg")
 endif()
-configure_file(org/libjpegturbo/turbojpeg/TJLoader.java.in
-  ${CMAKE_CURRENT_BINARY_DIR}/org/libjpegturbo/turbojpeg/TJLoader.java)
-
-set(JAVA_SOURCES "")
-set(JAVA_CLASSES "")
-set(JAVA_CLASSES_FULL "")
-foreach(class ${JAVA_CLASSNAMES})
-  set(JAVA_SOURCES ${JAVA_SOURCES} ${CMAKE_CURRENT_SOURCE_DIR}/${class}.java)
-  set(JAVA_CLASSES ${JAVA_CLASSES} ${class}.class)
-  set(JAVA_CLASSES_FULL ${JAVA_CLASSES_FULL} ${OBJDIR}/${class}.class)
-endforeach()
-
+if(WIN32)
+  configure_file(org/libjpegturbo/turbojpeg/TJLoader-win.java.in
+    ${CMAKE_CURRENT_BINARY_DIR}/org/libjpegturbo/turbojpeg/TJLoader.java)
+else()
+  configure_file(org/libjpegturbo/turbojpeg/TJLoader-unix.java.in
+    ${CMAKE_CURRENT_BINARY_DIR}/org/libjpegturbo/turbojpeg/TJLoader.java)
+endif()
 set(JAVA_SOURCES ${JAVA_SOURCES}
   ${CMAKE_CURRENT_BINARY_DIR}/org/libjpegturbo/turbojpeg/TJLoader.java)
-set(JAVA_CLASSES ${JAVA_CLASSES}
-  org/libjpegturbo/turbojpeg/TJLoader.class)
-set(JAVA_CLASSES_FULL ${JAVA_CLASSES_FULL}
-  ${OBJDIR}/org/libjpegturbo/turbojpeg/TJLoader.class)
-
-string(REGEX REPLACE " " ";" JAVACFLAGS "${JAVACFLAGS}")
-add_custom_command(OUTPUT ${JAVA_CLASSES_FULL} DEPENDS ${JAVA_SOURCES}
-  COMMAND ${JAVA_COMPILE} ARGS ${JAVACFLAGS} -d ${OBJDIR} ${JAVA_SOURCES})
 
-add_custom_command(OUTPUT ${JAR_FILE} DEPENDS ${JAVA_CLASSES_FULL}
-  ${MANIFEST_FILE}
-  COMMAND ${JAVA_ARCHIVE} cfm ${JAR_FILE} ${MANIFEST_FILE} ${JAVA_CLASSES}
-  WORKING_DIRECTORY ${OBJDIR})
+if(MSYS)
+  # UGLY HACK ALERT: If we don't do this, then UseJava.cmake will separate
+  # class path members with a semicolon, which is interpreted as a command
+  # separator by the MSYS shell.
+  set(CMAKE_HOST_SYSTEM_NAME_BAK ${CMAKE_HOST_SYSTEM_NAME})
+  set(CMAKE_HOST_SYSTEM_NAME "MSYS")
+endif()
+add_jar(turbojpeg-java ${JAVA_SOURCES} OUTPUT_NAME turbojpeg
+  ENTRY_POINT TJExample)
+if(MSYS)
+  set(CMAKE_HOST_SYSTEM_NAME ${CMAKE_HOST_SYSTEM_NAME_BAK})
+endif()
 
-add_custom_target(java ALL DEPENDS ${JAR_FILE})
+add_custom_target(javadoc COMMAND
+  javadoc -notimestamp -d ${CMAKE_CURRENT_SOURCE_DIR}/doc -sourcepath ${CMAKE_CURRENT_SOURCE_DIR} org.libjpegturbo.turbojpeg)
+set(JAVACLASSPATH ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_FILES_DIRECTORY}/turbojpeg-java.dir)
+add_custom_target(javah
+	COMMAND javah -d ${CMAKE_CURRENT_SOURCE_DIR} -classpath ${JAVACLASSPATH} org.libjpegturbo.turbojpeg.TJ
+	COMMAND javah -d ${CMAKE_CURRENT_SOURCE_DIR} -classpath ${JAVACLASSPATH} org.libjpegturbo.turbojpeg.TJCompressor
+	COMMAND javah -d ${CMAKE_CURRENT_SOURCE_DIR} -classpath ${JAVACLASSPATH} org.libjpegturbo.turbojpeg.TJDecompressor
+	COMMAND javah -d ${CMAKE_CURRENT_SOURCE_DIR} -classpath ${JAVACLASSPATH} org.libjpegturbo.turbojpeg.TJTransformer)
 
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/${JAR_FILE} DESTINATION classes)
+if(NOT DEFINED CMAKE_INSTALL_DEFAULT_JAVADIR)
+  set(CMAKE_INSTALL_DEFAULT_JAVADIR "<CMAKE_INSTALL_DATAROOTDIR>/java")
+endif()
+GNUInstallDirs_set_install_dir(JAVADIR
+  "The directory into which Java classes should be installed")
+GNUInstallDirs_get_absolute_install_dir(CMAKE_INSTALL_FULL_JAVADIR
+  CMAKE_INSTALL_JAVADIR)
+set(CMAKE_INSTALL_JAVADIR ${CMAKE_INSTALL_JAVADIR} PARENT_SCOPE)
+set(CMAKE_INSTALL_FULL_JAVADIR ${CMAKE_INSTALL_FULL_JAVADIR} PARENT_SCOPE)
+report_directory(JAVADIR)
+install_jar(turbojpeg-java ${CMAKE_INSTALL_JAVADIR})
+mark_as_advanced(CLEAR CMAKE_INSTALL_JAVADIR)
diff --git a/java/Makefile.am b/java/Makefile.am
deleted file mode 100644
index d3fc59c..0000000
--- a/java/Makefile.am
+++ /dev/null
@@ -1,75 +0,0 @@
-JAVAROOT = .
-
-org/libjpegturbo/turbojpeg/TJLoader.java: $(srcdir)/org/libjpegturbo/turbojpeg/TJLoader.java.tmpl
-	mkdir -p org/libjpegturbo/turbojpeg; \
-	cat $(srcdir)/org/libjpegturbo/turbojpeg/TJLoader.java.tmpl | \
-		sed s@%{__libdir}@$(libdir)@g > org/libjpegturbo/turbojpeg/TJLoader.java
-
-
-JAVASOURCES = org/libjpegturbo/turbojpeg/TJ.java \
-	org/libjpegturbo/turbojpeg/TJCompressor.java \
-	org/libjpegturbo/turbojpeg/TJCustomFilter.java \
-	org/libjpegturbo/turbojpeg/TJDecompressor.java \
-	org/libjpegturbo/turbojpeg/TJException.java \
-	org/libjpegturbo/turbojpeg/TJScalingFactor.java \
-	org/libjpegturbo/turbojpeg/TJTransform.java \
-	org/libjpegturbo/turbojpeg/TJTransformer.java \
-	org/libjpegturbo/turbojpeg/YUVImage.java \
-	TJExample.java \
-	TJUnitTest.java \
-	TJBench.java
-
-JNIHEADERS = org_libjpegturbo_turbojpeg_TJ.h \
-	org_libjpegturbo_turbojpeg_TJCompressor.h \
-	org_libjpegturbo_turbojpeg_TJDecompressor.h \
-	org_libjpegturbo_turbojpeg_TJTransformer.h
-
-if WITH_JAVA
-
-nodist_noinst_JAVA = ${JAVASOURCES} org/libjpegturbo/turbojpeg/TJLoader.java
-
-JAVA_CLASSES = org/libjpegturbo/turbojpeg/TJ.class \
-	org/libjpegturbo/turbojpeg/TJCompressor.class \
-	org/libjpegturbo/turbojpeg/TJCustomFilter.class \
-	org/libjpegturbo/turbojpeg/TJDecompressor.class \
-	org/libjpegturbo/turbojpeg/TJException.class \
-	org/libjpegturbo/turbojpeg/TJLoader.class \
-	org/libjpegturbo/turbojpeg/TJScalingFactor.class \
-	org/libjpegturbo/turbojpeg/TJTransform.class \
-	org/libjpegturbo/turbojpeg/TJTransformer.class \
-	org/libjpegturbo/turbojpeg/YUVImage.class \
-	TJExample.class \
-	TJUnitTest.class \
-	TJBench.class
-
-all: all-am turbojpeg.jar
-
-turbojpeg.jar: classnoinst.stamp ${srcdir}/MANIFEST.MF
-	$(JAR) cfm turbojpeg.jar ${srcdir}/MANIFEST.MF $(JAVA_CLASSES)
-
-clean-local:
-	rm -f turbojpeg.jar
-
-install-exec-local: turbojpeg.jar
-	mkdir -p $(DESTDIR)/$(datadir)/classes
-	$(INSTALL) -m 644 turbojpeg.jar $(DESTDIR)/$(datadir)/classes/
-
-uninstall-local:
-	rm -f $(DESTDIR)/$(datadir)/classes/turbojpeg.jar
-	if [ -d $(DESTDIR)/$(datadir)/classes ]; then rmdir $(DESTDIR)/$(datadir)/classes; fi
-
-headers: all
-	javah -d ${srcdir} org.libjpegturbo.turbojpeg.TJ; \
-	javah -d ${srcdir} org.libjpegturbo.turbojpeg.TJCompressor; \
-	javah -d ${srcdir} org.libjpegturbo.turbojpeg.TJDecompressor; \
-	javah -d ${srcdir} org.libjpegturbo.turbojpeg.TJTransformer
-
-docs: all
-	mkdir -p ${srcdir}/doc; \
-	javadoc -notimestamp -d ${srcdir}/doc -sourcepath ${srcdir} org.libjpegturbo.turbojpeg
-
-endif
-
-EXTRA_DIST = MANIFEST.MF ${JAVASOURCES} ${JNIHEADERS} doc CMakeLists.txt \
-	org/libjpegturbo/turbojpeg/TJLoader.java.tmpl \
-	org/libjpegturbo/turbojpeg/TJLoader.java.in
diff --git a/java/TJBench.java b/java/TJBench.java
index 5185d65..6f5f335 100644
--- a/java/TJBench.java
+++ b/java/TJBench.java
@@ -636,6 +636,8 @@ class TJBench {
     System.out.println("     codec");
     System.out.println("-accuratedct = Use the most accurate DCT/IDCT algorithms available in the");
     System.out.println("     underlying codec");
+    System.out.println("-progressive = Use progressive entropy coding in JPEG images generated by");
+    System.out.println("     compression and transform operations.");
     System.out.println("-subsamp <s> = When testing JPEG compression, this option specifies the level");
     System.out.println("     of chrominance subsampling to use (<s> = 444, 422, 440, 420, 411, or");
     System.out.println("     GRAY).  The default is to test Grayscale, 4:2:0, 4:2:2, and 4:4:4 in");
@@ -673,7 +675,10 @@ class TJBench {
     System.out.println("     consistency of the results.");
     System.out.println("-componly = Stop after running compression tests.  Do not test decompression.");
     System.out.println("-nowrite = Do not write reference or output images (improves consistency");
-    System.out.println("     of performance measurements.)\n");
+    System.out.println("     of performance measurements.)");
+    System.out.println("-stoponwarning = Immediately discontinue the current");
+    System.out.println("     compression/decompression/transform operation if the underlying codec");
+    System.out.println("     throws a warning (non-fatal error)\n");
     System.out.println("NOTE:  If the quality is specified as a range (e.g. 90-100), a separate");
     System.out.println("test will be performed for all quality values in the range.\n");
     System.exit(1);
@@ -733,6 +738,10 @@ class TJBench {
             System.out.println("Using most accurate DCT/IDCT algorithm\n");
             flags |= TJ.FLAG_ACCURATEDCT;
           }
+          if (argv[i].equalsIgnoreCase("-progressive")) {
+            System.out.println("Using progressive entropy coding\n");
+            flags |= TJ.FLAG_PROGRESSIVE;
+          }
           if (argv[i].equalsIgnoreCase("-rgb"))
             pf = TJ.PF_RGB;
           if (argv[i].equalsIgnoreCase("-rgbx"))
@@ -844,6 +853,8 @@ class TJBench {
             } else
               usage();
           }
+          if (argv[i].equalsIgnoreCase("-stoponwarning"))
+            flags |= TJ.FLAG_STOPONWARNING;
           if (argv[i].equalsIgnoreCase("-?"))
             usage();
         }
@@ -916,7 +927,12 @@ class TJBench {
       }
 
     } catch (Exception e) {
-      System.out.println("ERROR: " + e.getMessage());
+      if (e instanceof TJException) {
+        TJException tje = (TJException)e;
+        System.out.println((tje.getErrorCode() == TJ.ERR_WARNING ?
+                            "WARNING: " : "ERROR: ") + tje.getMessage());
+      } else
+        System.out.println("ERROR: " + e.getMessage());
       e.printStackTrace();
       retval = -1;
     }
diff --git a/java/doc/constant-values.html b/java/doc/constant-values.html
index ec1b21d..74366d4 100644
--- a/java/doc/constant-values.html
+++ b/java/doc/constant-values.html
@@ -115,6 +115,20 @@
 <td class="colLast"><code>4</code></td>
 </tr>
 <tr class="rowColor">
+<td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.ERR_FATAL">
+<!--   -->
+</a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
+<td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#ERR_FATAL">ERR_FATAL</a></code></td>
+<td class="colLast"><code>1</code></td>
+</tr>
+<tr class="altColor">
+<td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.ERR_WARNING">
+<!--   -->
+</a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
+<td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#ERR_WARNING">ERR_WARNING</a></code></td>
+<td class="colLast"><code>0</code></td>
+</tr>
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.FLAG_ACCURATEDCT">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
@@ -171,6 +185,20 @@
 <td class="colLast"><code>128</code></td>
 </tr>
 <tr class="rowColor">
+<td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.FLAG_PROGRESSIVE">
+<!--   -->
+</a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
+<td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#FLAG_PROGRESSIVE">FLAG_PROGRESSIVE</a></code></td>
+<td class="colLast"><code>16384</code></td>
+</tr>
+<tr class="altColor">
+<td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.FLAG_STOPONWARNING">
+<!--   -->
+</a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
+<td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING">FLAG_STOPONWARNING</a></code></td>
+<td class="colLast"><code>8192</code></td>
+</tr>
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.NUMCS">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
@@ -178,139 +206,146 @@
 <td class="colLast"><code>5</code></td>
 </tr>
 <tr class="altColor">
+<td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.NUMERR">
+<!--   -->
+</a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
+<td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#NUMERR">NUMERR</a></code></td>
+<td class="colLast"><code>2</code></td>
+</tr>
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.NUMPF">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#NUMPF">NUMPF</a></code></td>
 <td class="colLast"><code>12</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.NUMSAMP">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#NUMSAMP">NUMSAMP</a></code></td>
 <td class="colLast"><code>6</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_ABGR">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_ABGR">PF_ABGR</a></code></td>
 <td class="colLast"><code>9</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_ARGB">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_ARGB">PF_ARGB</a></code></td>
 <td class="colLast"><code>10</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_BGR">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_BGR">PF_BGR</a></code></td>
 <td class="colLast"><code>1</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_BGRA">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_BGRA">PF_BGRA</a></code></td>
 <td class="colLast"><code>8</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_BGRX">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_BGRX">PF_BGRX</a></code></td>
 <td class="colLast"><code>3</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_CMYK">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_CMYK">PF_CMYK</a></code></td>
 <td class="colLast"><code>11</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_GRAY">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_GRAY">PF_GRAY</a></code></td>
 <td class="colLast"><code>6</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_RGB">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_RGB">PF_RGB</a></code></td>
 <td class="colLast"><code>0</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_RGBA">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_RGBA">PF_RGBA</a></code></td>
 <td class="colLast"><code>7</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_RGBX">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_RGBX">PF_RGBX</a></code></td>
 <td class="colLast"><code>2</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_XBGR">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_XBGR">PF_XBGR</a></code></td>
 <td class="colLast"><code>4</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.PF_XRGB">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#PF_XRGB">PF_XRGB</a></code></td>
 <td class="colLast"><code>5</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.SAMP_411">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#SAMP_411">SAMP_411</a></code></td>
 <td class="colLast"><code>5</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.SAMP_420">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#SAMP_420">SAMP_420</a></code></td>
 <td class="colLast"><code>2</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.SAMP_422">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#SAMP_422">SAMP_422</a></code></td>
 <td class="colLast"><code>1</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.SAMP_440">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#SAMP_440">SAMP_440</a></code></td>
 <td class="colLast"><code>4</code></td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.SAMP_444">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
 <td><code><a href="org/libjpegturbo/turbojpeg/TJ.html#SAMP_444">SAMP_444</a></code></td>
 <td class="colLast"><code>0</code></td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><a name="org.libjpegturbo.turbojpeg.TJ.SAMP_GRAY">
 <!--   -->
 </a><code>public&nbsp;static&nbsp;final&nbsp;int</code></td>
diff --git a/java/doc/index-all.html b/java/doc/index-all.html
index a02d9c4..8f05a42 100644
--- a/java/doc/index-all.html
+++ b/java/doc/index-all.html
@@ -278,6 +278,15 @@
 <div class="block">Returns true or false, depending on whether this instance and
  <code>other</code> have the same numerator and denominator.</div>
 </dd>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#ERR_FATAL">ERR_FATAL</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
+<dd>
+<div class="block">The error was fatal and non-recoverable.</div>
+</dd>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#ERR_WARNING">ERR_WARNING</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
+<dd>
+<div class="block">The error was non-fatal and recoverable, but the image may still be
+ corrupt.</div>
+</dd>
 </dl>
 <a name="_F_">
 <!--   -->
@@ -324,6 +333,16 @@
 <dd>
 <div class="block"><span class="strong">Deprecated.</span></div>
 </dd>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_PROGRESSIVE">FLAG_PROGRESSIVE</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
+<dd>
+<div class="block">Use progressive entropy coding in JPEG images generated by compression and
+ transform operations.</div>
+</dd>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING">FLAG_STOPONWARNING</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
+<dd>
+<div class="block">Immediately discontinue the current compression/decompression/transform
+ operation if the underlying codec throws a warning (non-fatal error).</div>
+</dd>
 </dl>
 <a name="_G_">
 <!--   -->
@@ -354,6 +373,11 @@
 <dd>
 <div class="block">Returns denominator</div>
 </dd>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJException.html#getErrorCode()">getErrorCode()</a></span> - Method in exception org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></dt>
+<dd>
+<div class="block">Returns a code (one of <a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.ERR_*</code></a>) indicating the severity of the
+ last error.</div>
+</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#getGreenOffset(int)">getGreenOffset(int)</a></span> - Static method in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
 <dd>
 <div class="block">For the given pixel format, returns the number of bytes that the green
@@ -516,6 +540,10 @@
 <dd>
 <div class="block">The number of JPEG colorspaces</div>
 </dd>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJ.html#NUMERR">NUMERR</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg">TJ</a></dt>
+<dd>
+<div class="block">The number of error codes</div>
+</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJTransform.html#NUMOP">NUMOP</a></span> - Static variable in class org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJTransform.html" title="class in org.libjpegturbo.turbojpeg">TJTransform</a></dt>
 <dd>
 <div class="block">The number of lossless transform operations</div>
@@ -829,6 +857,8 @@
 <dd>&nbsp;</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJException.html#TJException(java.lang.String)">TJException(String)</a></span> - Constructor for exception org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></dt>
 <dd>&nbsp;</dd>
+<dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJException.html#TJException(java.lang.String,%20int)">TJException(String, int)</a></span> - Constructor for exception org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></dt>
+<dd>&nbsp;</dd>
 <dt><span class="strong"><a href="./org/libjpegturbo/turbojpeg/TJException.html#TJException(java.lang.Throwable)">TJException(Throwable)</a></span> - Constructor for exception org.libjpegturbo.turbojpeg.<a href="./org/libjpegturbo/turbojpeg/TJException.html" title="class in org.libjpegturbo.turbojpeg">TJException</a></dt>
 <dd>&nbsp;</dd>
 <dt><a href="./org/libjpegturbo/turbojpeg/TJScalingFactor.html" title="class in org.libjpegturbo.turbojpeg"><span class="strong">TJScalingFactor</span></a> - Class in <a href="./org/libjpegturbo/turbojpeg/package-summary.html">org.libjpegturbo.turbojpeg</a></dt>
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJ.html b/java/doc/org/libjpegturbo/turbojpeg/TJ.html
index ffef657..a544179 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJ.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJ.html
@@ -145,6 +145,19 @@ extends java.lang.Object</pre>
 </tr>
 <tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#ERR_FATAL">ERR_FATAL</a></strong></code>
+<div class="block">The error was fatal and non-recoverable.</div>
+</td>
+</tr>
+<tr class="altColor">
+<td class="colFirst"><code>static int</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#ERR_WARNING">ERR_WARNING</a></strong></code>
+<div class="block">The error was non-fatal and recoverable, but the image may still be
+ corrupt.</div>
+</td>
+</tr>
+<tr class="rowColor">
+<td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_ACCURATEDCT">FLAG_ACCURATEDCT</a></strong></code>
 <div class="block">Use the most accurate DCT/IDCT algorithm available in the underlying
  codec.</div>
@@ -197,125 +210,145 @@ extends java.lang.Object</pre>
 </tr>
 <tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_PROGRESSIVE">FLAG_PROGRESSIVE</a></strong></code>
+<div class="block">Use progressive entropy coding in JPEG images generated by compression and
+ transform operations.</div>
+</td>
+</tr>
+<tr class="altColor">
+<td class="colFirst"><code>static int</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#FLAG_STOPONWARNING">FLAG_STOPONWARNING</a></strong></code>
+<div class="block">Immediately discontinue the current compression/decompression/transform
+ operation if the underlying codec throws a warning (non-fatal error).</div>
+</td>
+</tr>
+<tr class="rowColor">
+<td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#NUMCS">NUMCS</a></strong></code>
 <div class="block">The number of JPEG colorspaces</div>
 </td>
 </tr>
 <tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#NUMERR">NUMERR</a></strong></code>
+<div class="block">The number of error codes</div>
+</td>
+</tr>
+<tr class="rowColor">
+<td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#NUMPF">NUMPF</a></strong></code>
 <div class="block">The number of pixel formats</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#NUMSAMP">NUMSAMP</a></strong></code>
 <div class="block">The number of chrominance subsampling options</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_ABGR">PF_ABGR</a></strong></code>
 <div class="block">ABGR pixel format.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_ARGB">PF_ARGB</a></strong></code>
 <div class="block">ARGB pixel format.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_BGR">PF_BGR</a></strong></code>
 <div class="block">BGR pixel format.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_BGRA">PF_BGRA</a></strong></code>
 <div class="block">BGRA pixel format.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_BGRX">PF_BGRX</a></strong></code>
 <div class="block">BGRX pixel format.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_CMYK">PF_CMYK</a></strong></code>
 <div class="block">CMYK pixel format.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_GRAY">PF_GRAY</a></strong></code>
 <div class="block">Grayscale pixel format.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGB">PF_RGB</a></strong></code>
 <div class="block">RGB pixel format.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGBA">PF_RGBA</a></strong></code>
 <div class="block">RGBA pixel format.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_RGBX">PF_RGBX</a></strong></code>
 <div class="block">RGBX pixel format.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_XBGR">PF_XBGR</a></strong></code>
 <div class="block">XBGR pixel format.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#PF_XRGB">PF_XRGB</a></strong></code>
 <div class="block">XRGB pixel format.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_411">SAMP_411</a></strong></code>
 <div class="block">4:1:1 chrominance subsampling.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_420">SAMP_420</a></strong></code>
 <div class="block">4:2:0 chrominance subsampling.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_422">SAMP_422</a></strong></code>
 <div class="block">4:2:2 chrominance subsampling.</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_440">SAMP_440</a></strong></code>
 <div class="block">4:4:0 chrominance subsampling.</div>
 </td>
 </tr>
-<tr class="altColor">
+<tr class="rowColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_444">SAMP_444</a></strong></code>
 <div class="block">4:4:4 chrominance subsampling (no chrominance subsampling).</div>
 </td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colFirst"><code>static int</code></td>
 <td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJ.html#SAMP_GRAY">SAMP_GRAY</a></strong></code>
 <div class="block">Grayscale.</div>
@@ -938,7 +971,7 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <a name="FLAG_ACCURATEDCT">
 <!--   -->
 </a>
-<ul class="blockListLast">
+<ul class="blockList">
 <li class="blockList">
 <h4>FLAG_ACCURATEDCT</h4>
 <pre>public static final&nbsp;int FLAG_ACCURATEDCT</pre>
@@ -952,6 +985,68 @@ public static final&nbsp;int FLAG_FORCESSE3</pre>
 <dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_ACCURATEDCT">Constant Field Values</a></dd></dl>
 </li>
 </ul>
+<a name="FLAG_STOPONWARNING">
+<!--   -->
+</a>
+<ul class="blockList">
+<li class="blockList">
+<h4>FLAG_STOPONWARNING</h4>
+<pre>public static final&nbsp;int FLAG_STOPONWARNING</pre>
+<div class="block">Immediately discontinue the current compression/decompression/transform
+ operation if the underlying codec throws a warning (non-fatal error).  The
+ default behavior is to allow the operation to complete unless a fatal
+ error is encountered.</div>
+<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_STOPONWARNING">Constant Field Values</a></dd></dl>
+</li>
+</ul>
+<a name="FLAG_PROGRESSIVE">
+<!--   -->
+</a>
+<ul class="blockList">
+<li class="blockList">
+<h4>FLAG_PROGRESSIVE</h4>
+<pre>public static final&nbsp;int FLAG_PROGRESSIVE</pre>
+<div class="block">Use progressive entropy coding in JPEG images generated by compression and
+ transform operations.  Progressive entropy coding will generally improve
+ compression relative to baseline entropy coding (the default), but it will
+ reduce compression and decompression performance considerably.</div>
+<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.FLAG_PROGRESSIVE">Constant Field Values</a></dd></dl>
+</li>
+</ul>
+<a name="NUMERR">
+<!--   -->
+</a>
+<ul class="blockList">
+<li class="blockList">
+<h4>NUMERR</h4>
+<pre>public static final&nbsp;int NUMERR</pre>
+<div class="block">The number of error codes</div>
+<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.NUMERR">Constant Field Values</a></dd></dl>
+</li>
+</ul>
+<a name="ERR_WARNING">
+<!--   -->
+</a>
+<ul class="blockList">
+<li class="blockList">
+<h4>ERR_WARNING</h4>
+<pre>public static final&nbsp;int ERR_WARNING</pre>
+<div class="block">The error was non-fatal and recoverable, but the image may still be
+ corrupt.</div>
+<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.ERR_WARNING">Constant Field Values</a></dd></dl>
+</li>
+</ul>
+<a name="ERR_FATAL">
+<!--   -->
+</a>
+<ul class="blockListLast">
+<li class="blockList">
+<h4>ERR_FATAL</h4>
+<pre>public static final&nbsp;int ERR_FATAL</pre>
+<div class="block">The error was fatal and non-recoverable.</div>
+<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../constant-values.html#org.libjpegturbo.turbojpeg.TJ.ERR_FATAL">Constant Field Values</a></dd></dl>
+</li>
+</ul>
 </li>
 </ul>
 <!-- ========= CONSTRUCTOR DETAIL ======== -->
diff --git a/java/doc/org/libjpegturbo/turbojpeg/TJException.html b/java/doc/org/libjpegturbo/turbojpeg/TJException.html
index 6088066..a57b351 100644
--- a/java/doc/org/libjpegturbo/turbojpeg/TJException.html
+++ b/java/doc/org/libjpegturbo/turbojpeg/TJException.html
@@ -60,13 +60,13 @@
 <li>Nested&nbsp;|&nbsp;</li>
 <li>Field&nbsp;|&nbsp;</li>
 <li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
-<li><a href="#methods_inherited_from_class_java.lang.Throwable">Method</a></li>
+<li><a href="#method_summary">Method</a></li>
 </ul>
 <ul class="subNavList">
 <li>Detail:&nbsp;</li>
 <li>Field&nbsp;|&nbsp;</li>
 <li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
-<li>Method</li>
+<li><a href="#method_detail">Method</a></li>
 </ul>
 </div>
 <a name="skip-navbar_top">
@@ -138,10 +138,14 @@ extends java.io.IOException</pre>
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJException.html#TJException(java.lang.String)">TJException</a></strong>(java.lang.String&nbsp;message)</code>&nbsp;</td>
 </tr>
 <tr class="altColor">
+<td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJException.html#TJException(java.lang.String,%20int)">TJException</a></strong>(java.lang.String&nbsp;message,
+           int&nbsp;code)</code>&nbsp;</td>
+</tr>
+<tr class="rowColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJException.html#TJException(java.lang.String,%20java.lang.Throwable)">TJException</a></strong>(java.lang.String&nbsp;message,
            java.lang.Throwable&nbsp;cause)</code>&nbsp;</td>
 </tr>
-<tr class="rowColor">
+<tr class="altColor">
 <td class="colOne"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJException.html#TJException(java.lang.Throwable)">TJException</a></strong>(java.lang.Throwable&nbsp;cause)</code>&nbsp;</td>
 </tr>
 </table>
@@ -153,6 +157,20 @@ extends java.io.IOException</pre>
 <!--   -->
 </a>
 <h3>Method Summary</h3>
+<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
+<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
+<tr>
+<th class="colFirst" scope="col">Modifier and Type</th>
+<th class="colLast" scope="col">Method and Description</th>
+</tr>
+<tr class="altColor">
+<td class="colFirst"><code>int</code></td>
+<td class="colLast"><code><strong><a href="../../../org/libjpegturbo/turbojpeg/TJException.html#getErrorCode()">getErrorCode</a></strong>()</code>
+<div class="block">Returns a code (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.ERR_*</code></a>) indicating the severity of the
+ last error.</div>
+</td>
+</tr>
+</table>
 <ul class="blockList">
 <li class="blockList"><a name="methods_inherited_from_class_java.lang.Throwable">
 <!--   -->
@@ -209,6 +227,16 @@ extends java.io.IOException</pre>
 <pre>public&nbsp;TJException(java.lang.String&nbsp;message)</pre>
 </li>
 </ul>
+<a name="TJException(java.lang.String, int)">
+<!--   -->
+</a>
+<ul class="blockList">
+<li class="blockList">
+<h4>TJException</h4>
+<pre>public&nbsp;TJException(java.lang.String&nbsp;message,
+           int&nbsp;code)</pre>
+</li>
+</ul>
 <a name="TJException(java.lang.Throwable)">
 <!--   -->
 </a>
@@ -220,6 +248,27 @@ extends java.io.IOException</pre>
 </ul>
 </li>
 </ul>
+<!-- ============ METHOD DETAIL ========== -->
+<ul class="blockList">
+<li class="blockList"><a name="method_detail">
+<!--   -->
+</a>
+<h3>Method Detail</h3>
+<a name="getErrorCode()">
+<!--   -->
+</a>
+<ul class="blockListLast">
+<li class="blockList">
+<h4>getErrorCode</h4>
+<pre>public&nbsp;int&nbsp;getErrorCode()</pre>
+<div class="block">Returns a code (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.ERR_*</code></a>) indicating the severity of the
+ last error.</div>
+<dl><dt><span class="strong">Returns:</span></dt><dd>a code (one of <a href="../../../org/libjpegturbo/turbojpeg/TJ.html" title="class in org.libjpegturbo.turbojpeg"><code>TJ.ERR_*</code></a>) indicating the severity of the
+ last error.</dd></dl>
+</li>
+</ul>
+</li>
+</ul>
 </li>
 </ul>
 </div>
@@ -270,13 +319,13 @@ extends java.io.IOException</pre>
 <li>Nested&nbsp;|&nbsp;</li>
 <li>Field&nbsp;|&nbsp;</li>
 <li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
-<li><a href="#methods_inherited_from_class_java.lang.Throwable">Method</a></li>
+<li><a href="#method_summary">Method</a></li>
 </ul>
 <ul class="subNavList">
 <li>Detail:&nbsp;</li>
 <li>Field&nbsp;|&nbsp;</li>
 <li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
-<li>Method</li>
+<li><a href="#method_detail">Method</a></li>
 </ul>
 </div>
 <a name="skip-navbar_bottom">
diff --git a/java/doc/script.js b/java/doc/script.js
new file mode 100644
index 0000000..b346356
--- /dev/null
+++ b/java/doc/script.js
@@ -0,0 +1,30 @@
+function show(type)
+{
+    count = 0;
+    for (var key in methods) {
+        var row = document.getElementById(key);
+        if ((methods[key] &  type) != 0) {
+            row.style.display = '';
+            row.className = (count++ % 2) ? rowColor : altColor;
+        }
+        else
+            row.style.display = 'none';
+    }
+    updateTabs(type);
+}
+
+function updateTabs(type)
+{
+    for (var value in tabs) {
+        var sNode = document.getElementById(tabs[value][0]);
+        var spanNode = sNode.firstChild;
+        if (value == type) {
+            sNode.className = activeTableTab;
+            spanNode.innerHTML = tabs[value][1];
+        }
+        else {
+            sNode.className = tableTab;
+            spanNode.innerHTML = "<a href=\"javascript:show("+ value + ");\">" + tabs[value][1] + "</a>";
+        }
+    }
+}
diff --git a/java/doc/serialized-form.html b/java/doc/serialized-form.html
index 846cabc..9ba3fd9 100644
--- a/java/doc/serialized-form.html
+++ b/java/doc/serialized-form.html
@@ -74,6 +74,19 @@
 <dt>serialVersionUID:</dt>
 <dd>1L</dd>
 </dl>
+<ul class="blockList">
+<li class="blockList"><a name="serializedForm">
+<!--   -->
+</a>
+<h3>Serialized Fields</h3>
+<ul class="blockList">
+<li class="blockListLast">
+<h4>errorCode</h4>
+<pre>int errorCode</pre>
+</li>
+</ul>
+</li>
+</ul>
 </li>
 <li class="blockList"><a name="org.libjpegturbo.turbojpeg.TJTransform">
 <!--   -->
diff --git a/java/org/libjpegturbo/turbojpeg/TJ.java b/java/org/libjpegturbo/turbojpeg/TJ.java
index 02d14c0..045e829 100644
--- a/java/org/libjpegturbo/turbojpeg/TJ.java
+++ b/java/org/libjpegturbo/turbojpeg/TJ.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011-2013 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011-2013, 2017 D. R. Commander.  All Rights Reserved.
  * Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -348,16 +348,16 @@ public final class TJ {
    * The uncompressed source/destination image is stored in bottom-up (Windows,
    * OpenGL) order, not top-down (X11) order.
    */
-  public static final int FLAG_BOTTOMUP     = 2;
+  public static final int FLAG_BOTTOMUP      = 2;
 
   @Deprecated
-  public static final int FLAG_FORCEMMX     = 8;
+  public static final int FLAG_FORCEMMX      = 8;
   @Deprecated
-  public static final int FLAG_FORCESSE     = 16;
+  public static final int FLAG_FORCESSE      = 16;
   @Deprecated
-  public static final int FLAG_FORCESSE2    = 32;
+  public static final int FLAG_FORCESSE2     = 32;
   @Deprecated
-  public static final int FLAG_FORCESSE3    = 128;
+  public static final int FLAG_FORCESSE3     = 128;
 
   /**
    * When decompressing an image that was compressed using chrominance
@@ -366,7 +366,7 @@ public final class TJ {
    * creates a smooth transition between neighboring chrominance components in
    * order to reduce upsampling artifacts in the decompressed image.
    */
-  public static final int FLAG_FASTUPSAMPLE = 256;
+  public static final int FLAG_FASTUPSAMPLE  = 256;
   /**
    * Use the fastest DCT/IDCT algorithm available in the underlying codec.  The
    * default if this flag is not specified is implementation-specific.  For
@@ -375,7 +375,7 @@ public final class TJ {
    * only a very slight effect on accuracy, but it uses the accurate algorithm
    * when decompressing, because this has been shown to have a larger effect.
    */
-  public static final int FLAG_FASTDCT      =  2048;
+  public static final int FLAG_FASTDCT       = 2048;
   /**
    * Use the most accurate DCT/IDCT algorithm available in the underlying
    * codec.  The default if this flag is not specified is
@@ -385,7 +385,36 @@ public final class TJ {
    * but it uses the accurate algorithm when decompressing, because this has
    * been shown to have a larger effect.
    */
-  public static final int FLAG_ACCURATEDCT  =  4096;
+  public static final int FLAG_ACCURATEDCT   = 4096;
+  /**
+   * Immediately discontinue the current compression/decompression/transform
+   * operation if the underlying codec throws a warning (non-fatal error).  The
+   * default behavior is to allow the operation to complete unless a fatal
+   * error is encountered.
+   */
+  public static final int FLAG_STOPONWARNING = 8192;
+  /**
+   * Use progressive entropy coding in JPEG images generated by compression and
+   * transform operations.  Progressive entropy coding will generally improve
+   * compression relative to baseline entropy coding (the default), but it will
+   * reduce compression and decompression performance considerably.
+   */
+  public static final int FLAG_PROGRESSIVE   = 16384;
+
+
+  /**
+   * The number of error codes
+   */
+  public static final int NUMERR = 2;
+  /**
+   * The error was non-fatal and recoverable, but the image may still be
+   * corrupt.
+   */
+  public static final int ERR_WARNING = 0;
+  /**
+   * The error was fatal and non-recoverable.
+   */
+  public static final int ERR_FATAL = 1;
 
 
   /**
diff --git a/java/org/libjpegturbo/turbojpeg/TJException.java b/java/org/libjpegturbo/turbojpeg/TJException.java
index 59c2041..97659d4 100644
--- a/java/org/libjpegturbo/turbojpeg/TJException.java
+++ b/java/org/libjpegturbo/turbojpeg/TJException.java
@@ -1,5 +1,6 @@
 /*
  * Copyright (C)2015 Viktor Szathmáry.  All Rights Reserved.
+ * Copyright (C)2017 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -46,8 +47,26 @@ public class TJException extends IOException {
     super(message);
   }
 
+  public TJException(String message, int code) {
+    super(message);
+    if (errorCode >= 0 && errorCode < TJ.NUMERR)
+      errorCode = code;
+  }
+
   public TJException(Throwable cause) {
     super(cause);
   }
 
+  /**
+   * Returns a code (one of {@link TJ TJ.ERR_*}) indicating the severity of the
+   * last error.
+   *
+   * @return a code (one of {@link TJ TJ.ERR_*}) indicating the severity of the
+   * last error.
+   */
+  public int getErrorCode() {
+    return errorCode;
+  }
+
+  private int errorCode = TJ.ERR_FATAL;
 }
diff --git a/java/org/libjpegturbo/turbojpeg/TJLoader.java.tmpl b/java/org/libjpegturbo/turbojpeg/TJLoader-unix.java.in
similarity index 78%
rename from java/org/libjpegturbo/turbojpeg/TJLoader.java.tmpl
rename to java/org/libjpegturbo/turbojpeg/TJLoader-unix.java.in
index 5ef3118..65884e8 100644
--- a/java/org/libjpegturbo/turbojpeg/TJLoader.java.tmpl
+++ b/java/org/libjpegturbo/turbojpeg/TJLoader-unix.java.in
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011-2013 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011-2013, 2016 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -36,19 +36,19 @@ final class TJLoader {
       String os = System.getProperty("os.name").toLowerCase();
       if (os.indexOf("mac") >= 0) {
         try {
-          System.load("%{__libdir}/libturbojpeg.jnilib");
+          System.load("@CMAKE_INSTALL_FULL_LIBDIR@/libturbojpeg.jnilib");
         } catch (java.lang.UnsatisfiedLinkError e2) {
           System.load("/usr/lib/libturbojpeg.jnilib");
         }
       } else {
         try {
-          System.load("%{__libdir}/libturbojpeg.so");
+          System.load("@CMAKE_INSTALL_FULL_LIBDIR@/libturbojpeg.so");
         } catch (java.lang.UnsatisfiedLinkError e3) {
-          String libdir = "%{__libdir}";
-          if (libdir.equals("/opt/libjpeg-turbo/lib64")) {
-            System.load("/opt/libjpeg-turbo/lib32/libturbojpeg.so");
-          } else if (libdir.equals("/opt/libjpeg-turbo/lib32")) {
-            System.load("/opt/libjpeg-turbo/lib64/libturbojpeg.so");
+          String libdir = "@CMAKE_INSTALL_FULL_LIBDIR@";
+          if (libdir.equals("@CMAKE_INSTALL_DEFAULT_PREFIX@/lib64")) {
+            System.load("@CMAKE_INSTALL_DEFAULT_PREFIX@/lib32/libturbojpeg.so");
+          } else if (libdir.equals("@CMAKE_INSTALL_DEFAULT_PREFIX@/lib32")) {
+            System.load("@CMAKE_INSTALL_DEFAULT_PREFIX@/lib64/libturbojpeg.so");
           } else {
             throw e3;
           }
diff --git a/java/org/libjpegturbo/turbojpeg/TJLoader.java.in b/java/org/libjpegturbo/turbojpeg/TJLoader-win.java.in
similarity index 100%
rename from java/org/libjpegturbo/turbojpeg/TJLoader.java.in
rename to java/org/libjpegturbo/turbojpeg/TJLoader-win.java.in
diff --git a/jcicc.c b/jcicc.c
new file mode 100644
index 0000000..0613779
--- /dev/null
+++ b/jcicc.c
@@ -0,0 +1,105 @@
+/*
+ * jcicc.c
+ *
+ * Copyright (C) 1997-1998, Thomas G. Lane, Todd Newman.
+ * Copyright (C) 2017, D. R. Commander.
+ * For conditions of distribution and use, see the accompanying README.ijg
+ * file.
+ *
+ * This file provides code to write International Color Consortium (ICC) device
+ * profiles embedded in JFIF JPEG image files.  The ICC has defined a standard
+ * for including such data in JPEG "APP2" markers.  The code given here does
+ * not know anything about the internal structure of the ICC profile data; it
+ * just knows how to embed the profile data in a JPEG file while writing it.
+ */
+
+#define JPEG_INTERNALS
+#include "jinclude.h"
+#include "jpeglib.h"
+#include "jerror.h"
+
+
+/*
+ * Since an ICC profile can be larger than the maximum size of a JPEG marker
+ * (64K), we need provisions to split it into multiple markers.  The format
+ * defined by the ICC specifies one or more APP2 markers containing the
+ * following data:
+ *      Identifying string      ASCII "ICC_PROFILE\0"  (12 bytes)
+ *      Marker sequence number  1 for first APP2, 2 for next, etc (1 byte)
+ *      Number of markers       Total number of APP2's used (1 byte)
+ *      Profile data            (remainder of APP2 data)
+ * Decoders should use the marker sequence numbers to reassemble the profile,
+ * rather than assuming that the APP2 markers appear in the correct sequence.
+ */
+
+#define ICC_MARKER  (JPEG_APP0 + 2)     /* JPEG marker code for ICC */
+#define ICC_OVERHEAD_LEN  14            /* size of non-profile data in APP2 */
+#define MAX_BYTES_IN_MARKER  65533      /* maximum data len of a JPEG marker */
+#define MAX_DATA_BYTES_IN_MARKER  (MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN)
+
+
+/*
+ * This routine writes the given ICC profile data into a JPEG file.  It *must*
+ * be called AFTER calling jpeg_start_compress() and BEFORE the first call to
+ * jpeg_write_scanlines().  (This ordering ensures that the APP2 marker(s) will
+ * appear after the SOI and JFIF or Adobe markers, but before all else.)
+ */
+
+GLOBAL(void)
+jpeg_write_icc_profile (j_compress_ptr cinfo, const JOCTET *icc_data_ptr,
+                        unsigned int icc_data_len)
+{
+  unsigned int num_markers;     /* total number of markers we'll write */
+  int cur_marker = 1;           /* per spec, counting starts at 1 */
+  unsigned int length;          /* number of bytes to write in this marker */
+
+  if (icc_data_ptr == NULL || icc_data_len == 0)
+    ERREXIT(cinfo, JERR_BUFFER_SIZE);
+  if (cinfo->global_state < CSTATE_SCANNING)
+    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
+
+  /* Calculate the number of markers we'll need, rounding up of course */
+  num_markers = icc_data_len / MAX_DATA_BYTES_IN_MARKER;
+  if (num_markers * MAX_DATA_BYTES_IN_MARKER != icc_data_len)
+    num_markers++;
+
+  while (icc_data_len > 0) {
+    /* length of profile to put in this marker */
+    length = icc_data_len;
+    if (length > MAX_DATA_BYTES_IN_MARKER)
+      length = MAX_DATA_BYTES_IN_MARKER;
+    icc_data_len -= length;
+
+    /* Write the JPEG marker header (APP2 code and marker length) */
+    jpeg_write_m_header(cinfo, ICC_MARKER,
+                        (unsigned int) (length + ICC_OVERHEAD_LEN));
+
+    /* Write the marker identifying string "ICC_PROFILE" (null-terminated).  We
+     * code it in this less-than-transparent way so that the code works even if
+     * the local character set is not ASCII.
+     */
+    jpeg_write_m_byte(cinfo, 0x49);
+    jpeg_write_m_byte(cinfo, 0x43);
+    jpeg_write_m_byte(cinfo, 0x43);
+    jpeg_write_m_byte(cinfo, 0x5F);
+    jpeg_write_m_byte(cinfo, 0x50);
+    jpeg_write_m_byte(cinfo, 0x52);
+    jpeg_write_m_byte(cinfo, 0x4F);
+    jpeg_write_m_byte(cinfo, 0x46);
+    jpeg_write_m_byte(cinfo, 0x49);
+    jpeg_write_m_byte(cinfo, 0x4C);
+    jpeg_write_m_byte(cinfo, 0x45);
+    jpeg_write_m_byte(cinfo, 0x0);
+
+    /* Add the sequencing info */
+    jpeg_write_m_byte(cinfo, cur_marker);
+    jpeg_write_m_byte(cinfo, (int) num_markers);
+
+    /* Add the profile data */
+    while (length--) {
+      jpeg_write_m_byte(cinfo, *icc_data_ptr);
+      icc_data_ptr++;
+    }
+    cur_marker++;
+  }
+}
diff --git a/jconfig.h.in b/jconfig.h.in
index 02c12cc..3a47c18 100644
--- a/jconfig.h.in
+++ b/jconfig.h.in
@@ -1,19 +1,25 @@
 /* Version ID for the JPEG library.
  * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
  */
-#define JPEG_LIB_VERSION  62	/* Version 6b */
+#define JPEG_LIB_VERSION @JPEG_LIB_VERSION@
 
 /* libjpeg-turbo version */
-#define LIBJPEG_TURBO_VERSION 0
+#define LIBJPEG_TURBO_VERSION @VERSION@
 
 /* libjpeg-turbo version in integer form */
-#define LIBJPEG_TURBO_VERSION_NUMBER 0
+#define LIBJPEG_TURBO_VERSION_NUMBER @LIBJPEG_TURBO_VERSION_NUMBER@
 
 /* Support arithmetic encoding */
-#undef C_ARITH_CODING_SUPPORTED
+#cmakedefine C_ARITH_CODING_SUPPORTED
 
 /* Support arithmetic decoding */
-#undef D_ARITH_CODING_SUPPORTED
+#cmakedefine D_ARITH_CODING_SUPPORTED
+
+/* Support in-memory source/destination managers */
+#cmakedefine MEM_SRCDST_SUPPORTED
+
+/* Use accelerated SIMD routines. */
+#cmakedefine WITH_SIMD
 
 /*
  * Define BITS_IN_JSAMPLE as either
@@ -24,50 +30,44 @@
  * We do not support run-time selection of data precision, sorry.
  */
 
-#define BITS_IN_JSAMPLE  8      /* use 8 or 12 */
+#define BITS_IN_JSAMPLE  @BITS_IN_JSAMPLE@      /* use 8 or 12 */
 
 /* Define to 1 if you have the <locale.h> header file. */
-#undef HAVE_LOCALE_H
+#cmakedefine HAVE_LOCALE_H
 
 /* Define to 1 if you have the <stddef.h> header file. */
-#undef HAVE_STDDEF_H
+#cmakedefine HAVE_STDDEF_H
 
 /* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
+#cmakedefine HAVE_STDLIB_H
+
+/* Define if you need to include <sys/types.h> to get size_t. */
+#cmakedefine NEED_SYS_TYPES_H
+
+/* Define if you have BSD-like bzero and bcopy in <strings.h> rather than
+   memset/memcpy in <string.h>. */
+#cmakedefine NEED_BSD_STRINGS
 
 /* Define to 1 if the system has the type `unsigned char'. */
-#undef HAVE_UNSIGNED_CHAR
+#cmakedefine HAVE_UNSIGNED_CHAR
 
 /* Define to 1 if the system has the type `unsigned short'. */
-#undef HAVE_UNSIGNED_SHORT
+#cmakedefine HAVE_UNSIGNED_SHORT
 
 /* Compiler does not support pointers to undefined structures. */
-#undef INCOMPLETE_TYPES_BROKEN
-
-/* Support in-memory source/destination managers */
-#undef MEM_SRCDST_SUPPORTED
-
-/* Define if you have BSD-like bzero and bcopy in <strings.h> rather than
-   memset/memcpy in <string.h>. */
-#undef NEED_BSD_STRINGS
-
-/* Define if you need to include <sys/types.h> to get size_t. */
-#undef NEED_SYS_TYPES_H
+#cmakedefine INCOMPLETE_TYPES_BROKEN
 
 /* Define if your (broken) compiler shifts signed values as if they were
    unsigned. */
-#undef RIGHT_SHIFT_IS_UNSIGNED
-
-/* Use accelerated SIMD routines. */
-#undef WITH_SIMD
+#cmakedefine RIGHT_SHIFT_IS_UNSIGNED
 
 /* Define to 1 if type `char' is unsigned and you are not using gcc.  */
 #ifndef __CHAR_UNSIGNED__
-# undef __CHAR_UNSIGNED__
+  #cmakedefine __CHAR_UNSIGNED__
 #endif
 
 /* Define to empty if `const' does not conform to ANSI C. */
-#undef const
+/* #undef const */
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef size_t
+/* #undef size_t */
diff --git a/jconfigint.h.in b/jconfigint.h.in
index 963e760..835f7c4 100644
--- a/jconfigint.h.in
+++ b/jconfigint.h.in
@@ -1,17 +1,21 @@
 /* libjpeg-turbo build number */
-#undef BUILD
+#define BUILD "@BUILD@"
 
 /* Compiler's inline keyword */
 #undef inline
 
 /* How to obtain function inlining. */
-#undef INLINE
+#define INLINE @INLINE@
 
 /* Define to the full name of this package. */
-#undef PACKAGE_NAME
+#define PACKAGE_NAME "@CMAKE_PROJECT_NAME@"
 
 /* Version number of package */
-#undef VERSION
+#define VERSION "@VERSION@"
+
+#ifndef _WIN32
 
 /* The size of `size_t', as computed by sizeof. */
-#undef SIZEOF_SIZE_T
+#define SIZEOF_SIZE_T @SIZE_T@
+
+#endif
diff --git a/jdicc.c b/jdicc.c
new file mode 100644
index 0000000..b233736
--- /dev/null
+++ b/jdicc.c
@@ -0,0 +1,171 @@
+/*
+ * jdicc.c
+ *
+ * Copyright (C) 1997-1998, Thomas G. Lane, Todd Newman.
+ * Copyright (C) 2017, D. R. Commander.
+ * For conditions of distribution and use, see the accompanying README.ijg
+ * file.
+ *
+ * This file provides code to read International Color Consortium (ICC) device
+ * profiles embedded in JFIF JPEG image files.  The ICC has defined a standard
+ * for including such data in JPEG "APP2" markers.  The code given here does
+ * not know anything about the internal structure of the ICC profile data; it
+ * just knows how to get the profile data from a JPEG file while reading it.
+ */
+
+#define JPEG_INTERNALS
+#include "jinclude.h"
+#include "jpeglib.h"
+#include "jerror.h"
+
+#ifndef HAVE_STDLIB_H           /* <stdlib.h> should declare malloc() */
+extern void *malloc (size_t size);
+#endif
+
+
+#define ICC_MARKER  (JPEG_APP0 + 2)     /* JPEG marker code for ICC */
+#define ICC_OVERHEAD_LEN  14            /* size of non-profile data in APP2 */
+
+
+/*
+ * Handy subroutine to test whether a saved marker is an ICC profile marker.
+ */
+
+LOCAL(boolean)
+marker_is_icc (jpeg_saved_marker_ptr marker)
+{
+  return
+    marker->marker == ICC_MARKER &&
+    marker->data_length >= ICC_OVERHEAD_LEN &&
+    /* verify the identifying string */
+    GETJOCTET(marker->data[0]) == 0x49 &&
+    GETJOCTET(marker->data[1]) == 0x43 &&
+    GETJOCTET(marker->data[2]) == 0x43 &&
+    GETJOCTET(marker->data[3]) == 0x5F &&
+    GETJOCTET(marker->data[4]) == 0x50 &&
+    GETJOCTET(marker->data[5]) == 0x52 &&
+    GETJOCTET(marker->data[6]) == 0x4F &&
+    GETJOCTET(marker->data[7]) == 0x46 &&
+    GETJOCTET(marker->data[8]) == 0x49 &&
+    GETJOCTET(marker->data[9]) == 0x4C &&
+    GETJOCTET(marker->data[10]) == 0x45 &&
+    GETJOCTET(marker->data[11]) == 0x0;
+}
+
+
+/*
+ * See if there was an ICC profile in the JPEG file being read; if so,
+ * reassemble and return the profile data.
+ *
+ * TRUE is returned if an ICC profile was found, FALSE if not.  If TRUE is
+ * returned, *icc_data_ptr is set to point to the returned data, and
+ * *icc_data_len is set to its length.
+ *
+ * IMPORTANT: the data at *icc_data_ptr is allocated with malloc() and must be
+ * freed by the caller with free() when the caller no longer needs it.
+ * (Alternatively, we could write this routine to use the IJG library's memory
+ * allocator, so that the data would be freed implicitly when
+ * jpeg_finish_decompress() is called.  But it seems likely that many
+ * applications will prefer to have the data stick around after decompression
+ * finishes.)
+ */
+
+GLOBAL(boolean)
+jpeg_read_icc_profile (j_decompress_ptr cinfo, JOCTET **icc_data_ptr,
+                       unsigned int *icc_data_len)
+{
+  jpeg_saved_marker_ptr marker;
+  int num_markers = 0;
+  int seq_no;
+  JOCTET *icc_data;
+  unsigned int total_length;
+#define MAX_SEQ_NO  255         /* sufficient since marker numbers are bytes */
+  char marker_present[MAX_SEQ_NO+1];      /* 1 if marker found */
+  unsigned int data_length[MAX_SEQ_NO+1]; /* size of profile data in marker */
+  unsigned int data_offset[MAX_SEQ_NO+1]; /* offset for data in marker */
+
+  if (icc_data_ptr == NULL || icc_data_len == NULL)
+    ERREXIT(cinfo, JERR_BUFFER_SIZE);
+  if (cinfo->global_state < DSTATE_READY)
+    ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
+
+  *icc_data_ptr = NULL;         /* avoid confusion if FALSE return */
+  *icc_data_len = 0;
+
+  /* This first pass over the saved markers discovers whether there are
+   * any ICC markers and verifies the consistency of the marker numbering.
+   */
+
+  for (seq_no = 1; seq_no <= MAX_SEQ_NO; seq_no++)
+    marker_present[seq_no] = 0;
+
+  for (marker = cinfo->marker_list; marker != NULL; marker = marker->next) {
+    if (marker_is_icc(marker)) {
+      if (num_markers == 0)
+        num_markers = GETJOCTET(marker->data[13]);
+      else if (num_markers != GETJOCTET(marker->data[13])) {
+        WARNMS(cinfo, JWRN_BOGUS_ICC);  /* inconsistent num_markers fields */
+        return FALSE;
+      }
+      seq_no = GETJOCTET(marker->data[12]);
+      if (seq_no <= 0 || seq_no > num_markers) {
+        WARNMS(cinfo, JWRN_BOGUS_ICC);  /* bogus sequence number */
+        return FALSE;
+      }
+      if (marker_present[seq_no]) {
+        WARNMS(cinfo, JWRN_BOGUS_ICC);  /* duplicate sequence numbers */
+        return FALSE;
+      }
+      marker_present[seq_no] = 1;
+      data_length[seq_no] = marker->data_length - ICC_OVERHEAD_LEN;
+    }
+  }
+
+  if (num_markers == 0)
+    return FALSE;
+
+  /* Check for missing markers, count total space needed,
+   * compute offset of each marker's part of the data.
+   */
+
+  total_length = 0;
+  for (seq_no = 1; seq_no <= num_markers; seq_no++) {
+    if (marker_present[seq_no] == 0) {
+      WARNMS(cinfo, JWRN_BOGUS_ICC);  /* missing sequence number */
+      return FALSE;
+    }
+    data_offset[seq_no] = total_length;
+    total_length += data_length[seq_no];
+  }
+
+  if (total_length == 0) {
+    WARNMS(cinfo, JWRN_BOGUS_ICC);  /* found only empty markers? */
+    return FALSE;
+  }
+
+  /* Allocate space for assembled data */
+  icc_data = (JOCTET *) malloc(total_length * sizeof(JOCTET));
+  if (icc_data == NULL)
+    ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 11);  /* oops, out of memory */
+
+  /* and fill it in */
+  for (marker = cinfo->marker_list; marker != NULL; marker = marker->next) {
+    if (marker_is_icc(marker)) {
+      JOCTET FAR *src_ptr;
+      JOCTET *dst_ptr;
+      unsigned int length;
+      seq_no = GETJOCTET(marker->data[12]);
+      dst_ptr = icc_data + data_offset[seq_no];
+      src_ptr = marker->data + ICC_OVERHEAD_LEN;
+      length = data_length[seq_no];
+      while (length--) {
+        *dst_ptr++ = *src_ptr++;
+      }
+    }
+  }
+
+  *icc_data_ptr = icc_data;
+  *icc_data_len = total_length;
+
+  return TRUE;
+}
diff --git a/jerror.h b/jerror.h
index 11a07cb..a79586f 100644
--- a/jerror.h
+++ b/jerror.h
@@ -5,7 +5,7 @@
  * Copyright (C) 1994-1997, Thomas G. Lane.
  * Modified 1997-2009 by Guido Vollbeding.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2014, D. R. Commander.
+ * Copyright (C) 2014, 2017, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -208,6 +208,7 @@ JMESSAGE(JERR_NO_ARITH_TABLE, "Arithmetic table 0x%02x was not defined")
 JMESSAGE(JWRN_ARITH_BAD_CODE, "Corrupt JPEG data: bad arithmetic code")
 #endif
 #endif
+JMESSAGE(JWRN_BOGUS_ICC, "Corrupt JPEG data: bad ICC marker")
 
 #ifdef JMAKE_ENUM_LIST
 
diff --git a/jmemmgr.c b/jmemmgr.c
index 8dfb633..4f74870 100644
--- a/jmemmgr.c
+++ b/jmemmgr.c
@@ -89,7 +89,9 @@ round_up_pow2 (size_t a, size_t b)
 #ifndef WITH_SIMD
 #define ALIGN_SIZE  sizeof(double)
 #else
-#define ALIGN_SIZE  16 /* Most SIMD implementations require this */
+#define ALIGN_SIZE  32 /* Most of the SIMD instructions we support require
+                          16-byte (128-bit) alignment, but AVX2 requires
+                          32-byte alignment. */
 #endif
 #endif
 
diff --git a/jpeglib.h b/jpeglib.h
index 6c63f58..de6883e 100644
--- a/jpeglib.h
+++ b/jpeglib.h
@@ -5,7 +5,7 @@
  * Copyright (C) 1991-1998, Thomas G. Lane.
  * Modified 2002-2009 by Guido Vollbeding.
  * libjpeg-turbo Modifications:
- * Copyright (C) 2009-2011, 2013-2014, 2016, D. R. Commander.
+ * Copyright (C) 2009-2011, 2013-2014, 2016-2017, D. R. Commander.
  * Copyright (C) 2015, Google, Inc.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
@@ -976,6 +976,12 @@ EXTERN(void) jpeg_write_m_byte (j_compress_ptr cinfo, int val);
 /* Alternate compression function: just write an abbreviated table file */
 EXTERN(void) jpeg_write_tables (j_compress_ptr cinfo);
 
+/* Write ICC profile.  See libjpeg.txt for usage information. */
+EXTERN(void) jpeg_write_icc_profile (j_compress_ptr cinfo,
+                                     const JOCTET *icc_data_ptr,
+                                     unsigned int icc_data_len);
+
+
 /* Decompression startup: read start of JPEG datastream to see what's there */
 EXTERN(int) jpeg_read_header (j_decompress_ptr cinfo, boolean require_image);
 /* Return value is one of: */
@@ -1057,6 +1063,11 @@ EXTERN(void) jpeg_destroy (j_common_ptr cinfo);
 /* Default restart-marker-resync procedure for use by data source modules */
 EXTERN(boolean) jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired);
 
+/* Read ICC profile.  See libjpeg.txt for usage information. */
+EXTERN(boolean) jpeg_read_icc_profile (j_decompress_ptr cinfo,
+                                       JOCTET **icc_data_ptr,
+                                       unsigned int *icc_data_len);
+
 
 /* These marker codes are exported since applications and data source modules
  * are likely to want to use them.
diff --git a/jpegtran.1 b/jpegtran.1
index 631455b..2efb264 100644
--- a/jpegtran.1
+++ b/jpegtran.1
@@ -217,6 +217,11 @@ v6a, \fBjpegtran\fR always did the equivalent of \fB-copy none\fR.)
 .PP
 Additional switches recognized by jpegtran are:
 .TP
+.BI \-icc " file"
+Embed ICC color management profile contained in the specified file.  Note that
+this will cause \fBjpegtran\fR to ignore any APP2 markers in the input file,
+even if \fB-copy all\fR is specified.
+.TP
 .BI \-maxmemory " N"
 Set limit for amount of memory to use in processing large images.  Value is
 in thousands of bytes, or millions of bytes if "M" is attached to the
diff --git a/jpegtran.c b/jpegtran.c
index 6f8fd5b..ebd751e 100644
--- a/jpegtran.c
+++ b/jpegtran.c
@@ -40,6 +40,7 @@
 
 
 static const char *progname;    /* program name for error messages */
+static char *icc_filename;      /* for -icc switch */
 static char *outfilename;       /* for -outfile switch */
 static JCOPY_OPTION copyoption; /* -copy switch */
 static jpeg_transform_info transformoption; /* image transformation options */
@@ -83,6 +84,7 @@ usage (void)
 #ifdef C_ARITH_CODING_SUPPORTED
   fprintf(stderr, "  -arithmetic    Use arithmetic coding\n");
 #endif
+  fprintf(stderr, "  -icc FILE      Embed ICC profile contained in FILE\n");
   fprintf(stderr, "  -restart N     Set restart interval in rows, or in blocks with B\n");
   fprintf(stderr, "  -maxmemory N   Maximum memory to use (in kbytes)\n");
   fprintf(stderr, "  -outfile name  Specify name for output file\n");
@@ -138,6 +140,7 @@ parse_switches (j_compress_ptr cinfo, int argc, char **argv,
 
   /* Set up default JPEG parameters. */
   simple_progressive = FALSE;
+  icc_filename = NULL;
   outfilename = NULL;
   copyoption = JCOPYOPT_DEFAULT;
   transformoption.transform = JXFORM_NONE;
@@ -238,6 +241,12 @@ parse_switches (j_compress_ptr cinfo, int argc, char **argv,
       select_transform(JXFORM_NONE);    /* force an error */
 #endif
 
+    } else if (keymatch(arg, "icc", 1)) {
+      /* Set ICC filename. */
+      if (++argn >= argc)       /* advance to next argument */
+        usage();
+      icc_filename = argv[argn];
+
     } else if (keymatch(arg, "maxmemory", 3)) {
       /* Maximum memory in Kb (or Mb with 'm'). */
       long lval;
@@ -385,6 +394,9 @@ main (int argc, char **argv)
    * single file pointer for sequential input and output operation.
    */
   FILE *fp;
+  FILE *icc_file;
+  JOCTET *icc_profile = NULL;
+  long icc_len = 0;
 
   /* On Mac, fetch a command line. */
 #ifdef USE_CCOMMAND
@@ -449,6 +461,35 @@ main (int argc, char **argv)
     fp = read_stdin();
   }
 
+  if (icc_filename != NULL) {
+    if ((icc_file = fopen(icc_filename, READ_BINARY)) == NULL) {
+      fprintf(stderr, "%s: can't open %s\n", progname, icc_filename);
+      exit(EXIT_FAILURE);
+    }
+    if (fseek(icc_file, 0, SEEK_END) < 0 ||
+        (icc_len = ftell(icc_file)) < 1 ||
+        fseek(icc_file, 0, SEEK_SET) < 0) {
+      fprintf(stderr, "%s: can't determine size of %s\n", progname,
+              icc_filename);
+      exit(EXIT_FAILURE);
+    }
+    if ((icc_profile = (JOCTET *)malloc(icc_len)) == NULL) {
+      fprintf(stderr, "%s: can't allocate memory for ICC profile\n", progname);
+      fclose(icc_file);
+      exit(EXIT_FAILURE);
+    }
+    if (fread(icc_profile, icc_len, 1, icc_file) < 1) {
+      fprintf(stderr, "%s: can't read ICC profile from %s\n", progname,
+              icc_filename);
+      free(icc_profile);
+      fclose(icc_file);
+      exit(EXIT_FAILURE);
+    }
+    fclose(icc_file);
+    if (copyoption == JCOPYOPT_ALL)
+      copyoption = JCOPYOPT_ALL_EXCEPT_ICC;
+  }
+
 #ifdef PROGRESS_REPORT
   start_progress_monitor((j_common_ptr) &dstinfo, &progress);
 #endif
@@ -524,6 +565,9 @@ main (int argc, char **argv)
   /* Copy to the output file any extra markers that we want to preserve */
   jcopy_markers_execute(&srcinfo, &dstinfo, copyoption);
 
+  if (icc_profile != NULL)
+    jpeg_write_icc_profile(&dstinfo, icc_profile, (unsigned int)icc_len);
+
   /* Execute image transformation, if any */
 #if TRANSFORMS_SUPPORTED
   jtransform_execute_transformation(&srcinfo, &dstinfo,
@@ -545,6 +589,9 @@ main (int argc, char **argv)
   end_progress_monitor((j_common_ptr) &dstinfo);
 #endif
 
+  if (icc_profile != NULL)
+    free(icc_profile);
+
   /* All done. */
   exit(jsrcerr.num_warnings + jdsterr.num_warnings ?EXIT_WARNING:EXIT_SUCCESS);
   return 0;                     /* suppress no-return-value warnings */
diff --git a/jversion.h b/jversion.h
index 7e44eaa..7bb8ff4 100644
--- a/jversion.h
+++ b/jversion.h
@@ -38,6 +38,7 @@
 #define JCOPYRIGHT      "Copyright (C) 2009-2017 D. R. Commander\n" \
                         "Copyright (C) 2011-2016 Siarhei Siamashka\n" \
                         "Copyright (C) 2015-2016 Matthieu Darbois\n" \
+                        "Copyright (C) 2015 Intel Corporation\n" \
                         "Copyright (C) 2015 Google, Inc.\n" \
                         "Copyright (C) 2013-2014 MIPS Technologies, Inc.\n" \
                         "Copyright (C) 2013 Linaro Limited\n" \
diff --git a/libjpeg.txt b/libjpeg.txt
index 5181afc..13094d4 100644
--- a/libjpeg.txt
+++ b/libjpeg.txt
@@ -47,6 +47,7 @@ Advanced features:
         Buffered-image mode
         Abbreviated datastreams and multiple images
         Special markers
+        ICC profiles
         Raw (downsampled) image data
         Really raw data: DCT coefficients
         Progress monitoring
@@ -2633,6 +2634,44 @@ A simple example of an external COM processor can be found in djpeg.c.
 Also, see jpegtran.c for an example of using jpeg_save_markers.
 
 
+ICC profiles
+------------
+
+Two functions are provided for writing and reading International Color
+Consortium (ICC) device profiles embedded in JFIF JPEG image files:
+
+        void jpeg_write_icc_profile (j_compress_ptr cinfo,
+                                     const JOCTET *icc_data_ptr,
+                                     unsigned int icc_data_len);
+        boolean jpeg_read_icc_profile (j_decompress_ptr cinfo,
+                                       JOCTET **icc_data_ptr,
+                                       unsigned int *icc_data_len);
+
+The ICC has defined a standard for including such data in JPEG "APP2" markers.
+The aforementioned functions do not know anything about the internal structure
+of the ICC profile data; they just know how to embed the profile data into a
+JPEG file while writing it, or to extract the profile data from a JPEG file
+while reading it.
+
+jpeg_write_icc_profile() must be called after calling jpeg_start_compress() and
+before the first call to jpeg_write_scanlines() or jpeg_write_raw_data().  This
+ordering ensures that the APP2 marker(s) will appear after the SOI and JFIF or
+Adobe markers, but before all other data.
+
+jpeg_read_icc_profile() returns TRUE if an ICC profile was found and FALSE
+otherwise.  If an ICC profile was found, then the function will allocate a
+memory region containing the profile and will return a pointer to that memory
+region in *icc_data_ptr, as well as the length of the region in *icc_data_len.
+This memory region is allocated by the library using malloc() and must be freed
+by the caller using free() when the memory region is no longer needed.  Callers
+wishing to use jpeg_read_icc_profile() must call
+
+        jpeg_save_markers(cinfo, JPEG_APP0 + 2, 0xFFFF);
+
+prior to calling jpeg_read_header().  jpeg_read_icc_profile() can be called at
+any point between jpeg_read_header() and jpeg_finish_decompress().
+
+
 Raw (downsampled) image data
 ----------------------------
 
diff --git a/md5/Makefile.am b/md5/Makefile.am
deleted file mode 100644
index b36f019..0000000
--- a/md5/Makefile.am
+++ /dev/null
@@ -1,4 +0,0 @@
-noinst_PROGRAMS = md5cmp
-
-md5cmp_SOURCES = md5cmp.c md5.c md5hl.c md5.h
-md5cmp_CFLAGS = -I$(srcdir)
diff --git a/release/Distribution.xml b/release/Distribution.xml.in
similarity index 63%
rename from release/Distribution.xml
rename to release/Distribution.xml.in
index ee73ab0..e1f79ee 100644
--- a/release/Distribution.xml
+++ b/release/Distribution.xml.in
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <installer-gui-script minSpecVersion="1">
-	<title>libjpeg-turbo</title>
+	<title>@CMAKE_PROJECT_NAME@</title>
 	<welcome file="Welcome.rtf" />
 	<readme file="ReadMe.txt" />
 	<license file="License.rtf" />
@@ -12,13 +12,13 @@
 	<options customize="never" />
 	<choices-outline>
 		<line choice="default">
-			<line choice="com.libjpeg-turbo.libjpeg-turbo"/>
+			<line choice="@PKGID@"/>
 		</line>
 	</choices-outline>
 	<choice id="default"/>
-	<choice id="com.libjpeg-turbo.libjpeg-turbo" visible="false">
-		<pkg-ref id="com.libjpeg-turbo.libjpeg-turbo"/>
+	<choice id="@PKGID@" visible="false">
+		<pkg-ref id="@PKGID@"/>
 	</choice>
 	<pkg-ref auth="root"
-		id="com.libjpeg-turbo.libjpeg-turbo">libjpeg-turbo.pkg</pkg-ref>
+		id="@PKGID@">@PKGNAME@.pkg</pkg-ref>
 </installer-gui-script>
diff --git a/release/ReadMe.txt b/release/ReadMe.txt
index 7fb8d0f..a3bafd9 100644
--- a/release/ReadMe.txt
+++ b/release/ReadMe.txt
@@ -1,4 +1,4 @@
-libjpeg-turbo is a JPEG image codec that uses SIMD instructions (MMX, SSE2, NEON, AltiVec) to accelerate baseline JPEG compression and decompression on x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is generally 2-6x as fast as libjpeg, all else being equal.  On other types of systems, libjpeg-turbo can still outperform libjpeg by a significant amount, by virtue of its highly-optimized Huffman coding routines.  In many cases, the performance of libjpeg-turbo rivals that of proprietary high-speed JPEG codecs.
+libjpeg-turbo is a JPEG image codec that uses SIMD instructions (MMX, SSE2, AVX2, NEON, AltiVec) to accelerate baseline JPEG compression and decompression on x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is generally 2-6x as fast as libjpeg, all else being equal.  On other types of systems, libjpeg-turbo can still outperform libjpeg by a significant amount, by virtue of its highly-optimized Huffman coding routines.  In many cases, the performance of libjpeg-turbo rivals that of proprietary high-speed JPEG codecs.
 
 libjpeg-turbo implements both the traditional libjpeg API as well as the less powerful but more straightforward TurboJPEG API.  libjpeg-turbo also features colorspace extensions that allow it to compress from/decompress to 32-bit and big-endian pixel buffers (RGBX, XBGR, etc.), as well as a full-featured Java interface.
 
diff --git a/release/deb-control.tmpl b/release/deb-control.in
similarity index 82%
rename from release/deb-control.tmpl
rename to release/deb-control.in
index 681721d..8c54dd9 100644
--- a/release/deb-control.tmpl
+++ b/release/deb-control.in
@@ -1,16 +1,16 @@
 Package: {__PKGNAME}
-Version: {__VERSION}-{__BUILD}
+Version: @VERSION@-@BUILD@
 Section: misc
 Priority: optional
 Architecture: {__ARCH}
 Essential: no
-Maintainer: The libjpeg-turbo Project <information@libjpeg-turbo.org>
-Homepage: http://www.libjpeg-turbo.org
+Maintainer: @PKGVENDOR@ <@PKGEMAIL@>
+Homepage: @PKGURL@
 Installed-Size: {__SIZE}
 Description: A SIMD-accelerated JPEG codec that provides both the libjpeg and TurboJPEG APIs
  libjpeg-turbo is a JPEG image codec that uses SIMD instructions (MMX, SSE2,
- NEON, AltiVec) to accelerate baseline JPEG compression and decompression on
- x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is
+ AVX2, NEON, AltiVec) to accelerate baseline JPEG compression and decompression
+ on x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is
  generally 2-6x as fast as libjpeg, all else being equal.  On other types of
  systems, libjpeg-turbo can still outperform libjpeg by a significant amount,
  by virtue of its highly-optimized Huffman coding routines.  In many cases, the
diff --git a/release/libjpeg-turbo.nsi.in b/release/installer.nsi.in
similarity index 63%
rename from release/libjpeg-turbo.nsi.in
rename to release/installer.nsi.in
index f458b81..b413838 100755
--- a/release/libjpeg-turbo.nsi.in
+++ b/release/installer.nsi.in
@@ -1,6 +1,6 @@
 !include x64.nsh
 Name "@CMAKE_PROJECT_NAME@ SDK for @INST_PLATFORM@"
-OutFile "@CMAKE_BINARY_DIR@\${BUILDDIR}@INST_NAME@.exe"
+OutFile "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}@INST_NAME@.exe"
 InstallDir @INST_DIR@
 
 SetCompressor bzip2
@@ -35,58 +35,58 @@ Section "@CMAKE_PROJECT_NAME@ SDK for @INST_PLATFORM@ (required)"
 	notexists:
 	SetOutPath $SYSDIR
 !ifdef GCC
-	File "@CMAKE_BINARY_DIR@\libturbojpeg.dll"
+	File "@CMAKE_CURRENT_BINARY_DIR@\libturbojpeg.dll"
 !else
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}turbojpeg.dll"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}turbojpeg.dll"
 !endif
 	SetOutPath $INSTDIR\bin
 !ifdef GCC
-	File "@CMAKE_BINARY_DIR@\libturbojpeg.dll"
+	File "@CMAKE_CURRENT_BINARY_DIR@\libturbojpeg.dll"
 !else
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}turbojpeg.dll"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}turbojpeg.dll"
 !endif
 !ifdef GCC
-	File "/oname=libjpeg-@DLL_VERSION@.dll" "@CMAKE_BINARY_DIR@\sharedlib\libjpeg-*.dll"
+	File "@CMAKE_CURRENT_BINARY_DIR@\libjpeg-@SO_MAJOR_VERSION@.dll"
 !else
-	File "@CMAKE_BINARY_DIR@\sharedlib\${BUILDDIR}jpeg@DLL_VERSION@.dll"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}jpeg@SO_MAJOR_VERSION@.dll"
 !endif
-	File "@CMAKE_BINARY_DIR@\sharedlib\${BUILDDIR}cjpeg.exe"
-	File "@CMAKE_BINARY_DIR@\sharedlib\${BUILDDIR}djpeg.exe"
-	File "@CMAKE_BINARY_DIR@\sharedlib\${BUILDDIR}jpegtran.exe"
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}tjbench.exe"
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}rdjpgcom.exe"
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}wrjpgcom.exe"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}cjpeg.exe"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}djpeg.exe"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}jpegtran.exe"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}tjbench.exe"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}rdjpgcom.exe"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}wrjpgcom.exe"
 	SetOutPath $INSTDIR\lib
 !ifdef GCC
-	File "@CMAKE_BINARY_DIR@\libturbojpeg.dll.a"
-	File "@CMAKE_BINARY_DIR@\libturbojpeg.a"
-	File "@CMAKE_BINARY_DIR@\sharedlib\libjpeg.dll.a"
-	File "@CMAKE_BINARY_DIR@\libjpeg.a"
+	File "@CMAKE_CURRENT_BINARY_DIR@\libturbojpeg.dll.a"
+	File "@CMAKE_CURRENT_BINARY_DIR@\libturbojpeg.a"
+	File "@CMAKE_CURRENT_BINARY_DIR@\libjpeg.dll.a"
+	File "@CMAKE_CURRENT_BINARY_DIR@\libjpeg.a"
 !else
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}turbojpeg.lib"
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}turbojpeg-static.lib"
-	File "@CMAKE_BINARY_DIR@\sharedlib\${BUILDDIR}jpeg.lib"
-	File "@CMAKE_BINARY_DIR@\${BUILDDIR}jpeg-static.lib"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}turbojpeg.lib"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}turbojpeg-static.lib"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}jpeg.lib"
+	File "@CMAKE_CURRENT_BINARY_DIR@\${BUILDDIR}jpeg-static.lib"
 !endif
 !ifdef JAVA
 	SetOutPath $INSTDIR\classes
-	File "@CMAKE_BINARY_DIR@\java\${BUILDDIR}turbojpeg.jar"
+	File "@CMAKE_CURRENT_BINARY_DIR@\java\turbojpeg.jar"
 !endif
 	SetOutPath $INSTDIR\include
-	File "@CMAKE_BINARY_DIR@\jconfig.h"
-	File "@CMAKE_SOURCE_DIR@\jerror.h"
-	File "@CMAKE_SOURCE_DIR@\jmorecfg.h"
-	File "@CMAKE_SOURCE_DIR@\jpeglib.h"
-	File "@CMAKE_SOURCE_DIR@\turbojpeg.h"
+	File "@CMAKE_CURRENT_BINARY_DIR@\jconfig.h"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\jerror.h"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\jmorecfg.h"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\jpeglib.h"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\turbojpeg.h"
 	SetOutPath $INSTDIR\doc
-	File "@CMAKE_SOURCE_DIR@\README.ijg"
-	File "@CMAKE_SOURCE_DIR@\README.md"
-	File "@CMAKE_SOURCE_DIR@\LICENSE.md"
-	File "@CMAKE_SOURCE_DIR@\example.c"
-	File "@CMAKE_SOURCE_DIR@\libjpeg.txt"
-	File "@CMAKE_SOURCE_DIR@\structure.txt"
-	File "@CMAKE_SOURCE_DIR@\usage.txt"
-	File "@CMAKE_SOURCE_DIR@\wizard.txt"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\README.ijg"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\README.md"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\LICENSE.md"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\example.c"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\libjpeg.txt"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\structure.txt"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\usage.txt"
+	File "@CMAKE_CURRENT_SOURCE_DIR@\wizard.txt"
 
 	WriteRegStr HKLM "SOFTWARE\@INST_REG_NAME@ @VERSION@" "Install_Dir" "$INSTDIR"
 
@@ -110,7 +110,7 @@ Section "Uninstall"
 	DeleteRegKey HKLM "SOFTWARE\@INST_REG_NAME@ @VERSION@"
 
 !ifdef GCC
-	Delete $INSTDIR\bin\libjpeg-@DLL_VERSION@.dll
+	Delete $INSTDIR\bin\libjpeg-@SO_MAJOR_VERSION@.dll
 	Delete $INSTDIR\bin\libturbojpeg.dll
 	Delete $SYSDIR\libturbojpeg.dll
 	Delete $INSTDIR\lib\libturbojpeg.dll.a"
@@ -118,7 +118,7 @@ Section "Uninstall"
 	Delete $INSTDIR\lib\libjpeg.dll.a"
 	Delete $INSTDIR\lib\libjpeg.a"
 !else
-	Delete $INSTDIR\bin\jpeg@DLL_VERSION@.dll
+	Delete $INSTDIR\bin\jpeg@SO_MAJOR_VERSION@.dll
 	Delete $INSTDIR\bin\turbojpeg.dll
 	Delete $SYSDIR\turbojpeg.dll
 	Delete $INSTDIR\lib\jpeg.lib
diff --git a/release/libjpeg-turbo.spec.in b/release/libjpeg-turbo.spec.in
deleted file mode 100644
index 4b792d7..0000000
--- a/release/libjpeg-turbo.spec.in
+++ /dev/null
@@ -1,153 +0,0 @@
-# Path under which libjpeg-turbo should be installed
-%define _prefix %{__prefix}
-
-# Path under which executables should be installed
-%define _bindir %{__bindir}
-
-# Path under which Java classes and man pages should be installed
-%define _datadir %{__datadir}
-
-# Path under which docs should be installed
-%define _docdir /usr/share/doc/%{name}-%{version}
-
-# Path under which headers should be installed
-%define _includedir %{__includedir}
-
-# _libdir is set to %{_prefix}/%{_lib} by default
-%ifarch x86_64
-%define _lib lib64
-%else
-%if "%{_prefix}" == "/opt/libjpeg-turbo"
-%define _lib lib32
-%endif
-%endif
-
-# Path under which man pages should be installed
-%define _mandir %{__mandir}
-
-Summary: A SIMD-accelerated JPEG codec that provides both the libjpeg and TurboJPEG APIs
-Name: @PKGNAME@
-Version: @VERSION@
-Vendor: The libjpeg-turbo Project
-URL: http://www.libjpeg-turbo.org
-Group: System Environment/Libraries
-#-->Source0: http://prdownloads.sourceforge.net/libjpeg-turbo/libjpeg-turbo-%{version}.tar.gz
-Release: @BUILD@
-License: BSD-style
-BuildRoot: %{_blddir}/%{name}-buildroot-%{version}-%{release}
-Prereq: /sbin/ldconfig
-%ifarch x86_64
-Provides: %{name} = %{version}-%{release}, @PACKAGE_NAME@ = %{version}-%{release}, libturbojpeg.so()(64bit)
-%else
-Provides: %{name} = %{version}-%{release}, @PACKAGE_NAME@ = %{version}-%{release}, libturbojpeg.so
-%endif
-
-%description
-libjpeg-turbo is a JPEG image codec that uses SIMD instructions (MMX, SSE2,
-NEON, AltiVec) to accelerate baseline JPEG compression and decompression on
-x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is
-generally 2-6x as fast as libjpeg, all else being equal.  On other types of
-systems, libjpeg-turbo can still outperform libjpeg by a significant amount, by
-virtue of its highly-optimized Huffman coding routines.  In many cases, the
-performance of libjpeg-turbo rivals that of proprietary high-speed JPEG codecs.
-
-libjpeg-turbo implements both the traditional libjpeg API as well as the less
-powerful but more straightforward TurboJPEG API.  libjpeg-turbo also features
-colorspace extensions that allow it to compress from/decompress to 32-bit and
-big-endian pixel buffers (RGBX, XBGR, etc.), as well as a full-featured Java
-interface.
-
-libjpeg-turbo was originally based on libjpeg/SIMD, an MMX-accelerated
-derivative of libjpeg v6b developed by Miyasaka Masaru.  The TigerVNC and
-VirtualGL projects made numerous enhancements to the codec in 2009, and in
-early 2010, libjpeg-turbo spun off into an independent project, with the goal
-of making high-speed JPEG compression/decompression technology available to a
-broader range of users and developers.
-
-#-->%prep
-#-->%setup -q -n libjpeg-turbo-%{version}
-
-#-->%build
-#-->./configure prefix=%{_prefix} bindir=%{_bindir} datadir=%{_datadir} \
-#-->	docdir=%{_docdir} includedir=%{_includedir} libdir=%{_libdir} \
-#-->	mandir=%{_mandir} JPEG_LIB_VERSION=@JPEG_LIB_VERSION@ \
-#-->	SO_MAJOR_VERSION=@SO_MAJOR_VERSION@ SO_MINOR_VERSION=@SO_MINOR_VERSION@ \
-#-->	--with-pic @RPM_CONFIG_ARGS@
-#-->make DESTDIR=$RPM_BUILD_ROOT
-
-%install
-
-rm -rf $RPM_BUILD_ROOT
-make install DESTDIR=$RPM_BUILD_ROOT docdir=%{_docdir} exampledir=%{_docdir}
-rm -f $RPM_BUILD_ROOT%{_libdir}/*.la
-/sbin/ldconfig -n $RPM_BUILD_ROOT%{_libdir}
-
-#-->%if 0
-
-LJT_LIBDIR=%{__libdir}
-if [ ! "$LJT_LIBDIR" = "%{_libdir}" ]; then
-	echo ERROR: libjpeg-turbo must be configured with libdir=%{_prefix}/%{_lib} when generating an in-tree RPM for this architecture.
-	exit 1
-fi
-
-#-->%endif
-
-LJT_DOCDIR=%{__docdir}
-if [ "%{_prefix}" = "/opt/libjpeg-turbo" -a "$LJT_DOCDIR" = "/opt/libjpeg-turbo/doc" ]; then
-	ln -fs %{_docdir} $RPM_BUILD_ROOT/$LJT_DOCDIR
-fi
-
-%post -p /sbin/ldconfig
-
-%postun -p /sbin/ldconfig
-
-%clean
-rm -rf $RPM_BUILD_ROOT
-
-%files
-%defattr(-,root,root)
-%dir %{_docdir}
-%doc %{_docdir}/*
-%dir %{_prefix}
-%if "%{_prefix}" == "/opt/libjpeg-turbo" && "%{_docdir}" != "%{_prefix}/doc"
- %{_prefix}/doc
-%endif
-%dir %{_bindir}
-%{_bindir}/cjpeg
-%{_bindir}/djpeg
-%{_bindir}/jpegtran
-%{_bindir}/tjbench
-%{_bindir}/rdjpgcom
-%{_bindir}/wrjpgcom
-%dir %{_libdir}
-%{_libdir}/libjpeg.so.@SO_MAJOR_VERSION@.@SO_AGE@.@SO_MINOR_VERSION@
-%{_libdir}/libjpeg.so.@SO_MAJOR_VERSION@
-%{_libdir}/libjpeg.so
-%{_libdir}/libjpeg.a
-%{_libdir}/pkgconfig
-%{_libdir}/pkgconfig/libjpeg.pc
-%{_libdir}/libturbojpeg.so.0.1.0
-%{_libdir}/libturbojpeg.so.0
-%{_libdir}/libturbojpeg.so
-%{_libdir}/libturbojpeg.a
-%{_libdir}/pkgconfig/libturbojpeg.pc
-%dir %{_includedir}
-%{_includedir}/jconfig.h
-%{_includedir}/jerror.h
-%{_includedir}/jmorecfg.h
-%{_includedir}/jpeglib.h
-%{_includedir}/turbojpeg.h
-%dir %{_mandir}
-%dir %{_mandir}/man1
-%{_mandir}/man1/cjpeg.1*
-%{_mandir}/man1/djpeg.1*
-%{_mandir}/man1/jpegtran.1*
-%{_mandir}/man1/rdjpgcom.1*
-%{_mandir}/man1/wrjpgcom.1*
-%if "%{_prefix}" != "%{_datadir}"
- %dir %{_datadir}
-%endif
-@JAVA_RPM_CONTENTS_1@
-@JAVA_RPM_CONTENTS_2@
-
-%changelog
diff --git a/release/libjpeg.pc.in b/release/libjpeg.pc.in
index 40795f7..74fb7fc 100644
--- a/release/libjpeg.pc.in
+++ b/release/libjpeg.pc.in
@@ -1,10 +1,10 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=@CMAKE_INSTALL_PREFIX@
+libdir=@CMAKE_INSTALL_FULL_LIBDIR@
+includedir=@CMAKE_INSTALL_FULL_INCLUDEDIR@
 
 Name: libjpeg
 Description: A SIMD-accelerated JPEG codec that provides the libjpeg API
-Version: @PACKAGE_VERSION@
+Version: @VERSION@
 Libs: -L${libdir} -ljpeg
 Cflags: -I${includedir}
diff --git a/release/libturbojpeg.pc.in b/release/libturbojpeg.pc.in
index 7d4b656..81a0063 100644
--- a/release/libturbojpeg.pc.in
+++ b/release/libturbojpeg.pc.in
@@ -1,10 +1,10 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=@CMAKE_INSTALL_PREFIX@
+libdir=@CMAKE_INSTALL_FULL_LIBDIR@
+includedir=@CMAKE_INSTALL_FULL_INCLUDEDIR@
 
 Name: libturbojpeg
 Description: A SIMD-accelerated JPEG codec that provides the TurboJPEG API
-Version: @PACKAGE_VERSION@
+Version: @VERSION@
 Libs: -L${libdir} -lturbojpeg
 Cflags: -I${includedir}
diff --git a/release/makecygwinpkg.in b/release/makecygwinpkg.in
index f303546..b7f353e 100755
--- a/release/makecygwinpkg.in
+++ b/release/makecygwinpkg.in
@@ -15,27 +15,51 @@ onexit()
 	fi
 }
 
-PACKAGE_NAME=@PKGNAME@
+safedirmove ()
+{
+	if [ "$1" = "$2" ]; then
+		return 0
+	fi
+	if [ "$1" = "" -o ! -d "$1" ]; then
+		echo safedirmove: source dir $1 is not valid
+		return 1
+	fi
+	if [ "$2" = "" -o -e "$2" ]; then
+		echo safedirmove: dest dir $2 is not valid
+		return 1
+	fi
+	if [ "$3" = "" -o -e "$3" ]; then
+		echo safedirmove: tmp dir $3 is not valid
+		return 1
+	fi
+	mkdir -p $3
+	mv $1/* $3/
+	rmdir $1
+	mkdir -p $2
+	mv $3/* $2/
+	rmdir $3
+	return 0
+}
+
+PKGNAME=@PKGNAME@
 VERSION=@VERSION@
 BUILD=@BUILD@
-SRCDIR=@abs_top_srcdir@
 
-PREFIX=%{__prefix}
-DOCDIR=%{__docdir}
-LIBDIR=%{__libdir}
+PREFIX=@CMAKE_INSTALL_PREFIX@
+DOCDIR=@CMAKE_INSTALL_FULL_DOCDIR@
+LIBDIR=@CMAKE_INSTALL_FULL_LIBDIR@
 
 umask 022
-rm -f $PACKAGE_NAME-$VERSION-$BUILD.tar.bz2
+rm -f $PKGNAME-$VERSION-$BUILD.tar.bz2
 TMPDIR=`mktemp -d /tmp/ljtbuild.XXXXXX`
 __PWD=`pwd`
-make install DESTDIR=$TMPDIR/pkg docdir=/usr/share/doc/$PACKAGE_NAME-$VERSION \
-	exampledir=/usr/share/doc/$PACKAGE_NAME-$VERSION
-rm $TMPDIR/pkg$LIBDIR/*.la
-if [ "$PREFIX" = "/opt/libjpeg-turbo" -a "$DOCDIR" = "/opt/libjpeg-turbo/doc" ]; then
-	ln -fs /usr/share/doc/$PACKAGE_NAME-$VERSION $TMPDIR/pkg$DOCDIR
+make install DESTDIR=$TMPDIR/pkg
+if [ "$PREFIX" = "@CMAKE_INSTALL_DEFAULT_PREFIX@" -a "$DOCDIR" = "@CMAKE_INSTALL_DEFAULT_PREFIX@/doc" ]; then
+	safedirmove $TMPDIR/pkg$DOCDIR $TMPDIR/pkg/usr/share/doc/$PKGNAME-$VERSION $TMPDIR/__tmpdoc
+	ln -fs /usr/share/doc/$PKGNAME-$VERSION $TMPDIR/pkg$DOCDIR
 fi
 cd $TMPDIR/pkg
-tar cfj ../$PACKAGE_NAME-$VERSION-$BUILD.tar.bz2 *
+tar cfj ../$PKGNAME-$VERSION-$BUILD.tar.bz2 *
 cd $__PWD
 mv $TMPDIR/*.tar.bz2 .
 
diff --git a/release/makedpkg.in b/release/makedpkg.in
index 80cc89b..77836dd 100644
--- a/release/makedpkg.in
+++ b/release/makedpkg.in
@@ -21,56 +21,89 @@ uid()
 	id | cut -f2 -d = | cut -f1 -d \(;
 }
 
+safedirmove ()
+{
+	if [ "$1" = "$2" ]; then
+		return 0
+	fi
+	if [ "$1" = "" -o ! -d "$1" ]; then
+		echo safedirmove: source dir $1 is not valid
+		return 1
+	fi
+	if [ "$2" = "" -o -e "$2" ]; then
+		echo safedirmove: dest dir $2 is not valid
+		return 1
+	fi
+	if [ "$3" = "" -o -e "$3" ]; then
+		echo safedirmove: tmp dir $3 is not valid
+		return 1
+	fi
+	mkdir -p $3
+	mv $1/* $3/
+	rmdir $1
+	mkdir -p $2
+	mv $3/* $2/
+	rmdir $3
+	return 0
+}
+
 makedeb()
 {
 	SUPPLEMENT=$1
-	DIRNAME=$PACKAGE_NAME
+	DIRNAME=$PKGNAME
 
 	if [ $SUPPLEMENT = 1 ]; then
-		PACKAGE_NAME=$PACKAGE_NAME\32
+		PKGNAME=$PKGNAME\32
 		DEBARCH=amd64
 	fi
 
 	umask 022
-	rm -f $PACKAGE_NAME\_$VERSION\_$DEBARCH.deb
-	TMPDIR=`mktemp -d /tmp/$PACKAGE_NAME-build.XXXXXX`
+	rm -f $PKGNAME\_$VERSION\_$DEBARCH.deb
+	TMPDIR=`mktemp -d /tmp/$PKGNAME-build.XXXXXX`
 	mkdir $TMPDIR/DEBIAN
 
 	if [ $SUPPLEMENT = 1 ]; then
-		make install DESTDIR=$TMPDIR bindir=/dummy/bin datadir=/dummy/data \
-			docdir=/dummy/doc includedir=/dummy/include mandir=/dummy/man
-		rm -f $TMPDIR$LIBDIR/*.la
-		rm -rf $TMPDIR/dummy
+		make install DESTDIR=$TMPDIR
+		rm -rf $TMPDIR$BINDIR
+		if [ "$DATAROOTDIR" != "$PREFIX" ]; then
+			rm -rf $TMPDIR$DATAROOTDIR
+		fi
+		if [ "$JAVADIR" != "" ]; then
+			rm -rf $TMPDIR$JAVADIR
+		fi
+		rm -rf $TMPDIR$DOCDIR
+		rm -rf $TMPDIR$INCLUDEDIR
+		rm -rf $TMPDIR$MANDIR
 	else
-		make install DESTDIR=$TMPDIR docdir=/usr/share/doc/$DIRNAME-$VERSION \
-			exampledir=/usr/share/doc/$DIRNAME-$VERSION
-		rm -f $TMPDIR$LIBDIR/*.la
-		if [ "$PREFIX" = "/opt/libjpeg-turbo" -a "$DOCDIR" = "/opt/libjpeg-turbo/doc" ]; then
+		make install DESTDIR=$TMPDIR
+		if [ "$PREFIX" = "@CMAKE_INSTALL_DEFAULT_PREFIX@" -a "$DOCDIR" = "@CMAKE_INSTALL_DEFAULT_PREFIX@/doc" ]; then
+			safedirmove $TMPDIR/$DOCDIR $TMPDIR/usr/share/doc/$PKGNAME-$VERSION $TMPDIR/__tmpdoc
 			ln -fs /usr/share/doc/$DIRNAME-$VERSION $TMPDIR$DOCDIR
 		fi
 	fi
 
 	SIZE=`du -s $TMPDIR | cut -f1`
-	(cat $SRCDIR/release/deb-control.tmpl | sed s/{__PKGNAME}/$PACKAGE_NAME/g \
-		| sed s/{__VERSION}/$VERSION/g | sed s/{__BUILD}/$BUILD/g \
+	(cat pkgscripts/deb-control | sed s/{__PKGNAME}/$PKGNAME/g \
 		| sed s/{__ARCH}/$DEBARCH/g | sed s/{__SIZE}/$SIZE/g \
 		> $TMPDIR/DEBIAN/control)
 
-
 	/sbin/ldconfig -n $TMPDIR$LIBDIR
 
 	$SUDO chown -Rh root:root $TMPDIR/*
-	dpkg -b $TMPDIR $PACKAGE_NAME\_$VERSION\_$DEBARCH.deb
+	dpkg -b $TMPDIR $PKGNAME\_$VERSION\_$DEBARCH.deb
 }
 
-PACKAGE_NAME=@PKGNAME@
+PKGNAME=@PKGNAME@
 VERSION=@VERSION@
-BUILD=@BUILD@
 DEBARCH=@DEBARCH@
-SRCDIR=@abs_top_srcdir@
-PREFIX=%{__prefix}
-DOCDIR=%{__docdir}
-LIBDIR=%{__libdir}
+PREFIX=@CMAKE_INSTALL_PREFIX@
+BINDIR=@CMAKE_INSTALL_FULL_BINDIR@
+DATAROOTDIR=@CMAKE_INSTALL_FULL_DATAROOTDIR@
+DOCDIR=@CMAKE_INSTALL_FULL_DOCDIR@
+INCLUDEDIR=@CMAKE_INSTALL_FULL_INCLUDEDIR@
+JAVADIR=@CMAKE_INSTALL_FULL_JAVADIR@
+LIBDIR=@CMAKE_INSTALL_FULL_LIBDIR@
+MANDIR=@CMAKE_INSTALL_FULL_MANDIR@
 
 if [ ! `uid` -eq 0 ]; then
 	SUDO=sudo
diff --git a/release/makemacpkg.in b/release/makemacpkg.in
index 7163757..b0a2e23 100644
--- a/release/makemacpkg.in
+++ b/release/makemacpkg.in
@@ -15,76 +15,63 @@ onexit()
 	fi
 }
 
+safedirmove ()
+{
+	if [ "$1" = "$2" ]; then
+		return 0
+	fi
+	if [ "$1" = "" -o ! -d "$1" ]; then
+		echo safedirmove: source dir $1 is not valid
+		return 1
+	fi
+	if [ "$2" = "" -o -e "$2" ]; then
+		echo safedirmove: dest dir $2 is not valid
+		return 1
+	fi
+	if [ "$3" = "" -o -e "$3" ]; then
+		echo safedirmove: tmp dir $3 is not valid
+		return 1
+	fi
+	mkdir -p $3
+	mv $1/* $3/
+	rmdir $1
+	mkdir -p $2
+	mv $3/* $2/
+	rmdir $3
+	return 0
+}
+
 usage()
 {
-	echo "$0 [-build32 [32-bit build dir]] [-buildarmv6 [ARMv6 build dir]] [-buildarmv7 [ARMv7 build dir]] [-buildarmv7s [ARMv7s build dir] [-buildarmv8 [ARMv8 build dir]] [-lipo [path to lipo]]"
+	echo "$0 [universal] [-lipo [path to lipo]]"
 	exit 1
 }
 
-PACKAGE_NAME=@PKGNAME@
+UNIVERSAL=0
+
+PKGNAME=@PKGNAME@
 VERSION=@VERSION@
 BUILD=@BUILD@
-SRCDIR=@abs_top_srcdir@
-BUILDDIR32=@abs_top_srcdir@/osxx86
-BUILD32=0
-BUILDDIRARMV6=@abs_top_srcdir@/iosarmv6
-BUILDARMV6=0
-BUILDDIRARMV7=@abs_top_srcdir@/iosarmv7
-BUILDARMV7=0
-BUILDDIRARMV7S=@abs_top_srcdir@/iosarmv7s
-BUILDARMV7S=0
-BUILDDIRARMV8=@abs_top_srcdir@/iosarmv8
-BUILDARMV8=0
+SRCDIR=@CMAKE_CURRENT_SOURCE_DIR@
+BUILDDIR32=@OSX_32BIT_BUILD@
+BUILDDIRARMV7=@IOS_ARMV7_BUILD@
+BUILDDIRARMV7S=@IOS_ARMV7S_BUILD@
+BUILDDIRARMV8=@IOS_ARMV8_BUILD@
 WITH_JAVA=@WITH_JAVA@
 LIPO=lipo
 
-PREFIX=%{__prefix}
-BINDIR=%{__bindir}
-DOCDIR=%{__docdir}
-LIBDIR=%{__libdir}
+PREFIX=@CMAKE_INSTALL_PREFIX@
+BINDIR=@CMAKE_INSTALL_FULL_BINDIR@
+DOCDIR=@CMAKE_INSTALL_FULL_DOCDIR@
+LIBDIR=@CMAKE_INSTALL_FULL_LIBDIR@
+
+LIBJPEG_DSO_NAME=libjpeg.@SO_MAJOR_VERSION@.@SO_AGE@.@SO_MINOR_VERSION@.dylib
+TURBOJPEG_DSO_NAME=libturbojpeg.@TURBOJPEG_SO_VERSION@.dylib
 
 while [ $# -gt 0 ]; do
 	case $1 in
-	-h*)             usage 0                   ;;
-	-build32)
-		BUILD32=1
-		if [ $# -gt 1 ]; then
-			if [[ ! "$2" =~ -.* ]]; then
-				BUILDDIR32=$2;  shift
-			fi
-		fi
-		;;
-	-buildarmv6)
-		BUILDARMV6=1
-		if [ $# -gt 1 ]; then
-			if [[ ! "$2" =~ -.* ]]; then
-				BUILDDIRARMV6=$2;  shift
-			fi
-		fi
-		;;
-	-buildarmv7)
-		BUILDARMV7=1
-		if [ $# -gt 1 ]; then
-			if [[ ! "$2" =~ -.* ]]; then
-				BUILDDIRARMV7=$2;  shift
-			fi
-		fi
-		;;
-	-buildarmv7s)
-		BUILDARMV7S=1
-		if [ $# -gt 1 ]; then
-			if [[ ! "$2" =~ -.* ]]; then
-				BUILDDIRARMV7S=$2;  shift
-			fi
-		fi
-		;;
-	-buildarmv8)
-		BUILDARMV8=1
-		if [ $# -gt 1 ]; then
-			if [[ ! "$2" =~ -.* ]]; then
-				BUILDDIRARMV8=$2;  shift
-			fi
-		fi
+	-h*)
+		usage 0
 		;;
 	-lipo)
 		if [ $# -gt 1 ]; then
@@ -93,27 +80,31 @@ while [ $# -gt 0 ]; do
 			fi
 		fi
 		;;
+	universal)
+		UNIVERSAL=1
+		;;
 	esac
 	shift
 done
 
-if [ -f $PACKAGE_NAME-$VERSION.dmg ]; then
-	rm -f $PACKAGE_NAME-$VERSION.dmg
+if [ -f $PKGNAME-$VERSION.dmg ]; then
+	rm -f $PKGNAME-$VERSION.dmg
 fi
 
 umask 022
-TMPDIR=`mktemp -d /tmp/$PACKAGE_NAME-build.XXXXXX`
+TMPDIR=`mktemp -d /tmp/$PKGNAME-build.XXXXXX`
 PKGROOT=$TMPDIR/pkg/Package_Root
 mkdir -p $PKGROOT
-make install DESTDIR=$PKGROOT docdir=/Library/Documentation/$PACKAGE_NAME \
-	exampledir=/Library/Documentation/$PACKAGE_NAME
-rm -f $PKGROOT$LIBDIR/*.la
 
-if [ "$PREFIX" = "/opt/libjpeg-turbo" -a "$DOCDIR" = "/opt/libjpeg-turbo/doc" ]; then
-	ln -fs /Library/Documentation/$PACKAGE_NAME $PKGROOT$DOCDIR
+make install DESTDIR=$PKGROOT
+
+if [ "$PREFIX" = "@CMAKE_INSTALL_DEFAULT_PREFIX@" -a "$DOCDIR" = "@CMAKE_INSTALL_DEFAULT_PREFIX@/doc" ]; then
+	mkdir -p $PKGROOT/Library/Documentation
+	safedirmove $PKGROOT$DOCDIR $PKGROOT/Library/Documentation/$PKGNAME $TMPDIR/__tmpdoc
+	ln -fs /Library/Documentation/$PKGNAME $PKGROOT$DOCDIR
 fi
 
-if [ $BUILD32 = 1 ]; then
+if [ $UNIVERSAL = 1 -a "$BUILDDIR32" != "" ]; then
 	if [ ! -d $BUILDDIR32 ]; then
 		echo ERROR: 32-bit build directory $BUILDDIR32 does not exist
 		exit 1
@@ -126,27 +117,18 @@ if [ $BUILD32 = 1 ]; then
 	pushd $BUILDDIR32
 	make install DESTDIR=$TMPDIR/dist.x86
 	popd
-	if [ ! -h $TMPDIR/dist.x86/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			-arch i386 $TMPDIR/dist.x86/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-arch x86_64 $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib
-	elif [ ! -h $TMPDIR/dist.x86/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			-arch i386 $TMPDIR/dist.x86/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-arch x86_64 $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib
-	fi
+	$LIPO -create \
+		-arch i386 $TMPDIR/dist.x86/$LIBDIR/$LIBJPEG_DSO_NAME \
+		-arch x86_64 $PKGROOT/$LIBDIR/$LIBJPEG_DSO_NAME \
+		-output $PKGROOT/$LIBDIR/$LIBJPEG_DSO_NAME
 	$LIPO -create \
 		-arch i386 $TMPDIR/dist.x86/$LIBDIR/libjpeg.a \
 		-arch x86_64 $PKGROOT/$LIBDIR/libjpeg.a \
 		-output $PKGROOT/$LIBDIR/libjpeg.a
 	$LIPO -create \
-		-arch i386 $TMPDIR/dist.x86/$LIBDIR/libturbojpeg.0.dylib \
-		-arch x86_64 $PKGROOT/$LIBDIR/libturbojpeg.0.dylib \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.0.dylib
+		-arch i386 $TMPDIR/dist.x86/$LIBDIR/$TURBOJPEG_DSO_NAME \
+		-arch x86_64 $PKGROOT/$LIBDIR/$TURBOJPEG_DSO_NAME \
+		-output $PKGROOT/$LIBDIR/$TURBOJPEG_DSO_NAME
 	$LIPO -create \
 		-arch i386 $TMPDIR/dist.x86/$LIBDIR/libturbojpeg.a \
 		-arch x86_64 $PKGROOT/$LIBDIR/libturbojpeg.a \
@@ -175,272 +157,88 @@ if [ $BUILD32 = 1 ]; then
 		-arch i386 $TMPDIR/dist.x86/$BINDIR/wrjpgcom \
 		-arch x86_64 $PKGROOT/$BINDIR/wrjpgcom \
 		-output $PKGROOT/$BINDIR/wrjpgcom
-
 fi
 
-if [ $BUILDARMV6 = 1 ]; then
-	if [ ! -d $BUILDDIRARMV6 ]; then
-		echo ERROR: ARMv6 build directory $BUILDDIRARMV6 does not exist
-		exit 1
-	fi
-	if [ ! -f $BUILDDIRARMV6/Makefile ]; then
-		echo ERROR: ARMv6 build directory $BUILDDIRARMV6 is not configured
-		exit 1
-	fi
-	mkdir -p $TMPDIR/dist.armv6
-	pushd $BUILDDIRARMV6
-	make install DESTDIR=$TMPDIR/dist.armv6
-	popd
-	if [ ! -h $TMPDIR/dist.armv6/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-arch arm $TMPDIR/dist.armv6/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib
-	elif [ ! -h $TMPDIR/dist.armv6/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-arch arm $TMPDIR/dist.armv6/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib
-	fi
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libjpeg.a \
-		-arch arm $TMPDIR/dist.armv6/$LIBDIR/libjpeg.a \
-		-output $PKGROOT/$LIBDIR/libjpeg.a
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libturbojpeg.0.dylib \
-		-arch arm $TMPDIR/dist.armv6/$LIBDIR/libturbojpeg.0.dylib \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.0.dylib
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libturbojpeg.a \
-		-arch arm $TMPDIR/dist.armv6/$LIBDIR/libturbojpeg.a \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.a
-	$LIPO -create \
-		$PKGROOT/$BINDIR/cjpeg \
-		-arch arm $TMPDIR/dist.armv6/$BINDIR/cjpeg \
-		-output $PKGROOT/$BINDIR/cjpeg
-	$LIPO -create \
-		$PKGROOT/$BINDIR/djpeg \
-		-arch arm $TMPDIR/dist.armv6/$BINDIR/djpeg \
-		-output $PKGROOT/$BINDIR/djpeg
-	$LIPO -create \
-		$PKGROOT/$BINDIR/jpegtran \
-		-arch arm $TMPDIR/dist.armv6/$BINDIR/jpegtran \
-		-output $PKGROOT/$BINDIR/jpegtran
-	$LIPO -create \
-		$PKGROOT/$BINDIR/tjbench \
-		-arch arm $TMPDIR/dist.armv6/$BINDIR/tjbench \
-		-output $PKGROOT/$BINDIR/tjbench
-	$LIPO -create \
-		$PKGROOT/$BINDIR/rdjpgcom \
-		-arch arm $TMPDIR/dist.armv6/$BINDIR/rdjpgcom \
-		-output $PKGROOT/$BINDIR/rdjpgcom
-	$LIPO -create \
-		$PKGROOT/$BINDIR/wrjpgcom \
-		-arch arm $TMPDIR/dist.armv6/$BINDIR/wrjpgcom \
-		-output $PKGROOT/$BINDIR/wrjpgcom
-fi
+install_ios()
+{
+	BUILDDIR=$1
+	ARCHNAME=$2
+	DIRNAME=$3
+	LIPOARCH=$4
 
-if [ $BUILDARMV7 = 1 ]; then
-	if [ ! -d $BUILDDIRARMV7 ]; then
-		echo ERROR: ARMv7 build directory $BUILDDIRARMV7 does not exist
+	if [ ! -d $BUILDDIR ]; then
+		echo ERROR: $ARCHNAME build directory $BUILDDIR does not exist
 		exit 1
 	fi
-	if [ ! -f $BUILDDIRARMV7/Makefile ]; then
-		echo ERROR: ARMv7 build directory $BUILDDIRARMV7 is not configured
+	if [ ! -f $BUILDDIR/Makefile ]; then
+		echo ERROR: $ARCHNAME build directory $BUILDDIR is not configured
 		exit 1
 	fi
-	mkdir -p $TMPDIR/dist.armv7
-	pushd $BUILDDIRARMV7
-	make install DESTDIR=$TMPDIR/dist.armv7
+	mkdir -p $TMPDIR/dist.$DIRNAME
+	pushd $BUILDDIR
+	make install DESTDIR=$TMPDIR/dist.$DIRNAME
 	popd
-	if [ ! -h $TMPDIR/dist.armv7/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-arch arm $TMPDIR/dist.armv7/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib
-	elif [ ! -h $TMPDIR/dist.armv7/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-arch arm $TMPDIR/dist.armv7/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib
-	fi
+	$LIPO -create \
+		$PKGROOT/$LIBDIR/$LIBJPEG_DSO_NAME \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$LIBDIR/$LIBJPEG_DSO_NAME \
+		-output $PKGROOT/$LIBDIR/$LIBJPEG_DSO_NAME
 	$LIPO -create \
 		$PKGROOT/$LIBDIR/libjpeg.a \
-		-arch arm $TMPDIR/dist.armv7/$LIBDIR/libjpeg.a \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$LIBDIR/libjpeg.a \
 		-output $PKGROOT/$LIBDIR/libjpeg.a
 	$LIPO -create \
-		$PKGROOT/$LIBDIR/libturbojpeg.0.dylib \
-		-arch arm $TMPDIR/dist.armv7/$LIBDIR/libturbojpeg.0.dylib \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.0.dylib
+		$PKGROOT/$LIBDIR/$TURBOJPEG_DSO_NAME \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$LIBDIR/$TURBOJPEG_DSO_NAME \
+		-output $PKGROOT/$LIBDIR/$TURBOJPEG_DSO_NAME
 	$LIPO -create \
 		$PKGROOT/$LIBDIR/libturbojpeg.a \
-		-arch arm $TMPDIR/dist.armv7/$LIBDIR/libturbojpeg.a \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$LIBDIR/libturbojpeg.a \
 		-output $PKGROOT/$LIBDIR/libturbojpeg.a
 	$LIPO -create \
 		$PKGROOT/$BINDIR/cjpeg \
-		-arch arm $TMPDIR/dist.armv7/$BINDIR/cjpeg \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$BINDIR/cjpeg \
 		-output $PKGROOT/$BINDIR/cjpeg
 	$LIPO -create \
 		$PKGROOT/$BINDIR/djpeg \
-		-arch arm $TMPDIR/dist.armv7/$BINDIR/djpeg \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$BINDIR/djpeg \
 		-output $PKGROOT/$BINDIR/djpeg
 	$LIPO -create \
 		$PKGROOT/$BINDIR/jpegtran \
-		-arch arm $TMPDIR/dist.armv7/$BINDIR/jpegtran \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$BINDIR/jpegtran \
 		-output $PKGROOT/$BINDIR/jpegtran
 	$LIPO -create \
 		$PKGROOT/$BINDIR/tjbench \
-		-arch arm $TMPDIR/dist.armv7/$BINDIR/tjbench \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$BINDIR/tjbench \
 		-output $PKGROOT/$BINDIR/tjbench
 	$LIPO -create \
 		$PKGROOT/$BINDIR/rdjpgcom \
-		-arch arm $TMPDIR/dist.armv7/$BINDIR/rdjpgcom \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$BINDIR/rdjpgcom \
 		-output $PKGROOT/$BINDIR/rdjpgcom
 	$LIPO -create \
 		$PKGROOT/$BINDIR/wrjpgcom \
-		-arch arm $TMPDIR/dist.armv7/$BINDIR/wrjpgcom \
+		-arch $LIPOARCH $TMPDIR/dist.$DIRNAME/$BINDIR/wrjpgcom \
 		-output $PKGROOT/$BINDIR/wrjpgcom
+}
+
+if [ $UNIVERSAL = 1 -a "$BUILDDIRARMV7" != "" ]; then
+	install_ios $BUILDDIRARMV7 ARMv7 armv7 arm
 fi
 
-if [ $BUILDARMV7S = 1 ]; then
-	if [ ! -d $BUILDDIRARMV7S ]; then
-		echo ERROR: ARMv7s build directory $BUILDDIRARMV7S does not exist
-		exit 1
-	fi
-	if [ ! -f $BUILDDIRARMV7S/Makefile ]; then
-		echo ERROR: ARMv7s build directory $BUILDDIRARMV7S is not configured
-		exit 1
-	fi
-	mkdir -p $TMPDIR/dist.armv7s
-	pushd $BUILDDIRARMV7S
-	make install DESTDIR=$TMPDIR/dist.armv7s
-	popd
-	if [ ! -h $TMPDIR/dist.armv7s/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-arch arm $TMPDIR/dist.armv7s/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib
-	elif [ ! -h $TMPDIR/dist.armv7s/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-arch arm $TMPDIR/dist.armv7s/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib
-	fi
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libjpeg.a \
-		-arch arm $TMPDIR/dist.armv7s/$LIBDIR/libjpeg.a \
-		-output $PKGROOT/$LIBDIR/libjpeg.a
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libturbojpeg.0.dylib \
-		-arch arm $TMPDIR/dist.armv7s/$LIBDIR/libturbojpeg.0.dylib \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.0.dylib
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libturbojpeg.a \
-		-arch arm $TMPDIR/dist.armv7s/$LIBDIR/libturbojpeg.a \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.a
-	$LIPO -create \
-		$PKGROOT/$BINDIR/cjpeg \
-		-arch arm $TMPDIR/dist.armv7s/$BINDIR/cjpeg \
-		-output $PKGROOT/$BINDIR/cjpeg
-	$LIPO -create \
-		$PKGROOT/$BINDIR/djpeg \
-		-arch arm $TMPDIR/dist.armv7s/$BINDIR/djpeg \
-		-output $PKGROOT/$BINDIR/djpeg
-	$LIPO -create \
-		$PKGROOT/$BINDIR/jpegtran \
-		-arch arm $TMPDIR/dist.armv7s/$BINDIR/jpegtran \
-		-output $PKGROOT/$BINDIR/jpegtran
-	$LIPO -create \
-		$PKGROOT/$BINDIR/tjbench \
-		-arch arm $TMPDIR/dist.armv7s/$BINDIR/tjbench \
-		-output $PKGROOT/$BINDIR/tjbench
-	$LIPO -create \
-		$PKGROOT/$BINDIR/rdjpgcom \
-		-arch arm $TMPDIR/dist.armv7s/$BINDIR/rdjpgcom \
-		-output $PKGROOT/$BINDIR/rdjpgcom
-	$LIPO -create \
-		$PKGROOT/$BINDIR/wrjpgcom \
-		-arch arm $TMPDIR/dist.armv7s/$BINDIR/wrjpgcom \
-		-output $PKGROOT/$BINDIR/wrjpgcom
+if [ $UNIVERSAL = 1 -a "$BUILDDIRARMV7S" != "" ]; then
+	install_ios $BUILDDIRARMV7S ARMv7s armv7s arm
 fi
 
-if [ $BUILDARMV8 = 1 ]; then
-	if [ ! -d $BUILDDIRARMV8 ]; then
-		echo ERROR: ARMv8 build directory $BUILDDIRARMV8 does not exist
-		exit 1
-	fi
-	if [ ! -f $BUILDDIRARMV8/Makefile ]; then
-		echo ERROR: ARMv8 build directory $BUILDDIRARMV8 is not configured
-		exit 1
-	fi
-	mkdir -p $TMPDIR/dist.armv8
-	pushd $BUILDDIRARMV8
-	make install DESTDIR=$TMPDIR/dist.armv8
-	popd
-	if [ ! -h $TMPDIR/dist.armv8/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-arch arm64 $TMPDIR/dist.armv8/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib
-	elif [ ! -h $TMPDIR/dist.armv8/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib -a \
-		! -h $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib ]; then
-		$LIPO -create \
-			$PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-arch arm64 $TMPDIR/dist.armv8/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib \
-			-output $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.0.@SO_MINOR_VERSION@.dylib
-	fi
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libjpeg.a \
-		-arch arm64 $TMPDIR/dist.armv8/$LIBDIR/libjpeg.a \
-		-output $PKGROOT/$LIBDIR/libjpeg.a
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libturbojpeg.0.dylib \
-		-arch arm64 $TMPDIR/dist.armv8/$LIBDIR/libturbojpeg.0.dylib \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.0.dylib
-	$LIPO -create \
-		$PKGROOT/$LIBDIR/libturbojpeg.a \
-		-arch arm64 $TMPDIR/dist.armv8/$LIBDIR/libturbojpeg.a \
-		-output $PKGROOT/$LIBDIR/libturbojpeg.a
-	$LIPO -create \
-		$PKGROOT/$BINDIR/cjpeg \
-		-arch arm64 $TMPDIR/dist.armv8/$BINDIR/cjpeg \
-		-output $PKGROOT/$BINDIR/cjpeg
-	$LIPO -create \
-		$PKGROOT/$BINDIR/djpeg \
-		-arch arm64 $TMPDIR/dist.armv8/$BINDIR/djpeg \
-		-output $PKGROOT/$BINDIR/djpeg
-	$LIPO -create \
-		$PKGROOT/$BINDIR/jpegtran \
-		-arch arm64 $TMPDIR/dist.armv8/$BINDIR/jpegtran \
-		-output $PKGROOT/$BINDIR/jpegtran
-	$LIPO -create \
-		$PKGROOT/$BINDIR/tjbench \
-		-arch arm64 $TMPDIR/dist.armv8/$BINDIR/tjbench \
-		-output $PKGROOT/$BINDIR/tjbench
-	$LIPO -create \
-		$PKGROOT/$BINDIR/rdjpgcom \
-		-arch arm64 $TMPDIR/dist.armv8/$BINDIR/rdjpgcom \
-		-output $PKGROOT/$BINDIR/rdjpgcom
-	$LIPO -create \
-		$PKGROOT/$BINDIR/wrjpgcom \
-		-arch arm64 $TMPDIR/dist.armv8/$BINDIR/wrjpgcom \
-		-output $PKGROOT/$BINDIR/wrjpgcom
+if [ $UNIVERSAL = 1 -a "BUILDDIRARMV8" != "" ]; then
+	install_ios $BUILDDIRARMV8 ARMv8 armv8 arm64
 fi
 
-install_name_tool -id $LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib $PKGROOT/$LIBDIR/libjpeg.@SO_MAJOR_VERSION@.dylib
-install_name_tool -id $LIBDIR/libturbojpeg.0.dylib $PKGROOT/$LIBDIR/libturbojpeg.0.dylib
+install_name_tool -id $LIBDIR/$LIBJPEG_DSO_NAME $PKGROOT/$LIBDIR/$LIBJPEG_DSO_NAME
+install_name_tool -id $LIBDIR/$TURBOJPEG_DSO_NAME $PKGROOT/$LIBDIR/$TURBOJPEG_DSO_NAME
 
 if [ $WITH_JAVA = 1 ]; then
-	ln -fs libturbojpeg.0.dylib $PKGROOT/$LIBDIR/libturbojpeg.jnilib
+	ln -fs $TURBOJPEG_DSO_NAME $PKGROOT/$LIBDIR/libturbojpeg.jnilib
 fi
-if [ "$PREFIX" = "/opt/libjpeg-turbo" -a "$LIBDIR" = "/opt/libjpeg-turbo/lib" ]; then
+if [ "$PREFIX" = "@CMAKE_INSTALL_DEFAULT_PREFIX@" -a "$LIBDIR" = "@CMAKE_INSTALL_DEFAULT_PREFIX@/lib" ]; then
 	if [ ! -h $PKGROOT/$PREFIX/lib32 ]; then
 		ln -fs lib $PKGROOT/$PREFIX/lib32
 	fi
@@ -458,13 +256,13 @@ find $PKGROOT -type f | while read file; do xattr -c $file; done
 cp $SRCDIR/release/License.rtf $SRCDIR/release/Welcome.rtf $SRCDIR/release/ReadMe.txt $TMPDIR/pkg/
 
 mkdir $TMPDIR/dmg
-pkgbuild --root $PKGROOT --version $VERSION.$BUILD \
-	--identifier com.libjpeg-turbo.libjpeg-turbo $TMPDIR/pkg/$PACKAGE_NAME.pkg
-productbuild --distribution $SRCDIR/release/Distribution.xml \
+pkgbuild --root $PKGROOT --version $VERSION.$BUILD --identifier @PKGID@ \
+	$TMPDIR/pkg/$PKGNAME.pkg
+productbuild --distribution pkgscripts/Distribution.xml \
 	--package-path $TMPDIR/pkg/ --resources $TMPDIR/pkg/ \
-	$TMPDIR/dmg/$PACKAGE_NAME.pkg
-hdiutil create -fs HFS+ -volname $PACKAGE_NAME-$VERSION \
-	-srcfolder "$TMPDIR/dmg" $TMPDIR/$PACKAGE_NAME-$VERSION.dmg
-cp $TMPDIR/$PACKAGE_NAME-$VERSION.dmg .
+	$TMPDIR/dmg/$PKGNAME.pkg
+hdiutil create -fs HFS+ -volname $PKGNAME-$VERSION \
+	-srcfolder "$TMPDIR/dmg" $TMPDIR/$PKGNAME-$VERSION.dmg
+cp $TMPDIR/$PKGNAME-$VERSION.dmg .
 
 exit
diff --git a/release/makerpm.in b/release/makerpm.in
new file mode 100644
index 0000000..fc3b1d4
--- /dev/null
+++ b/release/makerpm.in
@@ -0,0 +1,30 @@
+#!/bin/sh
+
+set -u
+set -e
+trap onexit INT
+trap onexit TERM
+trap onexit EXIT
+
+TMPDIR=
+
+onexit()
+{
+	if [ ! "$TMPDIR" = "" ]; then
+		rm -rf $TMPDIR
+	fi
+}
+
+if [ -f @PKGNAME@-@VERSION@.@RPMARCH@.rpm ]; then
+	rm -f @PKGNAME@-@VERSION@.@RPMARCH@.rpm
+fi
+
+umask 022
+TMPDIR=`mktemp -d /tmp/@CMAKE_PROJECT_NAME@-build.XXXXXX`
+
+mkdir -p $TMPDIR/RPMS
+ln -fs `pwd` $TMPDIR/BUILD
+rpmbuild -bb --define "_blddir $TMPDIR/buildroot" --define "_topdir $TMPDIR" \
+	--target @RPMARCH@ pkgscripts/rpm.spec; \
+cp $TMPDIR/RPMS/@RPMARCH@/@PKGNAME@-@VERSION@-@BUILD@.@RPMARCH@.rpm \
+	@PKGNAME@-@VERSION@.@RPMARCH@.rpm
diff --git a/release/makesrpm.in b/release/makesrpm.in
new file mode 100644
index 0000000..84c39d4
--- /dev/null
+++ b/release/makesrpm.in
@@ -0,0 +1,48 @@
+#!/bin/sh
+
+set -u
+set -e
+trap onexit INT
+trap onexit TERM
+trap onexit EXIT
+
+TMPDIR=
+
+onexit()
+{
+	if [ ! "$TMPDIR" = "" ]; then
+		rm -rf $TMPDIR
+	fi
+}
+
+PKGNAME=@PKGNAME@
+PROJECT=@CMAKE_PROJECT_NAME@
+VERSION=@VERSION@
+BUILD=@BUILD@
+
+if [ -f $PKGNAME-$VERSION.src.rpm ]; then
+	rm -f $PKGNAME-$VERSION.src.rpm
+fi
+
+umask 022
+TMPDIR=`mktemp -d /tmp/$PKGNAME-build.XXXXXX`
+
+mkdir -p $TMPDIR/RPMS
+mkdir -p $TMPDIR/SRPMS
+mkdir -p $TMPDIR/BUILD
+mkdir -p $TMPDIR/SOURCES
+mkdir -p $TMPDIR/SPECS
+
+if [ ! -f $PROJECT-$VERSION.tar.gz ]; then
+	echo "ERROR: $PROJECT-$VERSION.tar.gz does not exist."
+fi
+
+cp $PROJECT-$VERSION.tar.gz $TMPDIR/SOURCES/$PROJECT-$VERSION.tar.gz
+
+cat pkgscripts/rpm.spec | sed s/%{_blddir}/%{_tmppath}/g \
+	| sed s/#--\>//g > $TMPDIR/SPECS/$PKGNAME.spec
+
+rpmbuild -bs --define "_topdir $TMPDIR" $TMPDIR/SPECS/$PKGNAME.spec
+mv $TMPDIR/SRPMS/$PKGNAME-$VERSION-$BUILD.src.rpm $PKGNAME-$VERSION.src.rpm
+
+exit
diff --git a/release/maketarball.in b/release/maketarball.in
new file mode 100644
index 0000000..00a9c7e
--- /dev/null
+++ b/release/maketarball.in
@@ -0,0 +1,51 @@
+#!/bin/sh
+
+set -u
+set -e
+trap onexit INT
+trap onexit TERM
+trap onexit EXIT
+
+TMPDIR=
+SUDO=
+
+onexit()
+{
+	if [ ! "$TMPDIR" = "" ]; then
+		rm -rf $TMPDIR
+	fi
+}
+
+uid()
+{
+	id | cut -f2 -d = | cut -f1 -d \(;
+}
+
+PKGNAME=@PKGNAME@
+VERSION=@VERSION@
+ARCH=@CPU_TYPE@
+OS=@CMAKE_SYSTEM_NAME@
+PREFIX=@CMAKE_INSTALL_PREFIX@
+
+umask 022
+rm -f $PKGNAME-$VERSION-$OS-$ARCH.tar.bz2
+TMPDIR=`mktemp -d /tmp/$PKGNAME-build.XXXXXX`
+mkdir -p $TMPDIR/install
+
+make install DESTDIR=$TMPDIR/install
+echo tartest >$TMPDIR/tartest
+GNUTAR=0
+BSDTAR=0
+tar cf $TMPDIR/tartest.tar --owner=root --group=root -C $TMPDIR tartest >/dev/null 2>&1 && GNUTAR=1
+if [ "$GNUTAR" = "1" ]; then
+	tar cf - --owner=root --group=root -C $TMPDIR/install .$PREFIX | bzip2 -c >$PKGNAME-$VERSION-$OS-$ARCH.tar.bz2
+else
+	tar cf $TMPDIR/tartest.tar --uid 0 --gid 0 -C $TMPDIR tartest >/dev/null 2>&1 && BSDTAR=1
+	if [ "$BSDTAR" = "1" ]; then
+		tar cf - --uid=0 --gid=0 -C $TMPDIR/install .$PREFIX | bzip2 -c >$PKGNAME-$VERSION-$OS-$ARCH.tar.bz2
+	else
+		tar cf - -C $TMPDIR/install .$PREFIX | bzip2 -c >$PKGNAME-$VERSION-$OS-$ARCH.tar.bz2
+	fi
+fi
+
+exit
diff --git a/release/rpm.spec.in b/release/rpm.spec.in
new file mode 100644
index 0000000..36b0c51
--- /dev/null
+++ b/release/rpm.spec.in
@@ -0,0 +1,198 @@
+%define _prefix @CMAKE_INSTALL_PREFIX@
+%define _bindir @CMAKE_INSTALL_FULL_BINDIR@
+%define _datarootdir @CMAKE_INSTALL_FULL_DATAROOTDIR@
+%define _docdir %{_defaultdocdir}/%{name}-%{version}
+%define _includedir @CMAKE_INSTALL_FULL_INCLUDEDIR@
+%define _javadir @CMAKE_INSTALL_FULL_JAVADIR@
+%define _libdir @CMAKE_INSTALL_FULL_LIBDIR@
+%define _mandir @CMAKE_INSTALL_FULL_MANDIR@
+%define _enable_static @ENABLE_STATIC@
+%define _enable_shared @ENABLE_SHARED@
+%define _with_turbojpeg @WITH_TURBOJPEG@
+%define _with_java @WITH_JAVA@
+
+Summary: A SIMD-accelerated JPEG codec that provides both the libjpeg and TurboJPEG APIs
+Name: @PKGNAME@
+Version: @VERSION@
+Vendor: @PKGVENDOR@
+URL: @PKGURL@
+Group: System Environment/Libraries
+#-->Source0: http://prdownloads.sourceforge.net/@CMAKE_PROJECT_NAME@/@CMAKE_PROJECT_NAME@-%{version}.tar.gz
+Release: @BUILD@
+License: BSD-style
+BuildRoot: %{_blddir}/%{name}-buildroot-%{version}-%{release}
+Prereq: /sbin/ldconfig
+%ifarch x86_64
+Provides: %{name} = %{version}-%{release}, @CMAKE_PROJECT_NAME@ = %{version}-%{release}, libturbojpeg.so()(64bit)
+%else
+Provides: %{name} = %{version}-%{release}, @CMAKE_PROJECT_NAME@ = %{version}-%{release}, libturbojpeg.so
+%endif
+
+%description
+libjpeg-turbo is a JPEG image codec that uses SIMD instructions (MMX, SSE2,
+AVX2, NEON, AltiVec) to accelerate baseline JPEG compression and decompression
+on x86, x86-64, ARM, and PowerPC systems.  On such systems, libjpeg-turbo is
+generally 2-6x as fast as libjpeg, all else being equal.  On other types of
+systems, libjpeg-turbo can still outperform libjpeg by a significant amount, by
+virtue of its highly-optimized Huffman coding routines.  In many cases, the
+performance of libjpeg-turbo rivals that of proprietary high-speed JPEG codecs.
+
+libjpeg-turbo implements both the traditional libjpeg API as well as the less
+powerful but more straightforward TurboJPEG API.  libjpeg-turbo also features
+colorspace extensions that allow it to compress from/decompress to 32-bit and
+big-endian pixel buffers (RGBX, XBGR, etc.), as well as a full-featured Java
+interface.
+
+libjpeg-turbo was originally based on libjpeg/SIMD, an MMX-accelerated
+derivative of libjpeg v6b developed by Miyasaka Masaru.  The TigerVNC and
+VirtualGL projects made numerous enhancements to the codec in 2009, and in
+early 2010, libjpeg-turbo spun off into an independent project, with the goal
+of making high-speed JPEG compression/decompression technology available to a
+broader range of users and developers.
+
+#-->%prep
+#-->%setup -q -n @CMAKE_PROJECT_NAME@-%{version}
+
+#-->%build
+#-->cmake -G"Unix Makefiles" -DCMAKE_BUILD_TYPE=@CMAKE_BUILD_TYPE@ \
+#-->  -DBUILD=%{release} \
+#-->  -DCMAKE_INSTALL_BINDIR=%{_bindir} \
+#-->  -DCMAKE_INSTALL_DATAROOTDIR=%{_datarootdir} \
+#-->  -DCMAKE_INSTALL_DOCDIR=%{_docdir} \
+#-->  -DCMAKE_INSTALL_INCLUDEDIR=%{_includedir} \
+#-->  -DCMAKE_INSTALL_JAVADIR=%{_javadir} \
+#-->  -DCMAKE_INSTALL_LIBDIR=%{_libdir} \
+#-->  -DCMAKE_INSTALL_MANDIR=%{_mandir} \
+#-->  -DCMAKE_INSTALL_PREFIX=%{_prefix} \
+#-->  -DCMAKE_POSITION_INDEPENDENT_CODE=@CMAKE_POSITION_INDEPENDENT_CODE@ \
+#-->  -DENABLE_SHARED=@ENABLE_SHARED@ -DENABLE_STATIC=@ENABLE_STATIC@ \
+#-->  -DSO_MAJOR_VERSION=@SO_MAJOR_VERSION@ \
+#-->  -DSO_MINOR_VERSION=@SO_MINOR_VERSION@ \
+#-->  -DJPEG_LIB_VERSION=@JPEG_LIB_VERSION@ \
+#-->  -DREQUIRE_SIMD=@REQUIRE_SIMD@ \
+#-->  -DWITH_12BIT=@WITH_12BIT@ -DWITH_ARITH_DEC=@WITH_ARITH_DEC@ \
+#-->  -DWITH_ARITH_ENC=@WITH_ARITH_ENC@ -DWITH_JAVA=@WITH_JAVA@ \
+#-->  -DWITH_JPEG7=@WITH_JPEG7@ -DWITH_JPEG8=@WITH_JPEG8@ \
+#-->  -DWITH_MEM_SRCDST=@WITH_MEM_SRCDST@ -DWITH_SIMD=@WITH_SIMD@ \
+#-->  -DWITH_TURBOJPEG=@WITH_TURBOJPEG@ .
+#-->make DESTDIR=$RPM_BUILD_ROOT
+
+%install
+
+rm -rf $RPM_BUILD_ROOT
+make install DESTDIR=$RPM_BUILD_ROOT
+/sbin/ldconfig -n $RPM_BUILD_ROOT%{_libdir}
+
+#-->%if 0
+
+# This is only needed to support in-tree RPM generation via 'make rpm'.  When
+# building from a SRPM, we control where things are installed via CMake
+# variables.
+
+safedirmove ()
+{
+	if [ "$1" = "$2" ]; then
+		return 0
+	fi
+	if [ "$1" = "" -o ! -d "$1" ]; then
+		echo safedirmove: source dir $1 is not valid
+		return 1
+	fi
+	if [ "$2" = "" -o -e "$2" ]; then
+		echo safedirmove: dest dir $2 is not valid
+		return 1
+	fi
+	if [ "$3" = "" -o -e "$3" ]; then
+		echo safedirmove: tmp dir $3 is not valid
+		return 1
+	fi
+	mkdir -p $3
+	mv $1/* $3/
+	rmdir $1
+	mkdir -p $2
+	mv $3/* $2/
+	rmdir $3
+	return 0
+}
+
+LJT_DOCDIR=@CMAKE_INSTALL_FULL_DOCDIR@
+if [ ! "$LJT_DOCDIR" = "%{_docdir}" ]; then
+	safedirmove $RPM_BUILD_ROOT/$LJT_DOCDIR $RPM_BUILD_ROOT/%{_docdir} $RPM_BUILD_ROOT/__tmpdoc
+fi
+
+#-->%endif
+
+LJT_DOCDIR=@CMAKE_INSTALL_FULL_DOCDIR@
+if [ "%{_prefix}" = "@CMAKE_INSTALL_DEFAULT_PREFIX@" -a "$LJT_DOCDIR" = "@CMAKE_INSTALL_DEFAULT_PREFIX@/doc" ]; then
+	ln -fs %{_docdir} $RPM_BUILD_ROOT/$LJT_DOCDIR
+fi
+
+%post -p /sbin/ldconfig
+
+%postun -p /sbin/ldconfig
+
+%clean
+rm -rf $RPM_BUILD_ROOT
+
+%files
+%defattr(-,root,root)
+%dir %{_docdir}
+%doc %{_docdir}/*
+%dir %{_prefix}
+%if "%{_prefix}" == "@CMAKE_INSTALL_DEFAULT_PREFIX@" && "%{_docdir}" != "%{_prefix}/doc"
+ %{_prefix}/doc
+%endif
+%dir %{_bindir}
+%{_bindir}/cjpeg
+%{_bindir}/djpeg
+%{_bindir}/jpegtran
+%if "%{_with_turbojpeg}" == "1"
+ %{_bindir}/tjbench
+%endif
+%{_bindir}/rdjpgcom
+%{_bindir}/wrjpgcom
+%dir %{_libdir}
+%if "%{_enable_shared}" == "1"
+ %{_libdir}/libjpeg.so.@SO_MAJOR_VERSION@.@SO_AGE@.@SO_MINOR_VERSION@
+ %{_libdir}/libjpeg.so.@SO_MAJOR_VERSION@
+ %{_libdir}/libjpeg.so
+%endif
+%if "%{_enable_static}" == "1"
+ %{_libdir}/libjpeg.a
+%endif
+%{_libdir}/pkgconfig
+%{_libdir}/pkgconfig/libjpeg.pc
+%if "%{_with_turbojpeg}" == "1"
+ %if "%{_enable_shared}" == "1" || "%{_with_java}" == "1"
+  %{_libdir}/libturbojpeg.so.@TURBOJPEG_SO_VERSION@
+  %{_libdir}/libturbojpeg.so.@TURBOJPEG_SO_MAJOR_VERSION@
+  %{_libdir}/libturbojpeg.so
+ %endif
+ %if "%{_enable_static}" == "1"
+  %{_libdir}/libturbojpeg.a
+ %endif
+ %{_libdir}/pkgconfig/libturbojpeg.pc
+%endif
+%dir %{_includedir}
+%{_includedir}/jconfig.h
+%{_includedir}/jerror.h
+%{_includedir}/jmorecfg.h
+%{_includedir}/jpeglib.h
+%if "%{_with_turbojpeg}" == "1"
+ %{_includedir}/turbojpeg.h
+%endif
+%dir %{_mandir}
+%dir %{_mandir}/man1
+%{_mandir}/man1/cjpeg.1*
+%{_mandir}/man1/djpeg.1*
+%{_mandir}/man1/jpegtran.1*
+%{_mandir}/man1/rdjpgcom.1*
+%{_mandir}/man1/wrjpgcom.1*
+%if "%{_prefix}" != "%{_datarootdir}"
+ %dir %{_datarootdir}
+%endif
+%if "%{_with_java}" == "1"
+ %dir %{_javadir}
+ %{_javadir}/turbojpeg.jar
+%endif
+%changelog
diff --git a/release/uninstall.in b/release/uninstall.in
index 6cd1f86..cf1ba77 100644
--- a/release/uninstall.in
+++ b/release/uninstall.in
@@ -31,15 +31,15 @@ if [ ! "`id -u`" = "0" ]; then
 	exit -1
 fi
 
-PACKAGE=@PKGNAME@
-MACPACKAGE=com.$PACKAGE.$PACKAGE
-RECEIPT=/Library/Receipts/$PACKAGE.pkg
+PKGNAME=@PKGNAME@
+PKGID=@PKGID@
+RECEIPT=/Library/Receipts/$PKGNAME.pkg
 
 LSBOM=
 if [ -d $RECEIPT ]; then
 	LSBOM='lsbom -s -f -l '$RECEIPT'/Contents/Archive.bom'
 else
-	LSBOM='pkgutil --files '$MACPACKAGE
+	LSBOM='pkgutil --files '$PKGID
 fi
 
 mylsbom()
@@ -56,12 +56,13 @@ done
 popd
 
 echo Removing package directories ...
-PREFIX=%{__prefix}
-BINDIR=%{__bindir}
-DATADIR=%{__datadir}
-INCLUDEDIR=%{__includedir}
-LIBDIR=%{__libdir}
-MANDIR=%{__mandir}
+PREFIX=@CMAKE_INSTALL_PREFIX@
+BINDIR=@CMAKE_INSTALL_FULL_BINDIR@
+DATAROOTDIR=@CMAKE_INSTALL_FULL_DATAROOTDIR@
+INCLUDEDIR=@CMAKE_INSTALL_FULL_INCLUDEDIR@
+JAVADIR=@CMAKE_INSTALL_FULL_JAVADIR@
+LIBDIR=@CMAKE_INSTALL_FULL_LIBDIR@
+MANDIR=@CMAKE_INSTALL_FULL_MANDIR@
 
 if [ -d $BINDIR ]; then
 	rmdir $BINDIR 2>&1 || EXITSTATUS=-1
@@ -75,7 +76,7 @@ fi
 if [ -d $INCLUDEDIR ]; then
 	rmdir $INCLUDEDIR 2>&1 || EXITSTATUS=-1
 fi
-if [ "$PREFIX" = "/opt/libjpeg-turbo" -a "$LIBDIR" = "/opt/libjpeg-turbo/lib" ]; then
+if [ "$PREFIX" = "@CMAKE_INSTALL_DEFAULT_PREFIX@" -a "$LIBDIR" = "@CMAKE_INSTALL_DEFAULT_PREFIX@/lib" ]; then
 	if [ -h $LIBDIR\32 ]; then
 		rm $LIBDIR\32 2>&1 || EXITSTATUS=-1
 	fi
@@ -89,24 +90,24 @@ fi
 if [ -d $MANDIR ]; then
 	rmdir $MANDIR 2>&1 || EXITSTATUS=-1
 fi
-if [ -d $DATADIR/classes ]; then
-	rmdir $DATADIR/classes 2>&1 || EXITSTATUS=-1
+if [ -d $JAVADIR ]; then
+	rmdir $JAVADIR 2>&1 || EXITSTATUS=-1
 fi
-if [ -d $DATADIR -a "$DATADIR" != "$PREFIX" ]; then
-	rmdir $DATADIR 2>&1 || EXITSTATUS=-1
+if [ -d $DATAROOTDIR -a "$DATAROOTDIR" != "$PREFIX" ]; then
+	rmdir $DATAROOTDIR 2>&1 || EXITSTATUS=-1
 fi
-if [ "$PREFIX" = "/opt/libjpeg-turbo" -a -h "$PREFIX/doc" ]; then
+if [ "$PREFIX" = "@CMAKE_INSTALL_DEFAULT_PREFIX@" -a -h "$PREFIX/doc" ]; then
 	rm $PREFIX/doc 2>&1 || EXITSTATUS=-1
 fi
 rmdir $PREFIX 2>&1 || EXITSTATUS=-1
-rmdir /Library/Documentation/$PACKAGE 2>&1 || EXITSTATUS=-1
+rmdir /Library/Documentation/$PKGNAME 2>&1 || EXITSTATUS=-1
 
 if [ -d $RECEIPT ]; then
 	echo Removing package receipt ...
 	rm -r $RECEIPT 2>&1 || EXITSTATUS=-1
 else
-	echo Forgetting package $MACPACKAGE ...
-	pkgutil --forget $MACPACKAGE
+	echo Forgetting package $PKGID ...
+	pkgutil --forget $PKGID
 fi
 
 exit $EXITSTATUS
diff --git a/sharedlib/CMakeLists.txt b/sharedlib/CMakeLists.txt
index d423cce..ef7e046 100755
--- a/sharedlib/CMakeLists.txt
+++ b/sharedlib/CMakeLists.txt
@@ -5,6 +5,10 @@
 # better yet, provide a friendly way of configuring a Windows target to use the
 # static C library.
 
+set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/..)
+set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/..)
+set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/..)
+
 if(MSVC)
   # Build all configurations against shared C library
   foreach(var CMAKE_C_FLAGS CMAKE_C_FLAGS_DEBUG CMAKE_C_FLAGS_RELEASE
@@ -16,36 +20,48 @@ if(MSVC)
 endif()
 
 foreach(src ${JPEG_SOURCES})
-  set(JPEG_SRCS ${JPEG_SRCS} ${CMAKE_SOURCE_DIR}/${src})
+  set(JPEG_SRCS ${JPEG_SRCS} ../${src})
 endforeach()
 
-if(WITH_SIMD)
+if(WITH_SIMD AND MSVC_IDE)
   # This tells CMake that the "source" files haven't been generated yet
   set_source_files_properties(${SIMD_OBJS} PROPERTIES GENERATED 1)
 endif()
 
-if(WITH_MEM_SRCDST AND NOT WITH_JPEG8)
-  add_library(jpeg SHARED ${JPEG_SRCS} ${SIMD_OBJS}
-    ${CMAKE_SOURCE_DIR}/win/jpeg${DLL_VERSION}-memsrcdst.def)
-else()
-  add_library(jpeg SHARED ${JPEG_SRCS} ${SIMD_OBJS}
-    ${CMAKE_SOURCE_DIR}/win/jpeg${DLL_VERSION}.def)
+if(WIN32)
+  if(WITH_MEM_SRCDST)
+    set(DEFFILE ../win/jpeg${SO_MAJOR_VERSION}-memsrcdst.def)
+  else()
+    set(DEFFILE ../win/jpeg${SO_MAJOR_VERSION}.def)
+  endif()
+endif()
+add_library(jpeg SHARED ${JPEG_SRCS} ${DEFFILE} $<TARGET_OBJECTS:simd>
+  ${SIMD_OBJS})
+
+set_target_properties(jpeg PROPERTIES SOVERSION ${SO_MAJOR_VERSION}
+  VERSION ${SO_MAJOR_VERSION}.${SO_AGE}.${SO_MINOR_VERSION})
+if(APPLE)
+  set_target_properties(jpeg PROPERTIES MACOSX_RPATH 1)
+endif()
+if(MAPFLAG)
+  set_target_properties(jpeg PROPERTIES
+    LINK_FLAGS "${MAPFLAG}${CMAKE_CURRENT_BINARY_DIR}/../libjpeg.map")
 endif()
-set_target_properties(jpeg PROPERTIES SOVERSION ${DLL_VERSION}
-  VERSION ${FULLVERSION})
 if(MSVC)
-  set_target_properties(jpeg PROPERTIES SUFFIX ${DLL_VERSION}.dll)
-elseif(MINGW OR CYGWIN)
-  set_target_properties(jpeg PROPERTIES SUFFIX -${DLL_VERSION}.dll)
-endif(MSVC)
-if(WITH_SIMD)
-  add_dependencies(jpeg simd)
+  set_target_properties(jpeg PROPERTIES SUFFIX ${SO_MAJOR_VERSION}.dll)
+  # The jsimd_*.c file is built using /MT, so this prevents a linker warning.
+  set_target_properties(jpeg PROPERTIES LINK_FLAGS "/NODEFAULTLIB:LIBCMT /NODEFAULTLIB:LIBCMTD")
+elseif(MINGW)
+  set_target_properties(jpeg PROPERTIES SUFFIX -${SO_MAJOR_VERSION}.dll)
 endif()
 
+if(WIN32)
+  set(USE_SETMODE "-DUSE_SETMODE")
+endif()
 if(WITH_12BIT)
-  set(COMPILE_FLAGS "-DGIF_SUPPORTED -DPPM_SUPPORTED -DUSE_SETMODE")
+  set(COMPILE_FLAGS "-DGIF_SUPPORTED -DPPM_SUPPORTED ${USE_SETMODE}")
 else()
-  set(COMPILE_FLAGS "-DBMP_SUPPORTED -DGIF_SUPPORTED -DPPM_SUPPORTED -DTARGA_SUPPORTED -DUSE_SETMODE")
+  set(COMPILE_FLAGS "-DBMP_SUPPORTED -DGIF_SUPPORTED -DPPM_SUPPORTED -DTARGA_SUPPORTED ${USE_SETMODE}")
 	set(CJPEG_BMP_SOURCES ../rdbmp.c ../rdtarga.c)
 	set(DJPEG_BMP_SOURCES ../wrbmp.c ../wrtarga.c)
 endif()
@@ -62,12 +78,12 @@ target_link_libraries(djpeg jpeg)
 
 add_executable(jpegtran ../jpegtran.c ../cdjpeg.c ../rdswitch.c ../transupp.c)
 target_link_libraries(jpegtran jpeg)
-set_property(TARGET jpegtran PROPERTY COMPILE_FLAGS "-DUSE_SETMODE")
+set_property(TARGET jpegtran PROPERTY COMPILE_FLAGS "${USE_SETMODE}")
 
 add_executable(jcstest ../jcstest.c)
 target_link_libraries(jcstest jpeg)
 
 install(TARGETS jpeg cjpeg djpeg jpegtran
-  ARCHIVE DESTINATION lib
-  LIBRARY DESTINATION lib
-  RUNTIME DESTINATION bin)
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
diff --git a/simd/CMakeLists.txt b/simd/CMakeLists.txt
index 6e898d8..a882188 100755
--- a/simd/CMakeLists.txt
+++ b/simd/CMakeLists.txt
@@ -1,81 +1,312 @@
-if(NOT DEFINED NASM)
-  find_program(NASM NAMES nasm yasm DOC "Path to NASM/YASM executable")
+macro(simd_fail message)
+  if(REQUIRE_SIMD)
+    message(FATAL_ERROR "${message}.")
+  else()
+    message(WARNING "${message}.  Performance will suffer.")
+    set(WITH_SIMD 0 PARENT_SCOPE)
+  endif()
+endmacro()
+
+
+###############################################################################
+# x86[-64] (NASM)
+###############################################################################
+
+if(CPU_TYPE STREQUAL "x86_64" OR CPU_TYPE STREQUAL "i386")
+
+set(CMAKE_ASM_NASM_FLAGS_DEBUG_INIT "-g")
+set(CMAKE_ASM_NASM_FLAGS_RELWITHDEBINFO_INIT "-g")
+
+# Allow the location of the NASM executable to be specified using the ASM_NASM
+# environment variable.  This should happen automatically, but unfortunately
+# enable_language(ASM_NASM) doesn't parse the ASM_NASM environment variable
+# until after CMAKE_ASM_NASM_COMPILER has been populated with the results of
+# searching for NASM or YASM in the PATH.
+if(NOT DEFINED CMAKE_ASM_NASM_COMPILER AND DEFINED ENV{ASM_NASM})
+  set(CMAKE_ASM_NASM_COMPILER $ENV{ASM_NASM})
 endif()
-message(STATUS "NASM = ${NASM}")
 
-if(SIMD_X86_64)
-  set(NAFLAGS -fwin64 -DWIN64 -D__x86_64__)
-else()
+if(CPU_TYPE STREQUAL "x86_64")
+  if(CYGWIN)
+    set(CMAKE_ASM_NASM_OBJECT_FORMAT win64)
+  endif()
+elseif(CPU_TYPE STREQUAL "i386")
   if(BORLAND)
-    set(NAFLAGS -fobj -DOBJ32)
-  else()
-    set(NAFLAGS -fwin32 -DWIN32)
+    set(CMAKE_ASM_NASM_OBJECT_FORMAT obj)
+  elseif(CYGWIN)
+    set(CMAKE_ASM_NASM_OBJECT_FORMAT win32)
   endif()
 endif()
-set(NAFLAGS ${NAFLAGS} -I${CMAKE_SOURCE_DIR}/win/ -I${CMAKE_CURRENT_SOURCE_DIR}/)
 
-# This only works if building from the command line.  There is currently no way
-# to set a variable's value based on the build type when using the MSVC IDE.
-if(CMAKE_BUILD_TYPE STREQUAL "Debug"
-  OR CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")
-  set(NAFLAGS ${NAFLAGS} -g)
+enable_language(ASM_NASM)
+message(STATUS "CMAKE_ASM_NASM_COMPILER = ${CMAKE_ASM_NASM_COMPILER}")
+
+if(CMAKE_ASM_NASM_OBJECT_FORMAT MATCHES "macho*")
+  set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -DMACHO")
+elseif(CMAKE_ASM_NASM_OBJECT_FORMAT MATCHES "elf*")
+  set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -DELF")
+  set(CMAKE_ASM_NASM_DEBUG_FORMAT "dwarf2")
+endif()
+if(CPU_TYPE STREQUAL "x86_64")
+  if(WIN32 OR CYGWIN)
+    set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -DWIN64")
+  endif()
+  set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -D__x86_64__")
+elseif(CPU_TYPE STREQUAL "i386")
+  if(BORLAND)
+    set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -DOBJ32")
+  elseif(WIN32 OR CYGWIN)
+    set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -DWIN32")
+  endif()
+endif()
+
+message(STATUS "CMAKE_ASM_NASM_OBJECT_FORMAT = ${CMAKE_ASM_NASM_OBJECT_FORMAT}")
+
+if(NOT CMAKE_ASM_NASM_OBJECT_FORMAT)
+  simd_fail("SIMD extensions disabled: could not determine NASM object format")
+  return()
+endif()
+
+get_filename_component(CMAKE_ASM_NASM_COMPILER_TYPE
+  "${CMAKE_ASM_NASM_COMPILER}" NAME_WE)
+if(CMAKE_ASM_NASM_COMPILER_TYPE MATCHES "yasm")
+  foreach(var CMAKE_ASM_NASM_FLAGS_DEBUG CMAKE_ASM_NASM_FLAGS_RELWITHDEBINFO)
+    if(${var} STREQUAL "-g")
+      if(CMAKE_ASM_NASM_DEBUG_FORMAT)
+        set_property(CACHE ${var} PROPERTY VALUE "-g ${CMAKE_ASM_NASM_DEBUG_FORMAT}")
+      else()
+        set_property(CACHE ${var} PROPERTY VALUE "")
+      endif()
+    endif()
+  endforeach()
+endif()
+
+if(NOT WIN32 AND (CMAKE_POSITION_INDEPENDENT_CODE OR ENABLE_SHARED))
+  set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -DPIC")
+endif()
+
+string(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)
+set(EFFECTIVE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} ${CMAKE_ASM_NASM_FLAGS_${CMAKE_BUILD_TYPE_UC}}")
+message(STATUS "CMAKE_ASM_NASM_FLAGS = ${EFFECTIVE_ASM_NASM_FLAGS}")
+
+set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -I\"${CMAKE_CURRENT_SOURCE_DIR}/nasm/\" -I\"${CMAKE_CURRENT_SOURCE_DIR}/${CPU_TYPE}/\"")
+
+if(WIN32)
+  set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -I\"${CMAKE_CURRENT_SOURCE_DIR}/../win/\"")
+  set(JSIMDCFG_INC ${CMAKE_CURRENT_SOURCE_DIR}/../win/jsimdcfg.inc)
+else()
+  set(GREP grep)
+  if(CMAKE_SYSTEM_NAME STREQUAL "SunOS")
+    set(GREP ggrep)
+  endif()
+  add_custom_command(OUTPUT jsimdcfg.inc
+    COMMAND ${CMAKE_C_COMPILER} -E -I${CMAKE_BINARY_DIR} -I${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/jsimdcfg.inc.h | ${GREP} -E '^[\;%]|^\ %' | sed 's%_cpp_protection_%%' | sed 's@% define@%define@g' >jsimdcfg.inc)
+  set(JSIMDCFG_INC ${CMAKE_CURRENT_BINARY_DIR}/jsimdcfg.inc)
+  set(CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS} -I\"${CMAKE_CURRENT_BINARY_DIR}/\"")
 endif()
 
-if(SIMD_X86_64)
-  set(SIMD_BASENAMES jfdctflt-sse-64 jccolor-sse2-64 jcgray-sse2-64
-    jchuff-sse2-64 jcsample-sse2-64 jdcolor-sse2-64 jdmerge-sse2-64
-    jdsample-sse2-64 jfdctfst-sse2-64 jfdctint-sse2-64 jidctflt-sse2-64
-    jidctfst-sse2-64 jidctint-sse2-64 jidctred-sse2-64 jquantf-sse2-64
-    jquanti-sse2-64)
-  message(STATUS "Building x86_64 SIMD extensions")
+if(CPU_TYPE STREQUAL "x86_64")
+  set(SIMD_SOURCES x86_64/jsimdcpu.asm x86_64/jfdctflt-sse.asm
+    x86_64/jccolor-sse2.asm x86_64/jcgray-sse2.asm x86_64/jchuff-sse2.asm
+    x86_64/jcsample-sse2.asm x86_64/jdcolor-sse2.asm x86_64/jdmerge-sse2.asm
+    x86_64/jdsample-sse2.asm x86_64/jfdctfst-sse2.asm x86_64/jfdctint-sse2.asm
+    x86_64/jidctflt-sse2.asm x86_64/jidctfst-sse2.asm x86_64/jidctint-sse2.asm
+    x86_64/jidctred-sse2.asm x86_64/jquantf-sse2.asm x86_64/jquanti-sse2.asm
+    x86_64/jccolor-avx2.asm x86_64/jcgray-avx2.asm x86_64/jcsample-avx2.asm
+    x86_64/jdcolor-avx2.asm x86_64/jdmerge-avx2.asm x86_64/jdsample-avx2.asm
+    x86_64/jquanti-avx2.asm)
 else()
-  set(SIMD_BASENAMES jsimdcpu jfdctflt-3dn jidctflt-3dn jquant-3dn jccolor-mmx
-    jcgray-mmx jcsample-mmx jdcolor-mmx jdmerge-mmx jdsample-mmx jfdctfst-mmx
-    jfdctint-mmx jidctfst-mmx jidctint-mmx jidctred-mmx jquant-mmx jfdctflt-sse
-    jidctflt-sse jquant-sse jccolor-sse2 jcgray-sse2 jchuff-sse2 jcsample-sse2
-    jdcolor-sse2 jdmerge-sse2 jdsample-sse2 jfdctfst-sse2 jfdctint-sse2
-    jidctflt-sse2 jidctfst-sse2 jidctint-sse2 jidctred-sse2 jquantf-sse2
-    jquanti-sse2)
-  message(STATUS "Building i386 SIMD extensions")
+  set(SIMD_SOURCES i386/jsimdcpu.asm i386/jfdctflt-3dn.asm
+    i386/jidctflt-3dn.asm i386/jquant-3dn.asm
+    i386/jccolor-mmx.asm i386/jcgray-mmx.asm i386/jcsample-mmx.asm
+    i386/jdcolor-mmx.asm i386/jdmerge-mmx.asm i386/jdsample-mmx.asm
+    i386/jfdctfst-mmx.asm i386/jfdctint-mmx.asm i386/jidctfst-mmx.asm
+    i386/jidctint-mmx.asm i386/jidctred-mmx.asm i386/jquant-mmx.asm
+    i386/jfdctflt-sse.asm i386/jidctflt-sse.asm i386/jquant-sse.asm
+    i386/jccolor-sse2.asm i386/jcgray-sse2.asm i386/jchuff-sse2.asm
+    i386/jcsample-sse2.asm i386/jdcolor-sse2.asm i386/jdmerge-sse2.asm
+    i386/jdsample-sse2.asm i386/jfdctfst-sse2.asm i386/jfdctint-sse2.asm
+    i386/jidctflt-sse2.asm i386/jidctfst-sse2.asm i386/jidctint-sse2.asm
+    i386/jidctred-sse2.asm i386/jquantf-sse2.asm i386/jquanti-sse2.asm
+    i386/jccolor-avx2.asm i386/jcgray-avx2.asm i386/jcsample-avx2.asm
+    i386/jdcolor-avx2.asm i386/jdmerge-avx2.asm i386/jdsample-avx2.asm
+    i386/jquanti-avx2.asm)
 endif()
 
 if(MSVC_IDE)
   set(OBJDIR "${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}")
-else()
-  set(OBJDIR ${CMAKE_CURRENT_BINARY_DIR})
+  string(REGEX REPLACE " " ";" CMAKE_ASM_NASM_FLAGS "${CMAKE_ASM_NASM_FLAGS}")
 endif()
 
-file(GLOB INC_FILES *.inc)
+file(GLOB INC_FILES nasm/*.inc)
 
-foreach(file ${SIMD_BASENAMES})
-  set(DEPFILE "")
-  set(SIMD_SRC ${CMAKE_CURRENT_SOURCE_DIR}/${file}.asm)
+foreach(file ${SIMD_SOURCES})
+  set(OBJECT_DEPENDS "")
   if(${file} MATCHES jccolor)
-    set(DEPFILE ${file})
-    string(REGEX REPLACE "jccolor" "jccolext" DEPFILE ${DEPFILE})
-    set(DEPFILE ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE}.asm)
+    string(REGEX REPLACE "jccolor" "jccolext" DEPFILE ${file})
+    set(OBJECT_DEPENDS ${OBJECT_DEPENDS}
+      ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE})
   endif()
   if(${file} MATCHES jcgray)
-    set(DEPFILE ${file})
-    string(REGEX REPLACE "jcgray" "jcgryext" DEPFILE ${DEPFILE})
-    set(DEPFILE ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE}.asm)
+    string(REGEX REPLACE "jcgray" "jcgryext" DEPFILE ${file})
+    set(OBJECT_DEPENDS ${OBJECT_DEPENDS}
+      ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE})
   endif()
   if(${file} MATCHES jdcolor)
-    set(DEPFILE ${file})
-    string(REGEX REPLACE "jdcolor" "jdcolext" DEPFILE ${DEPFILE})
-    set(DEPFILE ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE}.asm)
+    string(REGEX REPLACE "jdcolor" "jdcolext" DEPFILE ${file})
+    set(OBJECT_DEPENDS ${OBJECT_DEPENDS}
+      ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE})
   endif()
   if(${file} MATCHES jdmerge)
-    set(DEPFILE ${file})
-    string(REGEX REPLACE "jdmerge" "jdmrgext" DEPFILE ${DEPFILE})
-    set(DEPFILE ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE}.asm)
+    string(REGEX REPLACE "jdmerge" "jdmrgext" DEPFILE ${file})
+    set(OBJECT_DEPENDS ${OBJECT_DEPENDS}
+      ${CMAKE_CURRENT_SOURCE_DIR}/${DEPFILE})
+  endif()
+  set(OBJECT_DEPENDS ${OBJECT_DEPENDS} ${INC_FILES} ${JSIMDCFG_INC})
+  if(MSVC_IDE)
+    # The CMake Visual Studio generators do not work properly with the ASM_NASM
+    # language, so we have to go rogue here and use a custom command like we
+    # did in prior versions of libjpeg-turbo.  (This is why we can't have nice
+    # things.)
+    string(REGEX REPLACE "${CPU_TYPE}/" "" filename ${file})
+    set(SIMD_OBJ ${OBJDIR}/${filename}.obj)
+    add_custom_command(OUTPUT ${SIMD_OBJ} DEPENDS ${file} ${OBJECT_DEPENDS}
+      COMMAND ${CMAKE_ASM_NASM_COMPILER} -f${CMAKE_ASM_NASM_OBJECT_FORMAT}
+        ${CMAKE_ASM_NASM_FLAGS} ${CMAKE_CURRENT_SOURCE_DIR}/${file}
+        -o${SIMD_OBJ})
+    set(SIMD_OBJS ${SIMD_OBJS} ${SIMD_OBJ})
+  else()
+    set_source_files_properties(${file} PROPERTIES OBJECT_DEPENDS
+      "${OBJECT_DEPENDS}")
   endif()
-  set(SIMD_OBJ ${OBJDIR}/${file}.obj)
-  add_custom_command(OUTPUT ${SIMD_OBJ}
-    DEPENDS ${SIMD_SRC} ${DEPFILE} ${INC_FILES}
-    COMMAND ${NASM} ${NAFLAGS} ${SIMD_SRC} -o${SIMD_OBJ})
-  set(SIMD_OBJS ${SIMD_OBJS} ${SIMD_OBJ})
 endforeach()
 
-set(SIMD_OBJS ${SIMD_OBJS} PARENT_SCOPE)
-add_custom_target(simd DEPENDS ${SIMD_OBJS})
+if(MSVC_IDE)
+  set(SIMD_OBJS ${SIMD_OBJS} PARENT_SCOPE)
+  add_library(simd OBJECT ${CPU_TYPE}/jsimd.c)
+  add_custom_target(simd-objs DEPENDS ${SIMD_OBJS})
+  add_dependencies(simd simd-objs)
+else()
+  add_library(simd OBJECT ${SIMD_SOURCES} ${CPU_TYPE}/jsimd.c)
+endif()
+if(NOT WIN32 AND (CMAKE_POSITION_INDEPENDENT_CODE OR ENABLE_SHARED))
+  set_target_properties(simd PROPERTIES POSITION_INDEPENDENT_CODE 1)
+endif()
+
+
+###############################################################################
+# ARM (GAS)
+###############################################################################
+
+elseif(CPU_TYPE STREQUAL "arm64" OR CPU_TYPE STREQUAL "arm")
+
+enable_language(ASM)
+
+set(CMAKE_ASM_FLAGS ${CMAKE_C_FLAGS}${CMAKE_ASM_FLAGS})
+
+string(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)
+set(EFFECTIVE_ASM_FLAGS "${CMAKE_ASM_FLAGS} ${CMAKE_ASM_FLAGS_${CMAKE_BUILD_TYPE_UC}}")
+message(STATUS "CMAKE_ASM_FLAGS = ${EFFECTIVE_ASM_FLAGS}")
+
+# Test whether we need gas-preprocessor.pl
+if(CPU_TYPE STREQUAL "arm")
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/gastest.S "
+    .text
+    .fpu neon
+    .arch armv7a
+    .object_arch armv4
+    .arm
+    pld [r0]
+    vmovn.u16 d0, q0")
+else()
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/gastest.S "
+    .text
+    MYVAR .req x0
+    movi v0.16b, #100
+    mov MYVAR, #100
+    .unreq MYVAR")
+endif()
+
+separate_arguments(CMAKE_ASM_FLAGS_SEP UNIX_COMMAND "${CMAKE_ASM_FLAGS}")
+
+execute_process(COMMAND ${CMAKE_ASM_COMPILER} ${CMAKE_ASM_FLAGS_SEP}
+    -x assembler-with-cpp -c ${CMAKE_CURRENT_BINARY_DIR}/gastest.S
+  RESULT_VARIABLE RESULT OUTPUT_VARIABLE OUTPUT ERROR_VARIABLE ERROR)
+if(NOT RESULT EQUAL 0)
+  message(STATUS "GAS appears to be broken.  Trying gas-preprocessor.pl ...")
+  execute_process(COMMAND gas-preprocessor.pl ${CMAKE_ASM_COMPILER}
+      ${CMAKE_ASM_FLAGS_SEP} -x assembler-with-cpp -c
+      ${CMAKE_CURRENT_BINARY_DIR}/gastest.S
+    RESULT_VARIABLE RESULT OUTPUT_VARIABLE OUTPUT ERROR_VARIABLE ERROR)
+  if(NOT RESULT EQUAL 0)
+    simd_fail("SIMD extensions disabled: GAS is not working properly")
+    return()
+  else()
+    message(STATUS "Using gas-preprocessor.pl")
+    configure_file(gas-preprocessor.in gas-preprocessor @ONLY)
+    set(CMAKE_ASM_COMPILER ${CMAKE_CURRENT_BINARY_DIR}/gas-preprocessor)
+  endif()
+else()
+  message(STATUS "GAS is working properly")
+endif()
+
+file(REMOVE ${CMAKE_CURRENT_BINARY_DIR}/gastest.S)
+
+add_library(simd OBJECT ${CPU_TYPE}/jsimd_neon.S ${CPU_TYPE}/jsimd.c)
+
+if(CMAKE_POSITION_INDEPENDENT_CODE OR ENABLE_SHARED)
+  set_target_properties(simd PROPERTIES POSITION_INDEPENDENT_CODE 1)
+endif()
+
+
+###############################################################################
+# MIPS (GAS)
+###############################################################################
+
+elseif(CPU_TYPE STREQUAL "mips")
+
+enable_language(ASM)
+
+string(TOUPPER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_UC)
+set(EFFECTIVE_ASM_FLAGS "${CMAKE_ASM_FLAGS} ${CMAKE_ASM_FLAGS_${CMAKE_BUILD_TYPE_UC}}")
+message(STATUS "CMAKE_ASM_FLAGS = ${EFFECTIVE_ASM_FLAGS}")
+
+add_library(simd OBJECT ${CPU_TYPE}/jsimd_dspr2.S ${CPU_TYPE}/jsimd.c)
+
+if(CMAKE_POSITION_INDEPENDENT_CODE OR ENABLE_SHARED)
+  set_target_properties(simd PROPERTIES POSITION_INDEPENDENT_CODE 1)
+endif()
+
+
+###############################################################################
+# PowerPC (Intrinsics)
+###############################################################################
+
+elseif(CPU_TYPE STREQUAL "powerpc")
+
+set(SIMD_SOURCES powerpc/jccolor-altivec.c powerpc/jcgray-altivec.c
+  powerpc/jcsample-altivec.c powerpc/jdcolor-altivec.c
+  powerpc/jdmerge-altivec.c powerpc/jdsample-altivec.c
+  powerpc/jfdctfst-altivec.c powerpc/jfdctint-altivec.c
+  powerpc/jidctfst-altivec.c powerpc/jidctint-altivec.c
+  powerpc/jquanti-altivec.c)
+
+set_source_files_properties(${SIMD_SOURCES} PROPERTIES
+  COMPILE_FLAGS -maltivec)
+
+add_library(simd OBJECT ${SIMD_SOURCES} powerpc/jsimd.c)
+
+if(CMAKE_POSITION_INDEPENDENT_CODE OR ENABLE_SHARED)
+  set_target_properties(simd PROPERTIES POSITION_INDEPENDENT_CODE 1)
+endif()
+
+
+###############################################################################
+# None
+###############################################################################
+
+else()
+
+simd_fail("SIMD extensions not available for this CPU (${CMAKE_SYSTEM_PROCESSOR})")
+
+endif() # CPU_TYPE
diff --git a/simd/Makefile.am b/simd/Makefile.am
deleted file mode 100644
index b8660d1..0000000
--- a/simd/Makefile.am
+++ /dev/null
@@ -1,102 +0,0 @@
-noinst_LTLIBRARIES = libsimd.la
-
-BUILT_SOURCES = jsimdcfg.inc
-
-EXTRA_DIST = nasm_lt.sh CMakeLists.txt \
-	jccolext-mmx.asm   jcgryext-mmx.asm   jdcolext-mmx.asm   jdmrgext-mmx.asm \
-	jccolext-sse2.asm  jcgryext-sse2.asm  jdcolext-sse2.asm  jdmrgext-sse2.asm \
-	jccolext-sse2-64.asm  jcgryext-sse2-64.asm  jdcolext-sse2-64.asm \
-	jdmrgext-sse2-64.asm  jccolext-altivec.c    jcgryext-altivec.c \
-	jdcolext-altivec.c    jdmrgext-altivec.c
-
-if SIMD_X86_64
-
-libsimd_la_SOURCES = jsimd_x86_64.c jsimd.h jsimdcfg.inc.h jsimdext.inc \
-	jcolsamp.inc jdct.inc jpeg_nbits_table.inc jfdctflt-sse-64.asm \
-	jccolor-sse2-64.asm   jcgray-sse2-64.asm    jchuff-sse2-64.asm \
-	jcsample-sse2-64.asm  jdcolor-sse2-64.asm   jdmerge-sse2-64.asm \
-	jdsample-sse2-64.asm  jfdctfst-sse2-64.asm  jfdctint-sse2-64.asm \
-	jidctflt-sse2-64.asm  jidctfst-sse2-64.asm  jidctint-sse2-64.asm \
-	jidctred-sse2-64.asm  jquantf-sse2-64.asm   jquanti-sse2-64.asm
-
-jccolor-sse2-64.lo:  jccolext-sse2-64.asm
-jcgray-sse2-64.lo:   jcgryext-sse2-64.asm
-jdcolor-sse2-64.lo:  jdcolext-sse2-64.asm
-jdmerge-sse2-64.lo:  jdmrgext-sse2-64.asm
-
-endif
-
-if SIMD_I386
-
-libsimd_la_SOURCES = jsimd_i386.c jsimd.h jsimdcfg.inc.h jsimdext.inc \
-	jcolsamp.inc jdct.inc jpeg_nbits_table.inc jsimdcpu.asm \
-	jfdctflt-3dn.asm   jidctflt-3dn.asm   jquant-3dn.asm \
-	jccolor-mmx.asm    jcgray-mmx.asm     jcsample-mmx.asm \
-	jdcolor-mmx.asm    jdmerge-mmx.asm    jdsample-mmx.asm \
-	jfdctfst-mmx.asm   jfdctint-mmx.asm   jidctfst-mmx.asm \
-	jidctint-mmx.asm   jidctred-mmx.asm   jquant-mmx.asm \
-	jfdctflt-sse.asm   jidctflt-sse.asm   jquant-sse.asm \
-	jccolor-sse2.asm   jcgray-sse2.asm    jchuff-sse2.asm \
-	jcsample-sse2.asm  jdcolor-sse2.asm   jdmerge-sse2.asm \
-	jdsample-sse2.asm  jfdctfst-sse2.asm  jfdctint-sse2.asm \
-	jidctflt-sse2.asm  jidctfst-sse2.asm  jidctint-sse2.asm \
-	jidctred-sse2.asm  jquantf-sse2.asm   jquanti-sse2.asm
-
-jccolor-mmx.lo:   jccolext-mmx.asm
-jcgray.-mmx.lo:   jcgryext-mmx.asm
-jdcolor-mmx.lo:   jdcolext-mmx.asm
-jdmerge-mmx.lo:   jdmrgext-mmx.asm
-jccolor-sse2.lo:  jccolext-sse2.asm
-jcgray-sse2.lo:   jcgryext-sse2.asm
-jdcolor-sse2.lo:  jdcolext-sse2.asm
-jdmerge-sse2.lo:  jdmrgext-sse2.asm
-
-endif
-
-if SIMD_ARM
-
-libsimd_la_SOURCES = jsimd_arm.c jsimd_arm_neon.S
-
-endif
-
-if SIMD_ARM_64
-
-libsimd_la_SOURCES = jsimd_arm64.c jsimd_arm64_neon.S
-
-endif
-
-if SIMD_MIPS
-
-libsimd_la_SOURCES = jsimd_mips.c jsimd_mips_dspr2_asm.h jsimd_mips_dspr2.S
-
-endif
-
-if SIMD_POWERPC
-
-noinst_LTLIBRARIES += libsimd_altivec.la
-
-libsimd_altivec_la_SOURCES = \
-	jccolor-altivec.c     jcgray-altivec.c      jcsample-altivec.c \
-	jdcolor-altivec.c     jdmerge-altivec.c     jdsample-altivec.c \
-	jfdctfst-altivec.c    jfdctint-altivec.c \
-	jidctfst-altivec.c    jidctint-altivec.c \
-	jquanti-altivec.c
-libsimd_altivec_la_CFLAGS = -maltivec
-
-jccolor-altivec.lo:  jccolext-altivec.c
-jcgray-altivec.lo:   jcgryext-altivec.c
-jdcolor-altivec.lo:  jdcolext-altivec.c
-jdmerge-altivec.lo:  jdmrgext-altivec.c
-
-libsimd_la_SOURCES = jsimd_powerpc.c jsimd_altivec.h jcsample.h
-libsimd_la_LIBADD = libsimd_altivec.la
-
-endif
-
-AM_CPPFLAGS = -I$(top_srcdir)
-
-.asm.lo:
-	$(AM_V_GEN) $(LIBTOOL) $(AM_V_lt) --mode=compile --tag NASM $(srcdir)/nasm_lt.sh $(AM_V_lt) $(NASM) $(NAFLAGS) -I$(srcdir) -I. $< -o $@
-
-jsimdcfg.inc: $(srcdir)/jsimdcfg.inc.h ../jpeglib.h ../jconfig.h ../jmorecfg.h
-	$(AM_V_GEN) $(CPP) -I$(top_builddir) -I$(top_builddir)/simd $(srcdir)/jsimdcfg.inc.h | $(EGREP) "^[\;%]|^\ %" | sed 's%_cpp_protection_%%' | sed 's@% define@%define@g' > $@
diff --git a/simd/jsimd_arm.c b/simd/arm/jsimd.c
similarity index 99%
rename from simd/jsimd_arm.c
rename to simd/arm/jsimd.c
index 0b955cd..1963349 100644
--- a/simd/jsimd_arm.c
+++ b/simd/arm/jsimd.c
@@ -16,12 +16,12 @@
  */
 
 #define JPEG_INTERNALS
-#include "../jinclude.h"
-#include "../jpeglib.h"
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "../jdct.h"
-#include "../jsimddct.h"
-#include "jsimd.h"
 
 #include <stdio.h>
 #include <string.h>
diff --git a/simd/jsimd_arm_neon.S b/simd/arm/jsimd_neon.S
similarity index 100%
rename from simd/jsimd_arm_neon.S
rename to simd/arm/jsimd_neon.S
diff --git a/simd/jsimd_arm64.c b/simd/arm64/jsimd.c
similarity index 99%
rename from simd/jsimd_arm64.c
rename to simd/arm64/jsimd.c
index f6e9736..12a7822 100644
--- a/simd/jsimd_arm64.c
+++ b/simd/arm64/jsimd.c
@@ -16,12 +16,12 @@
  */
 
 #define JPEG_INTERNALS
-#include "../jinclude.h"
-#include "../jpeglib.h"
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "../jdct.h"
-#include "../jsimddct.h"
-#include "jsimd.h"
 
 #include <stdio.h>
 #include <string.h>
diff --git a/simd/jsimd_arm64_neon.S b/simd/arm64/jsimd_neon.S
similarity index 100%
rename from simd/jsimd_arm64_neon.S
rename to simd/arm64/jsimd_neon.S
diff --git a/simd/gas-preprocessor.in b/simd/gas-preprocessor.in
new file mode 100755
index 0000000..560f788
--- /dev/null
+++ b/simd/gas-preprocessor.in
@@ -0,0 +1 @@
+gas-preprocessor.pl @CMAKE_ASM_COMPILER@ ${1+"$@"}
diff --git a/simd/i386/jccolext-avx2.asm b/simd/i386/jccolext-avx2.asm
new file mode 100644
index 0000000..19e05c0
--- /dev/null
+++ b/simd/i386/jccolext-avx2.asm
@@ -0,0 +1,581 @@
+;
+; jccolext.asm - colorspace conversion (AVX2)
+;
+; Copyright (C) 2015, Intel Corporation.
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_ycc_convert_avx2 (JDIMENSION img_width,
+;                             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                             JDIMENSION output_row, int num_rows);
+;
+
+%define img_width(b)   (b)+8            ; JDIMENSION img_width
+%define input_buf(b)   (b)+12           ; JSAMPARRAY input_buf
+%define output_buf(b)  (b)+16           ; JSAMPIMAGE output_buf
+%define output_row(b)  (b)+20           ; JDIMENSION output_row
+%define num_rows(b)    (b)+24           ; int num_rows
+
+%define original_ebp   ebp+0
+%define wk(i)          ebp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM         8
+%define gotptr         wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+
+    global      EXTN(jsimd_rgb_ycc_convert_avx2)
+
+EXTN(jsimd_rgb_ycc_convert_avx2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [img_width(eax)]
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         esi, JSAMPIMAGE [output_buf(eax)]
+    mov         ecx, JDIMENSION [output_row(eax)]
+    mov         edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [esi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [esi+2*SIZEOF_JSAMPARRAY]
+    lea         edi, [edi+ecx*SIZEOF_JSAMPROW]
+    lea         ebx, [ebx+ecx*SIZEOF_JSAMPROW]
+    lea         edx, [edx+ecx*SIZEOF_JSAMPROW]
+
+    pop         ecx
+
+    mov         esi, JSAMPARRAY [input_buf(eax)]
+    mov         eax, INT [num_rows(eax)]
+    test        eax, eax
+    jle         near .return
+    alignx      16, 7
+.rowloop:
+    pushpic     eax
+    push        edx
+    push        ebx
+    push        edi
+    push        esi
+    push        ecx                     ; col
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr0
+    mov         ebx, JSAMPROW [ebx]     ; outptr1
+    mov         edx, JSAMPROW [edx]     ; outptr2
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    alignx      16, 7
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        eax
+    push        edx
+    lea         ecx, [ecx+ecx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_BYTE
+    movzx       eax, BYTE [esi+ecx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_WORD
+    movzx       edx, WORD [esi+ecx]
+    shl         eax, WORD_BIT
+    or          eax, edx
+.column_ld4:
+    vmovd       xmmA, eax
+    pop         edx
+    pop         eax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_DWORD
+    vmovd       xmmF, XMM_DWORD [esi+ecx]
+    vpslldq     xmmA, xmmA, SIZEOF_DWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         ecx, byte SIZEOF_MMWORD
+    vmovq       xmmB, XMM_MMWORD [esi+ecx]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    sub         ecx, byte SIZEOF_XMMWORD
+    vmovdqu     xmmB, XMM_MMWORD [esi+ecx]
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    vpor        ymmA, ymmB
+.column_ld32:
+    test        cl, SIZEOF_YMMWORD
+    jz          short .column_ld64
+    sub         ecx, byte SIZEOF_YMMWORD
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+.column_ld64:
+    test        cl, 2*SIZEOF_YMMWORD
+    mov         ecx, SIZEOF_YMMWORD
+    jz          short .rgb_ycc_cnv
+    vmovdqa     ymmB, ymmA
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_ycc_cnv
+    alignx      16, 7
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmB, YMMWORD [esi+2*SIZEOF_YMMWORD]
+
+.rgb_ycc_cnv:
+    ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+    ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+    ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    ; ymmB=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+    ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vmovdqu     ymmC, ymmA
+    vinserti128 ymmA, ymmF, xmmA, 0  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                     ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vinserti128 ymmC, ymmC, xmmB, 0  ; ymmC=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                     ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vinserti128 ymmB, ymmB, xmmF, 0  ; ymmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                     ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+    vperm2i128  ymmF, ymmC, ymmC, 1  ; ymmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                     ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+
+    vmovdqa     ymmG, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12
+                                  ;       22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I)
+    vpsrldq     ymmG, ymmG, 8     ; ymmG=(22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I
+                                  ;       2I 0J 1J 2J 0K 1K 2K 0L -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmF  ; ymmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A
+                                  ;       0G 0O 1G 1O 2G 2O 0H 0P 1H 1P 2H 2P 0I 0Q 1I 1Q)
+    vpslldq     ymmF, ymmF, 8     ; ymmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27
+                                  ;       08 18 28 09 19 29 0A 1A 1L 2L 0M 1M 2M 0N 1N 2N)
+
+    vpunpcklbw  ymmG, ymmG, ymmB  ; ymmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D
+                                  ;       2I 2Q 0J 0R 1J 1R 2J 2R 0K 0S 1K 1S 2K 2S 0L 0T)
+    vpunpckhbw  ymmF, ymmF, ymmB  ; ymmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F
+                                  ;       1L 1T 2L 2T 0M 0U 1M 1U 2M 2U 0N 0V 1N 1V 2N 2V)
+
+    vmovdqa     ymmD, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09
+                                  ;       11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P)
+    vpsrldq     ymmD, ymmD, 8     ; ymmD=(11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P
+                                  ;       1H 1P 2H 2P 0I 0Q 1I 1Q -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmG  ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D
+                                  ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 0H 0L 0P 0T)
+    vpslldq     ymmG, ymmG, 8     ; ymmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B
+                                  ;       04 0C 14 1C 24 2C 05 0D 2I 2Q 0J 0R 1J 1R 2J 2R)
+
+    vpunpcklbw  ymmD, ymmD, ymmF  ; ymmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E
+                                  ;       1H 1L 1P 1T 2H 2L 2P 2T 0I 0M 0Q 0U 1I 1M 1Q 1U)
+    vpunpckhbw  ymmG, ymmG, ymmF  ; ymmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F
+                                  ;       2I 2M 2Q 2U 0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V)
+
+    vmovdqa     ymmE, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C
+                                  ;       20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S)
+    vpsrldq     ymmE, ymmE, 8     ; ymmE=(20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S
+                                  ;       2G 2K 2O 2S 0H 0L 0P 0T -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmD  ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                  ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpslldq     ymmD, ymmD, 8     ; ymmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D
+                                  ;       02 06 0A 0E 12 16 1A 1E 1H 1L 1P 1T 2H 2L 2P 2T)
+
+    vpunpcklbw  ymmE, ymmE, ymmG  ; ymmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F
+                                  ;       2G 2I 2K 2M 2O 2Q 2S 2U 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmG  ; ymmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F
+                                  ;       1H 1J 1L 1N 1P 1R 1T 1V 2H 2J 2L 2N 2P 2R 2T 2V)
+
+    vpxor       ymmH, ymmH, ymmH
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmH  ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmH  ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmB, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmH  ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmB, ymmB, ymmH  ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+
+    vmovdqa     ymmF, ymmD
+    vpunpcklbw  ymmD, ymmD, ymmH  ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmF, ymmF, ymmH  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_XMMWORD/16
+    vmovd       xmmA, XMM_DWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_XMMWORD/8
+    vmovq       xmmF, XMM_MMWORD [esi+ecx*RGB_PIXELSIZE]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_XMMWORD/4
+    vmovdqa     xmmF, xmmA
+    vperm2i128  ymmF, ymmF, ymmF, 1
+    vmovdqu     xmmA, XMMWORD [esi+ecx*RGB_PIXELSIZE]
+    vpor        ymmA, ymmA, ymmF
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    jz          short .column_ld16
+    sub         ecx, byte SIZEOF_XMMWORD/2
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    mov         ecx, SIZEOF_YMMWORD
+    jz          short .rgb_ycc_cnv
+    vmovdqa     ymmE, ymmA
+    vmovdqa     ymmH, ymmF
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_ycc_cnv
+    alignx      16, 7
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmE, YMMWORD [esi+2*SIZEOF_YMMWORD]
+    vmovdqu     ymmH, YMMWORD [esi+3*SIZEOF_YMMWORD]
+
+.rgb_ycc_cnv:
+    ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+    ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+    ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    ; ymmE=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+    ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+    ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmB, ymmA
+    vinserti128 ymmA, ymmA, xmmE, 1     ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vperm2i128  ymmE, ymmB, ymmE, 0x31  ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+
+    vmovdqa     ymmB, ymmF
+    vinserti128 ymmF, ymmF, xmmH, 1     ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+    vperm2i128  ymmH, ymmB, ymmH, 0x31  ; ymmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmD, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmE      ; ymmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35
+                                      ;       0G 0K 1G 1K 2G 2K 3G 3K 0H 0L 1H 1L 2H 2L 3H 3L)
+    vpunpckhbw  ymmD, ymmD, ymmE      ; ymmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37
+                                      ;       0I 0M 1I 1M 2I 2M 3I 3M 0J 0N 1J 1N 2J 2N 3J 3N)
+
+    vmovdqa     ymmC, ymmF
+    vpunpcklbw  ymmF, ymmF, ymmH      ; ymmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D
+                                      ;       0O 0S 1O 1S 2O 2S 3O 3S 0P 0T 1P 1T 2P 2T 3P 3T)
+    vpunpckhbw  ymmC, ymmC, ymmH      ; ymmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F
+                                      ;       0Q 0U 1Q 1U 2Q 2U 3Q 3U 0R 0V 1R 1V 2R 2V 3R 3V)
+
+    vmovdqa     ymmB, ymmA
+    vpunpcklwd  ymmA, ymmA, ymmF      ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C
+                                      ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 3G 3K 3O 3S)
+    vpunpckhwd  ymmB, ymmB, ymmF      ; ymmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D
+                                      ;       0H 0L 0P 0T 1H 1L 1P 1T 2H 2L 2P 2T 3H 3L 3P 3T)
+
+    vmovdqa     ymmG, ymmD
+    vpunpcklwd  ymmD, ymmD, ymmC      ; ymmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E
+                                      ;       0I 0M 0Q 0U 1I 1M 1Q 1U 2I 2M 2Q 2U 3I 3M 3Q 3U)
+    vpunpckhwd  ymmG, ymmG, ymmC      ; ymmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F
+                                      ;       0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V 3J 3N 3R 3V)
+
+    vmovdqa     ymmE, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmD      ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                      ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpunpckhbw  ymmE, ymmE, ymmD      ; ymmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E
+                                      ;       2G 2I 2K 2M 2O 2Q 2S 2U 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vmovdqa     ymmH, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmG      ; ymmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F
+                                      ;       0H 0J 0L 0N 0P 0R 0T 0V 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmH, ymmH, ymmG      ; ymmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F
+                                      ;       2H 2J 2L 2N 2P 2R 2T 2V 3H 3J 3L 3N 3P 3R 3T 3V)
+
+    vpxor       ymmF, ymmF, ymmF
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmF      ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmF      ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmD, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmF      ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmF      ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+
+    vmovdqa     ymmG, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmF      ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmG, ymmG, ymmF      ; ymmG=(30 32 34 36 38 3A 3C 3E 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vpunpcklbw  ymmF, ymmF, ymmH
+    vpunpckhbw  ymmH, ymmH, ymmH
+    vpsrlw      ymmF, ymmF, BYTE_BIT  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+    vpsrlw      ymmH, ymmH, BYTE_BIT  ; ymmH=(31 33 35 37 39 3B 3D 3F 3H 3J 3L 3N 3P 3R 3T 3V)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; ymm0=R(02468ACEGIKMOQSU)=RE, ymm2=G(02468ACEGIKMOQSU)=GE, ymm4=B(02468ACEGIKMOQSU)=BE
+    ; ymm1=R(13579BDFHJLNPRTV)=RO, ymm3=G(13579BDFHJLNPRTV)=GO, ymm5=B(13579BDFHJLNPRTV)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+
+    vmovdqa     YMMWORD [wk(0)], ymm0   ; wk(0)=RE
+    vmovdqa     YMMWORD [wk(1)], ymm1   ; wk(1)=RO
+    vmovdqa     YMMWORD [wk(2)], ymm4   ; wk(2)=BE
+    vmovdqa     YMMWORD [wk(3)], ymm5   ; wk(3)=BO
+
+    vmovdqa     ymm6, ymm1
+    vpunpcklwd  ymm1, ymm1, ymm3
+    vpunpckhwd  ymm6, ymm6, ymm3
+    vmovdqa     ymm7, ymm1
+    vmovdqa     ymm4, ymm6
+    vpmaddwd    ymm1, ymm1, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+    vpmaddwd    ymm7, ymm7, [GOTOFF(eax,PW_MF016_MF033)]  ; ymm7=ROL*-FIX(0.168)+GOL*-FIX(0.331)
+    vpmaddwd    ymm4, ymm4, [GOTOFF(eax,PW_MF016_MF033)]  ; ymm4=ROH*-FIX(0.168)+GOH*-FIX(0.331)
+
+    vmovdqa     YMMWORD [wk(4)], ymm1   ; wk(4)=ROL*FIX(0.299)+GOL*FIX(0.337)
+    vmovdqa     YMMWORD [wk(5)], ymm6   ; wk(5)=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    vpxor       ymm1, ymm1, ymm1
+    vpxor       ymm6, ymm6, ymm6
+    vpunpcklwd  ymm1, ymm1, ymm5        ; ymm1=BOL
+    vpunpckhwd  ymm6, ymm6, ymm5        ; ymm6=BOH
+    vpsrld      ymm1, ymm1, 1           ; ymm1=BOL*FIX(0.500)
+    vpsrld      ymm6, ymm6, 1           ; ymm6=BOH*FIX(0.500)
+
+    vmovdqa     ymm5, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; ymm5=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm7, ymm7, ymm1
+    vpaddd      ymm4, ymm4, ymm6
+    vpaddd      ymm7, ymm7, ymm5
+    vpaddd      ymm4, ymm4, ymm5
+    vpsrld      ymm7, ymm7, SCALEBITS   ; ymm7=CbOL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=CbOH
+    vpackssdw   ymm7, ymm7, ymm4        ; ymm7=CbO
+
+    vmovdqa     ymm1, YMMWORD [wk(2)]   ; ymm1=BE
+
+    vmovdqa     ymm6, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm2
+    vpunpckhwd  ymm6, ymm6, ymm2
+    vmovdqa     ymm5, ymm0
+    vmovdqa     ymm4, ymm6
+    vpmaddwd    ymm0, ymm0, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm6=REH*FIX(0.299)+GEH*FIX(0.337)
+    vpmaddwd    ymm5, ymm5, [GOTOFF(eax,PW_MF016_MF033)]  ; ymm5=REL*-FIX(0.168)+GEL*-FIX(0.331)
+    vpmaddwd    ymm4, ymm4, [GOTOFF(eax,PW_MF016_MF033)]  ; ymm4=REH*-FIX(0.168)+GEH*-FIX(0.331)
+
+    vmovdqa     YMMWORD [wk(6)], ymm0   ; wk(6)=REL*FIX(0.299)+GEL*FIX(0.337)
+    vmovdqa     YMMWORD [wk(7)], ymm6   ; wk(7)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    vpxor       ymm0, ymm0, ymm0
+    vpxor       ymm6, ymm6, ymm6
+    vpunpcklwd  ymm0, ymm0, ymm1        ; ymm0=BEL
+    vpunpckhwd  ymm6, ymm6, ymm1        ; ymm6=BEH
+    vpsrld      ymm0, ymm0, 1           ; ymm0=BEL*FIX(0.500)
+    vpsrld      ymm6, ymm6, 1           ; ymm6=BEH*FIX(0.500)
+
+
+    vmovdqa     ymm1, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; ymm1=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm5, ymm5, ymm0
+    vpaddd      ymm4, ymm4, ymm6
+    vpaddd      ymm5, ymm5, ymm1
+    vpaddd      ymm4, ymm4, ymm1
+    vpsrld      ymm5, ymm5, SCALEBITS   ; ymm5=CbEL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=CbEH
+    vpackssdw   ymm5, ymm5, ymm4        ; ymm5=CbE
+
+    vpsllw      ymm7, ymm7, BYTE_BIT
+    vpor        ymm5, ymm5, ymm7        ; ymm5=Cb
+    vmovdqu     YMMWORD [ebx], ymm5     ; Save Cb
+
+    vmovdqa     ymm0, YMMWORD [wk(3)]   ; ymm0=BO
+    vmovdqa     ymm6, YMMWORD [wk(2)]   ; ymm6=BE
+    vmovdqa     ymm1, YMMWORD [wk(1)]   ; ymm1=RO
+
+    vmovdqa     ymm4, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm3
+    vpunpckhwd  ymm4, ymm4, ymm3
+    vmovdqa     ymm7, ymm0
+    vmovdqa     ymm5, ymm4
+    vpmaddwd    ymm0, ymm0, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+    vpmaddwd    ymm7, ymm7, [GOTOFF(eax,PW_MF008_MF041)]  ; ymm7=BOL*-FIX(0.081)+GOL*-FIX(0.418)
+    vpmaddwd    ymm5, ymm5, [GOTOFF(eax,PW_MF008_MF041)]  ; ymm5=BOH*-FIX(0.081)+GOH*-FIX(0.418)
+
+    vmovdqa     ymm3, [GOTOFF(eax,PD_ONEHALF)]            ; ymm3=[PD_ONEHALF]
+
+    vpaddd      ymm0, ymm0, YMMWORD [wk(4)]
+    vpaddd      ymm4, ymm4, YMMWORD [wk(5)]
+    vpaddd      ymm0, ymm0, ymm3
+    vpaddd      ymm4, ymm4, ymm3
+    vpsrld      ymm0, ymm0, SCALEBITS   ; ymm0=YOL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YOH
+    vpackssdw   ymm0, ymm0, ymm4        ; ymm0=YO
+
+    vpxor       ymm3, ymm3, ymm3
+    vpxor       ymm4, ymm4, ymm4
+    vpunpcklwd  ymm3, ymm3, ymm1        ; ymm3=ROL
+    vpunpckhwd  ymm4, ymm4, ymm1        ; ymm4=ROH
+    vpsrld      ymm3, ymm3, 1           ; ymm3=ROL*FIX(0.500)
+    vpsrld      ymm4, ymm4, 1           ; ymm4=ROH*FIX(0.500)
+
+    vmovdqa     ymm1, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; ymm1=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm7, ymm7, ymm3
+    vpaddd      ymm5, ymm5, ymm4
+    vpaddd      ymm7, ymm7, ymm1
+    vpaddd      ymm5, ymm5, ymm1
+    vpsrld      ymm7, ymm7, SCALEBITS   ; ymm7=CrOL
+    vpsrld      ymm5, ymm5, SCALEBITS   ; ymm5=CrOH
+    vpackssdw   ymm7, ymm7, ymm5        ; ymm7=CrO
+
+    vmovdqa     ymm3, YMMWORD [wk(0)]   ; ymm3=RE
+
+    vmovdqa     ymm4, ymm6
+    vpunpcklwd  ymm6, ymm6, ymm2
+    vpunpckhwd  ymm4, ymm4, ymm2
+    vmovdqa     ymm1, ymm6
+    vmovdqa     ymm5, ymm4
+    vpmaddwd    ymm6, ymm6, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+    vpmaddwd    ymm1, ymm1, [GOTOFF(eax,PW_MF008_MF041)]  ; ymm1=BEL*-FIX(0.081)+GEL*-FIX(0.418)
+    vpmaddwd    ymm5, ymm5, [GOTOFF(eax,PW_MF008_MF041)]  ; ymm5=BEH*-FIX(0.081)+GEH*-FIX(0.418)
+
+    vmovdqa     ymm2, [GOTOFF(eax,PD_ONEHALF)]            ; ymm2=[PD_ONEHALF]
+
+    vpaddd      ymm6, ymm6, YMMWORD [wk(6)]
+    vpaddd      ymm4, ymm4, YMMWORD [wk(7)]
+    vpaddd      ymm6, ymm6, ymm2
+    vpaddd      ymm4, ymm4, ymm2
+    vpsrld      ymm6, ymm6, SCALEBITS   ; ymm6=YEL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YEH
+    vpackssdw   ymm6, ymm6, ymm4        ; ymm6=YE
+
+    vpsllw      ymm0, ymm0, BYTE_BIT
+    vpor        ymm6, ymm6, ymm0        ; ymm6=Y
+    vmovdqu     YMMWORD [edi], ymm6     ; Save Y
+
+    vpxor       ymm2, ymm2, ymm2
+    vpxor       ymm4, ymm4, ymm4
+    vpunpcklwd  ymm2, ymm2, ymm3        ; ymm2=REL
+    vpunpckhwd  ymm4, ymm4, ymm3        ; ymm4=REH
+    vpsrld      ymm2, ymm2, 1           ; ymm2=REL*FIX(0.500)
+    vpsrld      ymm4, ymm4, 1           ; ymm4=REH*FIX(0.500)
+
+    vmovdqa     ymm0, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; ymm0=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm1, ymm1, ymm2
+    vpaddd      ymm5, ymm5, ymm4
+    vpaddd      ymm1, ymm1, ymm0
+    vpaddd      ymm5, ymm5, ymm0
+    vpsrld      ymm1, ymm1, SCALEBITS   ; ymm1=CrEL
+    vpsrld      ymm5, ymm5, SCALEBITS   ; ymm5=CrEH
+    vpackssdw   ymm1, ymm1, ymm5        ; ymm1=CrE
+
+    vpsllw      ymm7, ymm7, BYTE_BIT
+    vpor        ymm1, ymm1, ymm7        ; ymm1=Cr
+    vmovdqu     YMMWORD [edx], ymm1     ; Save Cr
+
+    sub         ecx, byte SIZEOF_YMMWORD
+    add         esi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; inptr
+    add         edi, byte SIZEOF_YMMWORD           ; outptr0
+    add         ebx, byte SIZEOF_YMMWORD           ; outptr1
+    add         edx, byte SIZEOF_YMMWORD           ; outptr2
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    test        ecx, ecx
+    jnz         near .column_ld1
+
+    pop         ecx                     ; col
+    pop         esi
+    pop         edi
+    pop         ebx
+    pop         edx
+    poppic      eax
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         edi, byte SIZEOF_JSAMPROW
+    add         ebx, byte SIZEOF_JSAMPROW
+    add         edx, byte SIZEOF_JSAMPROW
+    dec         eax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jccolext-mmx.asm b/simd/i386/jccolext-mmx.asm
similarity index 99%
rename from simd/jccolext-mmx.asm
rename to simd/i386/jccolext-mmx.asm
index 96a0372..4748b20 100644
--- a/simd/jccolext-mmx.asm
+++ b/simd/i386/jccolext-mmx.asm
@@ -2,6 +2,7 @@
 ; jccolext.asm - colorspace conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -38,7 +39,7 @@
 %define WK_NUM          8
 %define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_rgb_ycc_convert_mmx)
 
 EXTN(jsimd_rgb_ycc_convert_mmx):
@@ -473,4 +474,4 @@ EXTN(jsimd_rgb_ycc_convert_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jccolext-sse2.asm b/simd/i386/jccolext-sse2.asm
new file mode 100644
index 0000000..611d804
--- /dev/null
+++ b/simd/i386/jccolext-sse2.asm
@@ -0,0 +1,505 @@
+;
+; jccolext.asm - colorspace conversion (SSE2)
+;
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_ycc_convert_sse2 (JDIMENSION img_width,
+;                             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                             JDIMENSION output_row, int num_rows);
+;
+
+%define img_width(b)   (b)+8            ; JDIMENSION img_width
+%define input_buf(b)   (b)+12           ; JSAMPARRAY input_buf
+%define output_buf(b)  (b)+16           ; JSAMPIMAGE output_buf
+%define output_row(b)  (b)+20           ; JDIMENSION output_row
+%define num_rows(b)    (b)+24           ; int num_rows
+
+%define original_ebp   ebp+0
+%define wk(i)          ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM         8
+%define gotptr         wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+
+    global      EXTN(jsimd_rgb_ycc_convert_sse2)
+
+EXTN(jsimd_rgb_ycc_convert_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [img_width(eax)]
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         esi, JSAMPIMAGE [output_buf(eax)]
+    mov         ecx, JDIMENSION [output_row(eax)]
+    mov         edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [esi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [esi+2*SIZEOF_JSAMPARRAY]
+    lea         edi, [edi+ecx*SIZEOF_JSAMPROW]
+    lea         ebx, [ebx+ecx*SIZEOF_JSAMPROW]
+    lea         edx, [edx+ecx*SIZEOF_JSAMPROW]
+
+    pop         ecx
+
+    mov         esi, JSAMPARRAY [input_buf(eax)]
+    mov         eax, INT [num_rows(eax)]
+    test        eax, eax
+    jle         near .return
+    alignx      16, 7
+.rowloop:
+    pushpic     eax
+    push        edx
+    push        ebx
+    push        edi
+    push        esi
+    push        ecx                     ; col
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr0
+    mov         ebx, JSAMPROW [ebx]     ; outptr1
+    mov         edx, JSAMPROW [edx]     ; outptr2
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    alignx      16, 7
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        eax
+    push        edx
+    lea         ecx, [ecx+ecx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_BYTE
+    movzx       eax, BYTE [esi+ecx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_WORD
+    movzx       edx, WORD [esi+ecx]
+    shl         eax, WORD_BIT
+    or          eax, edx
+.column_ld4:
+    movd        xmmA, eax
+    pop         edx
+    pop         eax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_DWORD
+    movd        xmmF, XMM_DWORD [esi+ecx]
+    pslldq      xmmA, SIZEOF_DWORD
+    por         xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         ecx, byte SIZEOF_MMWORD
+    movq        xmmB, XMM_MMWORD [esi+ecx]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    movdqa      xmmF, xmmA
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    mov         ecx, SIZEOF_XMMWORD
+    jmp         short .rgb_ycc_cnv
+.column_ld32:
+    test        cl, 2*SIZEOF_XMMWORD
+    mov         ecx, SIZEOF_XMMWORD
+    jz          short .rgb_ycc_cnv
+    movdqa      xmmB, xmmA
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_ycc_cnv
+    alignx      16, 7
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    movdqu      xmmB, XMMWORD [esi+2*SIZEOF_XMMWORD]
+
+.rgb_ycc_cnv:
+    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    movdqa      xmmG, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
+    psrldq      xmmG, 8     ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmF  ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
+    pslldq      xmmF, 8     ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
+
+    punpcklbw   xmmG, xmmB  ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
+    punpckhbw   xmmF, xmmB  ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
+
+    movdqa      xmmD, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
+    psrldq      xmmD, 8     ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmG  ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
+    pslldq      xmmG, 8     ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
+
+    punpcklbw   xmmD, xmmF  ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
+    punpckhbw   xmmG, xmmF  ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
+
+    movdqa      xmmE, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
+    psrldq      xmmE, 8     ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmD  ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    pslldq      xmmD, 8     ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
+
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmG  ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
+
+    pxor        xmmH, xmmH
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmH  ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmH  ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmB, xmmE
+    punpcklbw   xmmE, xmmH  ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmB, xmmH  ; xmmB=(01 03 05 07 09 0B 0D 0F)
+
+    movdqa      xmmF, xmmD
+    punpcklbw   xmmD, xmmH  ; xmmD=(11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmF, xmmH  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_XMMWORD/16
+    movd        xmmA, XMM_DWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_XMMWORD/8
+    movq        xmmE, XMM_MMWORD [esi+ecx*RGB_PIXELSIZE]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmE
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_XMMWORD/4
+    movdqa      xmmE, xmmA
+    movdqu      xmmA, XMMWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    mov         ecx, SIZEOF_XMMWORD
+    jz          short .rgb_ycc_cnv
+    movdqa      xmmF, xmmA
+    movdqa      xmmH, xmmE
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_ycc_cnv
+    alignx      16, 7
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [esi+2*SIZEOF_XMMWORD]
+    movdqu      xmmH, XMMWORD [esi+3*SIZEOF_XMMWORD]
+
+.rgb_ycc_cnv:
+    ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpcklbw   xmmA, xmmE      ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
+    punpckhbw   xmmD, xmmE      ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
+
+    movdqa      xmmC, xmmF
+    punpcklbw   xmmF, xmmH      ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
+    punpckhbw   xmmC, xmmH      ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
+
+    movdqa      xmmB, xmmA
+    punpcklwd   xmmA, xmmF      ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
+    punpckhwd   xmmB, xmmF      ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
+
+    movdqa      xmmG, xmmD
+    punpcklwd   xmmD, xmmC      ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
+    punpckhwd   xmmG, xmmC      ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
+
+    movdqa      xmmE, xmmA
+    punpcklbw   xmmA, xmmD      ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    punpckhbw   xmmE, xmmD      ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
+
+    movdqa      xmmH, xmmB
+    punpcklbw   xmmB, xmmG      ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmH, xmmG      ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
+
+    pxor        xmmF, xmmF
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmF      ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmF      ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmD, xmmB
+    punpcklbw   xmmB, xmmF      ; xmmB=(01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmF      ; xmmD=(11 13 15 17 19 1B 1D 1F)
+
+    movdqa      xmmG, xmmE
+    punpcklbw   xmmE, xmmF      ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmG, xmmF      ; xmmG=(30 32 34 36 38 3A 3C 3E)
+
+    punpcklbw   xmmF, xmmH
+    punpckhbw   xmmH, xmmH
+    psrlw       xmmF, BYTE_BIT  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+    psrlw       xmmH, BYTE_BIT  ; xmmH=(31 33 35 37 39 3B 3D 3F)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
+    ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=RE
+    movdqa      XMMWORD [wk(1)], xmm1   ; wk(1)=RO
+    movdqa      XMMWORD [wk(2)], xmm4   ; wk(2)=BE
+    movdqa      XMMWORD [wk(3)], xmm5   ; wk(3)=BO
+
+    movdqa      xmm6, xmm1
+    punpcklwd   xmm1, xmm3
+    punpckhwd   xmm6, xmm3
+    movdqa      xmm7, xmm1
+    movdqa      xmm4, xmm6
+    pmaddwd     xmm1, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    pmaddwd     xmm6, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+    pmaddwd     xmm7, [GOTOFF(eax,PW_MF016_MF033)]  ; xmm7=ROL*-FIX(0.168)+GOL*-FIX(0.331)
+    pmaddwd     xmm4, [GOTOFF(eax,PW_MF016_MF033)]  ; xmm4=ROH*-FIX(0.168)+GOH*-FIX(0.331)
+
+    movdqa      XMMWORD [wk(4)], xmm1   ; wk(4)=ROL*FIX(0.299)+GOL*FIX(0.337)
+    movdqa      XMMWORD [wk(5)], xmm6   ; wk(5)=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    pxor        xmm1, xmm1
+    pxor        xmm6, xmm6
+    punpcklwd   xmm1, xmm5              ; xmm1=BOL
+    punpckhwd   xmm6, xmm5              ; xmm6=BOH
+    psrld       xmm1, 1                 ; xmm1=BOL*FIX(0.500)
+    psrld       xmm6, 1                 ; xmm6=BOH*FIX(0.500)
+
+    movdqa      xmm5, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; xmm5=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm7, xmm1
+    paddd       xmm4, xmm6
+    paddd       xmm7, xmm5
+    paddd       xmm4, xmm5
+    psrld       xmm7, SCALEBITS         ; xmm7=CbOL
+    psrld       xmm4, SCALEBITS         ; xmm4=CbOH
+    packssdw    xmm7, xmm4              ; xmm7=CbO
+
+    movdqa      xmm1, XMMWORD [wk(2)]   ; xmm1=BE
+
+    movdqa      xmm6, xmm0
+    punpcklwd   xmm0, xmm2
+    punpckhwd   xmm6, xmm2
+    movdqa      xmm5, xmm0
+    movdqa      xmm4, xmm6
+    pmaddwd     xmm0, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    pmaddwd     xmm6, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
+    pmaddwd     xmm5, [GOTOFF(eax,PW_MF016_MF033)]  ; xmm5=REL*-FIX(0.168)+GEL*-FIX(0.331)
+    pmaddwd     xmm4, [GOTOFF(eax,PW_MF016_MF033)]  ; xmm4=REH*-FIX(0.168)+GEH*-FIX(0.331)
+
+    movdqa      XMMWORD [wk(6)], xmm0   ; wk(6)=REL*FIX(0.299)+GEL*FIX(0.337)
+    movdqa      XMMWORD [wk(7)], xmm6   ; wk(7)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    pxor        xmm0, xmm0
+    pxor        xmm6, xmm6
+    punpcklwd   xmm0, xmm1              ; xmm0=BEL
+    punpckhwd   xmm6, xmm1              ; xmm6=BEH
+    psrld       xmm0, 1                 ; xmm0=BEL*FIX(0.500)
+    psrld       xmm6, 1                 ; xmm6=BEH*FIX(0.500)
+
+    movdqa      xmm1, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; xmm1=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm5, xmm0
+    paddd       xmm4, xmm6
+    paddd       xmm5, xmm1
+    paddd       xmm4, xmm1
+    psrld       xmm5, SCALEBITS         ; xmm5=CbEL
+    psrld       xmm4, SCALEBITS         ; xmm4=CbEH
+    packssdw    xmm5, xmm4              ; xmm5=CbE
+
+    psllw       xmm7, BYTE_BIT
+    por         xmm5, xmm7              ; xmm5=Cb
+    movdqa      XMMWORD [ebx], xmm5     ; Save Cb
+
+    movdqa      xmm0, XMMWORD [wk(3)]   ; xmm0=BO
+    movdqa      xmm6, XMMWORD [wk(2)]   ; xmm6=BE
+    movdqa      xmm1, XMMWORD [wk(1)]   ; xmm1=RO
+
+    movdqa      xmm4, xmm0
+    punpcklwd   xmm0, xmm3
+    punpckhwd   xmm4, xmm3
+    movdqa      xmm7, xmm0
+    movdqa      xmm5, xmm4
+    pmaddwd     xmm0, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    pmaddwd     xmm4, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+    pmaddwd     xmm7, [GOTOFF(eax,PW_MF008_MF041)]  ; xmm7=BOL*-FIX(0.081)+GOL*-FIX(0.418)
+    pmaddwd     xmm5, [GOTOFF(eax,PW_MF008_MF041)]  ; xmm5=BOH*-FIX(0.081)+GOH*-FIX(0.418)
+
+    movdqa      xmm3, [GOTOFF(eax,PD_ONEHALF)]  ; xmm3=[PD_ONEHALF]
+
+    paddd       xmm0, XMMWORD [wk(4)]
+    paddd       xmm4, XMMWORD [wk(5)]
+    paddd       xmm0, xmm3
+    paddd       xmm4, xmm3
+    psrld       xmm0, SCALEBITS         ; xmm0=YOL
+    psrld       xmm4, SCALEBITS         ; xmm4=YOH
+    packssdw    xmm0, xmm4              ; xmm0=YO
+
+    pxor        xmm3, xmm3
+    pxor        xmm4, xmm4
+    punpcklwd   xmm3, xmm1              ; xmm3=ROL
+    punpckhwd   xmm4, xmm1              ; xmm4=ROH
+    psrld       xmm3, 1                 ; xmm3=ROL*FIX(0.500)
+    psrld       xmm4, 1                 ; xmm4=ROH*FIX(0.500)
+
+    movdqa      xmm1, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; xmm1=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm7, xmm3
+    paddd       xmm5, xmm4
+    paddd       xmm7, xmm1
+    paddd       xmm5, xmm1
+    psrld       xmm7, SCALEBITS         ; xmm7=CrOL
+    psrld       xmm5, SCALEBITS         ; xmm5=CrOH
+    packssdw    xmm7, xmm5              ; xmm7=CrO
+
+    movdqa      xmm3, XMMWORD [wk(0)]   ; xmm3=RE
+
+    movdqa      xmm4, xmm6
+    punpcklwd   xmm6, xmm2
+    punpckhwd   xmm4, xmm2
+    movdqa      xmm1, xmm6
+    movdqa      xmm5, xmm4
+    pmaddwd     xmm6, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    pmaddwd     xmm4, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+    pmaddwd     xmm1, [GOTOFF(eax,PW_MF008_MF041)]  ; xmm1=BEL*-FIX(0.081)+GEL*-FIX(0.418)
+    pmaddwd     xmm5, [GOTOFF(eax,PW_MF008_MF041)]  ; xmm5=BEH*-FIX(0.081)+GEH*-FIX(0.418)
+
+    movdqa      xmm2, [GOTOFF(eax,PD_ONEHALF)]      ; xmm2=[PD_ONEHALF]
+
+    paddd       xmm6, XMMWORD [wk(6)]
+    paddd       xmm4, XMMWORD [wk(7)]
+    paddd       xmm6, xmm2
+    paddd       xmm4, xmm2
+    psrld       xmm6, SCALEBITS         ; xmm6=YEL
+    psrld       xmm4, SCALEBITS         ; xmm4=YEH
+    packssdw    xmm6, xmm4              ; xmm6=YE
+
+    psllw       xmm0, BYTE_BIT
+    por         xmm6, xmm0              ; xmm6=Y
+    movdqa      XMMWORD [edi], xmm6     ; Save Y
+
+    pxor        xmm2, xmm2
+    pxor        xmm4, xmm4
+    punpcklwd   xmm2, xmm3              ; xmm2=REL
+    punpckhwd   xmm4, xmm3              ; xmm4=REH
+    psrld       xmm2, 1                 ; xmm2=REL*FIX(0.500)
+    psrld       xmm4, 1                 ; xmm4=REH*FIX(0.500)
+
+    movdqa      xmm0, [GOTOFF(eax,PD_ONEHALFM1_CJ)]  ; xmm0=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm1, xmm2
+    paddd       xmm5, xmm4
+    paddd       xmm1, xmm0
+    paddd       xmm5, xmm0
+    psrld       xmm1, SCALEBITS         ; xmm1=CrEL
+    psrld       xmm5, SCALEBITS         ; xmm5=CrEH
+    packssdw    xmm1, xmm5              ; xmm1=CrE
+
+    psllw       xmm7, BYTE_BIT
+    por         xmm1, xmm7              ; xmm1=Cr
+    movdqa      XMMWORD [edx], xmm1     ; Save Cr
+
+    sub         ecx, byte SIZEOF_XMMWORD
+    add         esi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
+    add         edi, byte SIZEOF_XMMWORD                ; outptr0
+    add         ebx, byte SIZEOF_XMMWORD                ; outptr1
+    add         edx, byte SIZEOF_XMMWORD                ; outptr2
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    test        ecx, ecx
+    jnz         near .column_ld1
+
+    pop         ecx                     ; col
+    pop         esi
+    pop         edi
+    pop         ebx
+    pop         edx
+    poppic      eax
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         edi, byte SIZEOF_JSAMPROW
+    add         ebx, byte SIZEOF_JSAMPROW
+    add         edx, byte SIZEOF_JSAMPROW
+    dec         eax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jccolor-avx2.asm b/simd/i386/jccolor-avx2.asm
new file mode 100644
index 0000000..9d8c56a
--- /dev/null
+++ b/simd/i386/jccolor-avx2.asm
@@ -0,0 +1,122 @@
+;
+; jccolor.asm - colorspace conversion (AVX2)
+;
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_081 equ  5329                ; FIX(0.08131)
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_168 equ 11059                ; FIX(0.16874)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_331 equ 21709                ; FIX(0.33126)
+F_0_418 equ 27439                ; FIX(0.41869)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_rgb_ycc_convert_avx2)
+
+EXTN(jconst_rgb_ycc_convert_avx2):
+
+PW_F0299_F0337  times 8 dw  F_0_299, F_0_337
+PW_F0114_F0250  times 8 dw  F_0_114, F_0_250
+PW_MF016_MF033  times 8 dw -F_0_168,-F_0_331
+PW_MF008_MF041  times 8 dw -F_0_081,-F_0_418
+PD_ONEHALFM1_CJ times 8 dd  (1 << (SCALEBITS-1)) - 1 + (CENTERJSAMPLE << SCALEBITS)
+PD_ONEHALF      times 8 dd  (1 << (SCALEBITS-1))
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extrgb_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extrgbx_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extbgr_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extbgrx_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extxbgr_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extxrgb_ycc_convert_avx2
+%include "jccolext-avx2.asm"
diff --git a/simd/jccolor-mmx.asm b/simd/i386/jccolor-mmx.asm
similarity index 97%
rename from simd/jccolor-mmx.asm
rename to simd/i386/jccolor-mmx.asm
index c4e6d88..aecdeed 100644
--- a/simd/jccolor-mmx.asm
+++ b/simd/i386/jccolor-mmx.asm
@@ -2,7 +2,7 @@
 ; jccolor.asm - colorspace conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -35,7 +35,7 @@ F_0_337 equ     (F_0_587 - F_0_250)     ; FIX(0.58700) - FIX(0.25000)
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_rgb_ycc_convert_mmx)
 
 EXTN(jconst_rgb_ycc_convert_mmx):
@@ -47,7 +47,7 @@ PW_MF008_MF041  times 2 dw -F_0_081,-F_0_418
 PD_ONEHALFM1_CJ times 2 dd  (1 << (SCALEBITS-1)) - 1 + (CENTERJSAMPLE << SCALEBITS)
 PD_ONEHALF      times 2 dd  (1 << (SCALEBITS-1))
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
diff --git a/simd/jccolor-sse2.asm b/simd/i386/jccolor-sse2.asm
similarity index 80%
rename from simd/jccolor-sse2.asm
rename to simd/i386/jccolor-sse2.asm
index 13124d1..f9b4c91 100644
--- a/simd/jccolor-sse2.asm
+++ b/simd/i386/jccolor-sse2.asm
@@ -1,7 +1,7 @@
 ;
 ; jccolor.asm - colorspace conversion (SSE2)
 ;
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -19,23 +19,23 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_081 equ      5329                   ; FIX(0.08131)
-F_0_114 equ      7471                   ; FIX(0.11400)
-F_0_168 equ     11059                   ; FIX(0.16874)
-F_0_250 equ     16384                   ; FIX(0.25000)
-F_0_299 equ     19595                   ; FIX(0.29900)
-F_0_331 equ     21709                   ; FIX(0.33126)
-F_0_418 equ     27439                   ; FIX(0.41869)
-F_0_587 equ     38470                   ; FIX(0.58700)
-F_0_337 equ     (F_0_587 - F_0_250)     ; FIX(0.58700) - FIX(0.25000)
+F_0_081 equ  5329                ; FIX(0.08131)
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_168 equ 11059                ; FIX(0.16874)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_331 equ 21709                ; FIX(0.33126)
+F_0_418 equ 27439                ; FIX(0.41869)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_rgb_ycc_convert_sse2)
+    alignz      32
+    global      EXTN(jconst_rgb_ycc_convert_sse2)
 
 EXTN(jconst_rgb_ycc_convert_sse2):
 
@@ -46,11 +46,11 @@ PW_MF008_MF041  times 4 dw -F_0_081,-F_0_418
 PD_ONEHALFM1_CJ times 4 dd  (1 << (SCALEBITS-1)) - 1 + (CENTERJSAMPLE << SCALEBITS)
 PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
+    SECTION     SEG_TEXT
+    BITS        32
 
 %include "jccolext-sse2.asm"
 
diff --git a/simd/i386/jcgray-avx2.asm b/simd/i386/jcgray-avx2.asm
new file mode 100644
index 0000000..5d78e63
--- /dev/null
+++ b/simd/i386/jcgray-avx2.asm
@@ -0,0 +1,115 @@
+;
+; jcgray.asm - grayscale colorspace conversion (AVX2)
+;
+; Copyright (C) 2011, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_rgb_gray_convert_avx2)
+
+EXTN(jconst_rgb_gray_convert_avx2):
+
+PW_F0299_F0337 times 8 dw F_0_299, F_0_337
+PW_F0114_F0250 times 8 dw F_0_114, F_0_250
+PD_ONEHALF     times 8 dd (1 << (SCALEBITS-1))
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extrgb_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extrgbx_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extbgr_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extbgrx_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extxbgr_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extxrgb_gray_convert_avx2
+%include "jcgryext-avx2.asm"
diff --git a/simd/jcgray-mmx.asm b/simd/i386/jcgray-mmx.asm
similarity index 97%
rename from simd/jcgray-mmx.asm
rename to simd/i386/jcgray-mmx.asm
index 0819b6c..48decc8 100644
--- a/simd/jcgray-mmx.asm
+++ b/simd/i386/jcgray-mmx.asm
@@ -2,7 +2,7 @@
 ; jcgray.asm - grayscale colorspace conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2011, D. R. Commander.
+; Copyright (C) 2011, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -31,7 +31,7 @@ F_0_337 equ     (F_0_587 - F_0_250)     ; FIX(0.58700) - FIX(0.25000)
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_rgb_gray_convert_mmx)
 
 EXTN(jconst_rgb_gray_convert_mmx):
@@ -40,7 +40,7 @@ PW_F0299_F0337  times 2 dw  F_0_299, F_0_337
 PW_F0114_F0250  times 2 dw  F_0_114, F_0_250
 PD_ONEHALF      times 2 dd  (1 << (SCALEBITS-1))
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
diff --git a/simd/jcgray-sse2.asm b/simd/i386/jcgray-sse2.asm
similarity index 80%
rename from simd/jcgray-sse2.asm
rename to simd/i386/jcgray-sse2.asm
index 5b0b466..dedfc8a 100644
--- a/simd/jcgray-sse2.asm
+++ b/simd/i386/jcgray-sse2.asm
@@ -1,7 +1,7 @@
 ;
 ; jcgray.asm - grayscale colorspace conversion (SSE2)
 ;
-; Copyright (C) 2011, D. R. Commander.
+; Copyright (C) 2011, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -19,31 +19,31 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_114 equ      7471                   ; FIX(0.11400)
-F_0_250 equ     16384                   ; FIX(0.25000)
-F_0_299 equ     19595                   ; FIX(0.29900)
-F_0_587 equ     38470                   ; FIX(0.58700)
-F_0_337 equ     (F_0_587 - F_0_250)     ; FIX(0.58700) - FIX(0.25000)
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_rgb_gray_convert_sse2)
+    alignz      32
+    global      EXTN(jconst_rgb_gray_convert_sse2)
 
 EXTN(jconst_rgb_gray_convert_sse2):
 
-PW_F0299_F0337  times 4 dw  F_0_299, F_0_337
-PW_F0114_F0250  times 4 dw  F_0_114, F_0_250
-PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
+PW_F0299_F0337 times 4 dw F_0_299, F_0_337
+PW_F0114_F0250 times 4 dw F_0_114, F_0_250
+PD_ONEHALF     times 4 dd (1 << (SCALEBITS-1))
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
+    SECTION     SEG_TEXT
+    BITS        32
 
 %include "jcgryext-sse2.asm"
 
diff --git a/simd/i386/jcgryext-avx2.asm b/simd/i386/jcgryext-avx2.asm
new file mode 100644
index 0000000..4f81c20
--- /dev/null
+++ b/simd/i386/jcgryext-avx2.asm
@@ -0,0 +1,459 @@
+;
+; jcgryext.asm - grayscale colorspace conversion (AVX2)
+;
+; Copyright (C) 2011, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_gray_convert_avx2 (JDIMENSION img_width,
+;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                              JDIMENSION output_row, int num_rows);
+;
+
+%define img_width(b)   (b)+8            ; JDIMENSION img_width
+%define input_buf(b)   (b)+12           ; JSAMPARRAY input_buf
+%define output_buf(b)  (b)+16           ; JSAMPIMAGE output_buf
+%define output_row(b)  (b)+20           ; JDIMENSION output_row
+%define num_rows(b)    (b)+24           ; int num_rows
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM        2
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+
+    global      EXTN(jsimd_rgb_gray_convert_avx2)
+
+EXTN(jsimd_rgb_gray_convert_avx2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [img_width(eax)]
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         esi, JSAMPIMAGE [output_buf(eax)]
+    mov         ecx, JDIMENSION [output_row(eax)]
+    mov         edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
+    lea         edi, [edi+ecx*SIZEOF_JSAMPROW]
+
+    pop         ecx
+
+    mov         esi, JSAMPARRAY [input_buf(eax)]
+    mov         eax, INT [num_rows(eax)]
+    test        eax, eax
+    jle         near .return
+    alignx      16, 7
+.rowloop:
+    pushpic     eax
+    push        edi
+    push        esi
+    push        ecx                     ; col
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr0
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    alignx      16, 7
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        eax
+    push        edx
+    lea         ecx, [ecx+ecx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_BYTE
+    movzx       eax, BYTE [esi+ecx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_WORD
+    movzx       edx, WORD [esi+ecx]
+    shl         eax, WORD_BIT
+    or          eax, edx
+.column_ld4:
+    vmovd       xmmA, eax
+    pop         edx
+    pop         eax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_DWORD
+    vmovd       xmmF, XMM_DWORD [esi+ecx]
+    vpslldq     xmmA, xmmA, SIZEOF_DWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         ecx, byte SIZEOF_MMWORD
+    vmovq       xmmB, XMM_MMWORD [esi+ecx]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    sub         ecx, byte SIZEOF_XMMWORD
+    vmovdqu     xmmB, XMM_MMWORD [esi+ecx]
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    vpor        ymmA, ymmB
+.column_ld32:
+    test        cl, SIZEOF_YMMWORD
+    jz          short .column_ld64
+    sub         ecx, byte SIZEOF_YMMWORD
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+.column_ld64:
+    test        cl, 2*SIZEOF_YMMWORD
+    mov         ecx, SIZEOF_YMMWORD
+    jz          short .rgb_gray_cnv
+    vmovdqa     ymmB, ymmA
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_gray_cnv
+    alignx      16, 7
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmB, YMMWORD [esi+2*SIZEOF_YMMWORD]
+
+.rgb_gray_cnv:
+    ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+    ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+    ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    ; ymmB=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+    ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vmovdqu     ymmC, ymmA
+    vinserti128 ymmA, ymmF, xmmA, 0  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                     ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vinserti128 ymmC, ymmC, xmmB, 0  ; ymmC=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                     ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vinserti128 ymmB, ymmB, xmmF, 0  ; ymmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                     ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+    vperm2i128  ymmF, ymmC, ymmC, 1  ; ymmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                     ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+
+    vmovdqa     ymmG, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12
+                                  ;       22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I)
+    vpsrldq     ymmG, ymmG, 8     ; ymmG=(22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I
+                                  ;       2I 0J 1J 2J 0K 1K 2K 0L -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmF  ; ymmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A
+                                  ;       0G 0O 1G 1O 2G 2O 0H 0P 1H 1P 2H 2P 0I 0Q 1I 1Q)
+    vpslldq     ymmF, ymmF, 8     ; ymmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27
+                                  ;       08 18 28 09 19 29 0A 1A 1L 2L 0M 1M 2M 0N 1N 2N)
+
+    vpunpcklbw  ymmG, ymmG, ymmB  ; ymmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D
+                                  ;       2I 2Q 0J 0R 1J 1R 2J 2R 0K 0S 1K 1S 2K 2S 0L 0T)
+    vpunpckhbw  ymmF, ymmF, ymmB  ; ymmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F
+                                  ;       1L 1T 2L 2T 0M 0U 1M 1U 2M 2U 0N 0V 1N 1V 2N 2V)
+
+    vmovdqa     ymmD, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09
+                                  ;       11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P)
+    vpsrldq     ymmD, ymmD, 8     ; ymmD=(11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P
+                                  ;       1H 1P 2H 2P 0I 0Q 1I 1Q -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmG  ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D
+                                  ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 0H 0L 0P 0T)
+    vpslldq     ymmG, ymmG, 8     ; ymmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B
+                                  ;       04 0C 14 1C 24 2C 05 0D 2I 2Q 0J 0R 1J 1R 2J 2R)
+
+    vpunpcklbw  ymmD, ymmD, ymmF  ; ymmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E
+                                  ;       1H 1L 1P 1T 2H 2L 2P 2T 0I 0M 0Q 0U 1I 1M 1Q 1U)
+    vpunpckhbw  ymmG, ymmG, ymmF  ; ymmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F
+                                  ;       2I 2M 2Q 2U 0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V)
+
+    vmovdqa     ymmE, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C
+                                  ;       20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S)
+    vpsrldq     ymmE, ymmE, 8     ; ymmE=(20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S
+                                  ;       2G 2K 2O 2S 0H 0L 0P 0T -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmD  ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                  ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpslldq     ymmD, ymmD, 8     ; ymmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D
+                                  ;       02 06 0A 0E 12 16 1A 1E 1H 1L 1P 1T 2H 2L 2P 2T)
+
+    vpunpcklbw  ymmE, ymmE, ymmG  ; ymmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F
+                                  ;       2G 2I 2K 2M 2O 2Q 2S 2U 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmG  ; ymmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F
+                                  ;       1H 1J 1L 1N 1P 1R 1T 1V 2H 2J 2L 2N 2P 2R 2T 2V)
+
+    vpxor       ymmH, ymmH, ymmH
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmH  ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmH  ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmB, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmH  ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmB, ymmB, ymmH  ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+
+    vmovdqa     ymmF, ymmD
+    vpunpcklbw  ymmD, ymmD, ymmH  ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmF, ymmF, ymmH  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_XMMWORD/16
+    vmovd       xmmA, XMM_DWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_XMMWORD/8
+    vmovq       xmmF, XMM_MMWORD [esi+ecx*RGB_PIXELSIZE]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_XMMWORD/4
+    vmovdqa     xmmF, xmmA
+    vperm2i128  ymmF, ymmF, ymmF, 1
+    vmovdqu     xmmA, XMMWORD [esi+ecx*RGB_PIXELSIZE]
+    vpor        ymmA, ymmA, ymmF
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    jz          short .column_ld16
+    sub         ecx, byte SIZEOF_XMMWORD/2
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    mov         ecx, SIZEOF_YMMWORD
+    jz          short .rgb_gray_cnv
+    vmovdqa     ymmE, ymmA
+    vmovdqa     ymmH, ymmF
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_gray_cnv
+    alignx      16, 7
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmE, YMMWORD [esi+2*SIZEOF_YMMWORD]
+    vmovdqu     ymmH, YMMWORD [esi+3*SIZEOF_YMMWORD]
+
+.rgb_gray_cnv:
+    ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+    ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+    ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    ; ymmE=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+    ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+    ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmB, ymmA
+    vinserti128 ymmA, ymmA, xmmE, 1     ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vperm2i128  ymmE, ymmB, ymmE, 0x31  ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+
+    vmovdqa     ymmB, ymmF
+    vinserti128 ymmF, ymmF, xmmH, 1     ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+    vperm2i128  ymmH, ymmB, ymmH, 0x31  ; ymmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmD, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmE      ; ymmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35
+                                      ;       0G 0K 1G 1K 2G 2K 3G 3K 0H 0L 1H 1L 2H 2L 3H 3L)
+    vpunpckhbw  ymmD, ymmD, ymmE      ; ymmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37
+                                      ;       0I 0M 1I 1M 2I 2M 3I 3M 0J 0N 1J 1N 2J 2N 3J 3N)
+
+    vmovdqa     ymmC, ymmF
+    vpunpcklbw  ymmF, ymmF, ymmH      ; ymmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D
+                                      ;       0O 0S 1O 1S 2O 2S 3O 3S 0P 0T 1P 1T 2P 2T 3P 3T)
+    vpunpckhbw  ymmC, ymmC, ymmH      ; ymmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F
+                                      ;       0Q 0U 1Q 1U 2Q 2U 3Q 3U 0R 0V 1R 1V 2R 2V 3R 3V)
+
+    vmovdqa     ymmB, ymmA
+    vpunpcklwd  ymmA, ymmA, ymmF      ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C
+                                      ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 3G 3K 3O 3S)
+    vpunpckhwd  ymmB, ymmB, ymmF      ; ymmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D
+                                      ;       0H 0L 0P 0T 1H 1L 1P 1T 2H 2L 2P 2T 3H 3L 3P 3T)
+
+    vmovdqa     ymmG, ymmD
+    vpunpcklwd  ymmD, ymmD, ymmC      ; ymmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E
+                                      ;       0I 0M 0Q 0U 1I 1M 1Q 1U 2I 2M 2Q 2U 3I 3M 3Q 3U)
+    vpunpckhwd  ymmG, ymmG, ymmC      ; ymmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F
+                                      ;       0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V 3J 3N 3R 3V)
+
+    vmovdqa     ymmE, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmD      ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                      ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpunpckhbw  ymmE, ymmE, ymmD      ; ymmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E
+                                      ;       2G 2I 2K 2M 2O 2Q 2S 2U 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vmovdqa     ymmH, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmG      ; ymmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F
+                                      ;       0H 0J 0L 0N 0P 0R 0T 0V 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmH, ymmH, ymmG      ; ymmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F
+                                      ;       2H 2J 2L 2N 2P 2R 2T 2V 3H 3J 3L 3N 3P 3R 3T 3V)
+
+    vpxor       ymmF, ymmF, ymmF
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmF      ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmF      ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmD, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmF      ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmF      ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+
+    vmovdqa     ymmG, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmF      ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmG, ymmG, ymmF      ; ymmG=(30 32 34 36 38 3A 3C 3E 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vpunpcklbw  ymmF, ymmF, ymmH
+    vpunpckhbw  ymmH, ymmH, ymmH
+    vpsrlw      ymmF, ymmF, BYTE_BIT  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+    vpsrlw      ymmH, ymmH, BYTE_BIT  ; ymmH=(31 33 35 37 39 3B 3D 3F 3H 3J 3L 3N 3P 3R 3T 3V)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; ymm0=R(02468ACEGIKMOQSU)=RE, ymm2=G(02468ACEGIKMOQSU)=GE, ymm4=B(02468ACEGIKMOQSU)=BE
+    ; ymm1=R(13579BDFHJLNPRTV)=RO, ymm3=G(13579BDFHJLNPRTV)=GO, ymm5=B(13579BDFHJLNPRTV)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+
+    vmovdqa     ymm6, ymm1
+    vpunpcklwd  ymm1, ymm1, ymm3
+    vpunpckhwd  ymm6, ymm6, ymm3
+    vpmaddwd    ymm1, ymm1, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    vmovdqa     ymm7, ymm6              ; ymm7=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    vmovdqa     ymm6, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm2
+    vpunpckhwd  ymm6, ymm6, ymm2
+    vpmaddwd    ymm0, ymm0, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [GOTOFF(eax,PW_F0299_F0337)]  ; ymm6=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    vmovdqa     YMMWORD [wk(0)], ymm0   ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
+    vmovdqa     YMMWORD [wk(1)], ymm6   ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    vmovdqa     ymm0, ymm5              ; ymm0=BO
+    vmovdqa     ymm6, ymm4              ; ymm6=BE
+
+    vmovdqa     ymm4, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm3
+    vpunpckhwd  ymm4, ymm4, ymm3
+    vpmaddwd    ymm0, ymm0, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+
+    vmovdqa     ymm3, [GOTOFF(eax,PD_ONEHALF)]            ; ymm3=[PD_ONEHALF]
+
+    vpaddd      ymm0, ymm0, ymm1
+    vpaddd      ymm4, ymm4, ymm7
+    vpaddd      ymm0, ymm0, ymm3
+    vpaddd      ymm4, ymm4, ymm3
+    vpsrld      ymm0, ymm0, SCALEBITS   ; ymm0=YOL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YOH
+    vpackssdw   ymm0, ymm0, ymm4        ; ymm0=YO
+
+    vmovdqa     ymm4, ymm6
+    vpunpcklwd  ymm6, ymm6, ymm2
+    vpunpckhwd  ymm4, ymm4, ymm2
+    vpmaddwd    ymm6, ymm6, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [GOTOFF(eax,PW_F0114_F0250)]  ; ymm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+
+    vmovdqa     ymm2, [GOTOFF(eax,PD_ONEHALF)]            ; ymm2=[PD_ONEHALF]
+
+    vpaddd      ymm6, ymm6, YMMWORD [wk(0)]
+    vpaddd      ymm4, ymm4, YMMWORD [wk(1)]
+    vpaddd      ymm6, ymm6, ymm2
+    vpaddd      ymm4, ymm4, ymm2
+    vpsrld      ymm6, ymm6, SCALEBITS   ; ymm6=YEL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YEH
+    vpackssdw   ymm6, ymm6, ymm4        ; ymm6=YE
+
+    vpsllw      ymm0, ymm0, BYTE_BIT
+    vpor        ymm6, ymm6, ymm0        ; ymm6=Y
+    vmovdqu     YMMWORD [edi], ymm6     ; Save Y
+
+    sub         ecx, byte SIZEOF_YMMWORD
+    add         esi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; inptr
+    add         edi, byte SIZEOF_YMMWORD           ; outptr0
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    test        ecx, ecx
+    jnz         near .column_ld1
+
+    pop         ecx                     ; col
+    pop         esi
+    pop         edi
+    poppic      eax
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         edi, byte SIZEOF_JSAMPROW
+    dec         eax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jcgryext-mmx.asm b/simd/i386/jcgryext-mmx.asm
similarity index 99%
rename from simd/jcgryext-mmx.asm
rename to simd/i386/jcgryext-mmx.asm
index 1c1b8d8..841eb0b 100644
--- a/simd/jcgryext-mmx.asm
+++ b/simd/i386/jcgryext-mmx.asm
@@ -2,7 +2,7 @@
 ; jcgryext.asm - grayscale colorspace conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2011, D. R. Commander.
+; Copyright (C) 2011, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -39,7 +39,7 @@
 %define WK_NUM          2
 %define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_rgb_gray_convert_mmx)
 
 EXTN(jsimd_rgb_gray_convert_mmx):
@@ -353,4 +353,4 @@ EXTN(jsimd_rgb_gray_convert_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jcgryext-sse2.asm b/simd/i386/jcgryext-sse2.asm
new file mode 100644
index 0000000..40505a5
--- /dev/null
+++ b/simd/i386/jcgryext-sse2.asm
@@ -0,0 +1,384 @@
+;
+; jcgryext.asm - grayscale colorspace conversion (SSE2)
+;
+; Copyright (C) 2011, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_gray_convert_sse2 (JDIMENSION img_width,
+;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                              JDIMENSION output_row, int num_rows);
+;
+
+%define img_width(b)   (b)+8            ; JDIMENSION img_width
+%define input_buf(b)   (b)+12           ; JSAMPARRAY input_buf
+%define output_buf(b)  (b)+16           ; JSAMPIMAGE output_buf
+%define output_row(b)  (b)+20           ; JDIMENSION output_row
+%define num_rows(b)    (b)+24           ; int num_rows
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+
+    global      EXTN(jsimd_rgb_gray_convert_sse2)
+
+EXTN(jsimd_rgb_gray_convert_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [img_width(eax)]
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         esi, JSAMPIMAGE [output_buf(eax)]
+    mov         ecx, JDIMENSION [output_row(eax)]
+    mov         edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
+    lea         edi, [edi+ecx*SIZEOF_JSAMPROW]
+
+    pop         ecx
+
+    mov         esi, JSAMPARRAY [input_buf(eax)]
+    mov         eax, INT [num_rows(eax)]
+    test        eax, eax
+    jle         near .return
+    alignx      16, 7
+.rowloop:
+    pushpic     eax
+    push        edi
+    push        esi
+    push        ecx                     ; col
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr0
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    alignx      16, 7
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        eax
+    push        edx
+    lea         ecx, [ecx+ecx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_BYTE
+    movzx       eax, BYTE [esi+ecx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_WORD
+    movzx       edx, WORD [esi+ecx]
+    shl         eax, WORD_BIT
+    or          eax, edx
+.column_ld4:
+    movd        xmmA, eax
+    pop         edx
+    pop         eax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_DWORD
+    movd        xmmF, XMM_DWORD [esi+ecx]
+    pslldq      xmmA, SIZEOF_DWORD
+    por         xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         ecx, byte SIZEOF_MMWORD
+    movq        xmmB, XMM_MMWORD [esi+ecx]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    movdqa      xmmF, xmmA
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    mov         ecx, SIZEOF_XMMWORD
+    jmp         short .rgb_gray_cnv
+.column_ld32:
+    test        cl, 2*SIZEOF_XMMWORD
+    mov         ecx, SIZEOF_XMMWORD
+    jz          short .rgb_gray_cnv
+    movdqa      xmmB, xmmA
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_gray_cnv
+    alignx      16, 7
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    movdqu      xmmB, XMMWORD [esi+2*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    movdqa      xmmG, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
+    psrldq      xmmG, 8     ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmF  ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
+    pslldq      xmmF, 8     ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
+
+    punpcklbw   xmmG, xmmB  ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
+    punpckhbw   xmmF, xmmB  ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
+
+    movdqa      xmmD, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
+    psrldq      xmmD, 8     ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmG  ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
+    pslldq      xmmG, 8     ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
+
+    punpcklbw   xmmD, xmmF  ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
+    punpckhbw   xmmG, xmmF  ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
+
+    movdqa      xmmE, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
+    psrldq      xmmE, 8     ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmD  ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    pslldq      xmmD, 8     ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
+
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmG  ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
+
+    pxor        xmmH, xmmH
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmH  ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmH  ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmB, xmmE
+    punpcklbw   xmmE, xmmH  ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmB, xmmH  ; xmmB=(01 03 05 07 09 0B 0D 0F)
+
+    movdqa      xmmF, xmmD
+    punpcklbw   xmmD, xmmH  ; xmmD=(11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmF, xmmH  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         ecx, byte SIZEOF_XMMWORD/16
+    movd        xmmA, XMM_DWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         ecx, byte SIZEOF_XMMWORD/8
+    movq        xmmE, XMM_MMWORD [esi+ecx*RGB_PIXELSIZE]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmE
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         ecx, byte SIZEOF_XMMWORD/4
+    movdqa      xmmE, xmmA
+    movdqu      xmmA, XMMWORD [esi+ecx*RGB_PIXELSIZE]
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    mov         ecx, SIZEOF_XMMWORD
+    jz          short .rgb_gray_cnv
+    movdqa      xmmF, xmmA
+    movdqa      xmmH, xmmE
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_gray_cnv
+    alignx      16, 7
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [esi+2*SIZEOF_XMMWORD]
+    movdqu      xmmH, XMMWORD [esi+3*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpcklbw   xmmA, xmmE      ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
+    punpckhbw   xmmD, xmmE      ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
+
+    movdqa      xmmC, xmmF
+    punpcklbw   xmmF, xmmH      ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
+    punpckhbw   xmmC, xmmH      ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
+
+    movdqa      xmmB, xmmA
+    punpcklwd   xmmA, xmmF      ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
+    punpckhwd   xmmB, xmmF      ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
+
+    movdqa      xmmG, xmmD
+    punpcklwd   xmmD, xmmC      ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
+    punpckhwd   xmmG, xmmC      ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
+
+    movdqa      xmmE, xmmA
+    punpcklbw   xmmA, xmmD      ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    punpckhbw   xmmE, xmmD      ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
+
+    movdqa      xmmH, xmmB
+    punpcklbw   xmmB, xmmG      ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmH, xmmG      ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
+
+    pxor        xmmF, xmmF
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmF      ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmF      ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmD, xmmB
+    punpcklbw   xmmB, xmmF      ; xmmB=(01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmF      ; xmmD=(11 13 15 17 19 1B 1D 1F)
+
+    movdqa      xmmG, xmmE
+    punpcklbw   xmmE, xmmF      ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmG, xmmF      ; xmmG=(30 32 34 36 38 3A 3C 3E)
+
+    punpcklbw   xmmF, xmmH
+    punpckhbw   xmmH, xmmH
+    psrlw       xmmF, BYTE_BIT  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+    psrlw       xmmH, BYTE_BIT  ; xmmH=(31 33 35 37 39 3B 3D 3F)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
+    ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+
+    movdqa      xmm6, xmm1
+    punpcklwd   xmm1, xmm3
+    punpckhwd   xmm6, xmm3
+    pmaddwd     xmm1, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    pmaddwd     xmm6, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa      xmm7, xmm6              ; xmm7=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa      xmm6, xmm0
+    punpcklwd   xmm0, xmm2
+    punpckhwd   xmm6, xmm2
+    pmaddwd     xmm0, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    pmaddwd     xmm6, [GOTOFF(eax,PW_F0299_F0337)]  ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa      xmm0, xmm5              ; xmm0=BO
+    movdqa      xmm6, xmm4              ; xmm6=BE
+
+    movdqa      xmm4, xmm0
+    punpcklwd   xmm0, xmm3
+    punpckhwd   xmm4, xmm3
+    pmaddwd     xmm0, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    pmaddwd     xmm4, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+
+    movdqa      xmm3, [GOTOFF(eax,PD_ONEHALF)]      ; xmm3=[PD_ONEHALF]
+
+    paddd       xmm0, xmm1
+    paddd       xmm4, xmm7
+    paddd       xmm0, xmm3
+    paddd       xmm4, xmm3
+    psrld       xmm0, SCALEBITS         ; xmm0=YOL
+    psrld       xmm4, SCALEBITS         ; xmm4=YOH
+    packssdw    xmm0, xmm4              ; xmm0=YO
+
+    movdqa      xmm4, xmm6
+    punpcklwd   xmm6, xmm2
+    punpckhwd   xmm4, xmm2
+    pmaddwd     xmm6, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    pmaddwd     xmm4, [GOTOFF(eax,PW_F0114_F0250)]  ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+
+    movdqa      xmm2, [GOTOFF(eax,PD_ONEHALF)]      ; xmm2=[PD_ONEHALF]
+
+    paddd       xmm6, XMMWORD [wk(0)]
+    paddd       xmm4, XMMWORD [wk(1)]
+    paddd       xmm6, xmm2
+    paddd       xmm4, xmm2
+    psrld       xmm6, SCALEBITS         ; xmm6=YEL
+    psrld       xmm4, SCALEBITS         ; xmm4=YEH
+    packssdw    xmm6, xmm4              ; xmm6=YE
+
+    psllw       xmm0, BYTE_BIT
+    por         xmm6, xmm0              ; xmm6=Y
+    movdqa      XMMWORD [edi], xmm6     ; Save Y
+
+    sub         ecx, byte SIZEOF_XMMWORD
+    add         esi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
+    add         edi, byte SIZEOF_XMMWORD                ; outptr0
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    test        ecx, ecx
+    jnz         near .column_ld1
+
+    pop         ecx                     ; col
+    pop         esi
+    pop         edi
+    poppic      eax
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         edi, byte SIZEOF_JSAMPROW
+    dec         eax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jchuff-sse2.asm b/simd/i386/jchuff-sse2.asm
new file mode 100644
index 0000000..c018c87
--- /dev/null
+++ b/simd/i386/jchuff-sse2.asm
@@ -0,0 +1,426 @@
+;
+; jchuff-sse2.asm - Huffman entropy encoding (SSE2)
+;
+; Copyright (C) 2009-2011, 2014-2016, D. R. Commander.
+; Copyright (C) 2015, Matthieu Darbois.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains an SSE2 implementation for Huffman coding of one block.
+; The following code is based directly on jchuff.c; see jchuff.c for more
+; details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_huff_encode_one_block)
+
+EXTN(jconst_huff_encode_one_block):
+
+%include "jpeg_nbits_table.inc"
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+
+; These macros perform the same task as the emit_bits() function in the
+; original libjpeg code.  In addition to reducing overhead by explicitly
+; inlining the code, additional performance is achieved by taking into
+; account the size of the bit buffer and waiting until it is almost full
+; before emptying it.  This mostly benefits 64-bit platforms, since 6
+; bytes can be stored in a 64-bit bit buffer before it has to be emptied.
+
+%macro EMIT_BYTE 0
+    sub         put_bits, 8             ; put_bits -= 8;
+    mov         edx, put_buffer
+    mov         ecx, put_bits
+    shr         edx, cl                 ; c = (JOCTET)GETJOCTET(put_buffer >> put_bits);
+    mov         byte [eax], dl          ; *buffer++ = c;
+    add         eax, 1
+    cmp         dl, 0xFF                ; need to stuff a zero byte?
+    jne         %%.EMIT_BYTE_END
+    mov         byte [eax], 0           ; *buffer++ = 0;
+    add         eax, 1
+%%.EMIT_BYTE_END:
+%endmacro
+
+%macro PUT_BITS 1
+    add         put_bits, ecx           ; put_bits += size;
+    shl         put_buffer, cl          ; put_buffer = (put_buffer << size);
+    or          put_buffer, %1
+%endmacro
+
+%macro CHECKBUF15 0
+    cmp         put_bits, 16            ; if (put_bits > 31) {
+    jl          %%.CHECKBUF15_END
+    mov         eax, POINTER [esp+buffer]
+    EMIT_BYTE
+    EMIT_BYTE
+    mov         POINTER [esp+buffer], eax
+%%.CHECKBUF15_END:
+%endmacro
+
+%macro EMIT_BITS 1
+    PUT_BITS    %1
+    CHECKBUF15
+%endmacro
+
+%macro kloop_prepare 37                 ;(ko, jno0, ..., jno31, xmm0, xmm1, xmm2, xmm3)
+    pxor        xmm4, xmm4              ; __m128i neg = _mm_setzero_si128();
+    pxor        xmm5, xmm5              ; __m128i neg = _mm_setzero_si128();
+    pxor        xmm6, xmm6              ; __m128i neg = _mm_setzero_si128();
+    pxor        xmm7, xmm7              ; __m128i neg = _mm_setzero_si128();
+    pinsrw      %34, word [esi + %2  * SIZEOF_WORD], 0  ; xmm_shadow[0] = block[jno0];
+    pinsrw      %35, word [esi + %10 * SIZEOF_WORD], 0  ; xmm_shadow[8] = block[jno8];
+    pinsrw      %36, word [esi + %18 * SIZEOF_WORD], 0  ; xmm_shadow[16] = block[jno16];
+    pinsrw      %37, word [esi + %26 * SIZEOF_WORD], 0  ; xmm_shadow[24] = block[jno24];
+    pinsrw      %34, word [esi + %3  * SIZEOF_WORD], 1  ; xmm_shadow[1] = block[jno1];
+    pinsrw      %35, word [esi + %11 * SIZEOF_WORD], 1  ; xmm_shadow[9] = block[jno9];
+    pinsrw      %36, word [esi + %19 * SIZEOF_WORD], 1  ; xmm_shadow[17] = block[jno17];
+    pinsrw      %37, word [esi + %27 * SIZEOF_WORD], 1  ; xmm_shadow[25] = block[jno25];
+    pinsrw      %34, word [esi + %4  * SIZEOF_WORD], 2  ; xmm_shadow[2] = block[jno2];
+    pinsrw      %35, word [esi + %12 * SIZEOF_WORD], 2  ; xmm_shadow[10] = block[jno10];
+    pinsrw      %36, word [esi + %20 * SIZEOF_WORD], 2  ; xmm_shadow[18] = block[jno18];
+    pinsrw      %37, word [esi + %28 * SIZEOF_WORD], 2  ; xmm_shadow[26] = block[jno26];
+    pinsrw      %34, word [esi + %5  * SIZEOF_WORD], 3  ; xmm_shadow[3] = block[jno3];
+    pinsrw      %35, word [esi + %13 * SIZEOF_WORD], 3  ; xmm_shadow[11] = block[jno11];
+    pinsrw      %36, word [esi + %21 * SIZEOF_WORD], 3  ; xmm_shadow[19] = block[jno19];
+    pinsrw      %37, word [esi + %29 * SIZEOF_WORD], 3  ; xmm_shadow[27] = block[jno27];
+    pinsrw      %34, word [esi + %6  * SIZEOF_WORD], 4  ; xmm_shadow[4] = block[jno4];
+    pinsrw      %35, word [esi + %14 * SIZEOF_WORD], 4  ; xmm_shadow[12] = block[jno12];
+    pinsrw      %36, word [esi + %22 * SIZEOF_WORD], 4  ; xmm_shadow[20] = block[jno20];
+    pinsrw      %37, word [esi + %30 * SIZEOF_WORD], 4  ; xmm_shadow[28] = block[jno28];
+    pinsrw      %34, word [esi + %7  * SIZEOF_WORD], 5  ; xmm_shadow[5] = block[jno5];
+    pinsrw      %35, word [esi + %15 * SIZEOF_WORD], 5  ; xmm_shadow[13] = block[jno13];
+    pinsrw      %36, word [esi + %23 * SIZEOF_WORD], 5  ; xmm_shadow[21] = block[jno21];
+    pinsrw      %37, word [esi + %31 * SIZEOF_WORD], 5  ; xmm_shadow[29] = block[jno29];
+    pinsrw      %34, word [esi + %8  * SIZEOF_WORD], 6  ; xmm_shadow[6] = block[jno6];
+    pinsrw      %35, word [esi + %16 * SIZEOF_WORD], 6  ; xmm_shadow[14] = block[jno14];
+    pinsrw      %36, word [esi + %24 * SIZEOF_WORD], 6  ; xmm_shadow[22] = block[jno22];
+    pinsrw      %37, word [esi + %32 * SIZEOF_WORD], 6  ; xmm_shadow[30] = block[jno30];
+    pinsrw      %34, word [esi + %9  * SIZEOF_WORD], 7  ; xmm_shadow[7] = block[jno7];
+    pinsrw      %35, word [esi + %17 * SIZEOF_WORD], 7  ; xmm_shadow[15] = block[jno15];
+    pinsrw      %36, word [esi + %25 * SIZEOF_WORD], 7  ; xmm_shadow[23] = block[jno23];
+%if %1 != 32
+    pinsrw      %37, word [esi + %33 * SIZEOF_WORD], 7  ; xmm_shadow[31] = block[jno31];
+%else
+    pinsrw      %37, ecx, 7             ; xmm_shadow[31] = block[jno31];
+%endif
+    pcmpgtw     xmm4, %34               ; neg = _mm_cmpgt_epi16(neg, x1);
+    pcmpgtw     xmm5, %35               ; neg = _mm_cmpgt_epi16(neg, x1);
+    pcmpgtw     xmm6, %36               ; neg = _mm_cmpgt_epi16(neg, x1);
+    pcmpgtw     xmm7, %37               ; neg = _mm_cmpgt_epi16(neg, x1);
+    paddw       %34, xmm4               ; x1 = _mm_add_epi16(x1, neg);
+    paddw       %35, xmm5               ; x1 = _mm_add_epi16(x1, neg);
+    paddw       %36, xmm6               ; x1 = _mm_add_epi16(x1, neg);
+    paddw       %37, xmm7               ; x1 = _mm_add_epi16(x1, neg);
+    pxor        %34, xmm4               ; x1 = _mm_xor_si128(x1, neg);
+    pxor        %35, xmm5               ; x1 = _mm_xor_si128(x1, neg);
+    pxor        %36, xmm6               ; x1 = _mm_xor_si128(x1, neg);
+    pxor        %37, xmm7               ; x1 = _mm_xor_si128(x1, neg);
+    pxor        xmm4, %34               ; neg = _mm_xor_si128(neg, x1);
+    pxor        xmm5, %35               ; neg = _mm_xor_si128(neg, x1);
+    pxor        xmm6, %36               ; neg = _mm_xor_si128(neg, x1);
+    pxor        xmm7, %37               ; neg = _mm_xor_si128(neg, x1);
+    movdqa      XMMWORD [esp + t1 + %1 * SIZEOF_WORD], %34          ; _mm_storeu_si128((__m128i *)(t1 + ko), x1);
+    movdqa      XMMWORD [esp + t1 + (%1 + 8) * SIZEOF_WORD], %35    ; _mm_storeu_si128((__m128i *)(t1 + ko + 8), x1);
+    movdqa      XMMWORD [esp + t1 + (%1 + 16) * SIZEOF_WORD], %36   ; _mm_storeu_si128((__m128i *)(t1 + ko + 16), x1);
+    movdqa      XMMWORD [esp + t1 + (%1 + 24) * SIZEOF_WORD], %37   ; _mm_storeu_si128((__m128i *)(t1 + ko + 24), x1);
+    movdqa      XMMWORD [esp + t2 + %1 * SIZEOF_WORD], xmm4         ; _mm_storeu_si128((__m128i *)(t2 + ko), neg);
+    movdqa      XMMWORD [esp + t2 + (%1 + 8) * SIZEOF_WORD], xmm5   ; _mm_storeu_si128((__m128i *)(t2 + ko + 8), neg);
+    movdqa      XMMWORD [esp + t2 + (%1 + 16) * SIZEOF_WORD], xmm6  ; _mm_storeu_si128((__m128i *)(t2 + ko + 16), neg);
+    movdqa      XMMWORD [esp + t2 + (%1 + 24) * SIZEOF_WORD], xmm7  ; _mm_storeu_si128((__m128i *)(t2 + ko + 24), neg);
+%endmacro
+
+;
+; Encode a single block's worth of coefficients.
+;
+; GLOBAL(JOCTET*)
+; jsimd_huff_encode_one_block_sse2 (working_state *state, JOCTET *buffer,
+;                                   JCOEFPTR block, int last_dc_val,
+;                                   c_derived_tbl *dctbl, c_derived_tbl *actbl)
+;
+
+; eax + 8 = working_state *state
+; eax + 12 = JOCTET *buffer
+; eax + 16 = JCOEFPTR block
+; eax + 20 = int last_dc_val
+; eax + 24 = c_derived_tbl *dctbl
+; eax + 28 = c_derived_tbl *actbl
+
+%define pad         6*SIZEOF_DWORD      ; Align to 16 bytes
+%define t1          pad
+%define t2          t1+(DCTSIZE2*SIZEOF_WORD)
+%define block       t2+(DCTSIZE2*SIZEOF_WORD)
+%define actbl       block+SIZEOF_DWORD
+%define buffer      actbl+SIZEOF_DWORD
+%define temp        buffer+SIZEOF_DWORD
+%define temp2       temp+SIZEOF_DWORD
+%define temp3       temp2+SIZEOF_DWORD
+%define temp4       temp3+SIZEOF_DWORD
+%define temp5       temp4+SIZEOF_DWORD
+%define gotptr      temp5+SIZEOF_DWORD  ; void *gotptr
+%define put_buffer  ebx
+%define put_bits    edi
+
+    align       32
+    global      EXTN(jsimd_huff_encode_one_block_sse2)
+
+EXTN(jsimd_huff_encode_one_block_sse2):
+    push        ebp
+    mov         eax,esp                        ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)    ; align to 128 bits
+    mov         [esp],eax
+    mov         ebp,esp                        ; ebp = aligned ebp
+    sub         esp, temp5+9*SIZEOF_DWORD-pad
+    push        ebx
+    push        ecx
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+    push        ebp
+
+    mov         esi, POINTER [eax+8]       ; (working_state *state)
+    mov         put_buffer, DWORD [esi+8]  ; put_buffer = state->cur.put_buffer;
+    mov         put_bits, DWORD [esi+12]   ; put_bits = state->cur.put_bits;
+    push        esi                        ; esi is now scratch
+
+    get_GOT     edx                        ; get GOT address
+    movpic      POINTER [esp+gotptr], edx  ; save GOT address
+
+    mov         ecx, POINTER [eax+28]
+    mov         edx, POINTER [eax+16]
+    mov         esi, POINTER [eax+12]
+    mov         POINTER [esp+actbl], ecx
+    mov         POINTER [esp+block], edx
+    mov         POINTER [esp+buffer], esi
+
+    ; Encode the DC coefficient difference per section F.1.2.1
+    mov         esi, POINTER [esp+block]  ; block
+    movsx       ecx, word [esi]           ; temp = temp2 = block[0] - last_dc_val;
+    sub         ecx, DWORD [eax+20]
+    mov         esi, ecx
+
+    ; This is a well-known technique for obtaining the absolute value
+    ; with out a branch.  It is derived from an assembly language technique
+    ; presented in "How to Optimize for the Pentium Processors",
+    ; Copyright (c) 1996, 1997 by Agner Fog.
+    mov         edx, ecx
+    sar         edx, 31                 ; temp3 = temp >> (CHAR_BIT * sizeof(int) - 1);
+    xor         ecx, edx                ; temp ^= temp3;
+    sub         ecx, edx                ; temp -= temp3;
+
+    ; For a negative input, want temp2 = bitwise complement of abs(input)
+    ; This code assumes we are on a two's complement machine
+    add         esi, edx                ; temp2 += temp3;
+    mov         DWORD [esp+temp], esi   ; backup temp2 in temp
+
+    ; Find the number of bits needed for the magnitude of the coefficient
+    movpic      ebp, POINTER [esp+gotptr]                        ; load GOT address (ebp)
+    movzx       edx, byte [GOTOFF(ebp, jpeg_nbits_table + ecx)]  ; nbits = JPEG_NBITS(temp);
+    mov         DWORD [esp+temp2], edx                           ; backup nbits in temp2
+
+    ; Emit the Huffman-coded symbol for the number of bits
+    mov         ebp, POINTER [eax+24]         ; After this point, arguments are not accessible anymore
+    mov         eax,  INT [ebp + edx * 4]     ; code = dctbl->ehufco[nbits];
+    movzx       ecx, byte [ebp + edx + 1024]  ; size = dctbl->ehufsi[nbits];
+    EMIT_BITS   eax                           ; EMIT_BITS(code, size)
+
+    mov         ecx, DWORD [esp+temp2]        ; restore nbits
+
+    ; Mask off any extra bits in code
+    mov         eax, 1
+    shl         eax, cl
+    dec         eax
+    and         eax, DWORD [esp+temp]   ; temp2 &= (((JLONG) 1)<<nbits) - 1;
+
+    ; Emit that number of bits of the value, if positive,
+    ; or the complement of its magnitude, if negative.
+    EMIT_BITS   eax                     ; EMIT_BITS(temp2, nbits)
+
+    ; Prepare data
+    xor         ecx, ecx
+    mov         esi, POINTER [esp+block]
+    kloop_prepare  0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, \
+                   18, 11, 4,  5,  12, 19, 26, 33, 40, 48, 41, 34, \
+                   27, 20, 13, 6,  7,  14, 21, 28, 35, \
+                   xmm0, xmm1, xmm2, xmm3
+    kloop_prepare  32, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, \
+                   30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, \
+                   53, 60, 61, 54, 47, 55, 62, 63, 63, \
+                   xmm0, xmm1, xmm2, xmm3
+
+    pxor        xmm7, xmm7
+    movdqa      xmm0, XMMWORD [esp + t1 + 0 * SIZEOF_WORD]   ; __m128i tmp0 = _mm_loadu_si128((__m128i *)(t1 + 0));
+    movdqa      xmm1, XMMWORD [esp + t1 + 8 * SIZEOF_WORD]   ; __m128i tmp1 = _mm_loadu_si128((__m128i *)(t1 + 8));
+    movdqa      xmm2, XMMWORD [esp + t1 + 16 * SIZEOF_WORD]  ; __m128i tmp2 = _mm_loadu_si128((__m128i *)(t1 + 16));
+    movdqa      xmm3, XMMWORD [esp + t1 + 24 * SIZEOF_WORD]  ; __m128i tmp3 = _mm_loadu_si128((__m128i *)(t1 + 24));
+    pcmpeqw     xmm0, xmm7              ; tmp0 = _mm_cmpeq_epi16(tmp0, zero);
+    pcmpeqw     xmm1, xmm7              ; tmp1 = _mm_cmpeq_epi16(tmp1, zero);
+    pcmpeqw     xmm2, xmm7              ; tmp2 = _mm_cmpeq_epi16(tmp2, zero);
+    pcmpeqw     xmm3, xmm7              ; tmp3 = _mm_cmpeq_epi16(tmp3, zero);
+    packsswb    xmm0, xmm1              ; tmp0 = _mm_packs_epi16(tmp0, tmp1);
+    packsswb    xmm2, xmm3              ; tmp2 = _mm_packs_epi16(tmp2, tmp3);
+    pmovmskb    edx, xmm0               ; index  = ((uint64_t)_mm_movemask_epi8(tmp0)) << 0;
+    pmovmskb    ecx, xmm2               ; index  = ((uint64_t)_mm_movemask_epi8(tmp2)) << 16;
+    shl         ecx, 16
+    or          edx, ecx
+    not         edx                     ; index = ~index;
+
+    lea         esi, [esp+t1]
+    mov         ebp, POINTER [esp+actbl]  ; ebp = actbl
+
+.BLOOP:
+    bsf         ecx, edx                ; r = __builtin_ctzl(index);
+    jz          .ELOOP
+    lea         esi, [esi+ecx*2]        ; k += r;
+    shr         edx, cl                 ; index >>= r;
+    mov         DWORD [esp+temp3], edx
+.BRLOOP:
+    cmp         ecx, 16                       ; while (r > 15) {
+    jl          .ERLOOP
+    sub         ecx, 16                       ; r -= 16;
+    mov         DWORD [esp+temp], ecx
+    mov         eax, INT [ebp + 240 * 4]      ; code_0xf0 = actbl->ehufco[0xf0];
+    movzx       ecx, byte [ebp + 1024 + 240]  ; size_0xf0 = actbl->ehufsi[0xf0];
+    EMIT_BITS   eax                           ; EMIT_BITS(code_0xf0, size_0xf0)
+    mov         ecx, DWORD [esp+temp]
+    jmp         .BRLOOP
+.ERLOOP:
+    movsx       eax, word [esi]                                  ; temp = t1[k];
+    movpic      edx, POINTER [esp+gotptr]                        ; load GOT address (edx)
+    movzx       eax, byte [GOTOFF(edx, jpeg_nbits_table + eax)]  ; nbits = JPEG_NBITS(temp);
+    mov         DWORD [esp+temp2], eax
+    ; Emit Huffman symbol for run length / number of bits
+    shl         ecx, 4                        ; temp3 = (r << 4) + nbits;
+    add         ecx, eax
+    mov         eax,  INT [ebp + ecx * 4]     ; code = actbl->ehufco[temp3];
+    movzx       ecx, byte [ebp + ecx + 1024]  ; size = actbl->ehufsi[temp3];
+    EMIT_BITS   eax
+
+    movsx       edx, word [esi+DCTSIZE2*2]    ; temp2 = t2[k];
+    ; Mask off any extra bits in code
+    mov         ecx, DWORD [esp+temp2]
+    mov         eax, 1
+    shl         eax, cl
+    dec         eax
+    and         eax, edx                ; temp2 &= (((JLONG) 1)<<nbits) - 1;
+    EMIT_BITS   eax                     ; PUT_BITS(temp2, nbits)
+    mov         edx, DWORD [esp+temp3]
+    add         esi, 2                  ; ++k;
+    shr         edx, 1                  ; index >>= 1;
+
+    jmp         .BLOOP
+.ELOOP:
+    movdqa      xmm0, XMMWORD [esp + t1 + 32 * SIZEOF_WORD]  ; __m128i tmp0 = _mm_loadu_si128((__m128i *)(t1 + 0));
+    movdqa      xmm1, XMMWORD [esp + t1 + 40 * SIZEOF_WORD]  ; __m128i tmp1 = _mm_loadu_si128((__m128i *)(t1 + 8));
+    movdqa      xmm2, XMMWORD [esp + t1 + 48 * SIZEOF_WORD]  ; __m128i tmp2 = _mm_loadu_si128((__m128i *)(t1 + 16));
+    movdqa      xmm3, XMMWORD [esp + t1 + 56 * SIZEOF_WORD]  ; __m128i tmp3 = _mm_loadu_si128((__m128i *)(t1 + 24));
+    pcmpeqw     xmm0, xmm7              ; tmp0 = _mm_cmpeq_epi16(tmp0, zero);
+    pcmpeqw     xmm1, xmm7              ; tmp1 = _mm_cmpeq_epi16(tmp1, zero);
+    pcmpeqw     xmm2, xmm7              ; tmp2 = _mm_cmpeq_epi16(tmp2, zero);
+    pcmpeqw     xmm3, xmm7              ; tmp3 = _mm_cmpeq_epi16(tmp3, zero);
+    packsswb    xmm0, xmm1              ; tmp0 = _mm_packs_epi16(tmp0, tmp1);
+    packsswb    xmm2, xmm3              ; tmp2 = _mm_packs_epi16(tmp2, tmp3);
+    pmovmskb    edx, xmm0               ; index  = ((uint64_t)_mm_movemask_epi8(tmp0)) << 0;
+    pmovmskb    ecx, xmm2               ; index  = ((uint64_t)_mm_movemask_epi8(tmp2)) << 16;
+    shl         ecx, 16
+    or          edx, ecx
+    not         edx                     ; index = ~index;
+
+    lea         eax, [esp + t1 + (DCTSIZE2/2) * 2]
+    sub         eax, esi
+    shr         eax, 1
+    bsf         ecx, edx                ; r = __builtin_ctzl(index);
+    jz          .ELOOP2
+    shr         edx, cl                 ; index >>= r;
+    add         ecx, eax
+    lea         esi, [esi+ecx*2]        ; k += r;
+    mov         DWORD [esp+temp3], edx
+    jmp         .BRLOOP2
+.BLOOP2:
+    bsf         ecx, edx                ; r = __builtin_ctzl(index);
+    jz          .ELOOP2
+    lea         esi, [esi+ecx*2]        ; k += r;
+    shr         edx, cl                 ; index >>= r;
+    mov         DWORD [esp+temp3], edx
+.BRLOOP2:
+    cmp         ecx, 16                       ; while (r > 15) {
+    jl          .ERLOOP2
+    sub         ecx, 16                       ; r -= 16;
+    mov         DWORD [esp+temp], ecx
+    mov         eax, INT [ebp + 240 * 4]      ; code_0xf0 = actbl->ehufco[0xf0];
+    movzx       ecx, byte [ebp + 1024 + 240]  ; size_0xf0 = actbl->ehufsi[0xf0];
+    EMIT_BITS   eax                           ; EMIT_BITS(code_0xf0, size_0xf0)
+    mov         ecx, DWORD [esp+temp]
+    jmp         .BRLOOP2
+.ERLOOP2:
+    movsx       eax, word [esi]         ; temp = t1[k];
+    bsr         eax, eax                ; nbits = 32 - __builtin_clz(temp);
+    inc         eax
+    mov         DWORD [esp+temp2], eax
+    ; Emit Huffman symbol for run length / number of bits
+    shl         ecx, 4                        ; temp3 = (r << 4) + nbits;
+    add         ecx, eax
+    mov         eax,  INT [ebp + ecx * 4]     ; code = actbl->ehufco[temp3];
+    movzx       ecx, byte [ebp + ecx + 1024]  ; size = actbl->ehufsi[temp3];
+    EMIT_BITS   eax
+
+    movsx       edx, word [esi+DCTSIZE2*2]    ; temp2 = t2[k];
+    ; Mask off any extra bits in code
+    mov         ecx, DWORD [esp+temp2]
+    mov         eax, 1
+    shl         eax, cl
+    dec         eax
+    and         eax, edx                ; temp2 &= (((JLONG) 1)<<nbits) - 1;
+    EMIT_BITS   eax                     ; PUT_BITS(temp2, nbits)
+    mov         edx, DWORD [esp+temp3]
+    add         esi, 2                  ; ++k;
+    shr         edx, 1                  ; index >>= 1;
+
+    jmp         .BLOOP2
+.ELOOP2:
+    ; If the last coef(s) were zero, emit an end-of-block code
+    lea         edx, [esp + t1 + (DCTSIZE2-1) * 2]  ; r = DCTSIZE2-1-k;
+    cmp         edx, esi                            ; if (r > 0) {
+    je          .EFN
+    mov         eax,  INT [ebp]                     ; code = actbl->ehufco[0];
+    movzx       ecx, byte [ebp + 1024]              ; size = actbl->ehufsi[0];
+    EMIT_BITS   eax
+.EFN:
+    mov         eax, [esp+buffer]
+    pop         esi
+    ; Save put_buffer & put_bits
+    mov         DWORD [esi+8], put_buffer  ; state->cur.put_buffer = put_buffer;
+    mov         DWORD [esi+12], put_bits   ; state->cur.put_bits = put_bits;
+
+    pop         ebp
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+    pop         ecx
+    pop         ebx
+    mov         esp,ebp                 ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jcsample-avx2.asm b/simd/i386/jcsample-avx2.asm
new file mode 100644
index 0000000..9efd415
--- /dev/null
+++ b/simd/i386/jcsample-avx2.asm
@@ -0,0 +1,388 @@
+;
+; jcsample.asm - downsampling (AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2015, Intel Corporation.
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Downsample pixel values of a single component.
+; This version handles the common case of 2:1 horizontal and 1:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v1_downsample_avx2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+%define img_width(b)    (b)+8           ; JDIMENSION image_width
+%define max_v_samp(b)   (b)+12          ; int max_v_samp_factor
+%define v_samp(b)       (b)+16          ; JDIMENSION v_samp_factor
+%define width_blks(b)   (b)+20          ; JDIMENSION width_blocks
+%define input_data(b)   (b)+24          ; JSAMPARRAY input_data
+%define output_data(b)  (b)+28          ; JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v1_downsample_avx2)
+
+EXTN(jsimd_h2v1_downsample_avx2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         ecx, JDIMENSION [width_blks(ebp)]
+    shl         ecx, 3                  ; imul ecx,DCTSIZE (ecx = output_cols)
+    jz          near .return
+
+    mov         edx, JDIMENSION [img_width(ebp)]
+
+    ; -- expand_right_edge
+
+    push        ecx
+    shl         ecx, 1                  ; output_cols * 2
+    sub         ecx, edx
+    jle         short .expand_end
+
+    mov         eax, INT [max_v_samp(ebp)]
+    test        eax, eax
+    jle         short .expand_end
+
+    cld
+    mov         esi, JSAMPARRAY [input_data(ebp)]  ; input_data
+    alignx      16, 7
+.expandloop:
+    push        eax
+    push        ecx
+
+    mov         edi, JSAMPROW [esi]
+    add         edi, edx
+    mov         al, JSAMPLE [edi-1]
+
+    rep stosb
+
+    pop         ecx
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW
+    dec         eax
+    jg          short .expandloop
+
+.expand_end:
+    pop         ecx                     ; output_cols
+
+    ; -- h2v1_downsample
+
+    mov         eax, JDIMENSION [v_samp(ebp)]  ; rowctr
+    test        eax, eax
+    jle         near .return
+
+    mov         edx, 0x00010000         ; bias pattern
+    vmovd       xmm7, edx
+    vpshufd     xmm7, xmm7, 0x00        ; xmm7={0, 1, 0, 1, 0, 1, 0, 1}
+    vperm2i128  ymm7, ymm7, ymm7, 0     ; ymm7={xmm7, xmm7}
+    vpcmpeqw    ymm6, ymm6, ymm6
+    vpsrlw      ymm6, ymm6, BYTE_BIT    ; ymm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]   ; input_data
+    mov         edi, JSAMPARRAY [output_data(ebp)]  ; output_data
+    alignx      16, 7
+.rowloop:
+    push        ecx
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         short .columnloop
+    alignx      16, 7
+
+.columnloop_r24:
+    ; ecx can possibly be 8, 16, 24
+    cmp         ecx, 24
+    jne         .columnloop_r16
+    vmovdqu     ymm0, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     xmm1, XMMWORD [esi+1*SIZEOF_YMMWORD]
+    mov         ecx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r16:
+    cmp         ecx, 16
+    jne         .columnloop_r8
+    vmovdqu     ymm0, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vpxor       ymm1, ymm1, ymm1
+    mov         ecx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r8:
+    vmovdqu     xmm0, XMMWORD[esi+0*SIZEOF_YMMWORD]
+    vpxor       ymm1, ymm1, ymm1
+    mov         ecx, SIZEOF_YMMWORD
+    jmp         short .downsample
+    alignx      16, 7
+
+.columnloop:
+    vmovdqu     ymm0, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [esi+1*SIZEOF_YMMWORD]
+
+.downsample:
+    vpsrlw      ymm2, ymm0, BYTE_BIT
+    vpand       ymm0, ymm0, ymm6
+    vpsrlw      ymm3, ymm1, BYTE_BIT
+    vpand       ymm1, ymm1, ymm6
+
+    vpaddw      ymm0, ymm0, ymm2
+    vpaddw      ymm1, ymm1, ymm3
+    vpaddw      ymm0, ymm0, ymm7
+    vpaddw      ymm1, ymm1, ymm7
+    vpsrlw      ymm0, ymm0, 1
+    vpsrlw      ymm1, ymm1, 1
+
+    vpackuswb   ymm0, ymm0, ymm1
+    vpermq      ymm0, ymm0, 0xd8
+
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymm0
+
+    sub         ecx, byte SIZEOF_YMMWORD    ; outcol
+    add         esi, byte 2*SIZEOF_YMMWORD  ; inptr
+    add         edi, byte 1*SIZEOF_YMMWORD  ; outptr
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         short .columnloop
+    test        ecx, ecx
+    jnz         near .columnloop_r24
+
+    pop         esi
+    pop         edi
+    pop         ecx
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         eax                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Downsample pixel values of a single component.
+; This version handles the standard case of 2:1 horizontal and 2:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v2_downsample_avx2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+%define img_width(b)    (b)+8           ; JDIMENSION image_width
+%define max_v_samp(b)   (b)+12          ; int max_v_samp_factor
+%define v_samp(b)       (b)+16          ; JDIMENSION v_samp_factor
+%define width_blks(b)   (b)+20          ; JDIMENSION width_blocks
+%define input_data(b)   (b)+24          ; JSAMPARRAY input_data
+%define output_data(b)  (b)+28          ; JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v2_downsample_avx2)
+
+EXTN(jsimd_h2v2_downsample_avx2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         ecx, JDIMENSION [width_blks(ebp)]
+    shl         ecx, 3                  ; imul ecx,DCTSIZE (ecx = output_cols)
+    jz          near .return
+
+    mov         edx, JDIMENSION [img_width(ebp)]
+
+    ; -- expand_right_edge
+
+    push        ecx
+    shl         ecx, 1                  ; output_cols * 2
+    sub         ecx, edx
+    jle         short .expand_end
+
+    mov         eax, INT [max_v_samp(ebp)]
+    test        eax, eax
+    jle         short .expand_end
+
+    cld
+    mov         esi, JSAMPARRAY [input_data(ebp)]  ; input_data
+    alignx      16, 7
+.expandloop:
+    push        eax
+    push        ecx
+
+    mov         edi, JSAMPROW [esi]
+    add         edi, edx
+    mov         al, JSAMPLE [edi-1]
+
+    rep stosb
+
+    pop         ecx
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW
+    dec         eax
+    jg          short .expandloop
+
+.expand_end:
+    pop         ecx                     ; output_cols
+
+    ; -- h2v2_downsample
+
+    mov         eax, JDIMENSION [v_samp(ebp)]  ; rowctr
+    test        eax, eax
+    jle         near .return
+
+    mov         edx, 0x00020001         ; bias pattern
+    vmovd       xmm7, edx
+    vpcmpeqw    ymm6, ymm6, ymm6
+    vpshufd     xmm7, xmm7, 0x00        ; ymm7={1, 2, 1, 2, 1, 2, 1, 2}
+    vperm2i128  ymm7, ymm7, ymm7, 0
+    vpsrlw      ymm6, ymm6, BYTE_BIT    ; ymm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]   ; input_data
+    mov         edi, JSAMPARRAY [output_data(ebp)]  ; output_data
+    alignx      16, 7
+.rowloop:
+    push        ecx
+    push        edi
+    push        esi
+
+    mov         edx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]  ; inptr1
+    mov         edi, JSAMPROW [edi]                    ; outptr
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         short .columnloop
+    alignx      16, 7
+
+.columnloop_r24:
+    cmp         ecx, 24
+    jne         .columnloop_r16
+    vmovdqu     ymm0, YMMWORD [edx+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     xmm2, XMMWORD [edx+1*SIZEOF_YMMWORD]
+    vmovdqu     xmm3, XMMWORD [esi+1*SIZEOF_YMMWORD]
+    mov         ecx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r16:
+    cmp         ecx, 16
+    jne         .columnloop_r8
+    vmovdqu     ymm0, YMMWORD [edx+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vpxor       ymm2, ymm2, ymm2
+    vpxor       ymm3, ymm3, ymm3
+    mov         ecx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r8:
+    vmovdqu     xmm0, XMMWORD [edx+0*SIZEOF_XMMWORD]
+    vmovdqu     xmm1, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    vpxor       ymm2, ymm2, ymm2
+    vpxor       ymm3, ymm3, ymm3
+    mov         ecx, SIZEOF_YMMWORD
+    jmp         short .downsample
+    alignx      16, 7
+
+.columnloop:
+    vmovdqu     ymm0, YMMWORD [edx+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm2, YMMWORD [edx+1*SIZEOF_YMMWORD]
+    vmovdqu     ymm3, YMMWORD [esi+1*SIZEOF_YMMWORD]
+
+.downsample:
+    vpand       ymm4, ymm0, ymm6
+    vpsrlw      ymm0, ymm0, BYTE_BIT
+    vpand       ymm5, ymm1, ymm6
+    vpsrlw      ymm1, ymm1, BYTE_BIT
+    vpaddw      ymm0, ymm0, ymm4
+    vpaddw      ymm1, ymm1, ymm5
+
+    vpand       ymm4, ymm2, ymm6
+    vpsrlw      ymm2, ymm2, BYTE_BIT
+    vpand       ymm5, ymm3, ymm6
+    vpsrlw      ymm3, ymm3, BYTE_BIT
+    vpaddw      ymm2, ymm2, ymm4
+    vpaddw      ymm3, ymm3, ymm5
+
+    vpaddw      ymm0, ymm0, ymm1
+    vpaddw      ymm2, ymm2, ymm3
+    vpaddw      ymm0, ymm0, ymm7
+    vpaddw      ymm2, ymm2, ymm7
+    vpsrlw      ymm0, ymm0, 2
+    vpsrlw      ymm2, ymm2, 2
+
+    vpackuswb   ymm0, ymm0, ymm2
+    vpermq      ymm0, ymm0, 0xd8
+
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymm0
+
+    sub         ecx, byte SIZEOF_YMMWORD    ; outcol
+    add         edx, byte 2*SIZEOF_YMMWORD  ; inptr0
+    add         esi, byte 2*SIZEOF_YMMWORD  ; inptr1
+    add         edi, byte 1*SIZEOF_YMMWORD  ; outptr
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    test        ecx, ecx
+    jnz         near .columnloop_r24
+
+    pop         esi
+    pop         edi
+    pop         ecx
+
+    add         esi, byte 2*SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte 1*SIZEOF_JSAMPROW  ; output_data
+    dec         eax                          ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jcsample-mmx.asm b/simd/i386/jcsample-mmx.asm
similarity index 99%
rename from simd/jcsample-mmx.asm
rename to simd/i386/jcsample-mmx.asm
index 6cd544e..2fa6a1a 100644
--- a/simd/jcsample-mmx.asm
+++ b/simd/i386/jcsample-mmx.asm
@@ -2,6 +2,7 @@
 ; jcsample.asm - downsampling (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -38,7 +39,7 @@
 %define input_data(b)   (b)+24          ; JSAMPARRAY input_data
 %define output_data(b)  (b)+28          ; JSAMPARRAY output_data
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v1_downsample_mmx)
 
 EXTN(jsimd_h2v1_downsample_mmx):
@@ -180,7 +181,7 @@ EXTN(jsimd_h2v1_downsample_mmx):
 %define input_data(b)   (b)+24          ; JSAMPARRAY input_data
 %define output_data(b)  (b)+28          ; JSAMPARRAY output_data
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v2_downsample_mmx)
 
 EXTN(jsimd_h2v2_downsample_mmx):
@@ -320,4 +321,4 @@ EXTN(jsimd_h2v2_downsample_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jcsample-sse2.asm b/simd/i386/jcsample-sse2.asm
new file mode 100644
index 0000000..3d34ab9
--- /dev/null
+++ b/simd/i386/jcsample-sse2.asm
@@ -0,0 +1,351 @@
+;
+; jcsample.asm - downsampling (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Downsample pixel values of a single component.
+; This version handles the common case of 2:1 horizontal and 1:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v1_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+%define img_width(b)    (b)+8           ; JDIMENSION image_width
+%define max_v_samp(b)   (b)+12          ; int max_v_samp_factor
+%define v_samp(b)       (b)+16          ; JDIMENSION v_samp_factor
+%define width_blks(b)   (b)+20          ; JDIMENSION width_blocks
+%define input_data(b)   (b)+24          ; JSAMPARRAY input_data
+%define output_data(b)  (b)+28          ; JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v1_downsample_sse2)
+
+EXTN(jsimd_h2v1_downsample_sse2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         ecx, JDIMENSION [width_blks(ebp)]
+    shl         ecx, 3                  ; imul ecx,DCTSIZE (ecx = output_cols)
+    jz          near .return
+
+    mov         edx, JDIMENSION [img_width(ebp)]
+
+    ; -- expand_right_edge
+
+    push        ecx
+    shl         ecx, 1                  ; output_cols * 2
+    sub         ecx, edx
+    jle         short .expand_end
+
+    mov         eax, INT [max_v_samp(ebp)]
+    test        eax, eax
+    jle         short .expand_end
+
+    cld
+    mov         esi, JSAMPARRAY [input_data(ebp)]  ; input_data
+    alignx      16, 7
+.expandloop:
+    push        eax
+    push        ecx
+
+    mov         edi, JSAMPROW [esi]
+    add         edi, edx
+    mov         al, JSAMPLE [edi-1]
+
+    rep stosb
+
+    pop         ecx
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW
+    dec         eax
+    jg          short .expandloop
+
+.expand_end:
+    pop         ecx                     ; output_cols
+
+    ; -- h2v1_downsample
+
+    mov         eax, JDIMENSION [v_samp(ebp)]  ; rowctr
+    test        eax, eax
+    jle         near .return
+
+    mov         edx, 0x00010000         ; bias pattern
+    movd        xmm7, edx
+    pcmpeqw     xmm6, xmm6
+    pshufd      xmm7, xmm7, 0x00        ; xmm7={0, 1, 0, 1, 0, 1, 0, 1}
+    psrlw       xmm6, BYTE_BIT          ; xmm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]   ; input_data
+    mov         edi, JSAMPARRAY [output_data(ebp)]  ; output_data
+    alignx      16, 7
+.rowloop:
+    push        ecx
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         short .columnloop
+    alignx      16, 7
+
+.columnloop_r8:
+    movdqa      xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    pxor        xmm1, xmm1
+    mov         ecx, SIZEOF_XMMWORD
+    jmp         short .downsample
+    alignx      16, 7
+
+.columnloop:
+    movdqa      xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqa      xmm1, XMMWORD [esi+1*SIZEOF_XMMWORD]
+
+.downsample:
+    movdqa      xmm2, xmm0
+    movdqa      xmm3, xmm1
+
+    pand        xmm0, xmm6
+    psrlw       xmm2, BYTE_BIT
+    pand        xmm1, xmm6
+    psrlw       xmm3, BYTE_BIT
+
+    paddw       xmm0, xmm2
+    paddw       xmm1, xmm3
+    paddw       xmm0, xmm7
+    paddw       xmm1, xmm7
+    psrlw       xmm0, 1
+    psrlw       xmm1, 1
+
+    packuswb    xmm0, xmm1
+
+    movdqa      XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
+
+    sub         ecx, byte SIZEOF_XMMWORD    ; outcol
+    add         esi, byte 2*SIZEOF_XMMWORD  ; inptr
+    add         edi, byte 1*SIZEOF_XMMWORD  ; outptr
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         short .columnloop
+    test        ecx, ecx
+    jnz         short .columnloop_r8
+
+    pop         esi
+    pop         edi
+    pop         ecx
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         eax                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Downsample pixel values of a single component.
+; This version handles the standard case of 2:1 horizontal and 2:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v2_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+%define img_width(b)    (b)+8           ; JDIMENSION image_width
+%define max_v_samp(b)   (b)+12          ; int max_v_samp_factor
+%define v_samp(b)       (b)+16          ; JDIMENSION v_samp_factor
+%define width_blks(b)   (b)+20          ; JDIMENSION width_blocks
+%define input_data(b)   (b)+24          ; JSAMPARRAY input_data
+%define output_data(b)  (b)+28          ; JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v2_downsample_sse2)
+
+EXTN(jsimd_h2v2_downsample_sse2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         ecx, JDIMENSION [width_blks(ebp)]
+    shl         ecx, 3                  ; imul ecx,DCTSIZE (ecx = output_cols)
+    jz          near .return
+
+    mov         edx, JDIMENSION [img_width(ebp)]
+
+    ; -- expand_right_edge
+
+    push        ecx
+    shl         ecx, 1                  ; output_cols * 2
+    sub         ecx, edx
+    jle         short .expand_end
+
+    mov         eax, INT [max_v_samp(ebp)]
+    test        eax, eax
+    jle         short .expand_end
+
+    cld
+    mov         esi, JSAMPARRAY [input_data(ebp)]  ; input_data
+    alignx      16, 7
+.expandloop:
+    push        eax
+    push        ecx
+
+    mov         edi, JSAMPROW [esi]
+    add         edi, edx
+    mov         al, JSAMPLE [edi-1]
+
+    rep stosb
+
+    pop         ecx
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW
+    dec         eax
+    jg          short .expandloop
+
+.expand_end:
+    pop         ecx                     ; output_cols
+
+    ; -- h2v2_downsample
+
+    mov         eax, JDIMENSION [v_samp(ebp)]  ; rowctr
+    test        eax, eax
+    jle         near .return
+
+    mov         edx, 0x00020001         ; bias pattern
+    movd        xmm7, edx
+    pcmpeqw     xmm6, xmm6
+    pshufd      xmm7, xmm7, 0x00        ; xmm7={1, 2, 1, 2, 1, 2, 1, 2}
+    psrlw       xmm6, BYTE_BIT          ; xmm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]   ; input_data
+    mov         edi, JSAMPARRAY [output_data(ebp)]  ; output_data
+    alignx      16, 7
+.rowloop:
+    push        ecx
+    push        edi
+    push        esi
+
+    mov         edx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]  ; inptr1
+    mov         edi, JSAMPROW [edi]                    ; outptr
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         short .columnloop
+    alignx      16, 7
+
+.columnloop_r8:
+    movdqa      xmm0, XMMWORD [edx+0*SIZEOF_XMMWORD]
+    movdqa      xmm1, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    pxor        xmm2, xmm2
+    pxor        xmm3, xmm3
+    mov         ecx, SIZEOF_XMMWORD
+    jmp         short .downsample
+    alignx      16, 7
+
+.columnloop:
+    movdqa      xmm0, XMMWORD [edx+0*SIZEOF_XMMWORD]
+    movdqa      xmm1, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqa      xmm2, XMMWORD [edx+1*SIZEOF_XMMWORD]
+    movdqa      xmm3, XMMWORD [esi+1*SIZEOF_XMMWORD]
+
+.downsample:
+    movdqa      xmm4, xmm0
+    movdqa      xmm5, xmm1
+    pand        xmm0, xmm6
+    psrlw       xmm4, BYTE_BIT
+    pand        xmm1, xmm6
+    psrlw       xmm5, BYTE_BIT
+    paddw       xmm0, xmm4
+    paddw       xmm1, xmm5
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm5, xmm3
+    pand        xmm2, xmm6
+    psrlw       xmm4, BYTE_BIT
+    pand        xmm3, xmm6
+    psrlw       xmm5, BYTE_BIT
+    paddw       xmm2, xmm4
+    paddw       xmm3, xmm5
+
+    paddw       xmm0, xmm1
+    paddw       xmm2, xmm3
+    paddw       xmm0, xmm7
+    paddw       xmm2, xmm7
+    psrlw       xmm0, 2
+    psrlw       xmm2, 2
+
+    packuswb    xmm0, xmm2
+
+    movdqa      XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
+
+    sub         ecx, byte SIZEOF_XMMWORD    ; outcol
+    add         edx, byte 2*SIZEOF_XMMWORD  ; inptr0
+    add         esi, byte 2*SIZEOF_XMMWORD  ; inptr1
+    add         edi, byte 1*SIZEOF_XMMWORD  ; outptr
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    test        ecx, ecx
+    jnz         near .columnloop_r8
+
+    pop         esi
+    pop         edi
+    pop         ecx
+
+    add         esi, byte 2*SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte 1*SIZEOF_JSAMPROW  ; output_data
+    dec         eax                          ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jdcolext-avx2.asm b/simd/i386/jdcolext-avx2.asm
new file mode 100644
index 0000000..1222b77
--- /dev/null
+++ b/simd/i386/jdcolext-avx2.asm
@@ -0,0 +1,516 @@
+;
+; jdcolext.asm - colorspace conversion (AVX2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2012, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_ycc_rgb_convert_avx2 (JDIMENSION out_width,
+;                             JSAMPIMAGE input_buf, JDIMENSION input_row,
+;                             JSAMPARRAY output_buf, int num_rows)
+;
+
+%define out_width(b)   (b)+8            ; JDIMENSION out_width
+%define input_buf(b)   (b)+12           ; JSAMPIMAGE input_buf
+%define input_row(b)   (b)+16           ; JDIMENSION input_row
+%define output_buf(b)  (b)+20           ; JSAMPARRAY output_buf
+%define num_rows(b)    (b)+24           ; int num_rows
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM        2
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+    global      EXTN(jsimd_ycc_rgb_convert_avx2)
+
+EXTN(jsimd_ycc_rgb_convert_avx2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [out_width(eax)]  ; num_cols
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         edi, JSAMPIMAGE [input_buf(eax)]
+    mov         ecx, JDIMENSION [input_row(eax)]
+    mov         esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
+    lea         esi, [esi+ecx*SIZEOF_JSAMPROW]
+    lea         ebx, [ebx+ecx*SIZEOF_JSAMPROW]
+    lea         edx, [edx+ecx*SIZEOF_JSAMPROW]
+
+    pop         ecx
+
+    mov         edi, JSAMPARRAY [output_buf(eax)]
+    mov         eax, INT [num_rows(eax)]
+    test        eax, eax
+    jle         near .return
+    alignx      16, 7
+.rowloop:
+    push        eax
+    push        edi
+    push        edx
+    push        ebx
+    push        esi
+    push        ecx                     ; col
+
+    mov         esi, JSAMPROW [esi]     ; inptr0
+    mov         ebx, JSAMPROW [ebx]     ; inptr1
+    mov         edx, JSAMPROW [edx]     ; inptr2
+    mov         edi, JSAMPROW [edi]     ; outptr
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+    alignx      16, 7
+.columnloop:
+
+    vmovdqu     ymm5, YMMWORD [ebx]     ; ymm5=Cb(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+    vmovdqu     ymm1, YMMWORD [edx]     ; ymm1=Cr(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpcmpeqw    ymm0, ymm0, ymm0
+    vpcmpeqw    ymm7, ymm7, ymm7
+    vpsrlw      ymm0, ymm0, BYTE_BIT    ; ymm0={0xFF 0x00 0xFF 0x00 ..}
+    vpsllw      ymm7, ymm7, 7           ; ymm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    vpand       ymm4, ymm0, ymm5        ; ymm4=Cb(02468ACEGIKMOQSU)=CbE
+    vpsrlw      ymm5, ymm5, BYTE_BIT    ; ymm5=Cb(13579BDFHJLNPRTV)=CbO
+    vpand       ymm0, ymm0, ymm1        ; ymm0=Cr(02468ACEGIKMOQSU)=CrE
+    vpsrlw      ymm1, ymm1, BYTE_BIT    ; ymm1=Cr(13579BDFHJLNPRTV)=CrO
+
+    vpaddw      ymm2, ymm4, ymm7
+    vpaddw      ymm3, ymm5, ymm7
+    vpaddw      ymm6, ymm0, ymm7
+    vpaddw      ymm7, ymm1, ymm7
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    vpaddw      ymm4, ymm2, ymm2                     ; ymm4=2*CbE
+    vpaddw      ymm5, ymm3, ymm3                     ; ymm5=2*CbO
+    vpaddw      ymm0, ymm6, ymm6                     ; ymm0=2*CrE
+    vpaddw      ymm1, ymm7, ymm7                     ; ymm1=2*CrO
+
+    vpmulhw     ymm4, ymm4, [GOTOFF(eax,PW_MF0228)]  ; ymm4=(2*CbE * -FIX(0.22800))
+    vpmulhw     ymm5, ymm5, [GOTOFF(eax,PW_MF0228)]  ; ymm5=(2*CbO * -FIX(0.22800))
+    vpmulhw     ymm0, ymm0, [GOTOFF(eax,PW_F0402)]   ; ymm0=(2*CrE * FIX(0.40200))
+    vpmulhw     ymm1, ymm1, [GOTOFF(eax,PW_F0402)]   ; ymm1=(2*CrO * FIX(0.40200))
+
+    vpaddw      ymm4, ymm4, [GOTOFF(eax,PW_ONE)]
+    vpaddw      ymm5, ymm5, [GOTOFF(eax,PW_ONE)]
+    vpsraw      ymm4, ymm4, 1                        ; ymm4=(CbE * -FIX(0.22800))
+    vpsraw      ymm5, ymm5, 1                        ; ymm5=(CbO * -FIX(0.22800))
+    vpaddw      ymm0, ymm0, [GOTOFF(eax,PW_ONE)]
+    vpaddw      ymm1, ymm1, [GOTOFF(eax,PW_ONE)]
+    vpsraw      ymm0, ymm0, 1                        ; ymm0=(CrE * FIX(0.40200))
+    vpsraw      ymm1, ymm1, 1                        ; ymm1=(CrO * FIX(0.40200))
+
+    vpaddw      ymm4, ymm4, ymm2
+    vpaddw      ymm5, ymm5, ymm3
+    vpaddw      ymm4, ymm4, ymm2                     ; ymm4=(CbE * FIX(1.77200))=(B-Y)E
+    vpaddw      ymm5, ymm5, ymm3                     ; ymm5=(CbO * FIX(1.77200))=(B-Y)O
+    vpaddw      ymm0, ymm0, ymm6                     ; ymm0=(CrE * FIX(1.40200))=(R-Y)E
+    vpaddw      ymm1, ymm1, ymm7                     ; ymm1=(CrO * FIX(1.40200))=(R-Y)O
+
+    vmovdqa     YMMWORD [wk(0)], ymm4                ; wk(0)=(B-Y)E
+    vmovdqa     YMMWORD [wk(1)], ymm5                ; wk(1)=(B-Y)O
+
+    vpunpckhwd  ymm4, ymm2, ymm6
+    vpunpcklwd  ymm2, ymm2, ymm6
+    vpmaddwd    ymm2, ymm2, [GOTOFF(eax,PW_MF0344_F0285)]
+    vpmaddwd    ymm4, ymm4, [GOTOFF(eax,PW_MF0344_F0285)]
+    vpunpckhwd  ymm5, ymm3, ymm7
+    vpunpcklwd  ymm3, ymm3, ymm7
+    vpmaddwd    ymm3, ymm3, [GOTOFF(eax,PW_MF0344_F0285)]
+    vpmaddwd    ymm5, ymm5, [GOTOFF(eax,PW_MF0344_F0285)]
+
+    vpaddd      ymm2, ymm2, [GOTOFF(eax,PD_ONEHALF)]
+    vpaddd      ymm4, ymm4, [GOTOFF(eax,PD_ONEHALF)]
+    vpsrad      ymm2, ymm2, SCALEBITS
+    vpsrad      ymm4, ymm4, SCALEBITS
+    vpaddd      ymm3, ymm3, [GOTOFF(eax,PD_ONEHALF)]
+    vpaddd      ymm5, ymm5, [GOTOFF(eax,PD_ONEHALF)]
+    vpsrad      ymm3, ymm3, SCALEBITS
+    vpsrad      ymm5, ymm5, SCALEBITS
+
+    vpackssdw   ymm2, ymm2, ymm4             ; ymm2=CbE*-FIX(0.344)+CrE*FIX(0.285)
+    vpackssdw   ymm3, ymm3, ymm5             ; ymm3=CbO*-FIX(0.344)+CrO*FIX(0.285)
+    vpsubw      ymm2, ymm2, ymm6             ; ymm2=CbE*-FIX(0.344)+CrE*-FIX(0.714)=(G-Y)E
+    vpsubw      ymm3, ymm3, ymm7             ; ymm3=CbO*-FIX(0.344)+CrO*-FIX(0.714)=(G-Y)O
+
+    vmovdqu     ymm5, YMMWORD [esi]          ; ymm5=Y(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpcmpeqw    ymm4, ymm4, ymm4
+    vpsrlw      ymm4, ymm4, BYTE_BIT         ; ymm4={0xFF 0x00 0xFF 0x00 ..}
+    vpand       ymm4, ymm4, ymm5             ; ymm4=Y(02468ACEGIKMOQSU)=YE
+    vpsrlw      ymm5, ymm5, BYTE_BIT         ; ymm5=Y(13579BDFHJLNPRTV)=YO
+
+    vpaddw      ymm0, ymm0, ymm4             ; ymm0=((R-Y)E+YE)=RE=R(02468ACEGIKMOQSU)
+    vpaddw      ymm1, ymm1, ymm5             ; ymm1=((R-Y)O+YO)=RO=R(13579BDFHJLNPRTV)
+    vpackuswb   ymm0, ymm0, ymm0             ; ymm0=R(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm1, ymm1, ymm1             ; ymm1=R(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm2, ymm2, ymm4             ; ymm2=((G-Y)E+YE)=GE=G(02468ACEGIKMOQSU)
+    vpaddw      ymm3, ymm3, ymm5             ; ymm3=((G-Y)O+YO)=GO=G(13579BDFHJLNPRTV)
+    vpackuswb   ymm2, ymm2, ymm2             ; ymm2=G(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm3, ymm3, ymm3             ; ymm3=G(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm4, ymm4, YMMWORD [wk(0)]  ; ymm4=(YE+(B-Y)E)=BE=B(02468ACEGIKMOQSU)
+    vpaddw      ymm5, ymm5, YMMWORD [wk(1)]  ; ymm5=(YO+(B-Y)O)=BO=B(13579BDFHJLNPRTV)
+    vpackuswb   ymm4, ymm4, ymm4             ; ymm4=B(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm5, ymm5, ymm5             ; ymm5=B(13579BDF********HJLNPRTV********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+    ; ymmH=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmB        ; ymmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F
+                                        ;       2G 0H 2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V)
+    vpunpcklbw  ymmD, ymmD, ymmF        ; ymmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F
+                                        ;       1H 2H 1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V)
+
+    vpsrldq     ymmH, ymmA, 2           ; ymmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E 0G 1G
+                                        ;       0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U -- --)
+    vpunpckhwd  ymmG, ymmA, ymmE        ; ymmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F
+                                        ;       0O 1O 2O 0P 0Q 1Q 2Q 0R 0S 1S 2S 0T 0U 1U 2U 0V)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07
+                                        ;       0G 1G 2G 0H 0I 1I 2I 0J 0K 1K 2K 0L 0M 1M 2M 0N)
+
+    vpsrldq     ymmE, ymmE, 2           ; ymmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F 2G 0H
+                                        ;       2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V -- --)
+
+    vpsrldq     ymmB, ymmD, 2           ; ymmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F 1H 2H
+                                        ;       1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V -- --)
+    vpunpckhwd  ymmC, ymmD, ymmH        ; ymmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F 0G 1G
+                                        ;       1P 2P 0Q 1Q 1R 2R 0S 1S 1T 2T 0U 1U 1V 2V -- --)
+    vpunpcklwd  ymmD, ymmD, ymmH        ; ymmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18
+                                        ;       1H 2H 0I 1I 1J 2J 0K 1K 1L 2L 0M 1M 1N 2N 0O 1O)
+
+    vpunpckhwd  ymmF, ymmE, ymmB        ; ymmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F 2G 0H 1H 2H
+                                        ;       2Q 0R 1R 2R 2S 0T 1T 2T 2U 0V 1V 2V -- -- -- --)
+    vpunpcklwd  ymmE, ymmE, ymmB        ; ymmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29
+                                        ;       2I 0J 1J 2J 2K 0L 1L 2L 2M 0N 1N 2N 2O 0P 1P 2P)
+
+    vpshufd     ymmH, ymmA, 0x4E        ; ymmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03
+                                        ;       0K 1K 2K 0L 0M 1M 2M 0N 0G 1G 2G 0H 0I 1I 2I 0J)
+    vpunpckldq  ymmA, ymmA, ymmD        ; ymmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 0I 1I 2I 0J 1J 2J 0K 1K)
+    vpunpckhdq  ymmD, ymmD, ymmE        ; ymmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 1N 2N 0O 1O 2O 0P 1P 2P)
+    vpunpckldq  ymmE, ymmE, ymmH        ; ymmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07
+                                        ;       2I 0J 1J 2J 0K 1K 2K 0L 2K 0L 1L 2L 0M 1M 2M 0N)
+
+    vpshufd     ymmH, ymmG, 0x4E        ; ymmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B
+                                        ;       0S 1S 2S 0T 0U 1U 2U 0V 0O 1O 2O 0P 0Q 1Q 2Q 0R)
+    vpunpckldq  ymmG, ymmG, ymmC        ; ymmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C
+                                        ;       0O 1O 2O 0P 1P 2P 0Q 1Q 0Q 1Q 2Q 0R 1R 2R 0S 1S)
+    vpunpckhdq  ymmC, ymmC, ymmF        ; ymmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F 0G 1G 2G 0H 1H 2H
+                                        ;       1T 2T 0U 1U 2U 0V 1V 2V 1V 2V -- -- -- -- -- --)
+    vpunpckldq  ymmF, ymmF, ymmH        ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 2S 0T 1T 2T 0U 1U 2U 0V)
+
+    vpunpcklqdq ymmH, ymmA, ymmE        ; ymmH=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vpunpcklqdq ymmG, ymmD, ymmG        ; ymmG=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+    vpunpcklqdq ymmC, ymmF, ymmC        ; ymmC=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vperm2i128  ymmA, ymmH, ymmG, 0x20  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vperm2i128  ymmD, ymmC, ymmH, 0x30  ; ymmD=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vperm2i128  ymmF, ymmG, ymmC, 0x31  ; ymmF=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        edi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [edi+2*SIZEOF_YMMWORD], ymmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [edi+2*SIZEOF_YMMWORD], ymmF
+.out0:
+    add         edi, byte RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_YMMWORD
+    jz          near .nextrow
+
+    add         esi, byte SIZEOF_YMMWORD  ; inptr0
+    add         ebx, byte SIZEOF_YMMWORD  ; inptr1
+    add         edx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st64:
+    lea         ecx, [ecx+ecx*2]            ; imul ecx, RGB_PIXELSIZE
+    cmp         ecx, byte 2*SIZEOF_YMMWORD
+    jb          short .column_st32
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    add         edi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmF
+    sub         ecx, byte 2*SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st32:
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jb          short .column_st31
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    add         edi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         ecx, byte SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st31:
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    vmovdqu     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    sub         ecx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    vmovq       XMM_MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_MMWORD
+    sub         ecx, byte SIZEOF_MMWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    vmovd       XMM_DWORD [edi], xmmA
+    add         edi, byte SIZEOF_DWORD
+    sub         ecx, byte SIZEOF_DWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of eax to the output when it has enough
+    ; space.
+    vmovd       eax, xmmA
+    cmp         ecx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [edi], ax
+    add         edi, byte SIZEOF_WORD
+    sub         ecx, byte SIZEOF_WORD
+    shr         eax, 16
+.column_st1:
+    ; Store the lower 1 byte of eax to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .nextrow
+    mov         BYTE [edi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    vpcmpeqb    ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpcmpeqb    ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%else
+    vpxor       ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpxor       ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%endif
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(30 32 34 36 38 3A 3C 3E ** 3G 3I 3K 3M 3O 3Q 3S 3U **)
+    ; ymmH=(31 33 35 37 39 3B 3D 3F ** 3H 3J 3L 3N 3P 3R 3T 3V **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmG        ; ymmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E
+                                        ;       2G 3G 2I 3I 2K 3K 2M 3M 2O 3O 2Q 3Q 2S 3S 2U 3U)
+    vpunpcklbw  ymmB, ymmB, ymmD        ; ymmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F
+                                        ;       0H 1H 0J 1J 0L 1L 0N 1N 0P 1P 0R 1R 0T 1T 0V 1V)
+    vpunpcklbw  ymmF, ymmF, ymmH        ; ymmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F
+                                        ;       2H 3H 2J 3J 2L 3L 2N 3N 2P 3P 2R 3R 2T 3T 2V 3V)
+
+    vpunpckhwd  ymmC, ymmA, ymmE        ; ymmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E
+                                        ;       0O 1O 2O 3O 0Q 1Q 2Q 3Q 0S 1S 2S 3S 0U 1U 2U 3U)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36
+                                        ;       0G 1G 2G 3G 0I 1I 2I 3I 0K 1K 2K 3K 0M 1M 2M 3M)
+    vpunpckhwd  ymmG, ymmB, ymmF        ; ymmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F
+                                        ;       0P 1P 2P 3P 0R 1R 2R 3R 0T 1T 2T 3T 0V 1V 2V 3V)
+    vpunpcklwd  ymmB, ymmB, ymmF        ; ymmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37
+                                        ;       0H 1H 2H 3H 0J 1J 2J 3J 0L 1L 2L 3L 0N 1N 2N 3N)
+
+    vpunpckhdq  ymmE, ymmA, ymmB        ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vpunpckldq  ymmB, ymmA, ymmB        ; ymmB=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vpunpckhdq  ymmF, ymmC, ymmG        ; ymmF=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+    vpunpckldq  ymmG, ymmC, ymmG        ; ymmG=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+
+    vperm2i128  ymmA, ymmB, ymmE, 0x20  ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    vperm2i128  ymmD, ymmG, ymmF, 0x20  ; ymmD=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    vperm2i128  ymmC, ymmB, ymmE, 0x31  ; ymmC=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vperm2i128  ymmH, ymmG, ymmF, 0x31  ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        edi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [edi+2*SIZEOF_YMMWORD], ymmC
+    vmovntdq    YMMWORD [edi+3*SIZEOF_YMMWORD], ymmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [edi+2*SIZEOF_YMMWORD], ymmC
+    vmovdqu     YMMWORD [edi+3*SIZEOF_YMMWORD], ymmH
+.out0:
+    add         edi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_YMMWORD
+    jz          near .nextrow
+
+    add         esi, byte SIZEOF_YMMWORD  ; inptr0
+    add         ebx, byte SIZEOF_YMMWORD  ; inptr1
+    add         edx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st64:
+    cmp         ecx, byte SIZEOF_YMMWORD/2
+    jb          short .column_st32
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    add         edi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmC
+    vmovdqa     ymmD, ymmH
+    sub         ecx, byte SIZEOF_YMMWORD/2
+.column_st32:
+    cmp         ecx, byte SIZEOF_YMMWORD/4
+    jb          short .column_st16
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    add         edi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         ecx, byte SIZEOF_YMMWORD/4
+.column_st16:
+    cmp         ecx, byte SIZEOF_YMMWORD/8
+    jb          short .column_st15
+    vmovdqu     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    sub         ecx, byte SIZEOF_YMMWORD/8
+.column_st15:
+    ; Store two pixels (8 bytes) of ymmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_YMMWORD/16
+    jb          short .column_st7
+    vmovq       MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_YMMWORD/16*4
+    sub         ecx, byte SIZEOF_YMMWORD/16
+    vpsrldq     xmmA, SIZEOF_YMMWORD/16*4
+.column_st7:
+    ; Store one pixel (4 bytes) of ymmA to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .nextrow
+    vmovd       XMM_DWORD [edi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    alignx      16, 7
+
+.nextrow:
+    pop         ecx
+    pop         esi
+    pop         ebx
+    pop         edx
+    pop         edi
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW
+    add         ebx, byte SIZEOF_JSAMPROW
+    add         edx, byte SIZEOF_JSAMPROW
+    add         edi, byte SIZEOF_JSAMPROW  ; output_buf
+    dec         eax                        ; num_rows
+    jg          near .rowloop
+
+    sfence                              ; flush the write buffer
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jdcolext-mmx.asm b/simd/i386/jdcolext-mmx.asm
similarity index 99%
rename from simd/jdcolext-mmx.asm
rename to simd/i386/jdcolext-mmx.asm
index 21e34f6..1f0614e 100644
--- a/simd/jdcolext-mmx.asm
+++ b/simd/i386/jdcolext-mmx.asm
@@ -2,6 +2,7 @@
 ; jdcolext.asm - colorspace conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -38,7 +39,7 @@
 %define WK_NUM          2
 %define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_ycc_rgb_convert_mmx)
 
 EXTN(jsimd_ycc_rgb_convert_mmx):
@@ -401,4 +402,4 @@ EXTN(jsimd_ycc_rgb_convert_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jdcolext-sse2.asm b/simd/i386/jdcolext-sse2.asm
new file mode 100644
index 0000000..69462ef
--- /dev/null
+++ b/simd/i386/jdcolext-sse2.asm
@@ -0,0 +1,459 @@
+;
+; jdcolext.asm - colorspace conversion (SSE2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2012, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_ycc_rgb_convert_sse2 (JDIMENSION out_width,
+;                             JSAMPIMAGE input_buf, JDIMENSION input_row,
+;                             JSAMPARRAY output_buf, int num_rows)
+;
+
+%define out_width(b)   (b)+8            ; JDIMENSION out_width
+%define input_buf(b)   (b)+12           ; JSAMPIMAGE input_buf
+%define input_row(b)   (b)+16           ; JDIMENSION input_row
+%define output_buf(b)  (b)+20           ; JSAMPARRAY output_buf
+%define num_rows(b)    (b)+24           ; int num_rows
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+    global      EXTN(jsimd_ycc_rgb_convert_sse2)
+
+EXTN(jsimd_ycc_rgb_convert_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [out_width(eax)]  ; num_cols
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         edi, JSAMPIMAGE [input_buf(eax)]
+    mov         ecx, JDIMENSION [input_row(eax)]
+    mov         esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
+    lea         esi, [esi+ecx*SIZEOF_JSAMPROW]
+    lea         ebx, [ebx+ecx*SIZEOF_JSAMPROW]
+    lea         edx, [edx+ecx*SIZEOF_JSAMPROW]
+
+    pop         ecx
+
+    mov         edi, JSAMPARRAY [output_buf(eax)]
+    mov         eax, INT [num_rows(eax)]
+    test        eax, eax
+    jle         near .return
+    alignx      16, 7
+.rowloop:
+    push        eax
+    push        edi
+    push        edx
+    push        ebx
+    push        esi
+    push        ecx                     ; col
+
+    mov         esi, JSAMPROW [esi]     ; inptr0
+    mov         ebx, JSAMPROW [ebx]     ; inptr1
+    mov         edx, JSAMPROW [edx]     ; inptr2
+    mov         edi, JSAMPROW [edi]     ; outptr
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+    alignx      16, 7
+.columnloop:
+
+    movdqa      xmm5, XMMWORD [ebx]     ; xmm5=Cb(0123456789ABCDEF)
+    movdqa      xmm1, XMMWORD [edx]     ; xmm1=Cr(0123456789ABCDEF)
+
+    pcmpeqw     xmm4, xmm4
+    pcmpeqw     xmm7, xmm7
+    psrlw       xmm4, BYTE_BIT
+    psllw       xmm7, 7                 ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+    movdqa      xmm0, xmm4              ; xmm0=xmm4={0xFF 0x00 0xFF 0x00 ..}
+
+    pand        xmm4, xmm5              ; xmm4=Cb(02468ACE)=CbE
+    psrlw       xmm5, BYTE_BIT          ; xmm5=Cb(13579BDF)=CbO
+    pand        xmm0, xmm1              ; xmm0=Cr(02468ACE)=CrE
+    psrlw       xmm1, BYTE_BIT          ; xmm1=Cr(13579BDF)=CrO
+
+    paddw       xmm4, xmm7
+    paddw       xmm5, xmm7
+    paddw       xmm0, xmm7
+    paddw       xmm1, xmm7
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    movdqa      xmm2, xmm4              ; xmm2=CbE
+    movdqa      xmm3, xmm5              ; xmm3=CbO
+    paddw       xmm4, xmm4              ; xmm4=2*CbE
+    paddw       xmm5, xmm5              ; xmm5=2*CbO
+    movdqa      xmm6, xmm0              ; xmm6=CrE
+    movdqa      xmm7, xmm1              ; xmm7=CrO
+    paddw       xmm0, xmm0              ; xmm0=2*CrE
+    paddw       xmm1, xmm1              ; xmm1=2*CrO
+
+    pmulhw      xmm4, [GOTOFF(eax,PW_MF0228)]  ; xmm4=(2*CbE * -FIX(0.22800))
+    pmulhw      xmm5, [GOTOFF(eax,PW_MF0228)]  ; xmm5=(2*CbO * -FIX(0.22800))
+    pmulhw      xmm0, [GOTOFF(eax,PW_F0402)]   ; xmm0=(2*CrE * FIX(0.40200))
+    pmulhw      xmm1, [GOTOFF(eax,PW_F0402)]   ; xmm1=(2*CrO * FIX(0.40200))
+
+    paddw       xmm4, [GOTOFF(eax,PW_ONE)]
+    paddw       xmm5, [GOTOFF(eax,PW_ONE)]
+    psraw       xmm4, 1                 ; xmm4=(CbE * -FIX(0.22800))
+    psraw       xmm5, 1                 ; xmm5=(CbO * -FIX(0.22800))
+    paddw       xmm0, [GOTOFF(eax,PW_ONE)]
+    paddw       xmm1, [GOTOFF(eax,PW_ONE)]
+    psraw       xmm0, 1                 ; xmm0=(CrE * FIX(0.40200))
+    psraw       xmm1, 1                 ; xmm1=(CrO * FIX(0.40200))
+
+    paddw       xmm4, xmm2
+    paddw       xmm5, xmm3
+    paddw       xmm4, xmm2              ; xmm4=(CbE * FIX(1.77200))=(B-Y)E
+    paddw       xmm5, xmm3              ; xmm5=(CbO * FIX(1.77200))=(B-Y)O
+    paddw       xmm0, xmm6              ; xmm0=(CrE * FIX(1.40200))=(R-Y)E
+    paddw       xmm1, xmm7              ; xmm1=(CrO * FIX(1.40200))=(R-Y)O
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=(B-Y)E
+    movdqa      XMMWORD [wk(1)], xmm5   ; wk(1)=(B-Y)O
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm5, xmm3
+    punpcklwd   xmm2, xmm6
+    punpckhwd   xmm4, xmm6
+    pmaddwd     xmm2, [GOTOFF(eax,PW_MF0344_F0285)]
+    pmaddwd     xmm4, [GOTOFF(eax,PW_MF0344_F0285)]
+    punpcklwd   xmm3, xmm7
+    punpckhwd   xmm5, xmm7
+    pmaddwd     xmm3, [GOTOFF(eax,PW_MF0344_F0285)]
+    pmaddwd     xmm5, [GOTOFF(eax,PW_MF0344_F0285)]
+
+    paddd       xmm2, [GOTOFF(eax,PD_ONEHALF)]
+    paddd       xmm4, [GOTOFF(eax,PD_ONEHALF)]
+    psrad       xmm2, SCALEBITS
+    psrad       xmm4, SCALEBITS
+    paddd       xmm3, [GOTOFF(eax,PD_ONEHALF)]
+    paddd       xmm5, [GOTOFF(eax,PD_ONEHALF)]
+    psrad       xmm3, SCALEBITS
+    psrad       xmm5, SCALEBITS
+
+    packssdw    xmm2, xmm4              ; xmm2=CbE*-FIX(0.344)+CrE*FIX(0.285)
+    packssdw    xmm3, xmm5              ; xmm3=CbO*-FIX(0.344)+CrO*FIX(0.285)
+    psubw       xmm2, xmm6              ; xmm2=CbE*-FIX(0.344)+CrE*-FIX(0.714)=(G-Y)E
+    psubw       xmm3, xmm7              ; xmm3=CbO*-FIX(0.344)+CrO*-FIX(0.714)=(G-Y)O
+
+    movdqa      xmm5, XMMWORD [esi]     ; xmm5=Y(0123456789ABCDEF)
+
+    pcmpeqw     xmm4, xmm4
+    psrlw       xmm4, BYTE_BIT          ; xmm4={0xFF 0x00 0xFF 0x00 ..}
+    pand        xmm4, xmm5              ; xmm4=Y(02468ACE)=YE
+    psrlw       xmm5, BYTE_BIT          ; xmm5=Y(13579BDF)=YO
+
+    paddw       xmm0, xmm4              ; xmm0=((R-Y)E+YE)=RE=R(02468ACE)
+    paddw       xmm1, xmm5              ; xmm1=((R-Y)O+YO)=RO=R(13579BDF)
+    packuswb    xmm0, xmm0              ; xmm0=R(02468ACE********)
+    packuswb    xmm1, xmm1              ; xmm1=R(13579BDF********)
+
+    paddw       xmm2, xmm4              ; xmm2=((G-Y)E+YE)=GE=G(02468ACE)
+    paddw       xmm3, xmm5              ; xmm3=((G-Y)O+YO)=GO=G(13579BDF)
+    packuswb    xmm2, xmm2              ; xmm2=G(02468ACE********)
+    packuswb    xmm3, xmm3              ; xmm3=G(13579BDF********)
+
+    paddw       xmm4, XMMWORD [wk(0)]   ; xmm4=(YE+(B-Y)E)=BE=B(02468ACE)
+    paddw       xmm5, XMMWORD [wk(1)]   ; xmm5=(YO+(B-Y)O)=BO=B(13579BDF)
+    packuswb    xmm4, xmm4              ; xmm4=B(02468ACE********)
+    packuswb    xmm5, xmm5              ; xmm5=B(13579BDF********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
+
+    punpcklbw   xmmA, xmmC        ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmB        ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
+    punpcklbw   xmmD, xmmF        ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
+
+    movdqa      xmmG, xmmA
+    movdqa      xmmH, xmmA
+    punpcklwd   xmmA, xmmE        ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
+    punpckhwd   xmmG, xmmE        ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
+
+    psrldq      xmmH, 2           ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
+    psrldq      xmmE, 2           ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
+
+    movdqa      xmmC, xmmD
+    movdqa      xmmB, xmmD
+    punpcklwd   xmmD, xmmH        ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
+    punpckhwd   xmmC, xmmH        ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
+
+    psrldq      xmmB, 2           ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
+
+    movdqa      xmmF, xmmE
+    punpcklwd   xmmE, xmmB        ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
+    punpckhwd   xmmF, xmmB        ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
+
+    pshufd      xmmH, xmmA, 0x4E  ; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
+    movdqa      xmmB, xmmE
+    punpckldq   xmmA, xmmD        ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
+    punpckldq   xmmE, xmmH        ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
+    punpckhdq   xmmD, xmmB        ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
+
+    pshufd      xmmH, xmmG, 0x4E  ; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
+    movdqa      xmmB, xmmF
+    punpckldq   xmmG, xmmC        ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
+    punpckldq   xmmF, xmmH        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
+    punpckhdq   xmmC, xmmB        ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
+
+    punpcklqdq  xmmA, xmmE        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    punpcklqdq  xmmD, xmmG        ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    punpcklqdq  xmmF, xmmC        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        edi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
+.out0:
+    add         edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_XMMWORD
+    jz          near .nextrow
+
+    add         esi, byte SIZEOF_XMMWORD  ; inptr0
+    add         ebx, byte SIZEOF_XMMWORD  ; inptr1
+    add         edx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st32:
+    lea         ecx, [ecx+ecx*2]        ; imul ecx, RGB_PIXELSIZE
+    cmp         ecx, byte 2*SIZEOF_XMMWORD
+    jb          short .column_st16
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    add         edi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmF
+    sub         ecx, byte 2*SIZEOF_XMMWORD
+    jmp         short .column_st15
+.column_st16:
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         ecx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    movq        XMM_MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_MMWORD
+    sub         ecx, byte SIZEOF_MMWORD
+    psrldq      xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    movd        XMM_DWORD [edi], xmmA
+    add         edi, byte SIZEOF_DWORD
+    sub         ecx, byte SIZEOF_DWORD
+    psrldq      xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of eax to the output when it has enough
+    ; space.
+    movd        eax, xmmA
+    cmp         ecx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [edi], ax
+    add         edi, byte SIZEOF_WORD
+    sub         ecx, byte SIZEOF_WORD
+    shr         eax, 16
+.column_st1:
+    ; Store the lower 1 byte of eax to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .nextrow
+    mov         BYTE [edi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    pcmpeqb     xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pcmpeqb     xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%else
+    pxor        xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pxor        xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%endif
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
+
+    punpcklbw   xmmA, xmmC  ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
+    punpcklbw   xmmB, xmmD  ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
+    punpcklbw   xmmF, xmmH  ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
+
+    movdqa      xmmC, xmmA
+    punpcklwd   xmmA, xmmE  ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
+    punpckhwd   xmmC, xmmE  ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
+    movdqa      xmmG, xmmB
+    punpcklwd   xmmB, xmmF  ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
+    punpckhwd   xmmG, xmmF  ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpckldq   xmmA, xmmB  ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    punpckhdq   xmmD, xmmB  ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    movdqa      xmmH, xmmC
+    punpckldq   xmmC, xmmG  ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    punpckhdq   xmmH, xmmG  ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        edi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
+    movntdq     XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
+    movdqu      XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
+.out0:
+    add         edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_XMMWORD
+    jz          near .nextrow
+
+    add         esi, byte SIZEOF_XMMWORD  ; inptr0
+    add         ebx, byte SIZEOF_XMMWORD  ; inptr1
+    add         edx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st32:
+    cmp         ecx, byte SIZEOF_XMMWORD/2
+    jb          short .column_st16
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    add         edi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmC
+    movdqa      xmmD, xmmH
+    sub         ecx, byte SIZEOF_XMMWORD/2
+.column_st16:
+    cmp         ecx, byte SIZEOF_XMMWORD/4
+    jb          short .column_st15
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         ecx, byte SIZEOF_XMMWORD/4
+.column_st15:
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_XMMWORD/8
+    jb          short .column_st7
+    movq        XMM_MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_XMMWORD/8*4
+    sub         ecx, byte SIZEOF_XMMWORD/8
+    psrldq      xmmA, SIZEOF_XMMWORD/8*4
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .nextrow
+    movd        XMM_DWORD [edi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    alignx      16, 7
+
+.nextrow:
+    pop         ecx
+    pop         esi
+    pop         ebx
+    pop         edx
+    pop         edi
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW
+    add         ebx, byte SIZEOF_JSAMPROW
+    add         edx, byte SIZEOF_JSAMPROW
+    add         edi, byte SIZEOF_JSAMPROW  ; output_buf
+    dec         eax                        ; num_rows
+    jg          near .rowloop
+
+    sfence                              ; flush the write buffer
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jdcolor-avx2.asm b/simd/i386/jdcolor-avx2.asm
new file mode 100644
index 0000000..f312064
--- /dev/null
+++ b/simd/i386/jdcolor-avx2.asm
@@ -0,0 +1,120 @@
+;
+; jdcolor.asm - colorspace conversion (AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2015, Intel Corporation.
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_ycc_rgb_convert_avx2)
+
+EXTN(jconst_ycc_rgb_convert_avx2):
+
+PW_F0402        times 16 dw  F_0_402
+PW_MF0228       times 16 dw -F_0_228
+PW_MF0344_F0285 times 8  dw -F_0_344, F_0_285
+PW_ONE          times 16 dw  1
+PD_ONEHALF      times 8  dd  1 << (SCALEBITS-1)
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extrgb_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extrgbx_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extbgr_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extbgrx_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extxbgr_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extxrgb_convert_avx2
+%include "jdcolext-avx2.asm"
diff --git a/simd/jdcolor-mmx.asm b/simd/i386/jdcolor-mmx.asm
similarity index 97%
rename from simd/jdcolor-mmx.asm
rename to simd/i386/jdcolor-mmx.asm
index 4e58031..5136fe6 100644
--- a/simd/jdcolor-mmx.asm
+++ b/simd/i386/jdcolor-mmx.asm
@@ -2,7 +2,7 @@
 ; jdcolor.asm - colorspace conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -33,7 +33,7 @@ F_0_228 equ     (131072 - F_1_772)      ; FIX(2) - FIX(1.77200)
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_ycc_rgb_convert_mmx)
 
 EXTN(jconst_ycc_rgb_convert_mmx):
@@ -44,7 +44,7 @@ PW_MF0344_F0285 times 2 dw -F_0_344, F_0_285
 PW_ONE          times 4 dw  1
 PD_ONEHALF      times 2 dd  1 << (SCALEBITS-1)
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
diff --git a/simd/jdcolor-sse2.asm b/simd/i386/jdcolor-sse2.asm
similarity index 82%
rename from simd/jdcolor-sse2.asm
rename to simd/i386/jdcolor-sse2.asm
index 7ff5d05..5552dca 100644
--- a/simd/jdcolor-sse2.asm
+++ b/simd/i386/jdcolor-sse2.asm
@@ -2,7 +2,7 @@
 ; jdcolor.asm - colorspace conversion (SSE2)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -20,21 +20,21 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_344 equ      22554                  ; FIX(0.34414)
-F_0_714 equ      46802                  ; FIX(0.71414)
-F_1_402 equ      91881                  ; FIX(1.40200)
-F_1_772 equ     116130                  ; FIX(1.77200)
-F_0_402 equ     (F_1_402 - 65536)       ; FIX(1.40200) - FIX(1)
-F_0_285 equ     ( 65536 - F_0_714)      ; FIX(1) - FIX(0.71414)
-F_0_228 equ     (131072 - F_1_772)      ; FIX(2) - FIX(1.77200)
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_ycc_rgb_convert_sse2)
+    alignz      32
+    global      EXTN(jconst_ycc_rgb_convert_sse2)
 
 EXTN(jconst_ycc_rgb_convert_sse2):
 
@@ -44,11 +44,11 @@ PW_MF0344_F0285 times 4 dw -F_0_344, F_0_285
 PW_ONE          times 8 dw  1
 PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
+    SECTION     SEG_TEXT
+    BITS        32
 
 %include "jdcolext-sse2.asm"
 
diff --git a/simd/i386/jdmerge-avx2.asm b/simd/i386/jdmerge-avx2.asm
new file mode 100644
index 0000000..b194bb7
--- /dev/null
+++ b/simd/i386/jdmerge-avx2.asm
@@ -0,0 +1,126 @@
+;
+; jdmerge.asm - merged upsampling/color conversion (AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_merged_upsample_avx2)
+
+EXTN(jconst_merged_upsample_avx2):
+
+PW_F0402        times 16 dw  F_0_402
+PW_MF0228       times 16 dw -F_0_228
+PW_MF0344_F0285 times 8  dw -F_0_344, F_0_285
+PW_ONE          times 16 dw  1
+PD_ONEHALF      times 8  dd  1 << (SCALEBITS-1)
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extrgb_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extrgb_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extrgbx_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extrgbx_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extbgr_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extbgr_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extbgrx_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extbgrx_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extxbgr_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extxbgr_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extxrgb_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extxrgb_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
diff --git a/simd/jdmerge-mmx.asm b/simd/i386/jdmerge-mmx.asm
similarity index 97%
rename from simd/jdmerge-mmx.asm
rename to simd/i386/jdmerge-mmx.asm
index ee58bff..7ce1d86 100644
--- a/simd/jdmerge-mmx.asm
+++ b/simd/i386/jdmerge-mmx.asm
@@ -2,7 +2,7 @@
 ; jdmerge.asm - merged upsampling/color conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -33,7 +33,7 @@ F_0_228 equ     (131072 - F_1_772)      ; FIX(2) - FIX(1.77200)
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_merged_upsample_mmx)
 
 EXTN(jconst_merged_upsample_mmx):
@@ -44,7 +44,7 @@ PW_MF0344_F0285 times 2 dw -F_0_344, F_0_285
 PW_ONE          times 4 dw  1
 PD_ONEHALF      times 2 dd  1 << (SCALEBITS-1)
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
diff --git a/simd/jdmerge-sse2.asm b/simd/i386/jdmerge-sse2.asm
similarity index 84%
rename from simd/jdmerge-sse2.asm
rename to simd/i386/jdmerge-sse2.asm
index 236de5a..fc1d6ad 100644
--- a/simd/jdmerge-sse2.asm
+++ b/simd/i386/jdmerge-sse2.asm
@@ -2,7 +2,7 @@
 ; jdmerge.asm - merged upsampling/color conversion (SSE2)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -20,21 +20,21 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_344 equ      22554                  ; FIX(0.34414)
-F_0_714 equ      46802                  ; FIX(0.71414)
-F_1_402 equ      91881                  ; FIX(1.40200)
-F_1_772 equ     116130                  ; FIX(1.77200)
-F_0_402 equ     (F_1_402 - 65536)       ; FIX(1.40200) - FIX(1)
-F_0_285 equ     ( 65536 - F_0_714)      ; FIX(1) - FIX(0.71414)
-F_0_228 equ     (131072 - F_1_772)      ; FIX(2) - FIX(1.77200)
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_merged_upsample_sse2)
+    alignz      32
+    global      EXTN(jconst_merged_upsample_sse2)
 
 EXTN(jconst_merged_upsample_sse2):
 
@@ -44,11 +44,11 @@ PW_MF0344_F0285 times 4 dw -F_0_344, F_0_285
 PW_ONE          times 8 dw  1
 PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
+    SECTION     SEG_TEXT
+    BITS        32
 
 %include "jdmrgext-sse2.asm"
 
diff --git a/simd/i386/jdmrgext-avx2.asm b/simd/i386/jdmrgext-avx2.asm
new file mode 100644
index 0000000..5f2b567
--- /dev/null
+++ b/simd/i386/jdmrgext-avx2.asm
@@ -0,0 +1,576 @@
+;
+; jdmrgext.asm - merged upsampling/color conversion (AVX2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2012, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v1_merged_upsample_avx2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+%define output_width(b)      (b)+8      ; JDIMENSION output_width
+%define input_buf(b)         (b)+12     ; JSAMPIMAGE input_buf
+%define in_row_group_ctr(b)  (b)+16     ; JDIMENSION in_row_group_ctr
+%define output_buf(b)        (b)+20     ; JSAMPARRAY output_buf
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM        3
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_merged_upsample_avx2)
+
+EXTN(jsimd_h2v1_merged_upsample_avx2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [output_width(eax)]  ; col
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         edi, JSAMPIMAGE [input_buf(eax)]
+    mov         ecx, JDIMENSION [in_row_group_ctr(eax)]
+    mov         esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
+    mov         edi, JSAMPARRAY [output_buf(eax)]
+    mov         esi, JSAMPROW [esi+ecx*SIZEOF_JSAMPROW]  ; inptr0
+    mov         ebx, JSAMPROW [ebx+ecx*SIZEOF_JSAMPROW]  ; inptr1
+    mov         edx, JSAMPROW [edx+ecx*SIZEOF_JSAMPROW]  ; inptr2
+    mov         edi, JSAMPROW [edi]                      ; outptr
+
+    pop         ecx                     ; col
+
+    alignx      16, 7
+.columnloop:
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+
+    vmovdqu     ymm6, YMMWORD [ebx]     ; ymm6=Cb(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+    vmovdqu     ymm7, YMMWORD [edx]     ; ymm7=Cr(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpxor       ymm1, ymm1, ymm1        ; ymm1=(all 0's)
+    vpcmpeqw    ymm3, ymm3, ymm3
+    vpsllw      ymm3, ymm3, 7           ; ymm3={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    vpermq      ymm6, ymm6, 0xd8        ; ymm6=Cb(01234567GHIJKLMN89ABCDEFOPQRSTUV)
+    vpermq      ymm7, ymm7, 0xd8        ; ymm7=Cr(01234567GHIJKLMN89ABCDEFOPQRSTUV)
+    vpunpcklbw  ymm4, ymm6, ymm1        ; ymm4=Cb(0123456789ABCDEF)=CbL
+    vpunpckhbw  ymm6, ymm6, ymm1        ; ymm6=Cb(GHIJKLMNOPQRSTUV)=CbH
+    vpunpcklbw  ymm0, ymm7, ymm1        ; ymm0=Cr(0123456789ABCDEF)=CrL
+    vpunpckhbw  ymm7, ymm7, ymm1        ; ymm7=Cr(GHIJKLMNOPQRSTUV)=CrH
+
+    vpaddw      ymm5, ymm6, ymm3
+    vpaddw      ymm2, ymm4, ymm3
+    vpaddw      ymm1, ymm7, ymm3
+    vpaddw      ymm3, ymm0, ymm3
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    vpaddw      ymm6, ymm5, ymm5             ; ymm6=2*CbH
+    vpaddw      ymm4, ymm2, ymm2             ; ymm4=2*CbL
+    vpaddw      ymm7, ymm1, ymm1             ; ymm7=2*CrH
+    vpaddw      ymm0, ymm3, ymm3             ; ymm0=2*CrL
+
+    vpmulhw     ymm6, ymm6, [GOTOFF(eax,PW_MF0228)]  ; ymm6=(2*CbH * -FIX(0.22800))
+    vpmulhw     ymm4, ymm4, [GOTOFF(eax,PW_MF0228)]  ; ymm4=(2*CbL * -FIX(0.22800))
+    vpmulhw     ymm7, ymm7, [GOTOFF(eax,PW_F0402)]   ; ymm7=(2*CrH * FIX(0.40200))
+    vpmulhw     ymm0, ymm0, [GOTOFF(eax,PW_F0402)]   ; ymm0=(2*CrL * FIX(0.40200))
+
+    vpaddw      ymm6, ymm6, [GOTOFF(eax,PW_ONE)]
+    vpaddw      ymm4, ymm4, [GOTOFF(eax,PW_ONE)]
+    vpsraw      ymm6, ymm6, 1                     ; ymm6=(CbH * -FIX(0.22800))
+    vpsraw      ymm4, ymm4, 1                     ; ymm4=(CbL * -FIX(0.22800))
+    vpaddw      ymm7, ymm7, [GOTOFF(eax,PW_ONE)]
+    vpaddw      ymm0, ymm0, [GOTOFF(eax,PW_ONE)]
+    vpsraw      ymm7, ymm7, 1                     ; ymm7=(CrH * FIX(0.40200))
+    vpsraw      ymm0, ymm0, 1                     ; ymm0=(CrL * FIX(0.40200))
+
+    vpaddw      ymm6, ymm6, ymm5
+    vpaddw      ymm4, ymm4, ymm2
+    vpaddw      ymm6, ymm6, ymm5                  ; ymm6=(CbH * FIX(1.77200))=(B-Y)H
+    vpaddw      ymm4, ymm4, ymm2                  ; ymm4=(CbL * FIX(1.77200))=(B-Y)L
+    vpaddw      ymm7, ymm7, ymm1                  ; ymm7=(CrH * FIX(1.40200))=(R-Y)H
+    vpaddw      ymm0, ymm0, ymm3                  ; ymm0=(CrL * FIX(1.40200))=(R-Y)L
+
+    vmovdqa     YMMWORD [wk(0)], ymm6             ; wk(0)=(B-Y)H
+    vmovdqa     YMMWORD [wk(1)], ymm7             ; wk(1)=(R-Y)H
+
+    vpunpckhwd  ymm6, ymm5, ymm1
+    vpunpcklwd  ymm5, ymm5, ymm1
+    vpmaddwd    ymm5, ymm5, [GOTOFF(eax,PW_MF0344_F0285)]
+    vpmaddwd    ymm6, ymm6, [GOTOFF(eax,PW_MF0344_F0285)]
+    vpunpckhwd  ymm7, ymm2, ymm3
+    vpunpcklwd  ymm2, ymm2, ymm3
+    vpmaddwd    ymm2, ymm2, [GOTOFF(eax,PW_MF0344_F0285)]
+    vpmaddwd    ymm7, ymm7, [GOTOFF(eax,PW_MF0344_F0285)]
+
+    vpaddd      ymm5, ymm5, [GOTOFF(eax,PD_ONEHALF)]
+    vpaddd      ymm6, ymm6, [GOTOFF(eax,PD_ONEHALF)]
+    vpsrad      ymm5, ymm5, SCALEBITS
+    vpsrad      ymm6, ymm6, SCALEBITS
+    vpaddd      ymm2, ymm2, [GOTOFF(eax,PD_ONEHALF)]
+    vpaddd      ymm7, ymm7, [GOTOFF(eax,PD_ONEHALF)]
+    vpsrad      ymm2, ymm2, SCALEBITS
+    vpsrad      ymm7, ymm7, SCALEBITS
+
+    vpackssdw   ymm5, ymm5, ymm6        ; ymm5=CbH*-FIX(0.344)+CrH*FIX(0.285)
+    vpackssdw   ymm2, ymm2, ymm7        ; ymm2=CbL*-FIX(0.344)+CrL*FIX(0.285)
+    vpsubw      ymm5, ymm5, ymm1        ; ymm5=CbH*-FIX(0.344)+CrH*-FIX(0.714)=(G-Y)H
+    vpsubw      ymm2, ymm2, ymm3        ; ymm2=CbL*-FIX(0.344)+CrL*-FIX(0.714)=(G-Y)L
+
+    vmovdqa     YMMWORD [wk(2)], ymm5   ; wk(2)=(G-Y)H
+
+    mov         al, 2                   ; Yctr
+    jmp         short .Yloop_1st
+    alignx      16, 7
+
+.Yloop_2nd:
+    vmovdqa     ymm0, YMMWORD [wk(1)]   ; ymm0=(R-Y)H
+    vmovdqa     ymm2, YMMWORD [wk(2)]   ; ymm2=(G-Y)H
+    vmovdqa     ymm4, YMMWORD [wk(0)]   ; ymm4=(B-Y)H
+    alignx      16, 7
+
+.Yloop_1st:
+    vmovdqu     ymm7, YMMWORD [esi]     ; ymm7=Y(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpcmpeqw    ymm6, ymm6, ymm6
+    vpsrlw      ymm6, ymm6, BYTE_BIT    ; ymm6={0xFF 0x00 0xFF 0x00 ..}
+    vpand       ymm6, ymm6, ymm7        ; ymm6=Y(02468ACEGIKMOQSU)=YE
+    vpsrlw      ymm7, ymm7, BYTE_BIT    ; ymm7=Y(13579BDFHJLNPRTV)=YO
+
+    vmovdqa     ymm1, ymm0              ; ymm1=ymm0=(R-Y)(L/H)
+    vmovdqa     ymm3, ymm2              ; ymm3=ymm2=(G-Y)(L/H)
+    vmovdqa     ymm5, ymm4              ; ymm5=ymm4=(B-Y)(L/H)
+
+    vpaddw      ymm0, ymm0, ymm6        ; ymm0=((R-Y)+YE)=RE=R(02468ACEGIKMOQSU)
+    vpaddw      ymm1, ymm1, ymm7        ; ymm1=((R-Y)+YO)=RO=R(13579BDFHJLNPRTV)
+    vpackuswb   ymm0, ymm0, ymm0        ; ymm0=R(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm1, ymm1, ymm1        ; ymm1=R(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm2, ymm2, ymm6        ; ymm2=((G-Y)+YE)=GE=G(02468ACEGIKMOQSU)
+    vpaddw      ymm3, ymm3, ymm7        ; ymm3=((G-Y)+YO)=GO=G(13579BDFHJLNPRTV)
+    vpackuswb   ymm2, ymm2, ymm2        ; ymm2=G(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm3, ymm3, ymm3        ; ymm3=G(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm4, ymm4, ymm6        ; ymm4=((B-Y)+YE)=BE=B(02468ACEGIKMOQSU)
+    vpaddw      ymm5, ymm5, ymm7        ; ymm5=((B-Y)+YO)=BO=B(13579BDFHJLNPRTV)
+    vpackuswb   ymm4, ymm4, ymm4        ; ymm4=B(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm5, ymm5, ymm5        ; ymm5=B(13579BDF********HJLNPRTV********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+    ; ymmH=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmB        ; ymmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F
+                                        ;       2G 0H 2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V)
+    vpunpcklbw  ymmD, ymmD, ymmF        ; ymmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F
+                                        ;       1H 2H 1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V)
+
+    vpsrldq     ymmH, ymmA, 2           ; ymmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E 0G 1G
+                                        ;       0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U -- --)
+    vpunpckhwd  ymmG, ymmA, ymmE        ; ymmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F
+                                        ;       0O 1O 2O 0P 0Q 1Q 2Q 0R 0S 1S 2S 0T 0U 1U 2U 0V)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07
+                                        ;       0G 1G 2G 0H 0I 1I 2I 0J 0K 1K 2K 0L 0M 1M 2M 0N)
+
+    vpsrldq     ymmE, ymmE, 2           ; ymmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F 2G 0H
+                                        ;       2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V -- --)
+
+    vpsrldq     ymmB, ymmD, 2           ; ymmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F 1H 2H
+                                        ;       1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V -- --)
+    vpunpckhwd  ymmC, ymmD, ymmH        ; ymmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F 0G 1G
+                                        ;       1P 2P 0Q 1Q 1R 2R 0S 1S 1T 2T 0U 1U 1V 2V -- --)
+    vpunpcklwd  ymmD, ymmD, ymmH        ; ymmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18
+                                        ;       1H 2H 0I 1I 1J 2J 0K 1K 1L 2L 0M 1M 1N 2N 0O 1O)
+
+    vpunpckhwd  ymmF, ymmE, ymmB        ; ymmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F 2G 0H 1H 2H
+                                        ;       2Q 0R 1R 2R 2S 0T 1T 2T 2U 0V 1V 2V -- -- -- --)
+    vpunpcklwd  ymmE, ymmE, ymmB        ; ymmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29
+                                        ;       2I 0J 1J 2J 2K 0L 1L 2L 2M 0N 1N 2N 2O 0P 1P 2P)
+
+    vpshufd     ymmH, ymmA, 0x4E        ; ymmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03
+                                        ;       0K 1K 2K 0L 0M 1M 2M 0N 0G 1G 2G 0H 0I 1I 2I 0J)
+    vpunpckldq  ymmA, ymmA, ymmD        ; ymmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 0I 1I 2I 0J 1J 2J 0K 1K)
+    vpunpckhdq  ymmD, ymmD, ymmE        ; ymmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 1N 2N 0O 1O 2O 0P 1P 2P)
+    vpunpckldq  ymmE, ymmE, ymmH        ; ymmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07
+                                        ;       2I 0J 1J 2J 0K 1K 2K 0L 2K 0L 1L 2L 0M 1M 2M 0N)
+
+    vpshufd     ymmH, ymmG, 0x4E        ; ymmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B
+                                        ;       0S 1S 2S 0T 0U 1U 2U 0V 0O 1O 2O 0P 0Q 1Q 2Q 0R)
+    vpunpckldq  ymmG, ymmG, ymmC        ; ymmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C
+                                        ;       0O 1O 2O 0P 1P 2P 0Q 1Q 0Q 1Q 2Q 0R 1R 2R 0S 1S)
+    vpunpckhdq  ymmC, ymmC, ymmF        ; ymmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F 0G 1G 2G 0H 1H 2H
+                                        ;       1T 2T 0U 1U 2U 0V 1V 2V 1V 2V -- -- -- -- -- --)
+    vpunpckldq  ymmF, ymmF, ymmH        ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 2S 0T 1T 2T 0U 1U 2U 0V)
+
+    vpunpcklqdq ymmH, ymmA, ymmE        ; ymmH=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vpunpcklqdq ymmG, ymmD, ymmG        ; ymmG=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+    vpunpcklqdq ymmC, ymmF, ymmC        ; ymmC=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vperm2i128  ymmA, ymmH, ymmG, 0x20  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vperm2i128  ymmD, ymmC, ymmH, 0x30  ; ymmD=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vperm2i128  ymmF, ymmG, ymmC, 0x31  ; ymmF=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        edi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [edi+2*SIZEOF_YMMWORD], ymmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [edi+2*SIZEOF_YMMWORD], ymmF
+.out0:
+    add         edi, byte RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_YMMWORD
+    jz          near .endcolumn
+
+    add         esi, byte SIZEOF_YMMWORD  ; inptr0
+    dec         al                        ; Yctr
+    jnz         near .Yloop_2nd
+
+    add         ebx, byte SIZEOF_YMMWORD  ; inptr1
+    add         edx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st64:
+    lea         ecx, [ecx+ecx*2]            ; imul ecx, RGB_PIXELSIZE
+    cmp         ecx, byte 2*SIZEOF_YMMWORD
+    jb          short .column_st32
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    add         edi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmF
+    sub         ecx, byte 2*SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st32:
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jb          short .column_st31
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    add         edi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         ecx, byte SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st31:
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    vmovdqu     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    sub         ecx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    vmovq       XMM_MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_MMWORD
+    sub         ecx, byte SIZEOF_MMWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    vmovd       XMM_DWORD [edi], xmmA
+    add         edi, byte SIZEOF_DWORD
+    sub         ecx, byte SIZEOF_DWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of eax to the output when it has enough
+    ; space.
+    vmovd       eax, xmmA
+    cmp         ecx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [edi], ax
+    add         edi, byte SIZEOF_WORD
+    sub         ecx, byte SIZEOF_WORD
+    shr         eax, 16
+.column_st1:
+    ; Store the lower 1 byte of eax to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .endcolumn
+    mov         BYTE [edi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    vpcmpeqb    ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpcmpeqb    ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%else
+    vpxor       ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpxor       ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%endif
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(30 32 34 36 38 3A 3C 3E ** 3G 3I 3K 3M 3O 3Q 3S 3U **)
+    ; ymmH=(31 33 35 37 39 3B 3D 3F ** 3H 3J 3L 3N 3P 3R 3T 3V **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmG        ; ymmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E
+                                        ;       2G 3G 2I 3I 2K 3K 2M 3M 2O 3O 2Q 3Q 2S 3S 2U 3U)
+    vpunpcklbw  ymmB, ymmB, ymmD        ; ymmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F
+                                        ;       0H 1H 0J 1J 0L 1L 0N 1N 0P 1P 0R 1R 0T 1T 0V 1V)
+    vpunpcklbw  ymmF, ymmF, ymmH        ; ymmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F
+                                        ;       2H 3H 2J 3J 2L 3L 2N 3N 2P 3P 2R 3R 2T 3T 2V 3V)
+
+    vpunpckhwd  ymmC, ymmA, ymmE        ; ymmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E
+                                        ;       0O 1O 2O 3O 0Q 1Q 2Q 3Q 0S 1S 2S 3S 0U 1U 2U 3U)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36
+                                        ;       0G 1G 2G 3G 0I 1I 2I 3I 0K 1K 2K 3K 0M 1M 2M 3M)
+    vpunpckhwd  ymmG, ymmB, ymmF        ; ymmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F
+                                        ;       0P 1P 2P 3P 0R 1R 2R 3R 0T 1T 2T 3T 0V 1V 2V 3V)
+    vpunpcklwd  ymmB, ymmB, ymmF        ; ymmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37
+                                        ;       0H 1H 2H 3H 0J 1J 2J 3J 0L 1L 2L 3L 0N 1N 2N 3N)
+
+    vpunpckhdq  ymmE, ymmA, ymmB        ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vpunpckldq  ymmB, ymmA, ymmB        ; ymmB=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vpunpckhdq  ymmF, ymmC, ymmG        ; ymmF=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+    vpunpckldq  ymmG, ymmC, ymmG        ; ymmG=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+
+    vperm2i128  ymmA, ymmB, ymmE, 0x20  ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    vperm2i128  ymmD, ymmG, ymmF, 0x20  ; ymmD=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    vperm2i128  ymmC, ymmB, ymmE, 0x31  ; ymmC=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vperm2i128  ymmH, ymmG, ymmF, 0x31  ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    cmp         ecx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        edi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [edi+2*SIZEOF_YMMWORD], ymmC
+    vmovntdq    YMMWORD [edi+3*SIZEOF_YMMWORD], ymmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [edi+2*SIZEOF_YMMWORD], ymmC
+    vmovdqu     YMMWORD [edi+3*SIZEOF_YMMWORD], ymmH
+.out0:
+    add         edi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_YMMWORD
+    jz          near .endcolumn
+
+    add         esi, byte SIZEOF_YMMWORD  ; inptr0
+    dec         al
+    jnz         near .Yloop_2nd
+
+    add         ebx, byte SIZEOF_YMMWORD  ; inptr1
+    add         edx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st64:
+    cmp         ecx, byte SIZEOF_YMMWORD/2
+    jb          short .column_st32
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymmD
+    add         edi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmC
+    vmovdqa     ymmD, ymmH
+    sub         ecx, byte SIZEOF_YMMWORD/2
+.column_st32:
+    cmp         ecx, byte SIZEOF_YMMWORD/4
+    jb          short .column_st16
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymmA
+    add         edi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         ecx, byte SIZEOF_YMMWORD/4
+.column_st16:
+    cmp         ecx, byte SIZEOF_YMMWORD/8
+    jb          short .column_st15
+    vmovdqu     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    sub         ecx, byte SIZEOF_YMMWORD/8
+.column_st15:
+    ; Store two pixels (8 bytes) of ymmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_YMMWORD/16
+    jb          short .column_st7
+    vmovq       MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_YMMWORD/16*4
+    sub         ecx, byte SIZEOF_YMMWORD/16
+    vpsrldq     xmmA, SIZEOF_YMMWORD/16*4
+.column_st7:
+    ; Store one pixel (4 bytes) of ymmA to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .endcolumn
+    vmovd       XMM_DWORD [edi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+.endcolumn:
+    sfence                              ; flush the write buffer
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v2_merged_upsample_avx2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+%define output_width(b)      (b)+8      ; JDIMENSION output_width
+%define input_buf(b)         (b)+12     ; JSAMPIMAGE input_buf
+%define in_row_group_ctr(b)  (b)+16     ; JDIMENSION in_row_group_ctr
+%define output_buf(b)        (b)+20     ; JSAMPARRAY output_buf
+
+    align       32
+    global      EXTN(jsimd_h2v2_merged_upsample_avx2)
+
+EXTN(jsimd_h2v2_merged_upsample_avx2):
+    push        ebp
+    mov         ebp, esp
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         eax, POINTER [output_width(ebp)]
+
+    mov         edi, JSAMPIMAGE [input_buf(ebp)]
+    mov         ecx, JDIMENSION [in_row_group_ctr(ebp)]
+    mov         esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
+    mov         edi, JSAMPARRAY [output_buf(ebp)]
+    lea         esi, [esi+ecx*SIZEOF_JSAMPROW]
+
+    push        edx                     ; inptr2
+    push        ebx                     ; inptr1
+    push        esi                     ; inptr00
+    mov         ebx, esp
+
+    push        edi                     ; output_buf (outptr0)
+    push        ecx                     ; in_row_group_ctr
+    push        ebx                     ; input_buf
+    push        eax                     ; output_width
+
+    call        near EXTN(jsimd_h2v1_merged_upsample_avx2)
+
+    add         esi, byte SIZEOF_JSAMPROW  ; inptr01
+    add         edi, byte SIZEOF_JSAMPROW  ; outptr1
+    mov         POINTER [ebx+0*SIZEOF_POINTER], esi
+    mov         POINTER [ebx-1*SIZEOF_POINTER], edi
+
+    call        near EXTN(jsimd_h2v1_merged_upsample_avx2)
+
+    add         esp, byte 7*SIZEOF_DWORD
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jdmrgext-mmx.asm b/simd/i386/jdmrgext-mmx.asm
similarity index 99%
rename from simd/jdmrgext-mmx.asm
rename to simd/i386/jdmrgext-mmx.asm
index 63f45cf..0444632 100644
--- a/simd/jdmrgext-mmx.asm
+++ b/simd/i386/jdmrgext-mmx.asm
@@ -2,6 +2,7 @@
 ; jdmrgext.asm - merged upsampling/color conversion (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -38,7 +39,7 @@
 %define WK_NUM          3
 %define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v1_merged_upsample_mmx)
 
 EXTN(jsimd_h2v1_merged_upsample_mmx):
@@ -407,7 +408,7 @@ EXTN(jsimd_h2v1_merged_upsample_mmx):
 %define in_row_group_ctr(b)     (b)+16          ; JDIMENSION in_row_group_ctr
 %define output_buf(b)           (b)+20          ; JSAMPARRAY output_buf
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v2_merged_upsample_mmx)
 
 EXTN(jsimd_h2v2_merged_upsample_mmx):
@@ -460,4 +461,4 @@ EXTN(jsimd_h2v2_merged_upsample_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jdmrgext-sse2.asm b/simd/i386/jdmrgext-sse2.asm
new file mode 100644
index 0000000..50702c6
--- /dev/null
+++ b/simd/i386/jdmrgext-sse2.asm
@@ -0,0 +1,518 @@
+;
+; jdmrgext.asm - merged upsampling/color conversion (SSE2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2012, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v1_merged_upsample_sse2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+%define output_width(b)      (b)+8      ; JDIMENSION output_width
+%define input_buf(b)         (b)+12     ; JSAMPIMAGE input_buf
+%define in_row_group_ctr(b)  (b)+16     ; JDIMENSION in_row_group_ctr
+%define output_buf(b)        (b)+20     ; JSAMPARRAY output_buf
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        3
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void * gotptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_merged_upsample_sse2)
+
+EXTN(jsimd_h2v1_merged_upsample_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         ecx, JDIMENSION [output_width(eax)]  ; col
+    test        ecx, ecx
+    jz          near .return
+
+    push        ecx
+
+    mov         edi, JSAMPIMAGE [input_buf(eax)]
+    mov         ecx, JDIMENSION [in_row_group_ctr(eax)]
+    mov         esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
+    mov         edi, JSAMPARRAY [output_buf(eax)]
+    mov         esi, JSAMPROW [esi+ecx*SIZEOF_JSAMPROW]  ; inptr0
+    mov         ebx, JSAMPROW [ebx+ecx*SIZEOF_JSAMPROW]  ; inptr1
+    mov         edx, JSAMPROW [edx+ecx*SIZEOF_JSAMPROW]  ; inptr2
+    mov         edi, JSAMPROW [edi]                      ; outptr
+
+    pop         ecx                     ; col
+
+    alignx      16, 7
+.columnloop:
+    movpic      eax, POINTER [gotptr]   ; load GOT address (eax)
+
+    movdqa      xmm6, XMMWORD [ebx]     ; xmm6=Cb(0123456789ABCDEF)
+    movdqa      xmm7, XMMWORD [edx]     ; xmm7=Cr(0123456789ABCDEF)
+
+    pxor        xmm1, xmm1              ; xmm1=(all 0's)
+    pcmpeqw     xmm3, xmm3
+    psllw       xmm3, 7                 ; xmm3={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    movdqa      xmm4, xmm6
+    punpckhbw   xmm6, xmm1              ; xmm6=Cb(89ABCDEF)=CbH
+    punpcklbw   xmm4, xmm1              ; xmm4=Cb(01234567)=CbL
+    movdqa      xmm0, xmm7
+    punpckhbw   xmm7, xmm1              ; xmm7=Cr(89ABCDEF)=CrH
+    punpcklbw   xmm0, xmm1              ; xmm0=Cr(01234567)=CrL
+
+    paddw       xmm6, xmm3
+    paddw       xmm4, xmm3
+    paddw       xmm7, xmm3
+    paddw       xmm0, xmm3
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    movdqa      xmm5, xmm6              ; xmm5=CbH
+    movdqa      xmm2, xmm4              ; xmm2=CbL
+    paddw       xmm6, xmm6              ; xmm6=2*CbH
+    paddw       xmm4, xmm4              ; xmm4=2*CbL
+    movdqa      xmm1, xmm7              ; xmm1=CrH
+    movdqa      xmm3, xmm0              ; xmm3=CrL
+    paddw       xmm7, xmm7              ; xmm7=2*CrH
+    paddw       xmm0, xmm0              ; xmm0=2*CrL
+
+    pmulhw      xmm6, [GOTOFF(eax,PW_MF0228)]  ; xmm6=(2*CbH * -FIX(0.22800))
+    pmulhw      xmm4, [GOTOFF(eax,PW_MF0228)]  ; xmm4=(2*CbL * -FIX(0.22800))
+    pmulhw      xmm7, [GOTOFF(eax,PW_F0402)]   ; xmm7=(2*CrH * FIX(0.40200))
+    pmulhw      xmm0, [GOTOFF(eax,PW_F0402)]   ; xmm0=(2*CrL * FIX(0.40200))
+
+    paddw       xmm6, [GOTOFF(eax,PW_ONE)]
+    paddw       xmm4, [GOTOFF(eax,PW_ONE)]
+    psraw       xmm6, 1                 ; xmm6=(CbH * -FIX(0.22800))
+    psraw       xmm4, 1                 ; xmm4=(CbL * -FIX(0.22800))
+    paddw       xmm7, [GOTOFF(eax,PW_ONE)]
+    paddw       xmm0, [GOTOFF(eax,PW_ONE)]
+    psraw       xmm7, 1                 ; xmm7=(CrH * FIX(0.40200))
+    psraw       xmm0, 1                 ; xmm0=(CrL * FIX(0.40200))
+
+    paddw       xmm6, xmm5
+    paddw       xmm4, xmm2
+    paddw       xmm6, xmm5              ; xmm6=(CbH * FIX(1.77200))=(B-Y)H
+    paddw       xmm4, xmm2              ; xmm4=(CbL * FIX(1.77200))=(B-Y)L
+    paddw       xmm7, xmm1              ; xmm7=(CrH * FIX(1.40200))=(R-Y)H
+    paddw       xmm0, xmm3              ; xmm0=(CrL * FIX(1.40200))=(R-Y)L
+
+    movdqa      XMMWORD [wk(0)], xmm6   ; wk(0)=(B-Y)H
+    movdqa      XMMWORD [wk(1)], xmm7   ; wk(1)=(R-Y)H
+
+    movdqa      xmm6, xmm5
+    movdqa      xmm7, xmm2
+    punpcklwd   xmm5, xmm1
+    punpckhwd   xmm6, xmm1
+    pmaddwd     xmm5, [GOTOFF(eax,PW_MF0344_F0285)]
+    pmaddwd     xmm6, [GOTOFF(eax,PW_MF0344_F0285)]
+    punpcklwd   xmm2, xmm3
+    punpckhwd   xmm7, xmm3
+    pmaddwd     xmm2, [GOTOFF(eax,PW_MF0344_F0285)]
+    pmaddwd     xmm7, [GOTOFF(eax,PW_MF0344_F0285)]
+
+    paddd       xmm5, [GOTOFF(eax,PD_ONEHALF)]
+    paddd       xmm6, [GOTOFF(eax,PD_ONEHALF)]
+    psrad       xmm5, SCALEBITS
+    psrad       xmm6, SCALEBITS
+    paddd       xmm2, [GOTOFF(eax,PD_ONEHALF)]
+    paddd       xmm7, [GOTOFF(eax,PD_ONEHALF)]
+    psrad       xmm2, SCALEBITS
+    psrad       xmm7, SCALEBITS
+
+    packssdw    xmm5, xmm6              ; xmm5=CbH*-FIX(0.344)+CrH*FIX(0.285)
+    packssdw    xmm2, xmm7              ; xmm2=CbL*-FIX(0.344)+CrL*FIX(0.285)
+    psubw       xmm5, xmm1              ; xmm5=CbH*-FIX(0.344)+CrH*-FIX(0.714)=(G-Y)H
+    psubw       xmm2, xmm3              ; xmm2=CbL*-FIX(0.344)+CrL*-FIX(0.714)=(G-Y)L
+
+    movdqa      XMMWORD [wk(2)], xmm5   ; wk(2)=(G-Y)H
+
+    mov         al, 2                   ; Yctr
+    jmp         short .Yloop_1st
+    alignx      16, 7
+
+.Yloop_2nd:
+    movdqa      xmm0, XMMWORD [wk(1)]   ; xmm0=(R-Y)H
+    movdqa      xmm2, XMMWORD [wk(2)]   ; xmm2=(G-Y)H
+    movdqa      xmm4, XMMWORD [wk(0)]   ; xmm4=(B-Y)H
+    alignx      16, 7
+
+.Yloop_1st:
+    movdqa      xmm7, XMMWORD [esi]     ; xmm7=Y(0123456789ABCDEF)
+
+    pcmpeqw     xmm6, xmm6
+    psrlw       xmm6, BYTE_BIT          ; xmm6={0xFF 0x00 0xFF 0x00 ..}
+    pand        xmm6, xmm7              ; xmm6=Y(02468ACE)=YE
+    psrlw       xmm7, BYTE_BIT          ; xmm7=Y(13579BDF)=YO
+
+    movdqa      xmm1, xmm0              ; xmm1=xmm0=(R-Y)(L/H)
+    movdqa      xmm3, xmm2              ; xmm3=xmm2=(G-Y)(L/H)
+    movdqa      xmm5, xmm4              ; xmm5=xmm4=(B-Y)(L/H)
+
+    paddw       xmm0, xmm6              ; xmm0=((R-Y)+YE)=RE=R(02468ACE)
+    paddw       xmm1, xmm7              ; xmm1=((R-Y)+YO)=RO=R(13579BDF)
+    packuswb    xmm0, xmm0              ; xmm0=R(02468ACE********)
+    packuswb    xmm1, xmm1              ; xmm1=R(13579BDF********)
+
+    paddw       xmm2, xmm6              ; xmm2=((G-Y)+YE)=GE=G(02468ACE)
+    paddw       xmm3, xmm7              ; xmm3=((G-Y)+YO)=GO=G(13579BDF)
+    packuswb    xmm2, xmm2              ; xmm2=G(02468ACE********)
+    packuswb    xmm3, xmm3              ; xmm3=G(13579BDF********)
+
+    paddw       xmm4, xmm6              ; xmm4=((B-Y)+YE)=BE=B(02468ACE)
+    paddw       xmm5, xmm7              ; xmm5=((B-Y)+YO)=BO=B(13579BDF)
+    packuswb    xmm4, xmm4              ; xmm4=B(02468ACE********)
+    packuswb    xmm5, xmm5              ; xmm5=B(13579BDF********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
+
+    punpcklbw   xmmA, xmmC        ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmB        ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
+    punpcklbw   xmmD, xmmF        ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
+
+    movdqa      xmmG, xmmA
+    movdqa      xmmH, xmmA
+    punpcklwd   xmmA, xmmE        ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
+    punpckhwd   xmmG, xmmE        ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
+
+    psrldq      xmmH, 2           ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
+    psrldq      xmmE, 2           ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
+
+    movdqa      xmmC, xmmD
+    movdqa      xmmB, xmmD
+    punpcklwd   xmmD, xmmH        ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
+    punpckhwd   xmmC, xmmH        ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
+
+    psrldq      xmmB, 2           ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
+
+    movdqa      xmmF, xmmE
+    punpcklwd   xmmE, xmmB        ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
+    punpckhwd   xmmF, xmmB        ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
+
+    pshufd      xmmH, xmmA, 0x4E  ; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
+    movdqa      xmmB, xmmE
+    punpckldq   xmmA, xmmD        ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
+    punpckldq   xmmE, xmmH        ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
+    punpckhdq   xmmD, xmmB        ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
+
+    pshufd      xmmH, xmmG, 0x4E  ; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
+    movdqa      xmmB, xmmF
+    punpckldq   xmmG, xmmC        ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
+    punpckldq   xmmF, xmmH        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
+    punpckhdq   xmmC, xmmB        ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
+
+    punpcklqdq  xmmA, xmmE        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    punpcklqdq  xmmD, xmmG        ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    punpcklqdq  xmmF, xmmC        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        edi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
+.out0:
+    add         edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_XMMWORD
+    jz          near .endcolumn
+
+    add         esi, byte SIZEOF_XMMWORD  ; inptr0
+    dec         al                        ; Yctr
+    jnz         near .Yloop_2nd
+
+    add         ebx, byte SIZEOF_XMMWORD  ; inptr1
+    add         edx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st32:
+    lea         ecx, [ecx+ecx*2]            ; imul ecx, RGB_PIXELSIZE
+    cmp         ecx, byte 2*SIZEOF_XMMWORD
+    jb          short .column_st16
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    add         edi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmF
+    sub         ecx, byte 2*SIZEOF_XMMWORD
+    jmp         short .column_st15
+.column_st16:
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         ecx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    movq        XMM_MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_MMWORD
+    sub         ecx, byte SIZEOF_MMWORD
+    psrldq      xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    movd        XMM_DWORD [edi], xmmA
+    add         edi, byte SIZEOF_DWORD
+    sub         ecx, byte SIZEOF_DWORD
+    psrldq      xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of eax to the output when it has enough
+    ; space.
+    movd        eax, xmmA
+    cmp         ecx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [edi], ax
+    add         edi, byte SIZEOF_WORD
+    sub         ecx, byte SIZEOF_WORD
+    shr         eax, 16
+.column_st1:
+    ; Store the lower 1 byte of eax to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .endcolumn
+    mov         BYTE [edi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    pcmpeqb     xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pcmpeqb     xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%else
+    pxor        xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pxor        xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%endif
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
+
+    punpcklbw   xmmA, xmmC  ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
+    punpcklbw   xmmB, xmmD  ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
+    punpcklbw   xmmF, xmmH  ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
+
+    movdqa      xmmC, xmmA
+    punpcklwd   xmmA, xmmE  ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
+    punpckhwd   xmmC, xmmE  ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
+    movdqa      xmmG, xmmB
+    punpcklwd   xmmB, xmmF  ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
+    punpckhwd   xmmG, xmmF  ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpckldq   xmmA, xmmB  ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    punpckhdq   xmmD, xmmB  ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    movdqa      xmmH, xmmC
+    punpckldq   xmmC, xmmG  ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    punpckhdq   xmmH, xmmG  ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    cmp         ecx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        edi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
+    movntdq     XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
+    movdqu      XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
+.out0:
+    add         edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         ecx, byte SIZEOF_XMMWORD
+    jz          near .endcolumn
+
+    add         esi, byte SIZEOF_XMMWORD  ; inptr0
+    dec         al                        ; Yctr
+    jnz         near .Yloop_2nd
+
+    add         ebx, byte SIZEOF_XMMWORD  ; inptr1
+    add         edx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+    alignx      16, 7
+
+.column_st32:
+    cmp         ecx, byte SIZEOF_XMMWORD/2
+    jb          short .column_st16
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
+    add         edi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmC
+    movdqa      xmmD, xmmH
+    sub         ecx, byte SIZEOF_XMMWORD/2
+.column_st16:
+    cmp         ecx, byte SIZEOF_XMMWORD/4
+    jb          short .column_st15
+    movdqu      XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
+    add         edi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         ecx, byte SIZEOF_XMMWORD/4
+.column_st15:
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp         ecx, byte SIZEOF_XMMWORD/8
+    jb          short .column_st7
+    movq        XMM_MMWORD [edi], xmmA
+    add         edi, byte SIZEOF_XMMWORD/8*4
+    sub         ecx, byte SIZEOF_XMMWORD/8
+    psrldq      xmmA, SIZEOF_XMMWORD/8*4
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test        ecx, ecx
+    jz          short .endcolumn
+    movd        XMM_DWORD [edi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+.endcolumn:
+    sfence                              ; flush the write buffer
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v2_merged_upsample_sse2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+%define output_width(b)      (b)+8      ; JDIMENSION output_width
+%define input_buf(b)         (b)+12     ; JSAMPIMAGE input_buf
+%define in_row_group_ctr(b)  (b)+16     ; JDIMENSION in_row_group_ctr
+%define output_buf(b)        (b)+20     ; JSAMPARRAY output_buf
+
+    align       32
+    global      EXTN(jsimd_h2v2_merged_upsample_sse2)
+
+EXTN(jsimd_h2v2_merged_upsample_sse2):
+    push        ebp
+    mov         ebp, esp
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         eax, POINTER [output_width(ebp)]
+
+    mov         edi, JSAMPIMAGE [input_buf(ebp)]
+    mov         ecx, JDIMENSION [in_row_group_ctr(ebp)]
+    mov         esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
+    mov         ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
+    mov         edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
+    mov         edi, JSAMPARRAY [output_buf(ebp)]
+    lea         esi, [esi+ecx*SIZEOF_JSAMPROW]
+
+    push        edx                     ; inptr2
+    push        ebx                     ; inptr1
+    push        esi                     ; inptr00
+    mov         ebx, esp
+
+    push        edi                     ; output_buf (outptr0)
+    push        ecx                     ; in_row_group_ctr
+    push        ebx                     ; input_buf
+    push        eax                     ; output_width
+
+    call        near EXTN(jsimd_h2v1_merged_upsample_sse2)
+
+    add         esi, byte SIZEOF_JSAMPROW  ; inptr01
+    add         edi, byte SIZEOF_JSAMPROW  ; outptr1
+    mov         POINTER [ebx+0*SIZEOF_POINTER], esi
+    mov         POINTER [ebx-1*SIZEOF_POINTER], edi
+
+    call        near EXTN(jsimd_h2v1_merged_upsample_sse2)
+
+    add         esp, byte 7*SIZEOF_DWORD
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jdsample-avx2.asm b/simd/i386/jdsample-avx2.asm
new file mode 100644
index 0000000..d087e3d
--- /dev/null
+++ b/simd/i386/jdsample-avx2.asm
@@ -0,0 +1,765 @@
+;
+; jdsample.asm - upsampling (AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2015, Intel Corporation.
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fancy_upsample_avx2)
+
+EXTN(jconst_fancy_upsample_avx2):
+
+PW_ONE   times 16 dw 1
+PW_TWO   times 16 dw 2
+PW_THREE times 16 dw 3
+PW_SEVEN times 16 dw 7
+PW_EIGHT times 16 dw 8
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
+;
+; The upsampling algorithm is linear interpolation between pixel centers,
+; also known as a "triangle filter".  This is a good compromise between
+; speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
+; of the way between input pixel centers.
+;
+; GLOBAL(void)
+; jsimd_h2v1_fancy_upsample_avx2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define downsamp_width(b)   (b)+12      ; JDIMENSION downsampled_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_fancy_upsample_avx2)
+
+EXTN(jsimd_h2v1_fancy_upsample_avx2):
+    push        ebp
+    mov         ebp, esp
+    pushpic     ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+
+    mov         eax, JDIMENSION [downsamp_width(ebp)]  ; colctr
+    test        eax, eax
+    jz          near .return
+
+    mov         ecx, INT [max_v_samp(ebp)]  ; rowctr
+    test        ecx, ecx
+    jz          near .return
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(ebp)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        eax                     ; colctr
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr
+
+    test        eax, SIZEOF_YMMWORD-1
+    jz          short .skip
+    mov         dl, JSAMPLE [esi+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [esi+eax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+.skip:
+    vpxor       ymm0, ymm0, ymm0                ; ymm0=(all 0's)
+    vpcmpeqb    xmm7, xmm7, xmm7
+    vpsrldq     xmm7, xmm7, (SIZEOF_XMMWORD-1)  ; (ff -- -- -- ... -- --) LSB is ff
+    vpand       ymm7, ymm7, YMMWORD [esi+0*SIZEOF_YMMWORD]
+
+    add         eax, byte SIZEOF_YMMWORD-1
+    and         eax, byte -SIZEOF_YMMWORD
+    cmp         eax, byte SIZEOF_YMMWORD
+    ja          short .columnloop
+    alignx      16, 7
+
+.columnloop_last:
+    vpcmpeqb    xmm6, xmm6, xmm6
+    vpslldq     xmm6, xmm6, (SIZEOF_XMMWORD-1)
+    vperm2i128  ymm6, ymm6, ymm6, 1             ; (---- ---- ... ---- ---- ff) MSB is ff
+    vpand       ymm6, ymm6, YMMWORD [esi+0*SIZEOF_YMMWORD]
+    jmp         short .upsample
+    alignx      16, 7
+
+.columnloop:
+    vmovdqu     ymm6, YMMWORD [esi+1*SIZEOF_YMMWORD]
+    vperm2i128  ymm6, ymm0, ymm6, 0x20
+    vpslldq     ymm6, ymm6, 15
+
+.upsample:
+    vmovdqu     ymm1, YMMWORD [esi+0*SIZEOF_YMMWORD]  ; ymm1=( 0  1  2 ... 29 30 31)
+
+    vperm2i128  ymm2, ymm0, ymm1, 0x20
+    vpalignr    ymm2, ymm1, ymm2, 15            ; ymm2=(--  0  1 ... 28 29 30)
+    vperm2i128  ymm4, ymm0, ymm1, 0x03
+    vpalignr    ymm3, ymm4, ymm1, 1             ; ymm3=( 1  2  3 ... 30 31 --)
+
+    vpor        ymm2, ymm2, ymm7                ; ymm2=(-1  0  1 ... 28 29 30)
+    vpor        ymm3, ymm3, ymm6                ; ymm3=( 1  2  3 ... 30 31 32)
+
+    vpsrldq     ymm7, ymm4, (SIZEOF_XMMWORD-1)  ; ymm7=(31 -- -- ... -- -- --)
+
+    vpunpckhbw  ymm4, ymm1, ymm0                ; ymm4=( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm5, ymm1, ymm0                ; ymm5=( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm1, ymm5, ymm4, 0x20          ; ymm1=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm4, ymm5, ymm4, 0x31          ; ymm4=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm5, ymm2, ymm0                ; ymm5=( 7  8  9 10 11 12 13 14 23 24 25 26 27 28 29 30)
+    vpunpcklbw  ymm6, ymm2, ymm0                ; ymm6=(-1  0  1  2  3  4  5  6 15 16 17 18 19 20 21 22)
+    vperm2i128  ymm2, ymm6, ymm5, 0x20          ; ymm2=(-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+    vperm2i128  ymm5, ymm6, ymm5, 0x31          ; ymm5=(15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vpunpckhbw  ymm6, ymm3, ymm0                ; ymm6=( 1  2  3  4  5  6  7  8 17 18 19 20 21 22 23 24)
+    vpunpcklbw  ymm0, ymm3, ymm0                ; ymm0=( 9 10 11 12 13 14 15 16 25 26 27 28 29 30 31 32)
+    vperm2i128  ymm3, ymm0, ymm6, 0x20          ; ymm3=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16)
+    vperm2i128  ymm6, ymm0, ymm6, 0x31          ; ymm6=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
+
+    vpxor       ymm0, ymm0, ymm0                ; ymm0=(all 0's)
+
+    vpmullw     ymm1, ymm1, [GOTOFF(ebx,PW_THREE)]
+    vpmullw     ymm4, ymm4, [GOTOFF(ebx,PW_THREE)]
+    vpaddw      ymm2, ymm2, [GOTOFF(ebx,PW_ONE)]
+    vpaddw      ymm5, ymm5, [GOTOFF(ebx,PW_ONE)]
+    vpaddw      ymm3, ymm3, [GOTOFF(ebx,PW_TWO)]
+    vpaddw      ymm6, ymm6, [GOTOFF(ebx,PW_TWO)]
+
+    vpaddw      ymm2, ymm2, ymm1
+    vpaddw      ymm5, ymm5, ymm4
+    vpsrlw      ymm2, ymm2, 2                   ; ymm2=OutLE=( 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30)
+    vpsrlw      ymm5, ymm5, 2                   ; ymm5=OutHE=(32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62)
+    vpaddw      ymm3, ymm3, ymm1
+    vpaddw      ymm6, ymm6, ymm4
+    vpsrlw      ymm3, ymm3, 2                   ; ymm3=OutLO=( 1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31)
+    vpsrlw      ymm6, ymm6, 2                   ; ymm6=OutHO=(33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63)
+
+    vpsllw      ymm3, ymm3, BYTE_BIT
+    vpsllw      ymm6, ymm6, BYTE_BIT
+    vpor        ymm2, ymm2, ymm3                ; ymm2=OutL=( 0  1  2 ... 29 30 31)
+    vpor        ymm5, ymm5, ymm6                ; ymm5=OutH=(32 33 34 ... 61 62 63)
+
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymm2
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymm5
+
+    sub         eax, byte SIZEOF_YMMWORD
+    add         esi, byte 1*SIZEOF_YMMWORD  ; inptr
+    add         edi, byte 2*SIZEOF_YMMWORD  ; outptr
+    cmp         eax, byte SIZEOF_YMMWORD
+    ja          near .columnloop
+    test        eax, eax
+    jnz         near .columnloop_last
+
+    pop         esi
+    pop         edi
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         ecx                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    poppic      ebx
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
+; Again a triangle filter; see comments for h2v1 case, above.
+;
+; GLOBAL(void)
+; jsimd_h2v2_fancy_upsample_avx2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define downsamp_width(b)   (b)+12      ; JDIMENSION downsampled_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM        4
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void *gotptr
+
+    align       32
+    global      EXTN(jsimd_h2v2_fancy_upsample_avx2)
+
+EXTN(jsimd_h2v2_fancy_upsample_avx2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         edx, eax                               ; edx = original ebp
+    mov         eax, JDIMENSION [downsamp_width(edx)]  ; colctr
+    test        eax, eax
+    jz          near .return
+
+    mov         ecx, INT [max_v_samp(edx)]           ; rowctr
+    test        ecx, ecx
+    jz          near .return
+
+    mov         esi, JSAMPARRAY [input_data(edx)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(edx)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        eax                     ; colctr
+    push        ecx
+    push        edi
+    push        esi
+
+    mov         ecx, JSAMPROW [esi-1*SIZEOF_JSAMPROW]  ; inptr1(above)
+    mov         ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]  ; inptr1(below)
+    mov         edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]  ; outptr1
+
+    test        eax, SIZEOF_YMMWORD-1
+    jz          short .skip
+    push        edx
+    mov         dl, JSAMPLE [ecx+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [ecx+eax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [ebx+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [ebx+eax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [esi+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [esi+eax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+    pop         edx
+.skip:
+    ; -- process the first column block
+
+    vmovdqu     ymm0, YMMWORD [ebx+0*SIZEOF_YMMWORD]  ; ymm0=row[ 0][0]
+    vmovdqu     ymm1, YMMWORD [ecx+0*SIZEOF_YMMWORD]  ; ymm1=row[-1][0]
+    vmovdqu     ymm2, YMMWORD [esi+0*SIZEOF_YMMWORD]  ; ymm2=row[+1][0]
+
+    pushpic     ebx
+    movpic      ebx, POINTER [gotptr]   ; load GOT address
+
+    vpxor       ymm3, ymm3, ymm3        ; ymm3=(all 0's)
+
+    vpunpckhbw  ymm4, ymm0, ymm3        ; ymm4=row[ 0]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm5, ymm0, ymm3        ; ymm5=row[ 0]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm0, ymm5, ymm4, 0x20  ; ymm0=row[ 0]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm4, ymm5, ymm4, 0x31  ; ymm4=row[ 0](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm5, ymm1, ymm3        ; ymm5=row[-1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm6, ymm1, ymm3        ; ymm6=row[-1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm1, ymm6, ymm5, 0x20  ; ymm1=row[-1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm5, ymm6, ymm5, 0x31  ; ymm5=row[-1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm6, ymm2, ymm3        ; ymm6=row[+1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm3, ymm2, ymm3        ; ymm3=row[+1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm2, ymm3, ymm6, 0x20  ; ymm2=row[+1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm6, ymm3, ymm6, 0x31  ; ymm6=row[+1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpmullw     ymm0, ymm0, [GOTOFF(ebx,PW_THREE)]
+    vpmullw     ymm4, ymm4, [GOTOFF(ebx,PW_THREE)]
+
+    vpcmpeqb    xmm7, xmm7, xmm7
+    vpsrldq     xmm7, xmm7, (SIZEOF_XMMWORD-2)  ; (ffff ---- ---- ... ---- ----) LSB is ffff
+
+    vpaddw      ymm1, ymm1, ymm0        ; ymm1=Int0L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm5, ymm5, ymm4        ; ymm5=Int0H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+    vpaddw      ymm2, ymm2, ymm0        ; ymm2=Int1L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm6, ymm6, ymm4        ; ymm6=Int1H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vmovdqu     YMMWORD [edx+0*SIZEOF_YMMWORD], ymm1  ; temporarily save
+    vmovdqu     YMMWORD [edx+1*SIZEOF_YMMWORD], ymm5  ; the intermediate data
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymm2
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymm6
+
+    vpand       ymm1, ymm1, ymm7        ; ymm1=( 0 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vpand       ymm2, ymm2, ymm7        ; ymm2=( 0 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+
+    vmovdqa     YMMWORD [wk(0)], ymm1
+    vmovdqa     YMMWORD [wk(1)], ymm2
+
+    poppic      ebx
+
+    add         eax, byte SIZEOF_YMMWORD-1
+    and         eax, byte -SIZEOF_YMMWORD
+    cmp         eax, byte SIZEOF_YMMWORD
+    ja          short .columnloop
+    alignx      16, 7
+
+.columnloop_last:
+    ; -- process the last column block
+
+    pushpic     ebx
+    movpic      ebx, POINTER [gotptr]   ; load GOT address
+
+    vpcmpeqb    xmm1, xmm1, xmm1
+    vpslldq     xmm1, xmm1, (SIZEOF_XMMWORD-2)
+    vperm2i128  ymm1, ymm1, ymm1, 1             ; (---- ---- ... ---- ---- ffff) MSB is ffff
+
+    vpand       ymm2, ymm1, YMMWORD [edi+1*SIZEOF_YMMWORD]
+    vpand       ymm1, ymm1, YMMWORD [edx+1*SIZEOF_YMMWORD]
+
+    vmovdqa     YMMWORD [wk(2)], ymm1          ; ymm1=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 31)
+    vmovdqa     YMMWORD [wk(3)], ymm2          ; ymm2=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 31)
+
+    jmp         near .upsample
+    alignx      16, 7
+
+.columnloop:
+    ; -- process the next column block
+
+    vmovdqu     ymm0, YMMWORD [ebx+1*SIZEOF_YMMWORD]  ; ymm0=row[ 0][1]
+    vmovdqu     ymm1, YMMWORD [ecx+1*SIZEOF_YMMWORD]  ; ymm1=row[-1][1]
+    vmovdqu     ymm2, YMMWORD [esi+1*SIZEOF_YMMWORD]  ; ymm2=row[+1][1]
+
+    pushpic     ebx
+    movpic      ebx, POINTER [gotptr]   ; load GOT address
+
+    vpxor       ymm3, ymm3, ymm3        ; ymm3=(all 0's)
+
+    vpunpckhbw  ymm4, ymm0, ymm3        ; ymm4=row[ 0]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm5, ymm0, ymm3        ; ymm5=row[ 0]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm0, ymm5, ymm4, 0x20  ; ymm0=row[ 0]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm4, ymm5, ymm4, 0x31  ; ymm4=row[ 0](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm5, ymm1, ymm3        ; ymm5=row[-1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm6, ymm1, ymm3        ; ymm6=row[-1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm1, ymm6, ymm5, 0x20  ; ymm1=row[-1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm5, ymm6, ymm5, 0x31  ; ymm5=row[-1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm6, ymm2, ymm3        ; ymm6=row[+1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm7, ymm2, ymm3        ; ymm7=row[+1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm2, ymm7, ymm6, 0x20  ; ymm2=row[+1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm6, ymm7, ymm6, 0x31  ; ymm6=row[+1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpmullw     ymm0, ymm0, [GOTOFF(ebx,PW_THREE)]
+    vpmullw     ymm4, ymm4, [GOTOFF(ebx,PW_THREE)]
+
+    vpaddw      ymm1, ymm1, ymm0        ; ymm1=Int0L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm5, ymm5, ymm4        ; ymm5=Int0H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+    vpaddw      ymm2, ymm2, ymm0        ; ymm2=Int1L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm6, ymm6, ymm4        ; ymm6=Int1H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vmovdqu     YMMWORD [edx+2*SIZEOF_YMMWORD], ymm1  ; temporarily save
+    vmovdqu     YMMWORD [edx+3*SIZEOF_YMMWORD], ymm5  ; the intermediate data
+    vmovdqu     YMMWORD [edi+2*SIZEOF_YMMWORD], ymm2
+    vmovdqu     YMMWORD [edi+3*SIZEOF_YMMWORD], ymm6
+
+    vperm2i128  ymm1, ymm3, ymm1, 0x20
+    vpslldq     ymm1, ymm1, 14          ; ymm1=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- --  0)
+    vperm2i128  ymm2, ymm3, ymm2, 0x20
+    vpslldq     ymm2, ymm2, 14          ; ymm2=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- --  0)
+
+    vmovdqa     YMMWORD [wk(2)], ymm1
+    vmovdqa     YMMWORD [wk(3)], ymm2
+
+.upsample:
+    ; -- process the upper row
+
+    vmovdqu     ymm7, YMMWORD [edx+0*SIZEOF_YMMWORD]  ; ymm7=Int0L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vmovdqu     ymm3, YMMWORD [edx+1*SIZEOF_YMMWORD]  ; ymm3=Int0H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpxor       ymm1, ymm1, ymm1        ; ymm1=(all 0's)
+
+    vperm2i128  ymm0, ymm1, ymm7, 0x03
+    vpalignr    ymm0, ymm0, ymm7, 2     ; ymm0=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 --)
+    vperm2i128  ymm4, ymm1, ymm3, 0x20
+    vpslldq     ymm4, ymm4, 14          ; ymm4=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 16)
+
+    vperm2i128  ymm5, ymm1, ymm7, 0x03
+    vpsrldq     ymm5, ymm5, 14          ; ymm5=(15 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm6, ymm1, ymm3, 0x20
+    vpalignr    ymm6, ymm3, ymm6, 14    ; ymm6=(-- 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vpor        ymm0, ymm0, ymm4        ; ymm0=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16)
+    vpor        ymm5, ymm5, ymm6        ; ymm5=(15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vperm2i128  ymm2, ymm1, ymm3, 0x03
+    vpalignr    ymm2, ymm2, ymm3, 2     ; ymm2=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 --)
+    vperm2i128  ymm4, ymm1, ymm3, 0x03
+    vpsrldq     ymm4, ymm4, 14          ; ymm4=(31 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm1, ymm1, ymm7, 0x20
+    vpalignr    ymm1, ymm7, ymm1, 14    ; ymm1=(--  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+
+    vpor        ymm1, ymm1, YMMWORD [wk(0)]  ; ymm1=(-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+    vpor        ymm2, ymm2, YMMWORD [wk(2)]  ; ymm2=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
+
+    vmovdqa     YMMWORD [wk(0)], ymm4
+
+    vpmullw     ymm7, ymm7, [GOTOFF(ebx,PW_THREE)]
+    vpmullw     ymm3, ymm3, [GOTOFF(ebx,PW_THREE)]
+    vpaddw      ymm1, ymm1, [GOTOFF(ebx,PW_EIGHT)]
+    vpaddw      ymm5, ymm5, [GOTOFF(ebx,PW_EIGHT)]
+    vpaddw      ymm0, ymm0, [GOTOFF(ebx,PW_SEVEN)]
+    vpaddw      ymm2, [GOTOFF(ebx,PW_SEVEN)]
+
+    vpaddw      ymm1, ymm1, ymm7
+    vpaddw      ymm5, ymm5, ymm3
+    vpsrlw      ymm1, ymm1, 4           ; ymm1=Out0LE=( 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30)
+    vpsrlw      ymm5, ymm5, 4           ; ymm5=Out0HE=(32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62)
+    vpaddw      ymm0, ymm0, ymm7
+    vpaddw      ymm2, ymm2, ymm3
+    vpsrlw      ymm0, ymm0, 4           ; ymm0=Out0LO=( 1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31)
+    vpsrlw      ymm2, ymm2, 4           ; ymm2=Out0HO=(33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63)
+
+    vpsllw      ymm0, ymm0, BYTE_BIT
+    vpsllw      ymm2, ymm2, BYTE_BIT
+    vpor        ymm1, ymm1, ymm0        ; ymm1=Out0L=( 0  1  2 ... 29 30 31)
+    vpor        ymm5, ymm5, ymm2        ; ymm5=Out0H=(32 33 34 ... 61 62 63)
+
+    vmovdqu     YMMWORD [edx+0*SIZEOF_YMMWORD], ymm1
+    vmovdqu     YMMWORD [edx+1*SIZEOF_YMMWORD], ymm5
+
+    ; -- process the lower row
+
+    vmovdqu     ymm6, YMMWORD [edi+0*SIZEOF_YMMWORD]  ; ymm6=Int1L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vmovdqu     ymm4, YMMWORD [edi+1*SIZEOF_YMMWORD]  ; ymm4=Int1H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpxor       ymm1, ymm1, ymm1        ; ymm1=(all 0's)
+
+    vperm2i128  ymm7, ymm1, ymm6, 0x03
+    vpalignr    ymm7, ymm7, ymm6, 2     ; ymm7=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 --)
+    vperm2i128  ymm3, ymm1, ymm4, 0x20
+    vpslldq     ymm3, ymm3, 14          ; ymm3=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 16)
+
+    vperm2i128  ymm0, ymm1, ymm6, 0x03
+    vpsrldq     ymm0, ymm0, 14          ; ymm0=(15 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm2, ymm1, ymm4, 0x20
+    vpalignr    ymm2, ymm4, ymm2, 14    ; ymm2=(-- 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vpor        ymm7, ymm7, ymm3        ; ymm7=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16)
+    vpor        ymm0, ymm0, ymm2        ; ymm0=(15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vperm2i128  ymm5, ymm1, ymm4, 0x03
+    vpalignr    ymm5, ymm5, ymm4, 2     ; ymm5=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 --)
+    vperm2i128  ymm3, ymm1, ymm4, 0x03
+    vpsrldq     ymm3, ymm3, 14          ; ymm3=(31 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm1, ymm1, ymm6, 0x20
+    vpalignr    ymm1, ymm6, ymm1, 14    ; ymm1=(--  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+
+    vpor        ymm1, ymm1, YMMWORD [wk(1)]  ; ymm1=(-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+    vpor        ymm5, ymm5, YMMWORD [wk(3)]  ; ymm5=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
+
+    vmovdqa     YMMWORD [wk(1)], ymm3
+
+    vpmullw     ymm6, ymm6, [GOTOFF(ebx,PW_THREE)]
+    vpmullw     ymm4, ymm4, [GOTOFF(ebx,PW_THREE)]
+    vpaddw      ymm1, ymm1, [GOTOFF(ebx,PW_EIGHT)]
+    vpaddw      ymm0, ymm0, [GOTOFF(ebx,PW_EIGHT)]
+    vpaddw      ymm7, ymm7, [GOTOFF(ebx,PW_SEVEN)]
+    vpaddw      ymm5, ymm5, [GOTOFF(ebx,PW_SEVEN)]
+
+    vpaddw      ymm1, ymm1, ymm6
+    vpaddw      ymm0, ymm0, ymm4
+    vpsrlw      ymm1, ymm1, 4           ; ymm1=Out1LE=( 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30)
+    vpsrlw      ymm0, ymm0, 4           ; ymm0=Out1HE=(32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62)
+    vpaddw      ymm7, ymm7, ymm6
+    vpaddw      ymm5, ymm5, ymm4
+    vpsrlw      ymm7, ymm7, 4           ; ymm7=Out1LO=( 1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31)
+    vpsrlw      ymm5, ymm5, 4           ; ymm5=Out1HO=(33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63)
+
+    vpsllw      ymm7, ymm7, BYTE_BIT
+    vpsllw      ymm5, ymm5, BYTE_BIT
+    vpor        ymm1, ymm1, ymm7        ; ymm1=Out1L=( 0  1  2 ... 29 30 31)
+    vpor        ymm0, ymm0, ymm5        ; ymm0=Out1H=(32 33 34 ... 61 62 63)
+
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymm1
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymm0
+
+    poppic      ebx
+
+    sub         eax, byte SIZEOF_YMMWORD
+    add         ecx, byte 1*SIZEOF_YMMWORD  ; inptr1(above)
+    add         ebx, byte 1*SIZEOF_YMMWORD  ; inptr0
+    add         esi, byte 1*SIZEOF_YMMWORD  ; inptr1(below)
+    add         edx, byte 2*SIZEOF_YMMWORD  ; outptr0
+    add         edi, byte 2*SIZEOF_YMMWORD  ; outptr1
+    cmp         eax, byte SIZEOF_YMMWORD
+    ja          near .columnloop
+    test        eax, eax
+    jnz         near .columnloop_last
+
+    pop         esi
+    pop         edi
+    pop         ecx
+    pop         eax
+
+    add         esi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         ecx, byte 2                  ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v1_upsample_avx2 (int max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define output_width(b)     (b)+12      ; JDIMENSION output_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_upsample_avx2)
+
+EXTN(jsimd_h2v1_upsample_avx2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         edx, JDIMENSION [output_width(ebp)]
+    add         edx, byte (SIZEOF_YMMWORD-1)
+    and         edx, -SIZEOF_YMMWORD
+    jz          short .return
+
+    mov         ecx, INT [max_v_samp(ebp)]  ; rowctr
+    test        ecx, ecx
+    jz          short .return
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(ebp)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr
+    mov         eax, edx                ; colctr
+    alignx      16, 7
+.columnloop:
+
+    cmp         eax, byte SIZEOF_YMMWORD
+    ja          near .above_16
+
+    vmovdqu     xmm0, XMMWORD [esi+0*SIZEOF_YMMWORD]
+    vpunpckhbw  xmm1, xmm0, xmm0
+    vpunpcklbw  xmm0, xmm0, xmm0
+
+    vmovdqu     XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
+    vmovdqu     XMMWORD [edi+1*SIZEOF_XMMWORD], xmm1
+
+    jmp         short .nextrow
+
+.above_16:
+    vmovdqu     ymm0, YMMWORD [esi+0*SIZEOF_YMMWORD]
+
+    vpermq      ymm0, ymm0, 0xd8
+    vpunpckhbw  ymm1, ymm0, ymm0
+    vpunpcklbw  ymm0, ymm0, ymm0
+
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymm0
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymm1
+
+    sub         eax, byte 2*SIZEOF_YMMWORD
+    jz          short .nextrow
+
+    add         esi, byte SIZEOF_YMMWORD    ; inptr
+    add         edi, byte 2*SIZEOF_YMMWORD  ; outptr
+    jmp         short .columnloop
+    alignx      16, 7
+
+.nextrow:
+    pop         esi
+    pop         edi
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         ecx                        ; rowctr
+    jg          short .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v2_upsample_avx2 (int max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define output_width(b)     (b)+12      ; JDIMENSION output_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v2_upsample_avx2)
+
+EXTN(jsimd_h2v2_upsample_avx2):
+    push        ebp
+    mov         ebp, esp
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         edx, JDIMENSION [output_width(ebp)]
+    add         edx, byte (SIZEOF_YMMWORD-1)
+    and         edx, -SIZEOF_YMMWORD
+    jz          near .return
+
+    mov         ecx, INT [max_v_samp(ebp)]  ; rowctr
+    test        ecx, ecx
+    jz          near .return
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(ebp)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]                    ; inptr
+    mov         ebx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]  ; outptr1
+    mov         eax, edx                               ; colctr
+    alignx      16, 7
+.columnloop:
+
+    cmp         eax, byte SIZEOF_YMMWORD
+    ja          short .above_16
+
+    vmovdqu     xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    vpunpckhbw  xmm1, xmm0, xmm0
+    vpunpcklbw  xmm0, xmm0, xmm0
+
+    vmovdqu     XMMWORD [ebx+0*SIZEOF_XMMWORD], xmm0
+    vmovdqu     XMMWORD [ebx+1*SIZEOF_XMMWORD], xmm1
+    vmovdqu     XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
+    vmovdqu     XMMWORD [edi+1*SIZEOF_XMMWORD], xmm1
+
+    jmp         near .nextrow
+
+.above_16:
+    vmovdqu     ymm0, YMMWORD [esi+0*SIZEOF_YMMWORD]
+
+    vpermq      ymm0, ymm0, 0xd8
+    vpunpckhbw  ymm1, ymm0, ymm0
+    vpunpcklbw  ymm0, ymm0, ymm0
+
+    vmovdqu     YMMWORD [ebx+0*SIZEOF_YMMWORD], ymm0
+    vmovdqu     YMMWORD [ebx+1*SIZEOF_YMMWORD], ymm1
+    vmovdqu     YMMWORD [edi+0*SIZEOF_YMMWORD], ymm0
+    vmovdqu     YMMWORD [edi+1*SIZEOF_YMMWORD], ymm1
+
+    sub         eax, byte 2*SIZEOF_YMMWORD
+    jz          short .nextrow
+
+    add         esi, byte SIZEOF_YMMWORD  ; inptr
+    add         ebx, 2*SIZEOF_YMMWORD     ; outptr0
+    add         edi, 2*SIZEOF_YMMWORD     ; outptr1
+    jmp         short .columnloop
+    alignx      16, 7
+
+.nextrow:
+    pop         esi
+    pop         edi
+
+    add         esi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         ecx, byte 2                  ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jdsample-mmx.asm b/simd/i386/jdsample-mmx.asm
similarity index 99%
rename from simd/jdsample-mmx.asm
rename to simd/i386/jdsample-mmx.asm
index 5e4fa7a..266ee7a 100644
--- a/simd/jdsample-mmx.asm
+++ b/simd/i386/jdsample-mmx.asm
@@ -2,6 +2,7 @@
 ; jdsample.asm - upsampling (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -20,7 +21,7 @@
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_fancy_upsample_mmx)
 
 EXTN(jconst_fancy_upsample_mmx):
@@ -31,7 +32,7 @@ PW_THREE        times 4 dw  3
 PW_SEVEN        times 4 dw  7
 PW_EIGHT        times 4 dw  8
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -56,7 +57,7 @@ PW_EIGHT        times 4 dw  8
 %define input_data(b)           (b)+16          ; JSAMPARRAY input_data
 %define output_data_ptr(b)      (b)+20          ; JSAMPARRAY *output_data_ptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v1_fancy_upsample_mmx)
 
 EXTN(jsimd_h2v1_fancy_upsample_mmx):
@@ -214,7 +215,7 @@ EXTN(jsimd_h2v1_fancy_upsample_mmx):
 %define WK_NUM          4
 %define gotptr          wk(0)-SIZEOF_POINTER    ; void *gotptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v2_fancy_upsample_mmx)
 
 EXTN(jsimd_h2v2_fancy_upsample_mmx):
@@ -540,7 +541,7 @@ EXTN(jsimd_h2v2_fancy_upsample_mmx):
 %define input_data(b)           (b)+16          ; JSAMPARRAY input_data
 %define output_data_ptr(b)      (b)+20          ; JSAMPARRAY *output_data_ptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v1_upsample_mmx)
 
 EXTN(jsimd_h2v1_upsample_mmx):
@@ -641,7 +642,7 @@ EXTN(jsimd_h2v1_upsample_mmx):
 %define input_data(b)           (b)+16          ; JSAMPARRAY input_data
 %define output_data_ptr(b)      (b)+20          ; JSAMPARRAY *output_data_ptr
 
-        align   16
+        align   32
         global  EXTN(jsimd_h2v2_upsample_mmx)
 
 EXTN(jsimd_h2v2_upsample_mmx):
@@ -733,4 +734,4 @@ EXTN(jsimd_h2v2_upsample_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jdsample-sse2.asm b/simd/i386/jdsample-sse2.asm
new file mode 100644
index 0000000..01d96b7
--- /dev/null
+++ b/simd/i386/jdsample-sse2.asm
@@ -0,0 +1,729 @@
+;
+; jdsample.asm - upsampling (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fancy_upsample_sse2)
+
+EXTN(jconst_fancy_upsample_sse2):
+
+PW_ONE   times 8 dw 1
+PW_TWO   times 8 dw 2
+PW_THREE times 8 dw 3
+PW_SEVEN times 8 dw 7
+PW_EIGHT times 8 dw 8
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
+;
+; The upsampling algorithm is linear interpolation between pixel centers,
+; also known as a "triangle filter".  This is a good compromise between
+; speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
+; of the way between input pixel centers.
+;
+; GLOBAL(void)
+; jsimd_h2v1_fancy_upsample_sse2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define downsamp_width(b)   (b)+12      ; JDIMENSION downsampled_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_fancy_upsample_sse2)
+
+EXTN(jsimd_h2v1_fancy_upsample_sse2):
+    push        ebp
+    mov         ebp, esp
+    pushpic     ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+
+    mov         eax, JDIMENSION [downsamp_width(ebp)]  ; colctr
+    test        eax, eax
+    jz          near .return
+
+    mov         ecx, INT [max_v_samp(ebp)]  ; rowctr
+    test        ecx, ecx
+    jz          near .return
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(ebp)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        eax                     ; colctr
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr
+
+    test        eax, SIZEOF_XMMWORD-1
+    jz          short .skip
+    mov         dl, JSAMPLE [esi+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [esi+eax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+.skip:
+    pxor        xmm0, xmm0              ; xmm0=(all 0's)
+    pcmpeqb     xmm7, xmm7
+    psrldq      xmm7, (SIZEOF_XMMWORD-1)
+    pand        xmm7, XMMWORD [esi+0*SIZEOF_XMMWORD]
+
+    add         eax, byte SIZEOF_XMMWORD-1
+    and         eax, byte -SIZEOF_XMMWORD
+    cmp         eax, byte SIZEOF_XMMWORD
+    ja          short .columnloop
+    alignx      16, 7
+
+.columnloop_last:
+    pcmpeqb     xmm6, xmm6
+    pslldq      xmm6, (SIZEOF_XMMWORD-1)
+    pand        xmm6, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    jmp         short .upsample
+    alignx      16, 7
+
+.columnloop:
+    movdqa      xmm6, XMMWORD [esi+1*SIZEOF_XMMWORD]
+    pslldq      xmm6, (SIZEOF_XMMWORD-1)
+
+.upsample:
+    movdqa      xmm1, XMMWORD [esi+0*SIZEOF_XMMWORD]
+    movdqa      xmm2, xmm1
+    movdqa      xmm3, xmm1                ; xmm1=( 0  1  2 ... 13 14 15)
+    pslldq      xmm2, 1                   ; xmm2=(--  0  1 ... 12 13 14)
+    psrldq      xmm3, 1                   ; xmm3=( 1  2  3 ... 14 15 --)
+
+    por         xmm2, xmm7                ; xmm2=(-1  0  1 ... 12 13 14)
+    por         xmm3, xmm6                ; xmm3=( 1  2  3 ... 14 15 16)
+
+    movdqa      xmm7, xmm1
+    psrldq      xmm7, (SIZEOF_XMMWORD-1)  ; xmm7=(15 -- -- ... -- -- --)
+
+    movdqa      xmm4, xmm1
+    punpcklbw   xmm1, xmm0                ; xmm1=( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm4, xmm0                ; xmm4=( 8  9 10 11 12 13 14 15)
+    movdqa      xmm5, xmm2
+    punpcklbw   xmm2, xmm0                ; xmm2=(-1  0  1  2  3  4  5  6)
+    punpckhbw   xmm5, xmm0                ; xmm5=( 7  8  9 10 11 12 13 14)
+    movdqa      xmm6, xmm3
+    punpcklbw   xmm3, xmm0                ; xmm3=( 1  2  3  4  5  6  7  8)
+    punpckhbw   xmm6, xmm0                ; xmm6=( 9 10 11 12 13 14 15 16)
+
+    pmullw      xmm1, [GOTOFF(ebx,PW_THREE)]
+    pmullw      xmm4, [GOTOFF(ebx,PW_THREE)]
+    paddw       xmm2, [GOTOFF(ebx,PW_ONE)]
+    paddw       xmm5, [GOTOFF(ebx,PW_ONE)]
+    paddw       xmm3, [GOTOFF(ebx,PW_TWO)]
+    paddw       xmm6, [GOTOFF(ebx,PW_TWO)]
+
+    paddw       xmm2, xmm1
+    paddw       xmm5, xmm4
+    psrlw       xmm2, 2                 ; xmm2=OutLE=( 0  2  4  6  8 10 12 14)
+    psrlw       xmm5, 2                 ; xmm5=OutHE=(16 18 20 22 24 26 28 30)
+    paddw       xmm3, xmm1
+    paddw       xmm6, xmm4
+    psrlw       xmm3, 2                 ; xmm3=OutLO=( 1  3  5  7  9 11 13 15)
+    psrlw       xmm6, 2                 ; xmm6=OutHO=(17 19 21 23 25 27 29 31)
+
+    psllw       xmm3, BYTE_BIT
+    psllw       xmm6, BYTE_BIT
+    por         xmm2, xmm3              ; xmm2=OutL=( 0  1  2 ... 13 14 15)
+    por         xmm5, xmm6              ; xmm5=OutH=(16 17 18 ... 29 30 31)
+
+    movdqa      XMMWORD [edi+0*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [edi+1*SIZEOF_XMMWORD], xmm5
+
+    sub         eax, byte SIZEOF_XMMWORD
+    add         esi, byte 1*SIZEOF_XMMWORD  ; inptr
+    add         edi, byte 2*SIZEOF_XMMWORD  ; outptr
+    cmp         eax, byte SIZEOF_XMMWORD
+    ja          near .columnloop
+    test        eax, eax
+    jnz         near .columnloop_last
+
+    pop         esi
+    pop         edi
+    pop         eax
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         ecx                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    poppic      ebx
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
+; Again a triangle filter; see comments for h2v1 case, above.
+;
+; GLOBAL(void)
+; jsimd_h2v2_fancy_upsample_sse2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define downsamp_width(b)   (b)+12      ; JDIMENSION downsampled_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        4
+%define gotptr        wk(0)-SIZEOF_POINTER  ; void *gotptr
+
+    align       32
+    global      EXTN(jsimd_h2v2_fancy_upsample_sse2)
+
+EXTN(jsimd_h2v2_fancy_upsample_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     eax                     ; make a room for GOT address
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+    movpic      POINTER [gotptr], ebx   ; save GOT address
+
+    mov         edx, eax                               ; edx = original ebp
+    mov         eax, JDIMENSION [downsamp_width(edx)]  ; colctr
+    test        eax, eax
+    jz          near .return
+
+    mov         ecx, INT [max_v_samp(edx)]           ; rowctr
+    test        ecx, ecx
+    jz          near .return
+
+    mov         esi, JSAMPARRAY [input_data(edx)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(edx)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        eax                     ; colctr
+    push        ecx
+    push        edi
+    push        esi
+
+    mov         ecx, JSAMPROW [esi-1*SIZEOF_JSAMPROW]  ; inptr1(above)
+    mov         ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]  ; inptr1(below)
+    mov         edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]  ; outptr1
+
+    test        eax, SIZEOF_XMMWORD-1
+    jz          short .skip
+    push        edx
+    mov         dl, JSAMPLE [ecx+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [ecx+eax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [ebx+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [ebx+eax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [esi+(eax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [esi+eax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+    pop         edx
+.skip:
+    ; -- process the first column block
+
+    movdqa      xmm0, XMMWORD [ebx+0*SIZEOF_XMMWORD]  ; xmm0=row[ 0][0]
+    movdqa      xmm1, XMMWORD [ecx+0*SIZEOF_XMMWORD]  ; xmm1=row[-1][0]
+    movdqa      xmm2, XMMWORD [esi+0*SIZEOF_XMMWORD]  ; xmm2=row[+1][0]
+
+    pushpic     ebx
+    movpic      ebx, POINTER [gotptr]   ; load GOT address
+
+    pxor        xmm3, xmm3              ; xmm3=(all 0's)
+    movdqa      xmm4, xmm0
+    punpcklbw   xmm0, xmm3              ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm4, xmm3              ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm5, xmm1
+    punpcklbw   xmm1, xmm3              ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm5, xmm3              ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm6, xmm2
+    punpcklbw   xmm2, xmm3              ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm6, xmm3              ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
+
+    pmullw      xmm0, [GOTOFF(ebx,PW_THREE)]
+    pmullw      xmm4, [GOTOFF(ebx,PW_THREE)]
+
+    pcmpeqb     xmm7, xmm7
+    psrldq      xmm7, (SIZEOF_XMMWORD-2)
+
+    paddw       xmm1, xmm0              ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm5, xmm4              ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
+    paddw       xmm2, xmm0              ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm6, xmm4              ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
+
+    movdqa      XMMWORD [edx+0*SIZEOF_XMMWORD], xmm1  ; temporarily save
+    movdqa      XMMWORD [edx+1*SIZEOF_XMMWORD], xmm5  ; the intermediate data
+    movdqa      XMMWORD [edi+0*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [edi+1*SIZEOF_XMMWORD], xmm6
+
+    pand        xmm1, xmm7              ; xmm1=( 0 -- -- -- -- -- -- --)
+    pand        xmm2, xmm7              ; xmm2=( 0 -- -- -- -- -- -- --)
+
+    movdqa      XMMWORD [wk(0)], xmm1
+    movdqa      XMMWORD [wk(1)], xmm2
+
+    poppic      ebx
+
+    add         eax, byte SIZEOF_XMMWORD-1
+    and         eax, byte -SIZEOF_XMMWORD
+    cmp         eax, byte SIZEOF_XMMWORD
+    ja          short .columnloop
+    alignx      16, 7
+
+.columnloop_last:
+    ; -- process the last column block
+
+    pushpic     ebx
+    movpic      ebx, POINTER [gotptr]   ; load GOT address
+
+    pcmpeqb     xmm1, xmm1
+    pslldq      xmm1, (SIZEOF_XMMWORD-2)
+    movdqa      xmm2, xmm1
+
+    pand        xmm1, XMMWORD [edx+1*SIZEOF_XMMWORD]
+    pand        xmm2, XMMWORD [edi+1*SIZEOF_XMMWORD]
+
+    movdqa      XMMWORD [wk(2)], xmm1   ; xmm1=(-- -- -- -- -- -- -- 15)
+    movdqa      XMMWORD [wk(3)], xmm2   ; xmm2=(-- -- -- -- -- -- -- 15)
+
+    jmp         near .upsample
+    alignx      16, 7
+
+.columnloop:
+    ; -- process the next column block
+
+    movdqa      xmm0, XMMWORD [ebx+1*SIZEOF_XMMWORD]  ; xmm0=row[ 0][1]
+    movdqa      xmm1, XMMWORD [ecx+1*SIZEOF_XMMWORD]  ; xmm1=row[-1][1]
+    movdqa      xmm2, XMMWORD [esi+1*SIZEOF_XMMWORD]  ; xmm2=row[+1][1]
+
+    pushpic     ebx
+    movpic      ebx, POINTER [gotptr]   ; load GOT address
+
+    pxor        xmm3, xmm3              ; xmm3=(all 0's)
+    movdqa      xmm4, xmm0
+    punpcklbw   xmm0, xmm3              ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm4, xmm3              ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm5, xmm1
+    punpcklbw   xmm1, xmm3              ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm5, xmm3              ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm6, xmm2
+    punpcklbw   xmm2, xmm3              ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm6, xmm3              ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
+
+    pmullw      xmm0, [GOTOFF(ebx,PW_THREE)]
+    pmullw      xmm4, [GOTOFF(ebx,PW_THREE)]
+
+    paddw       xmm1, xmm0              ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm5, xmm4              ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
+    paddw       xmm2, xmm0              ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm6, xmm4              ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
+
+    movdqa      XMMWORD [edx+2*SIZEOF_XMMWORD], xmm1  ; temporarily save
+    movdqa      XMMWORD [edx+3*SIZEOF_XMMWORD], xmm5  ; the intermediate data
+    movdqa      XMMWORD [edi+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [edi+3*SIZEOF_XMMWORD], xmm6
+
+    pslldq      xmm1, (SIZEOF_XMMWORD-2)  ; xmm1=(-- -- -- -- -- -- --  0)
+    pslldq      xmm2, (SIZEOF_XMMWORD-2)  ; xmm2=(-- -- -- -- -- -- --  0)
+
+    movdqa      XMMWORD [wk(2)], xmm1
+    movdqa      XMMWORD [wk(3)], xmm2
+
+.upsample:
+    ; -- process the upper row
+
+    movdqa      xmm7, XMMWORD [edx+0*SIZEOF_XMMWORD]
+    movdqa      xmm3, XMMWORD [edx+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm0, xmm7                ; xmm7=Int0L=( 0  1  2  3  4  5  6  7)
+    movdqa      xmm4, xmm3                ; xmm3=Int0H=( 8  9 10 11 12 13 14 15)
+    psrldq      xmm0, 2                   ; xmm0=( 1  2  3  4  5  6  7 --)
+    pslldq      xmm4, (SIZEOF_XMMWORD-2)  ; xmm4=(-- -- -- -- -- -- --  8)
+    movdqa      xmm5, xmm7
+    movdqa      xmm6, xmm3
+    psrldq      xmm5, (SIZEOF_XMMWORD-2)  ; xmm5=( 7 -- -- -- -- -- -- --)
+    pslldq      xmm6, 2                   ; xmm6=(--  8  9 10 11 12 13 14)
+
+    por         xmm0, xmm4                ; xmm0=( 1  2  3  4  5  6  7  8)
+    por         xmm5, xmm6                ; xmm5=( 7  8  9 10 11 12 13 14)
+
+    movdqa      xmm1, xmm7
+    movdqa      xmm2, xmm3
+    pslldq      xmm1, 2                   ; xmm1=(--  0  1  2  3  4  5  6)
+    psrldq      xmm2, 2                   ; xmm2=( 9 10 11 12 13 14 15 --)
+    movdqa      xmm4, xmm3
+    psrldq      xmm4, (SIZEOF_XMMWORD-2)  ; xmm4=(15 -- -- -- -- -- -- --)
+
+    por         xmm1, XMMWORD [wk(0)]     ; xmm1=(-1  0  1  2  3  4  5  6)
+    por         xmm2, XMMWORD [wk(2)]     ; xmm2=( 9 10 11 12 13 14 15 16)
+
+    movdqa      XMMWORD [wk(0)], xmm4
+
+    pmullw      xmm7, [GOTOFF(ebx,PW_THREE)]
+    pmullw      xmm3, [GOTOFF(ebx,PW_THREE)]
+    paddw       xmm1, [GOTOFF(ebx,PW_EIGHT)]
+    paddw       xmm5, [GOTOFF(ebx,PW_EIGHT)]
+    paddw       xmm0, [GOTOFF(ebx,PW_SEVEN)]
+    paddw       xmm2, [GOTOFF(ebx,PW_SEVEN)]
+
+    paddw       xmm1, xmm7
+    paddw       xmm5, xmm3
+    psrlw       xmm1, 4                 ; xmm1=Out0LE=( 0  2  4  6  8 10 12 14)
+    psrlw       xmm5, 4                 ; xmm5=Out0HE=(16 18 20 22 24 26 28 30)
+    paddw       xmm0, xmm7
+    paddw       xmm2, xmm3
+    psrlw       xmm0, 4                 ; xmm0=Out0LO=( 1  3  5  7  9 11 13 15)
+    psrlw       xmm2, 4                 ; xmm2=Out0HO=(17 19 21 23 25 27 29 31)
+
+    psllw       xmm0, BYTE_BIT
+    psllw       xmm2, BYTE_BIT
+    por         xmm1, xmm0              ; xmm1=Out0L=( 0  1  2 ... 13 14 15)
+    por         xmm5, xmm2              ; xmm5=Out0H=(16 17 18 ... 29 30 31)
+
+    movdqa      XMMWORD [edx+0*SIZEOF_XMMWORD], xmm1
+    movdqa      XMMWORD [edx+1*SIZEOF_XMMWORD], xmm5
+
+    ; -- process the lower row
+
+    movdqa      xmm6, XMMWORD [edi+0*SIZEOF_XMMWORD]
+    movdqa      xmm4, XMMWORD [edi+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm7, xmm6                ; xmm6=Int1L=( 0  1  2  3  4  5  6  7)
+    movdqa      xmm3, xmm4                ; xmm4=Int1H=( 8  9 10 11 12 13 14 15)
+    psrldq      xmm7, 2                   ; xmm7=( 1  2  3  4  5  6  7 --)
+    pslldq      xmm3, (SIZEOF_XMMWORD-2)  ; xmm3=(-- -- -- -- -- -- --  8)
+    movdqa      xmm0, xmm6
+    movdqa      xmm2, xmm4
+    psrldq      xmm0, (SIZEOF_XMMWORD-2)  ; xmm0=( 7 -- -- -- -- -- -- --)
+    pslldq      xmm2, 2                   ; xmm2=(--  8  9 10 11 12 13 14)
+
+    por         xmm7, xmm3                ; xmm7=( 1  2  3  4  5  6  7  8)
+    por         xmm0, xmm2                ; xmm0=( 7  8  9 10 11 12 13 14)
+
+    movdqa      xmm1, xmm6
+    movdqa      xmm5, xmm4
+    pslldq      xmm1, 2                   ; xmm1=(--  0  1  2  3  4  5  6)
+    psrldq      xmm5, 2                   ; xmm5=( 9 10 11 12 13 14 15 --)
+    movdqa      xmm3, xmm4
+    psrldq      xmm3, (SIZEOF_XMMWORD-2)  ; xmm3=(15 -- -- -- -- -- -- --)
+
+    por         xmm1, XMMWORD [wk(1)]     ; xmm1=(-1  0  1  2  3  4  5  6)
+    por         xmm5, XMMWORD [wk(3)]     ; xmm5=( 9 10 11 12 13 14 15 16)
+
+    movdqa      XMMWORD [wk(1)], xmm3
+
+    pmullw      xmm6, [GOTOFF(ebx,PW_THREE)]
+    pmullw      xmm4, [GOTOFF(ebx,PW_THREE)]
+    paddw       xmm1, [GOTOFF(ebx,PW_EIGHT)]
+    paddw       xmm0, [GOTOFF(ebx,PW_EIGHT)]
+    paddw       xmm7, [GOTOFF(ebx,PW_SEVEN)]
+    paddw       xmm5, [GOTOFF(ebx,PW_SEVEN)]
+
+    paddw       xmm1, xmm6
+    paddw       xmm0, xmm4
+    psrlw       xmm1, 4                 ; xmm1=Out1LE=( 0  2  4  6  8 10 12 14)
+    psrlw       xmm0, 4                 ; xmm0=Out1HE=(16 18 20 22 24 26 28 30)
+    paddw       xmm7, xmm6
+    paddw       xmm5, xmm4
+    psrlw       xmm7, 4                 ; xmm7=Out1LO=( 1  3  5  7  9 11 13 15)
+    psrlw       xmm5, 4                 ; xmm5=Out1HO=(17 19 21 23 25 27 29 31)
+
+    psllw       xmm7, BYTE_BIT
+    psllw       xmm5, BYTE_BIT
+    por         xmm1, xmm7              ; xmm1=Out1L=( 0  1  2 ... 13 14 15)
+    por         xmm0, xmm5              ; xmm0=Out1H=(16 17 18 ... 29 30 31)
+
+    movdqa      XMMWORD [edi+0*SIZEOF_XMMWORD], xmm1
+    movdqa      XMMWORD [edi+1*SIZEOF_XMMWORD], xmm0
+
+    poppic      ebx
+
+    sub         eax, byte SIZEOF_XMMWORD
+    add         ecx, byte 1*SIZEOF_XMMWORD  ; inptr1(above)
+    add         ebx, byte 1*SIZEOF_XMMWORD  ; inptr0
+    add         esi, byte 1*SIZEOF_XMMWORD  ; inptr1(below)
+    add         edx, byte 2*SIZEOF_XMMWORD  ; outptr0
+    add         edi, byte 2*SIZEOF_XMMWORD  ; outptr1
+    cmp         eax, byte SIZEOF_XMMWORD
+    ja          near .columnloop
+    test        eax, eax
+    jnz         near .columnloop_last
+
+    pop         esi
+    pop         edi
+    pop         ecx
+    pop         eax
+
+    add         esi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         ecx, byte 2                  ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v1_upsample_sse2 (int max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define output_width(b)     (b)+12      ; JDIMENSION output_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_upsample_sse2)
+
+EXTN(jsimd_h2v1_upsample_sse2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         edx, JDIMENSION [output_width(ebp)]
+    add         edx, byte (2*SIZEOF_XMMWORD)-1
+    and         edx, byte -(2*SIZEOF_XMMWORD)
+    jz          short .return
+
+    mov         ecx, INT [max_v_samp(ebp)]  ; rowctr
+    test        ecx, ecx
+    jz          short .return
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(ebp)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]     ; inptr
+    mov         edi, JSAMPROW [edi]     ; outptr
+    mov         eax, edx                ; colctr
+    alignx      16, 7
+.columnloop:
+
+    movdqa      xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
+
+    movdqa      xmm1, xmm0
+    punpcklbw   xmm0, xmm0
+    punpckhbw   xmm1, xmm1
+
+    movdqa      XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
+    movdqa      XMMWORD [edi+1*SIZEOF_XMMWORD], xmm1
+
+    sub         eax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    movdqa      xmm2, XMMWORD [esi+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm3, xmm2
+    punpcklbw   xmm2, xmm2
+    punpckhbw   xmm3, xmm3
+
+    movdqa      XMMWORD [edi+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [edi+3*SIZEOF_XMMWORD], xmm3
+
+    sub         eax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    add         esi, byte 2*SIZEOF_XMMWORD  ; inptr
+    add         edi, byte 4*SIZEOF_XMMWORD  ; outptr
+    jmp         short .columnloop
+    alignx      16, 7
+
+.nextrow:
+    pop         esi
+    pop         edi
+
+    add         esi, byte SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         ecx                        ; rowctr
+    jg          short .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v2_upsample_sse2 (nt max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+%define max_v_samp(b)       (b)+8       ; int max_v_samp_factor
+%define output_width(b)     (b)+12      ; JDIMENSION output_width
+%define input_data(b)       (b)+16      ; JSAMPARRAY input_data
+%define output_data_ptr(b)  (b)+20      ; JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v2_upsample_sse2)
+
+EXTN(jsimd_h2v2_upsample_sse2):
+    push        ebp
+    mov         ebp, esp
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         edx, JDIMENSION [output_width(ebp)]
+    add         edx, byte (2*SIZEOF_XMMWORD)-1
+    and         edx, byte -(2*SIZEOF_XMMWORD)
+    jz          near .return
+
+    mov         ecx, INT [max_v_samp(ebp)]  ; rowctr
+    test        ecx, ecx
+    jz          near .return
+
+    mov         esi, JSAMPARRAY [input_data(ebp)]    ; input_data
+    mov         edi, POINTER [output_data_ptr(ebp)]
+    mov         edi, JSAMPARRAY [edi]                ; output_data
+    alignx      16, 7
+.rowloop:
+    push        edi
+    push        esi
+
+    mov         esi, JSAMPROW [esi]                    ; inptr
+    mov         ebx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]  ; outptr1
+    mov         eax, edx                               ; colctr
+    alignx      16, 7
+.columnloop:
+
+    movdqa      xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
+
+    movdqa      xmm1, xmm0
+    punpcklbw   xmm0, xmm0
+    punpckhbw   xmm1, xmm1
+
+    movdqa      XMMWORD [ebx+0*SIZEOF_XMMWORD], xmm0
+    movdqa      XMMWORD [ebx+1*SIZEOF_XMMWORD], xmm1
+    movdqa      XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
+    movdqa      XMMWORD [edi+1*SIZEOF_XMMWORD], xmm1
+
+    sub         eax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    movdqa      xmm2, XMMWORD [esi+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm3, xmm2
+    punpcklbw   xmm2, xmm2
+    punpckhbw   xmm3, xmm3
+
+    movdqa      XMMWORD [ebx+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [ebx+3*SIZEOF_XMMWORD], xmm3
+    movdqa      XMMWORD [edi+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [edi+3*SIZEOF_XMMWORD], xmm3
+
+    sub         eax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    add         esi, byte 2*SIZEOF_XMMWORD  ; inptr
+    add         ebx, byte 4*SIZEOF_XMMWORD  ; outptr0
+    add         edi, byte 4*SIZEOF_XMMWORD  ; outptr1
+    jmp         short .columnloop
+    alignx      16, 7
+
+.nextrow:
+    pop         esi
+    pop         edi
+
+    add         esi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         edi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         ecx, byte 2                  ; rowctr
+    jg          short .rowloop
+
+.return:
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jfdctflt-3dn.asm b/simd/i386/jfdctflt-3dn.asm
similarity index 99%
rename from simd/jfdctflt-3dn.asm
rename to simd/i386/jfdctflt-3dn.asm
index 2191618..c3d8fba 100644
--- a/simd/jfdctflt-3dn.asm
+++ b/simd/i386/jfdctflt-3dn.asm
@@ -2,6 +2,7 @@
 ; jfdctflt.asm - floating-point FDCT (3DNow!)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -25,7 +26,7 @@
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_fdct_float_3dnow)
 
 EXTN(jconst_fdct_float_3dnow):
@@ -35,7 +36,7 @@ PD_0_707        times 2 dd  0.707106781186547524400844
 PD_0_541        times 2 dd  0.541196100146196984399723
 PD_1_306        times 2 dd  1.306562964876376527856643
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -53,7 +54,7 @@ PD_1_306        times 2 dd  1.306562964876376527856643
 %define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_MMWORD  ; mmword wk[WK_NUM]
 %define WK_NUM          2
 
-        align   16
+        align   32
         global  EXTN(jsimd_fdct_float_3dnow)
 
 EXTN(jsimd_fdct_float_3dnow):
@@ -316,4 +317,4 @@ EXTN(jsimd_fdct_float_3dnow):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jfdctflt-sse.asm b/simd/i386/jfdctflt-sse.asm
new file mode 100644
index 0000000..b15eb5c
--- /dev/null
+++ b/simd/i386/jfdctflt-sse.asm
@@ -0,0 +1,370 @@
+;
+; jfdctflt.asm - floating-point FDCT (SSE)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a floating-point implementation of the forward DCT
+; (Discrete Cosine Transform). The following code is based directly on
+; the IJG's original jfdctflt.c; see the jfdctflt.c for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%macro  unpcklps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
+    shufps      %1, %2, 0x44
+%endmacro
+
+%macro  unpckhps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
+    shufps      %1, %2, 0xEE
+%endmacro
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fdct_float_sse)
+
+EXTN(jconst_fdct_float_sse):
+
+PD_0_382 times 4 dd 0.382683432365089771728460
+PD_0_707 times 4 dd 0.707106781186547524400844
+PD_0_541 times 4 dd 0.541196100146196984399723
+PD_1_306 times 4 dd 1.306562964876376527856643
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Perform the forward DCT on one block of samples.
+;
+; GLOBAL(void)
+; jsimd_fdct_float_sse (FAST_FLOAT *data)
+;
+
+%define data(b)       (b)+8             ; FAST_FLOAT *data
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+
+    align       32
+    global      EXTN(jsimd_fdct_float_sse)
+
+EXTN(jsimd_fdct_float_sse):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+;   push        esi                     ; unused
+;   push        edi                     ; unused
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process rows.
+
+    mov         edx, POINTER [data(eax)]  ; (FAST_FLOAT *)
+    mov         ecx, DCTSIZE/4
+    alignx      16, 7
+.rowloop:
+
+    movaps      xmm0, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(2,1,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(3,1,edx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm0=(20 21 22 23), xmm2=(24 25 26 27)
+    ; xmm1=(30 31 32 33), xmm3=(34 35 36 37)
+
+    movaps      xmm4, xmm0              ; transpose coefficients(phase 1)
+    unpcklps    xmm0, xmm1              ; xmm0=(20 30 21 31)
+    unpckhps    xmm4, xmm1              ; xmm4=(22 32 23 33)
+    movaps      xmm5, xmm2              ; transpose coefficients(phase 1)
+    unpcklps    xmm2, xmm3              ; xmm2=(24 34 25 35)
+    unpckhps    xmm5, xmm3              ; xmm5=(26 36 27 37)
+
+    movaps      xmm6, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm7, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(0,1,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(1,1,edx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm6=(00 01 02 03), xmm1=(04 05 06 07)
+    ; xmm7=(10 11 12 13), xmm3=(14 15 16 17)
+
+    movaps      XMMWORD [wk(0)], xmm4   ; wk(0)=(22 32 23 33)
+    movaps      XMMWORD [wk(1)], xmm2   ; wk(1)=(24 34 25 35)
+
+    movaps      xmm4, xmm6              ; transpose coefficients(phase 1)
+    unpcklps    xmm6, xmm7              ; xmm6=(00 10 01 11)
+    unpckhps    xmm4, xmm7              ; xmm4=(02 12 03 13)
+    movaps      xmm2, xmm1              ; transpose coefficients(phase 1)
+    unpcklps    xmm1, xmm3              ; xmm1=(04 14 05 15)
+    unpckhps    xmm2, xmm3              ; xmm2=(06 16 07 17)
+
+    movaps      xmm7, xmm6              ; transpose coefficients(phase 2)
+    unpcklps2   xmm6, xmm0              ; xmm6=(00 10 20 30)=data0
+    unpckhps2   xmm7, xmm0              ; xmm7=(01 11 21 31)=data1
+    movaps      xmm3, xmm2              ; transpose coefficients(phase 2)
+    unpcklps2   xmm2, xmm5              ; xmm2=(06 16 26 36)=data6
+    unpckhps2   xmm3, xmm5              ; xmm3=(07 17 27 37)=data7
+
+    movaps      xmm0, xmm7
+    movaps      xmm5, xmm6
+    subps       xmm7, xmm2              ; xmm7=data1-data6=tmp6
+    subps       xmm6, xmm3              ; xmm6=data0-data7=tmp7
+    addps       xmm0, xmm2              ; xmm0=data1+data6=tmp1
+    addps       xmm5, xmm3              ; xmm5=data0+data7=tmp0
+
+    movaps      xmm2, XMMWORD [wk(0)]   ; xmm2=(22 32 23 33)
+    movaps      xmm3, XMMWORD [wk(1)]   ; xmm3=(24 34 25 35)
+    movaps      XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
+    movaps      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
+
+    movaps      xmm7, xmm4              ; transpose coefficients(phase 2)
+    unpcklps2   xmm4, xmm2              ; xmm4=(02 12 22 32)=data2
+    unpckhps2   xmm7, xmm2              ; xmm7=(03 13 23 33)=data3
+    movaps      xmm6, xmm1              ; transpose coefficients(phase 2)
+    unpcklps2   xmm1, xmm3              ; xmm1=(04 14 24 34)=data4
+    unpckhps2   xmm6, xmm3              ; xmm6=(05 15 25 35)=data5
+
+    movaps      xmm2, xmm7
+    movaps      xmm3, xmm4
+    addps       xmm7, xmm1              ; xmm7=data3+data4=tmp3
+    addps       xmm4, xmm6              ; xmm4=data2+data5=tmp2
+    subps       xmm2, xmm1              ; xmm2=data3-data4=tmp4
+    subps       xmm3, xmm6              ; xmm3=data2-data5=tmp5
+
+    ; -- Even part
+
+    movaps      xmm1, xmm5
+    movaps      xmm6, xmm0
+    subps       xmm5, xmm7              ; xmm5=tmp13
+    subps       xmm0, xmm4              ; xmm0=tmp12
+    addps       xmm1, xmm7              ; xmm1=tmp10
+    addps       xmm6, xmm4              ; xmm6=tmp11
+
+    addps       xmm0, xmm5
+    mulps       xmm0, [GOTOFF(ebx,PD_0_707)]  ; xmm0=z1
+
+    movaps      xmm7, xmm1
+    movaps      xmm4, xmm5
+    subps       xmm1, xmm6              ; xmm1=data4
+    subps       xmm5, xmm0              ; xmm5=data6
+    addps       xmm7, xmm6              ; xmm7=data0
+    addps       xmm4, xmm0              ; xmm4=data2
+
+    movaps      XMMWORD [XMMBLOCK(0,1,edx,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(2,1,edx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)], xmm4
+
+    ; -- Odd part
+
+    movaps      xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
+    movaps      xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
+
+    addps       xmm2, xmm3              ; xmm2=tmp10
+    addps       xmm3, xmm6              ; xmm3=tmp11
+    addps       xmm6, xmm0              ; xmm6=tmp12, xmm0=tmp7
+
+    mulps       xmm3, [GOTOFF(ebx,PD_0_707)]  ; xmm3=z3
+
+    movaps      xmm1, xmm2                    ; xmm1=tmp10
+    subps       xmm2, xmm6
+    mulps       xmm2, [GOTOFF(ebx,PD_0_382)]  ; xmm2=z5
+    mulps       xmm1, [GOTOFF(ebx,PD_0_541)]  ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
+    mulps       xmm6, [GOTOFF(ebx,PD_1_306)]  ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
+    addps       xmm1, xmm2                    ; xmm1=z2
+    addps       xmm6, xmm2                    ; xmm6=z4
+
+    movaps      xmm5, xmm0
+    subps       xmm0, xmm3              ; xmm0=z13
+    addps       xmm5, xmm3              ; xmm5=z11
+
+    movaps      xmm7, xmm0
+    movaps      xmm4, xmm5
+    subps       xmm0, xmm1              ; xmm0=data3
+    subps       xmm5, xmm6              ; xmm5=data7
+    addps       xmm7, xmm1              ; xmm7=data5
+    addps       xmm4, xmm6              ; xmm4=data1
+
+    movaps      XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(3,1,edx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(1,1,edx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)], xmm4
+
+    add         edx, 4*DCTSIZE*SIZEOF_FAST_FLOAT
+    dec         ecx
+    jnz         near .rowloop
+
+    ; ---- Pass 2: process columns.
+
+    mov         edx, POINTER [data(eax)]  ; (FAST_FLOAT *)
+    mov         ecx, DCTSIZE/4
+    alignx      16, 7
+.columnloop:
+
+    movaps      xmm0, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm0=(02 12 22 32), xmm2=(42 52 62 72)
+    ; xmm1=(03 13 23 33), xmm3=(43 53 63 73)
+
+    movaps      xmm4, xmm0              ; transpose coefficients(phase 1)
+    unpcklps    xmm0, xmm1              ; xmm0=(02 03 12 13)
+    unpckhps    xmm4, xmm1              ; xmm4=(22 23 32 33)
+    movaps      xmm5, xmm2              ; transpose coefficients(phase 1)
+    unpcklps    xmm2, xmm3              ; xmm2=(42 43 52 53)
+    unpckhps    xmm5, xmm3              ; xmm5=(62 63 72 73)
+
+    movaps      xmm6, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm7, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm6=(00 10 20 30), xmm1=(40 50 60 70)
+    ; xmm7=(01 11 21 31), xmm3=(41 51 61 71)
+
+    movaps      XMMWORD [wk(0)], xmm4   ; wk(0)=(22 23 32 33)
+    movaps      XMMWORD [wk(1)], xmm2   ; wk(1)=(42 43 52 53)
+
+    movaps      xmm4, xmm6              ; transpose coefficients(phase 1)
+    unpcklps    xmm6, xmm7              ; xmm6=(00 01 10 11)
+    unpckhps    xmm4, xmm7              ; xmm4=(20 21 30 31)
+    movaps      xmm2, xmm1              ; transpose coefficients(phase 1)
+    unpcklps    xmm1, xmm3              ; xmm1=(40 41 50 51)
+    unpckhps    xmm2, xmm3              ; xmm2=(60 61 70 71)
+
+    movaps      xmm7, xmm6              ; transpose coefficients(phase 2)
+    unpcklps2   xmm6, xmm0              ; xmm6=(00 01 02 03)=data0
+    unpckhps2   xmm7, xmm0              ; xmm7=(10 11 12 13)=data1
+    movaps      xmm3, xmm2              ; transpose coefficients(phase 2)
+    unpcklps2   xmm2, xmm5              ; xmm2=(60 61 62 63)=data6
+    unpckhps2   xmm3, xmm5              ; xmm3=(70 71 72 73)=data7
+
+    movaps      xmm0, xmm7
+    movaps      xmm5, xmm6
+    subps       xmm7, xmm2              ; xmm7=data1-data6=tmp6
+    subps       xmm6, xmm3              ; xmm6=data0-data7=tmp7
+    addps       xmm0, xmm2              ; xmm0=data1+data6=tmp1
+    addps       xmm5, xmm3              ; xmm5=data0+data7=tmp0
+
+    movaps      xmm2, XMMWORD [wk(0)]   ; xmm2=(22 23 32 33)
+    movaps      xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53)
+    movaps      XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
+    movaps      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
+
+    movaps      xmm7, xmm4              ; transpose coefficients(phase 2)
+    unpcklps2   xmm4, xmm2              ; xmm4=(20 21 22 23)=data2
+    unpckhps2   xmm7, xmm2              ; xmm7=(30 31 32 33)=data3
+    movaps      xmm6, xmm1              ; transpose coefficients(phase 2)
+    unpcklps2   xmm1, xmm3              ; xmm1=(40 41 42 43)=data4
+    unpckhps2   xmm6, xmm3              ; xmm6=(50 51 52 53)=data5
+
+    movaps      xmm2, xmm7
+    movaps      xmm3, xmm4
+    addps       xmm7, xmm1              ; xmm7=data3+data4=tmp3
+    addps       xmm4, xmm6              ; xmm4=data2+data5=tmp2
+    subps       xmm2, xmm1              ; xmm2=data3-data4=tmp4
+    subps       xmm3, xmm6              ; xmm3=data2-data5=tmp5
+
+    ; -- Even part
+
+    movaps      xmm1, xmm5
+    movaps      xmm6, xmm0
+    subps       xmm5, xmm7              ; xmm5=tmp13
+    subps       xmm0, xmm4              ; xmm0=tmp12
+    addps       xmm1, xmm7              ; xmm1=tmp10
+    addps       xmm6, xmm4              ; xmm6=tmp11
+
+    addps       xmm0, xmm5
+    mulps       xmm0, [GOTOFF(ebx,PD_0_707)]  ; xmm0=z1
+
+    movaps      xmm7, xmm1
+    movaps      xmm4, xmm5
+    subps       xmm1, xmm6              ; xmm1=data4
+    subps       xmm5, xmm0              ; xmm5=data6
+    addps       xmm7, xmm6              ; xmm7=data0
+    addps       xmm4, xmm0              ; xmm4=data2
+
+    movaps      XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)], xmm4
+
+    ; -- Odd part
+
+    movaps      xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
+    movaps      xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
+
+    addps       xmm2, xmm3              ; xmm2=tmp10
+    addps       xmm3, xmm6              ; xmm3=tmp11
+    addps       xmm6, xmm0              ; xmm6=tmp12, xmm0=tmp7
+
+    mulps       xmm3, [GOTOFF(ebx,PD_0_707)]  ; xmm3=z3
+
+    movaps      xmm1, xmm2                    ; xmm1=tmp10
+    subps       xmm2, xmm6
+    mulps       xmm2, [GOTOFF(ebx,PD_0_382)]  ; xmm2=z5
+    mulps       xmm1, [GOTOFF(ebx,PD_0_541)]  ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
+    mulps       xmm6, [GOTOFF(ebx,PD_1_306)]  ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
+    addps       xmm1, xmm2                    ; xmm1=z2
+    addps       xmm6, xmm2                    ; xmm6=z4
+
+    movaps      xmm5, xmm0
+    subps       xmm0, xmm3              ; xmm0=z13
+    addps       xmm5, xmm3              ; xmm5=z11
+
+    movaps      xmm7, xmm0
+    movaps      xmm4, xmm5
+    subps       xmm0, xmm1              ; xmm0=data3
+    subps       xmm5, xmm6              ; xmm5=data7
+    addps       xmm7, xmm1              ; xmm7=data5
+    addps       xmm4, xmm6              ; xmm4=data1
+
+    movaps      XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)], xmm4
+
+    add         edx, byte 4*SIZEOF_FAST_FLOAT
+    dec         ecx
+    jnz         near .columnloop
+
+;   pop         edi                     ; unused
+;   pop         esi                     ; unused
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    poppic      ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jfdctfst-mmx.asm b/simd/i386/jfdctfst-mmx.asm
similarity index 99%
rename from simd/jfdctfst-mmx.asm
rename to simd/i386/jfdctfst-mmx.asm
index eb2eb9c..f274924 100644
--- a/simd/jfdctfst-mmx.asm
+++ b/simd/i386/jfdctfst-mmx.asm
@@ -2,6 +2,7 @@
 ; jfdctfst.asm - fast integer FDCT (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -50,7 +51,7 @@ F_1_306 equ     DESCALE(1402911301,30-CONST_BITS)       ; FIX(1.306562965)
 %define PRE_MULTIPLY_SCALE_BITS   2
 %define CONST_SHIFT     (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_fdct_ifast_mmx)
 
 EXTN(jconst_fdct_ifast_mmx):
@@ -60,7 +61,7 @@ PW_F0382        times 4 dw  F_0_382 << CONST_SHIFT
 PW_F0541        times 4 dw  F_0_541 << CONST_SHIFT
 PW_F1306        times 4 dw  F_1_306 << CONST_SHIFT
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -78,7 +79,7 @@ PW_F1306        times 4 dw  F_1_306 << CONST_SHIFT
 %define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_MMWORD  ; mmword wk[WK_NUM]
 %define WK_NUM          2
 
-        align   16
+        align   32
         global  EXTN(jsimd_fdct_ifast_mmx)
 
 EXTN(jsimd_fdct_ifast_mmx):
@@ -393,4 +394,4 @@ EXTN(jsimd_fdct_ifast_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jfdctfst-sse2.asm b/simd/i386/jfdctfst-sse2.asm
new file mode 100644
index 0000000..fb140fa
--- /dev/null
+++ b/simd/i386/jfdctfst-sse2.asm
@@ -0,0 +1,404 @@
+;
+; jfdctfst.asm - fast integer FDCT (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a fast, not so accurate integer implementation of
+; the forward DCT (Discrete Cosine Transform). The following code is
+; based directly on the IJG's original jfdctfst.c; see the jfdctfst.c
+; for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  8  ; 14 is also OK.
+
+%if CONST_BITS == 8
+F_0_382 equ  98  ; FIX(0.382683433)
+F_0_541 equ 139  ; FIX(0.541196100)
+F_0_707 equ 181  ; FIX(0.707106781)
+F_1_306 equ 334  ; FIX(1.306562965)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_382 equ DESCALE( 410903207, 30-CONST_BITS)  ; FIX(0.382683433)
+F_0_541 equ DESCALE( 581104887, 30-CONST_BITS)  ; FIX(0.541196100)
+F_0_707 equ DESCALE( 759250124, 30-CONST_BITS)  ; FIX(0.707106781)
+F_1_306 equ DESCALE(1402911301, 30-CONST_BITS)  ; FIX(1.306562965)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
+; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
+
+%define PRE_MULTIPLY_SCALE_BITS  2
+%define CONST_SHIFT              (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
+
+    alignz      32
+    global      EXTN(jconst_fdct_ifast_sse2)
+
+EXTN(jconst_fdct_ifast_sse2):
+
+PW_F0707 times 8 dw F_0_707 << CONST_SHIFT
+PW_F0382 times 8 dw F_0_382 << CONST_SHIFT
+PW_F0541 times 8 dw F_0_541 << CONST_SHIFT
+PW_F1306 times 8 dw F_1_306 << CONST_SHIFT
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Perform the forward DCT on one block of samples.
+;
+; GLOBAL(void)
+; jsimd_fdct_ifast_sse2 (DCTELEM *data)
+;
+
+%define data(b)       (b)+8             ; DCTELEM *data
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+
+    align       32
+    global      EXTN(jsimd_fdct_ifast_sse2)
+
+EXTN(jsimd_fdct_ifast_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     ebx
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+;   push        esi                     ; unused
+;   push        edi                     ; unused
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process rows.
+
+    mov         edx, POINTER [data(eax)]  ; (DCTELEM *)
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)]
+
+    ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
+    ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm4, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm1              ; xmm0=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm4, xmm1              ; xmm4=(04 14 05 15 06 16 07 17)
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm3              ; xmm2=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm5, xmm3              ; xmm5=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm6, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm7, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)]
+
+    ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
+    ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
+    movdqa      XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm2, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm7              ; xmm6=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm2, xmm7              ; xmm2=(44 54 45 55 46 56 47 57)
+    movdqa      xmm5, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm3              ; xmm1=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm5, xmm3              ; xmm5=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm7, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm1              ; xmm6=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm7, xmm1              ; xmm7=(42 52 62 72 43 53 63 73)
+    movdqa      xmm3, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm5              ; xmm2=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm3, xmm5              ; xmm3=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=(42 52 62 72 43 53 63 73)
+    movdqa      XMMWORD [wk(1)], xmm2   ; wk(1)=(44 54 64 74 45 55 65 75)
+
+    movdqa      xmm7, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm1              ; xmm0=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm7, xmm1              ; xmm7=(02 12 22 32 03 13 23 33)
+    movdqa      xmm2, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm5              ; xmm4=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm2, xmm5              ; xmm2=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm1, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm6              ; xmm0=(00 10 20 30 40 50 60 70)=data0
+    punpckhqdq  xmm1, xmm6              ; xmm1=(01 11 21 31 41 51 61 71)=data1
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm3              ; xmm2=(06 16 26 36 46 56 66 76)=data6
+    punpckhqdq  xmm5, xmm3              ; xmm5=(07 17 27 37 47 57 67 77)=data7
+
+    movdqa      xmm6, xmm1
+    movdqa      xmm3, xmm0
+    psubw       xmm1, xmm2              ; xmm1=data1-data6=tmp6
+    psubw       xmm0, xmm5              ; xmm0=data0-data7=tmp7
+    paddw       xmm6, xmm2              ; xmm6=data1+data6=tmp1
+    paddw       xmm3, xmm5              ; xmm3=data0+data7=tmp0
+
+    movdqa      xmm2, XMMWORD [wk(0)]   ; xmm2=(42 52 62 72 43 53 63 73)
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=(44 54 64 74 45 55 65 75)
+    movdqa      XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
+
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm2              ; xmm7=(02 12 22 32 42 52 62 72)=data2
+    punpckhqdq  xmm1, xmm2              ; xmm1=(03 13 23 33 43 53 63 73)=data3
+    movdqa      xmm0, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm5              ; xmm4=(04 14 24 34 44 54 64 74)=data4
+    punpckhqdq  xmm0, xmm5              ; xmm0=(05 15 25 35 45 55 65 75)=data5
+
+    movdqa      xmm2, xmm1
+    movdqa      xmm5, xmm7
+    paddw       xmm1, xmm4              ; xmm1=data3+data4=tmp3
+    paddw       xmm7, xmm0              ; xmm7=data2+data5=tmp2
+    psubw       xmm2, xmm4              ; xmm2=data3-data4=tmp4
+    psubw       xmm5, xmm0              ; xmm5=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm0, xmm6
+    psubw       xmm3, xmm1              ; xmm3=tmp13
+    psubw       xmm6, xmm7              ; xmm6=tmp12
+    paddw       xmm4, xmm1              ; xmm4=tmp10
+    paddw       xmm0, xmm7              ; xmm0=tmp11
+
+    paddw       xmm6, xmm3
+    psllw       xmm6, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm6, [GOTOFF(ebx,PW_F0707)]  ; xmm6=z1
+
+    movdqa      xmm1, xmm4
+    movdqa      xmm7, xmm3
+    psubw       xmm4, xmm0              ; xmm4=data4
+    psubw       xmm3, xmm6              ; xmm3=data6
+    paddw       xmm1, xmm0              ; xmm1=data0
+    paddw       xmm7, xmm6              ; xmm7=data2
+
+    movdqa      xmm0, XMMWORD [wk(0)]   ; xmm0=tmp6
+    movdqa      xmm6, XMMWORD [wk(1)]   ; xmm6=tmp7
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=data4
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=data6
+
+    ; -- Odd part
+
+    paddw       xmm2, xmm5              ; xmm2=tmp10
+    paddw       xmm5, xmm0              ; xmm5=tmp11
+    paddw       xmm0, xmm6              ; xmm0=tmp12, xmm6=tmp7
+
+    psllw       xmm2, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm0, PRE_MULTIPLY_SCALE_BITS
+
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm5, [GOTOFF(ebx,PW_F0707)]  ; xmm5=z3
+
+    movdqa      xmm4, xmm2                    ; xmm4=tmp10
+    psubw       xmm2, xmm0
+    pmulhw      xmm2, [GOTOFF(ebx,PW_F0382)]  ; xmm2=z5
+    pmulhw      xmm4, [GOTOFF(ebx,PW_F0541)]  ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
+    pmulhw      xmm0, [GOTOFF(ebx,PW_F1306)]  ; xmm0=MULTIPLY(tmp12,FIX_1_306562)
+    paddw       xmm4, xmm2                    ; xmm4=z2
+    paddw       xmm0, xmm2                    ; xmm0=z4
+
+    movdqa      xmm3, xmm6
+    psubw       xmm6, xmm5              ; xmm6=z13
+    paddw       xmm3, xmm5              ; xmm3=z11
+
+    movdqa      xmm2, xmm6
+    movdqa      xmm5, xmm3
+    psubw       xmm6, xmm4              ; xmm6=data3
+    psubw       xmm3, xmm0              ; xmm3=data7
+    paddw       xmm2, xmm4              ; xmm2=data5
+    paddw       xmm5, xmm0              ; xmm5=data1
+
+    ; ---- Pass 2: process columns.
+
+;   mov         edx, POINTER [data(eax)]  ; (DCTELEM *)
+
+    ; xmm1=(00 10 20 30 40 50 60 70), xmm7=(02 12 22 32 42 52 62 72)
+    ; xmm5=(01 11 21 31 41 51 61 71), xmm6=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm4, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm5              ; xmm1=(00 01 10 11 20 21 30 31)
+    punpckhwd   xmm4, xmm5              ; xmm4=(40 41 50 51 60 61 70 71)
+    movdqa      xmm0, xmm7              ; transpose coefficients(phase 1)
+    punpcklwd   xmm7, xmm6              ; xmm7=(02 03 12 13 22 23 32 33)
+    punpckhwd   xmm0, xmm6              ; xmm0=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=col4
+    movdqa      xmm6, XMMWORD [wk(1)]   ; xmm6=col6
+
+    ; xmm5=(04 14 24 34 44 54 64 74), xmm6=(06 16 26 36 46 56 66 76)
+    ; xmm2=(05 15 25 35 45 55 65 75), xmm3=(07 17 27 37 47 57 67 77)
+
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=(02 03 12 13 22 23 32 33)
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm7, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm2              ; xmm5=(04 05 14 15 24 25 34 35)
+    punpckhwd   xmm7, xmm2              ; xmm7=(44 45 54 55 64 65 74 75)
+    movdqa      xmm0, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm3              ; xmm6=(06 07 16 17 26 27 36 37)
+    punpckhwd   xmm0, xmm3              ; xmm0=(46 47 56 57 66 67 76 77)
+
+    movdqa      xmm2, xmm5              ; transpose coefficients(phase 2)
+    punpckldq   xmm5, xmm6              ; xmm5=(04 05 06 07 14 15 16 17)
+    punpckhdq   xmm2, xmm6              ; xmm2=(24 25 26 27 34 35 36 37)
+    movdqa      xmm3, xmm7              ; transpose coefficients(phase 2)
+    punpckldq   xmm7, xmm0              ; xmm7=(44 45 46 47 54 55 56 57)
+    punpckhdq   xmm3, xmm0              ; xmm3=(64 65 66 67 74 75 76 77)
+
+    movdqa      xmm6, XMMWORD [wk(0)]   ; xmm6=(02 03 12 13 22 23 32 33)
+    movdqa      xmm0, XMMWORD [wk(1)]   ; xmm0=(42 43 52 53 62 63 72 73)
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=(24 25 26 27 34 35 36 37)
+    movdqa      XMMWORD [wk(1)], xmm7   ; wk(1)=(44 45 46 47 54 55 56 57)
+
+    movdqa      xmm2, xmm1              ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm6              ; xmm1=(00 01 02 03 10 11 12 13)
+    punpckhdq   xmm2, xmm6              ; xmm2=(20 21 22 23 30 31 32 33)
+    movdqa      xmm7, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm0              ; xmm4=(40 41 42 43 50 51 52 53)
+    punpckhdq   xmm7, xmm0              ; xmm7=(60 61 62 63 70 71 72 73)
+
+    movdqa      xmm6, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm5              ; xmm1=(00 01 02 03 04 05 06 07)=data0
+    punpckhqdq  xmm6, xmm5              ; xmm6=(10 11 12 13 14 15 16 17)=data1
+    movdqa      xmm0, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm3              ; xmm7=(60 61 62 63 64 65 66 67)=data6
+    punpckhqdq  xmm0, xmm3              ; xmm0=(70 71 72 73 74 75 76 77)=data7
+
+    movdqa      xmm5, xmm6
+    movdqa      xmm3, xmm1
+    psubw       xmm6, xmm7              ; xmm6=data1-data6=tmp6
+    psubw       xmm1, xmm0              ; xmm1=data0-data7=tmp7
+    paddw       xmm5, xmm7              ; xmm5=data1+data6=tmp1
+    paddw       xmm3, xmm0              ; xmm3=data0+data7=tmp0
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=(24 25 26 27 34 35 36 37)
+    movdqa      xmm0, XMMWORD [wk(1)]   ; xmm0=(44 45 46 47 54 55 56 57)
+    movdqa      XMMWORD [wk(0)], xmm6   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm1   ; wk(1)=tmp7
+
+    movdqa      xmm6, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm7              ; xmm2=(20 21 22 23 24 25 26 27)=data2
+    punpckhqdq  xmm6, xmm7              ; xmm6=(30 31 32 33 34 35 36 37)=data3
+    movdqa      xmm1, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm0              ; xmm4=(40 41 42 43 44 45 46 47)=data4
+    punpckhqdq  xmm1, xmm0              ; xmm1=(50 51 52 53 54 55 56 57)=data5
+
+    movdqa      xmm7, xmm6
+    movdqa      xmm0, xmm2
+    paddw       xmm6, xmm4              ; xmm6=data3+data4=tmp3
+    paddw       xmm2, xmm1              ; xmm2=data2+data5=tmp2
+    psubw       xmm7, xmm4              ; xmm7=data3-data4=tmp4
+    psubw       xmm0, xmm1              ; xmm0=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm1, xmm5
+    psubw       xmm3, xmm6              ; xmm3=tmp13
+    psubw       xmm5, xmm2              ; xmm5=tmp12
+    paddw       xmm4, xmm6              ; xmm4=tmp10
+    paddw       xmm1, xmm2              ; xmm1=tmp11
+
+    paddw       xmm5, xmm3
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm5, [GOTOFF(ebx,PW_F0707)]  ; xmm5=z1
+
+    movdqa      xmm6, xmm4
+    movdqa      xmm2, xmm3
+    psubw       xmm4, xmm1              ; xmm4=data4
+    psubw       xmm3, xmm5              ; xmm3=data6
+    paddw       xmm6, xmm1              ; xmm6=data0
+    paddw       xmm2, xmm5              ; xmm2=data2
+
+    movdqa      XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)], xmm4
+    movdqa      XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)], xmm3
+    movdqa      XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)], xmm6
+    movdqa      XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)], xmm2
+
+    ; -- Odd part
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=tmp6
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
+
+    paddw       xmm7, xmm0              ; xmm7=tmp10
+    paddw       xmm0, xmm1              ; xmm0=tmp11
+    paddw       xmm1, xmm5              ; xmm1=tmp12, xmm5=tmp7
+
+    psllw       xmm7, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm1, PRE_MULTIPLY_SCALE_BITS
+
+    psllw       xmm0, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm0, [GOTOFF(ebx,PW_F0707)]  ; xmm0=z3
+
+    movdqa      xmm4, xmm7                    ; xmm4=tmp10
+    psubw       xmm7, xmm1
+    pmulhw      xmm7, [GOTOFF(ebx,PW_F0382)]  ; xmm7=z5
+    pmulhw      xmm4, [GOTOFF(ebx,PW_F0541)]  ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
+    pmulhw      xmm1, [GOTOFF(ebx,PW_F1306)]  ; xmm1=MULTIPLY(tmp12,FIX_1_306562)
+    paddw       xmm4, xmm7                    ; xmm4=z2
+    paddw       xmm1, xmm7                    ; xmm1=z4
+
+    movdqa      xmm3, xmm5
+    psubw       xmm5, xmm0              ; xmm5=z13
+    paddw       xmm3, xmm0              ; xmm3=z11
+
+    movdqa      xmm6, xmm5
+    movdqa      xmm2, xmm3
+    psubw       xmm5, xmm4              ; xmm5=data3
+    psubw       xmm3, xmm1              ; xmm3=data7
+    paddw       xmm6, xmm4              ; xmm6=data5
+    paddw       xmm2, xmm1              ; xmm2=data1
+
+    movdqa      XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)], xmm5
+    movdqa      XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)], xmm3
+    movdqa      XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)], xmm6
+    movdqa      XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)], xmm2
+
+;   pop         edi                     ; unused
+;   pop         esi                     ; unused
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+    poppic      ebx
+    mov         esp,ebp                 ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jfdctint-mmx.asm b/simd/i386/jfdctint-mmx.asm
similarity index 99%
rename from simd/jfdctint-mmx.asm
rename to simd/i386/jfdctint-mmx.asm
index 9142ad8..c035b0c 100644
--- a/simd/jfdctint-mmx.asm
+++ b/simd/i386/jfdctint-mmx.asm
@@ -2,6 +2,7 @@
 ; jfdctint.asm - accurate integer FDCT (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -64,7 +65,7 @@ F_3_072 equ     DESCALE(3299298341,30-CONST_BITS)       ; FIX(3.072711026)
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_fdct_islow_mmx)
 
 EXTN(jconst_fdct_islow_mmx):
@@ -81,7 +82,7 @@ PD_DESCALE_P1   times 2 dd  1 << (DESCALE_P1-1)
 PD_DESCALE_P2   times 2 dd  1 << (DESCALE_P2-1)
 PW_DESCALE_P2X  times 4 dw  1 << (PASS1_BITS-1)
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -99,7 +100,7 @@ PW_DESCALE_P2X  times 4 dw  1 << (PASS1_BITS-1)
 %define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_MMWORD  ; mmword wk[WK_NUM]
 %define WK_NUM          2
 
-        align   16
+        align   32
         global  EXTN(jsimd_fdct_islow_mmx)
 
 EXTN(jsimd_fdct_islow_mmx):
@@ -618,4 +619,4 @@ EXTN(jsimd_fdct_islow_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jfdctint-sse2.asm b/simd/i386/jfdctint-sse2.asm
new file mode 100644
index 0000000..66f2cc6
--- /dev/null
+++ b/simd/i386/jfdctint-sse2.asm
@@ -0,0 +1,634 @@
+;
+; jfdctint.asm - accurate integer FDCT (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a slow-but-accurate integer implementation of the
+; forward DCT (Discrete Cosine Transform). The following code is based
+; directly on the IJG's original jfdctint.c; see the jfdctint.c for
+; more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  13
+%define PASS1_BITS  2
+
+%define DESCALE_P1  (CONST_BITS-PASS1_BITS)
+%define DESCALE_P2  (CONST_BITS+PASS1_BITS)
+
+%if CONST_BITS == 13
+F_0_298 equ  2446  ; FIX(0.298631336)
+F_0_390 equ  3196  ; FIX(0.390180644)
+F_0_541 equ  4433  ; FIX(0.541196100)
+F_0_765 equ  6270  ; FIX(0.765366865)
+F_0_899 equ  7373  ; FIX(0.899976223)
+F_1_175 equ  9633  ; FIX(1.175875602)
+F_1_501 equ 12299  ; FIX(1.501321110)
+F_1_847 equ 15137  ; FIX(1.847759065)
+F_1_961 equ 16069  ; FIX(1.961570560)
+F_2_053 equ 16819  ; FIX(2.053119869)
+F_2_562 equ 20995  ; FIX(2.562915447)
+F_3_072 equ 25172  ; FIX(3.072711026)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_298 equ DESCALE( 320652955, 30-CONST_BITS)  ; FIX(0.298631336)
+F_0_390 equ DESCALE( 418953276, 30-CONST_BITS)  ; FIX(0.390180644)
+F_0_541 equ DESCALE( 581104887, 30-CONST_BITS)  ; FIX(0.541196100)
+F_0_765 equ DESCALE( 821806413, 30-CONST_BITS)  ; FIX(0.765366865)
+F_0_899 equ DESCALE( 966342111, 30-CONST_BITS)  ; FIX(0.899976223)
+F_1_175 equ DESCALE(1262586813, 30-CONST_BITS)  ; FIX(1.175875602)
+F_1_501 equ DESCALE(1612031267, 30-CONST_BITS)  ; FIX(1.501321110)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_1_961 equ DESCALE(2106220350, 30-CONST_BITS)  ; FIX(1.961570560)
+F_2_053 equ DESCALE(2204520673, 30-CONST_BITS)  ; FIX(2.053119869)
+F_2_562 equ DESCALE(2751909506, 30-CONST_BITS)  ; FIX(2.562915447)
+F_3_072 equ DESCALE(3299298341, 30-CONST_BITS)  ; FIX(3.072711026)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fdct_islow_sse2)
+
+EXTN(jconst_fdct_islow_sse2):
+
+PW_F130_F054   times 4 dw  (F_0_541+F_0_765), F_0_541
+PW_F054_MF130  times 4 dw  F_0_541, (F_0_541-F_1_847)
+PW_MF078_F117  times 4 dw  (F_1_175-F_1_961), F_1_175
+PW_F117_F078   times 4 dw  F_1_175, (F_1_175-F_0_390)
+PW_MF060_MF089 times 4 dw  (F_0_298-F_0_899),-F_0_899
+PW_MF089_F060  times 4 dw -F_0_899, (F_1_501-F_0_899)
+PW_MF050_MF256 times 4 dw  (F_2_053-F_2_562),-F_2_562
+PW_MF256_F050  times 4 dw -F_2_562, (F_3_072-F_2_562)
+PD_DESCALE_P1  times 4 dd  1 << (DESCALE_P1-1)
+PD_DESCALE_P2  times 4 dd  1 << (DESCALE_P2-1)
+PW_DESCALE_P2X times 8 dw  1 << (PASS1_BITS-1)
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Perform the forward DCT on one block of samples.
+;
+; GLOBAL(void)
+; jsimd_fdct_islow_sse2 (DCTELEM *data)
+;
+
+%define data(b)       (b)+8             ; DCTELEM *data
+
+%define original_ebp  ebp+0
+%define wk(i)         ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        6
+
+    align       32
+    global      EXTN(jsimd_fdct_islow_sse2)
+
+EXTN(jsimd_fdct_islow_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     ebx
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+;   push        esi                     ; unused
+;   push        edi                     ; unused
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process rows.
+
+    mov         edx, POINTER [data(eax)]  ; (DCTELEM *)
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)]
+
+    ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
+    ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm4, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm1              ; xmm0=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm4, xmm1              ; xmm4=(04 14 05 15 06 16 07 17)
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm3              ; xmm2=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm5, xmm3              ; xmm5=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm6, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm7, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)]
+
+    ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
+    ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
+    movdqa      XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm2, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm7              ; xmm6=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm2, xmm7              ; xmm2=(44 54 45 55 46 56 47 57)
+    movdqa      xmm5, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm3              ; xmm1=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm5, xmm3              ; xmm5=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm7, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm1              ; xmm6=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm7, xmm1              ; xmm7=(42 52 62 72 43 53 63 73)
+    movdqa      xmm3, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm5              ; xmm2=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm3, xmm5              ; xmm3=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
+    movdqa      XMMWORD [wk(2)], xmm7   ; wk(2)=(42 52 62 72 43 53 63 73)
+    movdqa      XMMWORD [wk(3)], xmm2   ; wk(3)=(44 54 64 74 45 55 65 75)
+
+    movdqa      xmm7, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm1              ; xmm0=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm7, xmm1              ; xmm7=(02 12 22 32 03 13 23 33)
+    movdqa      xmm2, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm5              ; xmm4=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm2, xmm5              ; xmm2=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm1, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm6              ; xmm0=(00 10 20 30 40 50 60 70)=data0
+    punpckhqdq  xmm1, xmm6              ; xmm1=(01 11 21 31 41 51 61 71)=data1
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm3              ; xmm2=(06 16 26 36 46 56 66 76)=data6
+    punpckhqdq  xmm5, xmm3              ; xmm5=(07 17 27 37 47 57 67 77)=data7
+
+    movdqa      xmm6, xmm1
+    movdqa      xmm3, xmm0
+    psubw       xmm1, xmm2              ; xmm1=data1-data6=tmp6
+    psubw       xmm0, xmm5              ; xmm0=data0-data7=tmp7
+    paddw       xmm6, xmm2              ; xmm6=data1+data6=tmp1
+    paddw       xmm3, xmm5              ; xmm3=data0+data7=tmp0
+
+    movdqa      xmm2, XMMWORD [wk(2)]   ; xmm2=(42 52 62 72 43 53 63 73)
+    movdqa      xmm5, XMMWORD [wk(3)]   ; xmm5=(44 54 64 74 45 55 65 75)
+    movdqa      XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
+
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm2              ; xmm7=(02 12 22 32 42 52 62 72)=data2
+    punpckhqdq  xmm1, xmm2              ; xmm1=(03 13 23 33 43 53 63 73)=data3
+    movdqa      xmm0, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm5              ; xmm4=(04 14 24 34 44 54 64 74)=data4
+    punpckhqdq  xmm0, xmm5              ; xmm0=(05 15 25 35 45 55 65 75)=data5
+
+    movdqa      xmm2, xmm1
+    movdqa      xmm5, xmm7
+    paddw       xmm1, xmm4              ; xmm1=data3+data4=tmp3
+    paddw       xmm7, xmm0              ; xmm7=data2+data5=tmp2
+    psubw       xmm2, xmm4              ; xmm2=data3-data4=tmp4
+    psubw       xmm5, xmm0              ; xmm5=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm0, xmm6
+    paddw       xmm3, xmm1              ; xmm3=tmp10
+    paddw       xmm6, xmm7              ; xmm6=tmp11
+    psubw       xmm4, xmm1              ; xmm4=tmp13
+    psubw       xmm0, xmm7              ; xmm0=tmp12
+
+    movdqa      xmm1, xmm3
+    paddw       xmm3, xmm6              ; xmm3=tmp10+tmp11
+    psubw       xmm1, xmm6              ; xmm1=tmp10-tmp11
+
+    psllw       xmm3, PASS1_BITS        ; xmm3=data0
+    psllw       xmm1, PASS1_BITS        ; xmm1=data4
+
+    movdqa      XMMWORD [wk(2)], xmm3   ; wk(2)=data0
+    movdqa      XMMWORD [wk(3)], xmm1   ; wk(3)=data4
+
+    ; (Original)
+    ; z1 = (tmp12 + tmp13) * 0.541196100;
+    ; data2 = z1 + tmp13 * 0.765366865;
+    ; data6 = z1 + tmp12 * -1.847759065;
+    ;
+    ; (This implementation)
+    ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
+    ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
+
+    movdqa      xmm7, xmm4              ; xmm4=tmp13
+    movdqa      xmm6, xmm4
+    punpcklwd   xmm7, xmm0              ; xmm0=tmp12
+    punpckhwd   xmm6, xmm0
+    movdqa      xmm4, xmm7
+    movdqa      xmm0, xmm6
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_F130_F054)]   ; xmm7=data2L
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_F130_F054)]   ; xmm6=data2H
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm4=data6L
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm0=data6H
+
+    paddd       xmm7, [GOTOFF(ebx,PD_DESCALE_P1)]
+    paddd       xmm6, [GOTOFF(ebx,PD_DESCALE_P1)]
+    psrad       xmm7, DESCALE_P1
+    psrad       xmm6, DESCALE_P1
+    paddd       xmm4, [GOTOFF(ebx,PD_DESCALE_P1)]
+    paddd       xmm0, [GOTOFF(ebx,PD_DESCALE_P1)]
+    psrad       xmm4, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+
+    packssdw    xmm7, xmm6              ; xmm7=data2
+    packssdw    xmm4, xmm0              ; xmm4=data6
+
+    movdqa      XMMWORD [wk(4)], xmm7   ; wk(4)=data2
+    movdqa      XMMWORD [wk(5)], xmm4   ; wk(5)=data6
+
+    ; -- Odd part
+
+    movdqa      xmm3, XMMWORD [wk(0)]   ; xmm3=tmp6
+    movdqa      xmm1, XMMWORD [wk(1)]   ; xmm1=tmp7
+
+    movdqa      xmm6, xmm2              ; xmm2=tmp4
+    movdqa      xmm0, xmm5              ; xmm5=tmp5
+    paddw       xmm6, xmm3              ; xmm6=z3
+    paddw       xmm0, xmm1              ; xmm0=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm7, xmm6
+    movdqa      xmm4, xmm6
+    punpcklwd   xmm7, xmm0
+    punpckhwd   xmm4, xmm0
+    movdqa      xmm6, xmm7
+    movdqa      xmm0, xmm4
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm7=z3L
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm4=z3H
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_F117_F078)]   ; xmm6=z4L
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_F117_F078)]   ; xmm0=z4H
+
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=z3L
+    movdqa      XMMWORD [wk(1)], xmm4   ; wk(1)=z3H
+
+    ; (Original)
+    ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
+    ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
+    ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
+    ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
+    ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
+    ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
+    ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
+    ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
+    ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
+
+    movdqa      xmm7, xmm2
+    movdqa      xmm4, xmm2
+    punpcklwd   xmm7, xmm1
+    punpckhwd   xmm4, xmm1
+    movdqa      xmm2, xmm7
+    movdqa      xmm1, xmm4
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm7=tmp4L
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm4=tmp4H
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm2=tmp7L
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm1=tmp7H
+
+    paddd       xmm7, XMMWORD [wk(0)]   ; xmm7=data7L
+    paddd       xmm4, XMMWORD [wk(1)]   ; xmm4=data7H
+    paddd       xmm2, xmm6              ; xmm2=data1L
+    paddd       xmm1, xmm0              ; xmm1=data1H
+
+    paddd       xmm7, [GOTOFF(ebx,PD_DESCALE_P1)]
+    paddd       xmm4, [GOTOFF(ebx,PD_DESCALE_P1)]
+    psrad       xmm7, DESCALE_P1
+    psrad       xmm4, DESCALE_P1
+    paddd       xmm2, [GOTOFF(ebx,PD_DESCALE_P1)]
+    paddd       xmm1, [GOTOFF(ebx,PD_DESCALE_P1)]
+    psrad       xmm2, DESCALE_P1
+    psrad       xmm1, DESCALE_P1
+
+    packssdw    xmm7, xmm4              ; xmm7=data7
+    packssdw    xmm2, xmm1              ; xmm2=data1
+
+    movdqa      xmm4, xmm5
+    movdqa      xmm1, xmm5
+    punpcklwd   xmm4, xmm3
+    punpckhwd   xmm1, xmm3
+    movdqa      xmm5, xmm4
+    movdqa      xmm3, xmm1
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm4=tmp5L
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm1=tmp5H
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm5=tmp6L
+    pmaddwd     xmm3, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm3=tmp6H
+
+    paddd       xmm4, xmm6              ; xmm4=data5L
+    paddd       xmm1, xmm0              ; xmm1=data5H
+    paddd       xmm5, XMMWORD [wk(0)]   ; xmm5=data3L
+    paddd       xmm3, XMMWORD [wk(1)]   ; xmm3=data3H
+
+    paddd       xmm4, [GOTOFF(ebx,PD_DESCALE_P1)]
+    paddd       xmm1, [GOTOFF(ebx,PD_DESCALE_P1)]
+    psrad       xmm4, DESCALE_P1
+    psrad       xmm1, DESCALE_P1
+    paddd       xmm5, [GOTOFF(ebx,PD_DESCALE_P1)]
+    paddd       xmm3, [GOTOFF(ebx,PD_DESCALE_P1)]
+    psrad       xmm5, DESCALE_P1
+    psrad       xmm3, DESCALE_P1
+
+    packssdw    xmm4, xmm1              ; xmm4=data5
+    packssdw    xmm5, xmm3              ; xmm5=data3
+
+    ; ---- Pass 2: process columns.
+
+;   mov         edx, POINTER [data(eax)]  ; (DCTELEM *)
+
+    movdqa      xmm6, XMMWORD [wk(2)]   ; xmm6=col0
+    movdqa      xmm0, XMMWORD [wk(4)]   ; xmm0=col2
+
+    ; xmm6=(00 10 20 30 40 50 60 70), xmm0=(02 12 22 32 42 52 62 72)
+    ; xmm2=(01 11 21 31 41 51 61 71), xmm5=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm1, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm2              ; xmm6=(00 01 10 11 20 21 30 31)
+    punpckhwd   xmm1, xmm2              ; xmm1=(40 41 50 51 60 61 70 71)
+    movdqa      xmm3, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm5              ; xmm0=(02 03 12 13 22 23 32 33)
+    punpckhwd   xmm3, xmm5              ; xmm3=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm2, XMMWORD [wk(3)]   ; xmm2=col4
+    movdqa      xmm5, XMMWORD [wk(5)]   ; xmm5=col6
+
+    ; xmm2=(04 14 24 34 44 54 64 74), xmm5=(06 16 26 36 46 56 66 76)
+    ; xmm4=(05 15 25 35 45 55 65 75), xmm7=(07 17 27 37 47 57 67 77)
+
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=(02 03 12 13 22 23 32 33)
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm0, xmm2              ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm4              ; xmm2=(04 05 14 15 24 25 34 35)
+    punpckhwd   xmm0, xmm4              ; xmm0=(44 45 54 55 64 65 74 75)
+    movdqa      xmm3, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm7              ; xmm5=(06 07 16 17 26 27 36 37)
+    punpckhwd   xmm3, xmm7              ; xmm3=(46 47 56 57 66 67 76 77)
+
+    movdqa      xmm4, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm5              ; xmm2=(04 05 06 07 14 15 16 17)
+    punpckhdq   xmm4, xmm5              ; xmm4=(24 25 26 27 34 35 36 37)
+    movdqa      xmm7, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm3              ; xmm0=(44 45 46 47 54 55 56 57)
+    punpckhdq   xmm7, xmm3              ; xmm7=(64 65 66 67 74 75 76 77)
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=(02 03 12 13 22 23 32 33)
+    movdqa      xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53 62 63 72 73)
+    movdqa      XMMWORD [wk(2)], xmm4   ; wk(2)=(24 25 26 27 34 35 36 37)
+    movdqa      XMMWORD [wk(3)], xmm0   ; wk(3)=(44 45 46 47 54 55 56 57)
+
+    movdqa      xmm4, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm5              ; xmm6=(00 01 02 03 10 11 12 13)
+    punpckhdq   xmm4, xmm5              ; xmm4=(20 21 22 23 30 31 32 33)
+    movdqa      xmm0, xmm1              ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm3              ; xmm1=(40 41 42 43 50 51 52 53)
+    punpckhdq   xmm0, xmm3              ; xmm0=(60 61 62 63 70 71 72 73)
+
+    movdqa      xmm5, xmm6              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm6, xmm2              ; xmm6=(00 01 02 03 04 05 06 07)=data0
+    punpckhqdq  xmm5, xmm2              ; xmm5=(10 11 12 13 14 15 16 17)=data1
+    movdqa      xmm3, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm7              ; xmm0=(60 61 62 63 64 65 66 67)=data6
+    punpckhqdq  xmm3, xmm7              ; xmm3=(70 71 72 73 74 75 76 77)=data7
+
+    movdqa      xmm2, xmm5
+    movdqa      xmm7, xmm6
+    psubw       xmm5, xmm0              ; xmm5=data1-data6=tmp6
+    psubw       xmm6, xmm3              ; xmm6=data0-data7=tmp7
+    paddw       xmm2, xmm0              ; xmm2=data1+data6=tmp1
+    paddw       xmm7, xmm3              ; xmm7=data0+data7=tmp0
+
+    movdqa      xmm0, XMMWORD [wk(2)]   ; xmm0=(24 25 26 27 34 35 36 37)
+    movdqa      xmm3, XMMWORD [wk(3)]   ; xmm3=(44 45 46 47 54 55 56 57)
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
+
+    movdqa      xmm5, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm0              ; xmm4=(20 21 22 23 24 25 26 27)=data2
+    punpckhqdq  xmm5, xmm0              ; xmm5=(30 31 32 33 34 35 36 37)=data3
+    movdqa      xmm6, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm3              ; xmm1=(40 41 42 43 44 45 46 47)=data4
+    punpckhqdq  xmm6, xmm3              ; xmm6=(50 51 52 53 54 55 56 57)=data5
+
+    movdqa      xmm0, xmm5
+    movdqa      xmm3, xmm4
+    paddw       xmm5, xmm1              ; xmm5=data3+data4=tmp3
+    paddw       xmm4, xmm6              ; xmm4=data2+data5=tmp2
+    psubw       xmm0, xmm1              ; xmm0=data3-data4=tmp4
+    psubw       xmm3, xmm6              ; xmm3=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm1, xmm7
+    movdqa      xmm6, xmm2
+    paddw       xmm7, xmm5              ; xmm7=tmp10
+    paddw       xmm2, xmm4              ; xmm2=tmp11
+    psubw       xmm1, xmm5              ; xmm1=tmp13
+    psubw       xmm6, xmm4              ; xmm6=tmp12
+
+    movdqa      xmm5, xmm7
+    paddw       xmm7, xmm2              ; xmm7=tmp10+tmp11
+    psubw       xmm5, xmm2              ; xmm5=tmp10-tmp11
+
+    paddw       xmm7, [GOTOFF(ebx,PW_DESCALE_P2X)]
+    paddw       xmm5, [GOTOFF(ebx,PW_DESCALE_P2X)]
+    psraw       xmm7, PASS1_BITS        ; xmm7=data0
+    psraw       xmm5, PASS1_BITS        ; xmm5=data4
+
+    movdqa      XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)], xmm7
+    movdqa      XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)], xmm5
+
+    ; (Original)
+    ; z1 = (tmp12 + tmp13) * 0.541196100;
+    ; data2 = z1 + tmp13 * 0.765366865;
+    ; data6 = z1 + tmp12 * -1.847759065;
+    ;
+    ; (This implementation)
+    ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
+    ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
+
+    movdqa      xmm4, xmm1              ; xmm1=tmp13
+    movdqa      xmm2, xmm1
+    punpcklwd   xmm4, xmm6              ; xmm6=tmp12
+    punpckhwd   xmm2, xmm6
+    movdqa      xmm1, xmm4
+    movdqa      xmm6, xmm2
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_F130_F054)]   ; xmm4=data2L
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_F130_F054)]   ; xmm2=data2H
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm1=data6L
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm6=data6H
+
+    paddd       xmm4, [GOTOFF(ebx,PD_DESCALE_P2)]
+    paddd       xmm2, [GOTOFF(ebx,PD_DESCALE_P2)]
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm2, DESCALE_P2
+    paddd       xmm1, [GOTOFF(ebx,PD_DESCALE_P2)]
+    paddd       xmm6, [GOTOFF(ebx,PD_DESCALE_P2)]
+    psrad       xmm1, DESCALE_P2
+    psrad       xmm6, DESCALE_P2
+
+    packssdw    xmm4, xmm2              ; xmm4=data2
+    packssdw    xmm1, xmm6              ; xmm1=data6
+
+    movdqa      XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)], xmm4
+    movdqa      XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)], xmm1
+
+    ; -- Odd part
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp6
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
+
+    movdqa      xmm2, xmm0              ; xmm0=tmp4
+    movdqa      xmm6, xmm3              ; xmm3=tmp5
+    paddw       xmm2, xmm7              ; xmm2=z3
+    paddw       xmm6, xmm5              ; xmm6=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm1, xmm2
+    punpcklwd   xmm4, xmm6
+    punpckhwd   xmm1, xmm6
+    movdqa      xmm2, xmm4
+    movdqa      xmm6, xmm1
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm4=z3L
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm1=z3H
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_F117_F078)]   ; xmm2=z4L
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_F117_F078)]   ; xmm6=z4H
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=z3L
+    movdqa      XMMWORD [wk(1)], xmm1   ; wk(1)=z3H
+
+    ; (Original)
+    ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
+    ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
+    ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
+    ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
+    ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
+    ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
+    ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
+    ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
+    ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
+
+    movdqa      xmm4, xmm0
+    movdqa      xmm1, xmm0
+    punpcklwd   xmm4, xmm5
+    punpckhwd   xmm1, xmm5
+    movdqa      xmm0, xmm4
+    movdqa      xmm5, xmm1
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm4=tmp4L
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm1=tmp4H
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm0=tmp7L
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm5=tmp7H
+
+    paddd       xmm4,  XMMWORD [wk(0)]  ; xmm4=data7L
+    paddd       xmm1,  XMMWORD [wk(1)]  ; xmm1=data7H
+    paddd       xmm0, xmm2              ; xmm0=data1L
+    paddd       xmm5, xmm6              ; xmm5=data1H
+
+    paddd       xmm4, [GOTOFF(ebx,PD_DESCALE_P2)]
+    paddd       xmm1, [GOTOFF(ebx,PD_DESCALE_P2)]
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm1, DESCALE_P2
+    paddd       xmm0, [GOTOFF(ebx,PD_DESCALE_P2)]
+    paddd       xmm5, [GOTOFF(ebx,PD_DESCALE_P2)]
+    psrad       xmm0, DESCALE_P2
+    psrad       xmm5, DESCALE_P2
+
+    packssdw    xmm4, xmm1              ; xmm4=data7
+    packssdw    xmm0, xmm5              ; xmm0=data1
+
+    movdqa      XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)], xmm4
+    movdqa      XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)], xmm0
+
+    movdqa      xmm1, xmm3
+    movdqa      xmm5, xmm3
+    punpcklwd   xmm1, xmm7
+    punpckhwd   xmm5, xmm7
+    movdqa      xmm3, xmm1
+    movdqa      xmm7, xmm5
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm1=tmp5L
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm5=tmp5H
+    pmaddwd     xmm3, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm3=tmp6L
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm7=tmp6H
+
+    paddd       xmm1, xmm2              ; xmm1=data5L
+    paddd       xmm5, xmm6              ; xmm5=data5H
+    paddd       xmm3, XMMWORD [wk(0)]   ; xmm3=data3L
+    paddd       xmm7, XMMWORD [wk(1)]   ; xmm7=data3H
+
+    paddd       xmm1, [GOTOFF(ebx,PD_DESCALE_P2)]
+    paddd       xmm5, [GOTOFF(ebx,PD_DESCALE_P2)]
+    psrad       xmm1, DESCALE_P2
+    psrad       xmm5, DESCALE_P2
+    paddd       xmm3, [GOTOFF(ebx,PD_DESCALE_P2)]
+    paddd       xmm7, [GOTOFF(ebx,PD_DESCALE_P2)]
+    psrad       xmm3, DESCALE_P2
+    psrad       xmm7, DESCALE_P2
+
+    packssdw    xmm1, xmm5              ; xmm1=data5
+    packssdw    xmm3, xmm7              ; xmm3=data3
+
+    movdqa      XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)], xmm1
+    movdqa      XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)], xmm3
+
+;   pop         edi                     ; unused
+;   pop         esi                     ; unused
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+    poppic      ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jidctflt-3dn.asm b/simd/i386/jidctflt-3dn.asm
similarity index 99%
rename from simd/jidctflt-3dn.asm
rename to simd/i386/jidctflt-3dn.asm
index 99356f2..1e47cf1 100644
--- a/simd/jidctflt-3dn.asm
+++ b/simd/i386/jidctflt-3dn.asm
@@ -2,6 +2,7 @@
 ; jidctflt.asm - floating-point IDCT (3DNow! & MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -25,7 +26,7 @@
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_idct_float_3dnow)
 
 EXTN(jconst_idct_float_3dnow):
@@ -37,7 +38,7 @@ PD_2_613        times 2 dd  2.613125929752753055713286
 PD_RNDINT_MAGIC times 2 dd  100663296.0 ; (float)(0x00C00000 << 3)
 PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -61,7 +62,7 @@ PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 %define workspace       wk(0)-DCTSIZE2*SIZEOF_FAST_FLOAT
                                         ; FAST_FLOAT workspace[DCTSIZE2]
 
-        align   16
+        align   32
         global  EXTN(jsimd_idct_float_3dnow)
 
 EXTN(jsimd_idct_float_3dnow):
@@ -448,4 +449,4 @@ EXTN(jsimd_idct_float_3dnow):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/jidctflt-sse.asm b/simd/i386/jidctflt-sse.asm
similarity index 99%
rename from simd/jidctflt-sse.asm
rename to simd/i386/jidctflt-sse.asm
index 4d4af2f..a1c99e9 100644
--- a/simd/jidctflt-sse.asm
+++ b/simd/i386/jidctflt-sse.asm
@@ -2,6 +2,7 @@
 ; jidctflt.asm - floating-point IDCT (SSE & MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -35,7 +36,7 @@
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_idct_float_sse)
 
 EXTN(jconst_idct_float_sse):
@@ -47,7 +48,7 @@ PD_M2_613       times 4 dd -2.613125929752753055713286
 PD_0_125        times 4 dd  0.125       ; 1/8
 PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -71,7 +72,7 @@ PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 %define workspace       wk(0)-DCTSIZE2*SIZEOF_FAST_FLOAT
                                         ; FAST_FLOAT workspace[DCTSIZE2]
 
-        align   16
+        align   32
         global  EXTN(jsimd_idct_float_sse)
 
 EXTN(jsimd_idct_float_sse):
@@ -568,4 +569,4 @@ EXTN(jsimd_idct_float_sse):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jidctflt-sse2.asm b/simd/i386/jidctflt-sse2.asm
new file mode 100644
index 0000000..e8be844
--- /dev/null
+++ b/simd/i386/jidctflt-sse2.asm
@@ -0,0 +1,498 @@
+;
+; jidctflt.asm - floating-point IDCT (SSE & SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a floating-point implementation of the inverse DCT
+; (Discrete Cosine Transform). The following code is based directly on
+; the IJG's original jidctflt.c; see the jidctflt.c for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%macro unpcklps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
+    shufps      %1, %2, 0x44
+%endmacro
+
+%macro unpckhps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
+    shufps      %1, %2, 0xEE
+%endmacro
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_idct_float_sse2)
+
+EXTN(jconst_idct_float_sse2):
+
+PD_1_414        times 4  dd  1.414213562373095048801689
+PD_1_847        times 4  dd  1.847759065022573512256366
+PD_1_082        times 4  dd  1.082392200292393968799446
+PD_M2_613       times 4  dd -2.613125929752753055713286
+PD_RNDINT_MAGIC times 4  dd  100663296.0  ; (float)(0x00C00000 << 3)
+PB_CENTERJSAMP  times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Perform dequantization and inverse DCT on one block of coefficients.
+;
+; GLOBAL(void)
+; jsimd_idct_float_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                        JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+%define dct_table(b)   (b)+8            ; void *dct_table
+%define coef_block(b)  (b)+12           ; JCOEFPTR coef_block
+%define output_buf(b)  (b)+16           ; JSAMPARRAY output_buf
+%define output_col(b)  (b)+20           ; JDIMENSION output_col
+
+%define original_ebp   ebp+0
+%define wk(i)          ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM         2
+%define workspace      wk(0)-DCTSIZE2*SIZEOF_FAST_FLOAT
+                                        ; FAST_FLOAT workspace[DCTSIZE2]
+
+    align       32
+    global      EXTN(jsimd_idct_float_sse2)
+
+EXTN(jsimd_idct_float_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [workspace]
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process columns from input, store into work array.
+
+;   mov         eax, [original_ebp]
+    mov         edx, POINTER [dct_table(eax)]    ; quantptr
+    mov         esi, JCOEFPTR [coef_block(eax)]  ; inptr
+    lea         edi, [workspace]                 ; FAST_FLOAT *wsptr
+    mov         ecx, DCTSIZE/4                   ; ctr
+    alignx      16, 7
+.columnloop:
+%ifndef NO_ZERO_COLUMN_TEST_FLOAT_SSE
+    mov         eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    jnz         near .columnDCT
+
+    movq        xmm1, XMM_MMWORD [MMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movq        xmm2, XMM_MMWORD [MMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    movq        xmm3, XMM_MMWORD [MMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    movq        xmm4, XMM_MMWORD [MMBLOCK(4,0,esi,SIZEOF_JCOEF)]
+    movq        xmm5, XMM_MMWORD [MMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    movq        xmm6, XMM_MMWORD [MMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+    movq        xmm7, XMM_MMWORD [MMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, xmm2
+    por         xmm3, xmm4
+    por         xmm5, xmm6
+    por         xmm1, xmm3
+    por         xmm5, xmm7
+    por         xmm1, xmm5
+    packsswb    xmm1, xmm1
+    movd        eax, xmm1
+    test        eax, eax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movq        xmm0, XMM_MMWORD [MMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+
+    punpcklwd   xmm0, xmm0                  ; xmm0=(00 00 01 01 02 02 03 03)
+    psrad       xmm0, (DWORD_BIT-WORD_BIT)  ; xmm0=in0=(00 01 02 03)
+    cvtdq2ps    xmm0, xmm0                  ; xmm0=in0=(00 01 02 03)
+
+    mulps       xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+
+    movaps      xmm1, xmm0
+    movaps      xmm2, xmm0
+    movaps      xmm3, xmm0
+
+    shufps      xmm0, xmm0, 0x00        ; xmm0=(00 00 00 00)
+    shufps      xmm1, xmm1, 0x55        ; xmm1=(01 01 01 01)
+    shufps      xmm2, xmm2, 0xAA        ; xmm2=(02 02 02 02)
+    shufps      xmm3, xmm3, 0xFF        ; xmm3=(03 03 03 03)
+
+    movaps      XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(0,1,edi,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(1,1,edi,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_FAST_FLOAT)], xmm2
+    movaps      XMMWORD [XMMBLOCK(2,1,edi,SIZEOF_FAST_FLOAT)], xmm2
+    movaps      XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_FAST_FLOAT)], xmm3
+    movaps      XMMWORD [XMMBLOCK(3,1,edi,SIZEOF_FAST_FLOAT)], xmm3
+    jmp         near .nextcolumn
+    alignx      16, 7
+%endif
+.columnDCT:
+
+    ; -- Even part
+
+    movq        xmm0, XMM_MMWORD [MMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    movq        xmm1, XMM_MMWORD [MMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    movq        xmm2, XMM_MMWORD [MMBLOCK(4,0,esi,SIZEOF_JCOEF)]
+    movq        xmm3, XMM_MMWORD [MMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+
+    punpcklwd   xmm0, xmm0                  ; xmm0=(00 00 01 01 02 02 03 03)
+    punpcklwd   xmm1, xmm1                  ; xmm1=(20 20 21 21 22 22 23 23)
+    psrad       xmm0, (DWORD_BIT-WORD_BIT)  ; xmm0=in0=(00 01 02 03)
+    psrad       xmm1, (DWORD_BIT-WORD_BIT)  ; xmm1=in2=(20 21 22 23)
+    cvtdq2ps    xmm0, xmm0                  ; xmm0=in0=(00 01 02 03)
+    cvtdq2ps    xmm1, xmm1                  ; xmm1=in2=(20 21 22 23)
+
+    punpcklwd   xmm2, xmm2                  ; xmm2=(40 40 41 41 42 42 43 43)
+    punpcklwd   xmm3, xmm3                  ; xmm3=(60 60 61 61 62 62 63 63)
+    psrad       xmm2, (DWORD_BIT-WORD_BIT)  ; xmm2=in4=(40 41 42 43)
+    psrad       xmm3, (DWORD_BIT-WORD_BIT)  ; xmm3=in6=(60 61 62 63)
+    cvtdq2ps    xmm2, xmm2                  ; xmm2=in4=(40 41 42 43)
+    cvtdq2ps    xmm3, xmm3                  ; xmm3=in6=(60 61 62 63)
+
+    mulps       xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm1, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm2, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm3, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+
+    movaps      xmm4, xmm0
+    movaps      xmm5, xmm1
+    subps       xmm0, xmm2              ; xmm0=tmp11
+    subps       xmm1, xmm3
+    addps       xmm4, xmm2              ; xmm4=tmp10
+    addps       xmm5, xmm3              ; xmm5=tmp13
+
+    mulps       xmm1, [GOTOFF(ebx,PD_1_414)]
+    subps       xmm1, xmm5              ; xmm1=tmp12
+
+    movaps      xmm6, xmm4
+    movaps      xmm7, xmm0
+    subps       xmm4, xmm5              ; xmm4=tmp3
+    subps       xmm0, xmm1              ; xmm0=tmp2
+    addps       xmm6, xmm5              ; xmm6=tmp0
+    addps       xmm7, xmm1              ; xmm7=tmp1
+
+    movaps      XMMWORD [wk(1)], xmm4   ; tmp3
+    movaps      XMMWORD [wk(0)], xmm0   ; tmp2
+
+    ; -- Odd part
+
+    movq        xmm2, XMM_MMWORD [MMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movq        xmm3, XMM_MMWORD [MMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    movq        xmm5, XMM_MMWORD [MMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    movq        xmm1, XMM_MMWORD [MMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+
+    punpcklwd   xmm2, xmm2                  ; xmm2=(10 10 11 11 12 12 13 13)
+    punpcklwd   xmm3, xmm3                  ; xmm3=(30 30 31 31 32 32 33 33)
+    psrad       xmm2, (DWORD_BIT-WORD_BIT)  ; xmm2=in1=(10 11 12 13)
+    psrad       xmm3, (DWORD_BIT-WORD_BIT)  ; xmm3=in3=(30 31 32 33)
+    cvtdq2ps    xmm2, xmm2                  ; xmm2=in1=(10 11 12 13)
+    cvtdq2ps    xmm3, xmm3                  ; xmm3=in3=(30 31 32 33)
+
+    punpcklwd   xmm5, xmm5                  ; xmm5=(50 50 51 51 52 52 53 53)
+    punpcklwd   xmm1, xmm1                  ; xmm1=(70 70 71 71 72 72 73 73)
+    psrad       xmm5, (DWORD_BIT-WORD_BIT)  ; xmm5=in5=(50 51 52 53)
+    psrad       xmm1, (DWORD_BIT-WORD_BIT)  ; xmm1=in7=(70 71 72 73)
+    cvtdq2ps    xmm5, xmm5                  ; xmm5=in5=(50 51 52 53)
+    cvtdq2ps    xmm1, xmm1                  ; xmm1=in7=(70 71 72 73)
+
+    mulps       xmm2, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm5, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm1, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
+
+    movaps      xmm4, xmm2
+    movaps      xmm0, xmm5
+    addps       xmm2, xmm1              ; xmm2=z11
+    addps       xmm5, xmm3              ; xmm5=z13
+    subps       xmm4, xmm1              ; xmm4=z12
+    subps       xmm0, xmm3              ; xmm0=z10
+
+    movaps      xmm1, xmm2
+    subps       xmm2, xmm5
+    addps       xmm1, xmm5              ; xmm1=tmp7
+
+    mulps       xmm2, [GOTOFF(ebx,PD_1_414)]  ; xmm2=tmp11
+
+    movaps      xmm3, xmm0
+    addps       xmm0, xmm4
+    mulps       xmm0, [GOTOFF(ebx,PD_1_847)]   ; xmm0=z5
+    mulps       xmm3, [GOTOFF(ebx,PD_M2_613)]  ; xmm3=(z10 * -2.613125930)
+    mulps       xmm4, [GOTOFF(ebx,PD_1_082)]   ; xmm4=(z12 * 1.082392200)
+    addps       xmm3, xmm0              ; xmm3=tmp12
+    subps       xmm4, xmm0              ; xmm4=tmp10
+
+    ; -- Final output stage
+
+    subps       xmm3, xmm1              ; xmm3=tmp6
+    movaps      xmm5, xmm6
+    movaps      xmm0, xmm7
+    addps       xmm6, xmm1              ; xmm6=data0=(00 01 02 03)
+    addps       xmm7, xmm3              ; xmm7=data1=(10 11 12 13)
+    subps       xmm5, xmm1              ; xmm5=data7=(70 71 72 73)
+    subps       xmm0, xmm3              ; xmm0=data6=(60 61 62 63)
+    subps       xmm2, xmm3              ; xmm2=tmp5
+
+    movaps      xmm1, xmm6              ; transpose coefficients(phase 1)
+    unpcklps    xmm6, xmm7              ; xmm6=(00 10 01 11)
+    unpckhps    xmm1, xmm7              ; xmm1=(02 12 03 13)
+    movaps      xmm3, xmm0              ; transpose coefficients(phase 1)
+    unpcklps    xmm0, xmm5              ; xmm0=(60 70 61 71)
+    unpckhps    xmm3, xmm5              ; xmm3=(62 72 63 73)
+
+    movaps      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
+    movaps      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp3
+
+    movaps      XMMWORD [wk(0)], xmm0   ; wk(0)=(60 70 61 71)
+    movaps      XMMWORD [wk(1)], xmm3   ; wk(1)=(62 72 63 73)
+
+    addps       xmm4, xmm2              ; xmm4=tmp4
+    movaps      xmm0, xmm7
+    movaps      xmm3, xmm5
+    addps       xmm7, xmm2              ; xmm7=data2=(20 21 22 23)
+    addps       xmm5, xmm4              ; xmm5=data4=(40 41 42 43)
+    subps       xmm0, xmm2              ; xmm0=data5=(50 51 52 53)
+    subps       xmm3, xmm4              ; xmm3=data3=(30 31 32 33)
+
+    movaps      xmm2, xmm7              ; transpose coefficients(phase 1)
+    unpcklps    xmm7, xmm3              ; xmm7=(20 30 21 31)
+    unpckhps    xmm2, xmm3              ; xmm2=(22 32 23 33)
+    movaps      xmm4, xmm5              ; transpose coefficients(phase 1)
+    unpcklps    xmm5, xmm0              ; xmm5=(40 50 41 51)
+    unpckhps    xmm4, xmm0              ; xmm4=(42 52 43 53)
+
+    movaps      xmm3, xmm6              ; transpose coefficients(phase 2)
+    unpcklps2   xmm6, xmm7              ; xmm6=(00 10 20 30)
+    unpckhps2   xmm3, xmm7              ; xmm3=(01 11 21 31)
+    movaps      xmm0, xmm1              ; transpose coefficients(phase 2)
+    unpcklps2   xmm1, xmm2              ; xmm1=(02 12 22 32)
+    unpckhps2   xmm0, xmm2              ; xmm0=(03 13 23 33)
+
+    movaps      xmm7, XMMWORD [wk(0)]   ; xmm7=(60 70 61 71)
+    movaps      xmm2, XMMWORD [wk(1)]   ; xmm2=(62 72 63 73)
+
+    movaps      XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_FAST_FLOAT)], xmm6
+    movaps      XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_FAST_FLOAT)], xmm3
+    movaps      XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_FAST_FLOAT)], xmm0
+
+    movaps      xmm6, xmm5              ; transpose coefficients(phase 2)
+    unpcklps2   xmm5, xmm7              ; xmm5=(40 50 60 70)
+    unpckhps2   xmm6, xmm7              ; xmm6=(41 51 61 71)
+    movaps      xmm3, xmm4              ; transpose coefficients(phase 2)
+    unpcklps2   xmm4, xmm2              ; xmm4=(42 52 62 72)
+    unpckhps2   xmm3, xmm2              ; xmm3=(43 53 63 73)
+
+    movaps      XMMWORD [XMMBLOCK(0,1,edi,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(1,1,edi,SIZEOF_FAST_FLOAT)], xmm6
+    movaps      XMMWORD [XMMBLOCK(2,1,edi,SIZEOF_FAST_FLOAT)], xmm4
+    movaps      XMMWORD [XMMBLOCK(3,1,edi,SIZEOF_FAST_FLOAT)], xmm3
+
+.nextcolumn:
+    add         esi, byte 4*SIZEOF_JCOEF               ; coef_block
+    add         edx, byte 4*SIZEOF_FLOAT_MULT_TYPE     ; quantptr
+    add         edi,      4*DCTSIZE*SIZEOF_FAST_FLOAT  ; wsptr
+    dec         ecx                                    ; ctr
+    jnz         near .columnloop
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 0*32]
+    prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 1*32]
+    prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 2*32]
+    prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows from work array, store into output array.
+
+    mov         eax, [original_ebp]
+    lea         esi, [workspace]                   ; FAST_FLOAT *wsptr
+    mov         edi, JSAMPARRAY [output_buf(eax)]  ; (JSAMPROW *)
+    mov         eax, JDIMENSION [output_col(eax)]
+    mov         ecx, DCTSIZE/4                     ; ctr
+    alignx      16, 7
+.rowloop:
+
+    ; -- Even part
+
+    movaps      xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_FAST_FLOAT)]
+
+    movaps      xmm4, xmm0
+    movaps      xmm5, xmm1
+    subps       xmm0, xmm2              ; xmm0=tmp11
+    subps       xmm1, xmm3
+    addps       xmm4, xmm2              ; xmm4=tmp10
+    addps       xmm5, xmm3              ; xmm5=tmp13
+
+    mulps       xmm1, [GOTOFF(ebx,PD_1_414)]
+    subps       xmm1, xmm5              ; xmm1=tmp12
+
+    movaps      xmm6, xmm4
+    movaps      xmm7, xmm0
+    subps       xmm4, xmm5              ; xmm4=tmp3
+    subps       xmm0, xmm1              ; xmm0=tmp2
+    addps       xmm6, xmm5              ; xmm6=tmp0
+    addps       xmm7, xmm1              ; xmm7=tmp1
+
+    movaps      XMMWORD [wk(1)], xmm4   ; tmp3
+    movaps      XMMWORD [wk(0)], xmm0   ; tmp2
+
+    ; -- Odd part
+
+    movaps      xmm2, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm5, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_FAST_FLOAT)]
+
+    movaps      xmm4, xmm2
+    movaps      xmm0, xmm5
+    addps       xmm2, xmm1              ; xmm2=z11
+    addps       xmm5, xmm3              ; xmm5=z13
+    subps       xmm4, xmm1              ; xmm4=z12
+    subps       xmm0, xmm3              ; xmm0=z10
+
+    movaps      xmm1, xmm2
+    subps       xmm2, xmm5
+    addps       xmm1, xmm5              ; xmm1=tmp7
+
+    mulps       xmm2, [GOTOFF(ebx,PD_1_414)]  ; xmm2=tmp11
+
+    movaps      xmm3, xmm0
+    addps       xmm0, xmm4
+    mulps       xmm0, [GOTOFF(ebx,PD_1_847)]   ; xmm0=z5
+    mulps       xmm3, [GOTOFF(ebx,PD_M2_613)]  ; xmm3=(z10 * -2.613125930)
+    mulps       xmm4, [GOTOFF(ebx,PD_1_082)]   ; xmm4=(z12 * 1.082392200)
+    addps       xmm3, xmm0                     ; xmm3=tmp12
+    subps       xmm4, xmm0                     ; xmm4=tmp10
+
+    ; -- Final output stage
+
+    subps       xmm3, xmm1              ; xmm3=tmp6
+    movaps      xmm5, xmm6
+    movaps      xmm0, xmm7
+    addps       xmm6, xmm1              ; xmm6=data0=(00 10 20 30)
+    addps       xmm7, xmm3              ; xmm7=data1=(01 11 21 31)
+    subps       xmm5, xmm1              ; xmm5=data7=(07 17 27 37)
+    subps       xmm0, xmm3              ; xmm0=data6=(06 16 26 36)
+    subps       xmm2, xmm3              ; xmm2=tmp5
+
+    movaps      xmm1, [GOTOFF(ebx,PD_RNDINT_MAGIC)]  ; xmm1=[PD_RNDINT_MAGIC]
+    pcmpeqd     xmm3, xmm3
+    psrld       xmm3, WORD_BIT          ; xmm3={0xFFFF 0x0000 0xFFFF 0x0000 ..}
+
+    addps       xmm6, xmm1              ; xmm6=roundint(data0/8)=(00 ** 10 ** 20 ** 30 **)
+    addps       xmm7, xmm1              ; xmm7=roundint(data1/8)=(01 ** 11 ** 21 ** 31 **)
+    addps       xmm0, xmm1              ; xmm0=roundint(data6/8)=(06 ** 16 ** 26 ** 36 **)
+    addps       xmm5, xmm1              ; xmm5=roundint(data7/8)=(07 ** 17 ** 27 ** 37 **)
+
+    pand        xmm6, xmm3              ; xmm6=(00 -- 10 -- 20 -- 30 --)
+    pslld       xmm7, WORD_BIT          ; xmm7=(-- 01 -- 11 -- 21 -- 31)
+    pand        xmm0, xmm3              ; xmm0=(06 -- 16 -- 26 -- 36 --)
+    pslld       xmm5, WORD_BIT          ; xmm5=(-- 07 -- 17 -- 27 -- 37)
+    por         xmm6, xmm7              ; xmm6=(00 01 10 11 20 21 30 31)
+    por         xmm0, xmm5              ; xmm0=(06 07 16 17 26 27 36 37)
+
+    movaps      xmm1, XMMWORD [wk(0)]   ; xmm1=tmp2
+    movaps      xmm3, XMMWORD [wk(1)]   ; xmm3=tmp3
+
+    addps       xmm4, xmm2              ; xmm4=tmp4
+    movaps      xmm7, xmm1
+    movaps      xmm5, xmm3
+    addps       xmm1, xmm2              ; xmm1=data2=(02 12 22 32)
+    addps       xmm3, xmm4              ; xmm3=data4=(04 14 24 34)
+    subps       xmm7, xmm2              ; xmm7=data5=(05 15 25 35)
+    subps       xmm5, xmm4              ; xmm5=data3=(03 13 23 33)
+
+    movaps      xmm2, [GOTOFF(ebx,PD_RNDINT_MAGIC)]  ; xmm2=[PD_RNDINT_MAGIC]
+    pcmpeqd     xmm4, xmm4
+    psrld       xmm4, WORD_BIT          ; xmm4={0xFFFF 0x0000 0xFFFF 0x0000 ..}
+
+    addps       xmm3, xmm2              ; xmm3=roundint(data4/8)=(04 ** 14 ** 24 ** 34 **)
+    addps       xmm7, xmm2              ; xmm7=roundint(data5/8)=(05 ** 15 ** 25 ** 35 **)
+    addps       xmm1, xmm2              ; xmm1=roundint(data2/8)=(02 ** 12 ** 22 ** 32 **)
+    addps       xmm5, xmm2              ; xmm5=roundint(data3/8)=(03 ** 13 ** 23 ** 33 **)
+
+    pand        xmm3, xmm4              ; xmm3=(04 -- 14 -- 24 -- 34 --)
+    pslld       xmm7, WORD_BIT          ; xmm7=(-- 05 -- 15 -- 25 -- 35)
+    pand        xmm1, xmm4              ; xmm1=(02 -- 12 -- 22 -- 32 --)
+    pslld       xmm5, WORD_BIT          ; xmm5=(-- 03 -- 13 -- 23 -- 33)
+    por         xmm3, xmm7              ; xmm3=(04 05 14 15 24 25 34 35)
+    por         xmm1, xmm5              ; xmm1=(02 03 12 13 22 23 32 33)
+
+    movdqa      xmm2, [GOTOFF(ebx,PB_CENTERJSAMP)]  ; xmm2=[PB_CENTERJSAMP]
+
+    packsswb    xmm6, xmm3        ; xmm6=(00 01 10 11 20 21 30 31 04 05 14 15 24 25 34 35)
+    packsswb    xmm1, xmm0        ; xmm1=(02 03 12 13 22 23 32 33 06 07 16 17 26 27 36 37)
+    paddb       xmm6, xmm2
+    paddb       xmm1, xmm2
+
+    movdqa      xmm4, xmm6        ; transpose coefficients(phase 2)
+    punpcklwd   xmm6, xmm1        ; xmm6=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
+    punpckhwd   xmm4, xmm1        ; xmm4=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
+
+    movdqa      xmm7, xmm6        ; transpose coefficients(phase 3)
+    punpckldq   xmm6, xmm4        ; xmm6=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
+    punpckhdq   xmm7, xmm4        ; xmm7=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
+
+    pshufd      xmm5, xmm6, 0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
+    pshufd      xmm3, xmm7, 0x4E  ; xmm3=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
+
+    pushpic     ebx                     ; save GOT address
+
+    mov         edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
+    mov         ebx, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm6
+    movq        XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE], xmm7
+    mov         edx, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
+    mov         ebx, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm5
+    movq        XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE], xmm3
+
+    poppic      ebx                     ; restore GOT address
+
+    add         esi, byte 4*SIZEOF_FAST_FLOAT  ; wsptr
+    add         edi, byte 4*SIZEOF_JSAMPROW
+    dec         ecx                            ; ctr
+    jnz         near .rowloop
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jidctfst-mmx.asm b/simd/i386/jidctfst-mmx.asm
similarity index 99%
rename from simd/jidctfst-mmx.asm
rename to simd/i386/jidctfst-mmx.asm
index 6e95bfb..7b5c2f2 100644
--- a/simd/jidctfst-mmx.asm
+++ b/simd/i386/jidctfst-mmx.asm
@@ -2,6 +2,7 @@
 ; jidctfst.asm - fast integer IDCT (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -57,7 +58,7 @@ F_1_613 equ     (F_2_613 - (1 << CONST_BITS))   ; FIX(2.613125930) - FIX(1)
 %define PRE_MULTIPLY_SCALE_BITS   2
 %define CONST_SHIFT     (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_idct_ifast_mmx)
 
 EXTN(jconst_idct_ifast_mmx):
@@ -68,7 +69,7 @@ PW_MF1613       times 4 dw -F_1_613 << CONST_SHIFT
 PW_F1082        times 4 dw  F_1_082 << CONST_SHIFT
 PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -92,7 +93,7 @@ PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 %define workspace       wk(0)-DCTSIZE2*SIZEOF_JCOEF
                                         ; JCOEF workspace[DCTSIZE2]
 
-        align   16
+        align   32
         global  EXTN(jsimd_idct_ifast_mmx)
 
 EXTN(jsimd_idct_ifast_mmx):
@@ -496,4 +497,4 @@ EXTN(jsimd_idct_ifast_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jidctfst-sse2.asm b/simd/i386/jidctfst-sse2.asm
new file mode 100644
index 0000000..51e3317
--- /dev/null
+++ b/simd/i386/jidctfst-sse2.asm
@@ -0,0 +1,502 @@
+;
+; jidctfst.asm - fast integer IDCT (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a fast, not so accurate integer implementation of
+; the inverse DCT (Discrete Cosine Transform). The following code is
+; based directly on the IJG's original jidctfst.c; see the jidctfst.c
+; for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  8  ; 14 is also OK.
+%define PASS1_BITS  2
+
+%if IFAST_SCALE_BITS != PASS1_BITS
+%error "'IFAST_SCALE_BITS' must be equal to 'PASS1_BITS'."
+%endif
+
+%if CONST_BITS == 8
+F_1_082 equ 277              ; FIX(1.082392200)
+F_1_414 equ 362              ; FIX(1.414213562)
+F_1_847 equ 473              ; FIX(1.847759065)
+F_2_613 equ 669              ; FIX(2.613125930)
+F_1_613 equ (F_2_613 - 256)  ; FIX(2.613125930) - FIX(1)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_1_082 equ DESCALE(1162209775, 30-CONST_BITS)  ; FIX(1.082392200)
+F_1_414 equ DESCALE(1518500249, 30-CONST_BITS)  ; FIX(1.414213562)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_2_613 equ DESCALE(2805822602, 30-CONST_BITS)  ; FIX(2.613125930)
+F_1_613 equ (F_2_613 - (1 << CONST_BITS))       ; FIX(2.613125930) - FIX(1)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
+; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
+
+%define PRE_MULTIPLY_SCALE_BITS  2
+%define CONST_SHIFT              (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
+
+    alignz      32
+    global      EXTN(jconst_idct_ifast_sse2)
+
+EXTN(jconst_idct_ifast_sse2):
+
+PW_F1414       times 8  dw  F_1_414 << CONST_SHIFT
+PW_F1847       times 8  dw  F_1_847 << CONST_SHIFT
+PW_MF1613      times 8  dw -F_1_613 << CONST_SHIFT
+PW_F1082       times 8  dw  F_1_082 << CONST_SHIFT
+PB_CENTERJSAMP times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Perform dequantization and inverse DCT on one block of coefficients.
+;
+; GLOBAL(void)
+; jsimd_idct_ifast_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                       JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+%define dct_table(b)   (b)+8            ; jpeg_component_info *compptr
+%define coef_block(b)  (b)+12           ; JCOEFPTR coef_block
+%define output_buf(b)  (b)+16           ; JSAMPARRAY output_buf
+%define output_col(b)  (b)+20           ; JDIMENSION output_col
+
+%define original_ebp   ebp+0
+%define wk(i)          ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM         2
+
+    align       32
+    global      EXTN(jsimd_idct_ifast_sse2)
+
+EXTN(jsimd_idct_ifast_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     ebx
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process columns from input.
+
+;   mov         eax, [original_ebp]
+    mov         edx, POINTER [dct_table(eax)]    ; quantptr
+    mov         esi, JCOEFPTR [coef_block(eax)]  ; inptr
+
+%ifndef NO_ZERO_COLUMN_TEST_IFAST_SSE2
+    mov         eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    jnz         near .columnDCT
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, xmm0
+    packsswb    xmm1, xmm1
+    packsswb    xmm1, xmm1
+    movd        eax, xmm1
+    test        eax, eax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    movdqa      xmm7, xmm0              ; xmm0=in0=(00 01 02 03 04 05 06 07)
+    punpcklwd   xmm0, xmm0              ; xmm0=(00 00 01 01 02 02 03 03)
+    punpckhwd   xmm7, xmm7              ; xmm7=(04 04 05 05 06 06 07 07)
+
+    pshufd      xmm6, xmm0, 0x00        ; xmm6=col0=(00 00 00 00 00 00 00 00)
+    pshufd      xmm2, xmm0, 0x55        ; xmm2=col1=(01 01 01 01 01 01 01 01)
+    pshufd      xmm5, xmm0, 0xAA        ; xmm5=col2=(02 02 02 02 02 02 02 02)
+    pshufd      xmm0, xmm0, 0xFF        ; xmm0=col3=(03 03 03 03 03 03 03 03)
+    pshufd      xmm1, xmm7, 0x00        ; xmm1=col4=(04 04 04 04 04 04 04 04)
+    pshufd      xmm4, xmm7, 0x55        ; xmm4=col5=(05 05 05 05 05 05 05 05)
+    pshufd      xmm3, xmm7, 0xAA        ; xmm3=col6=(06 06 06 06 06 06 06 06)
+    pshufd      xmm7, xmm7, 0xFF        ; xmm7=col7=(07 07 07 07 07 07 07 07)
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=col1
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=col3
+    jmp         near .column_end
+    alignx      16, 7
+%endif
+.columnDCT:
+
+    ; -- Even part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+
+    movdqa      xmm4, xmm0
+    movdqa      xmm5, xmm1
+    psubw       xmm0, xmm2              ; xmm0=tmp11
+    psubw       xmm1, xmm3
+    paddw       xmm4, xmm2              ; xmm4=tmp10
+    paddw       xmm5, xmm3              ; xmm5=tmp13
+
+    psllw       xmm1, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm1, [GOTOFF(ebx,PW_F1414)]
+    psubw       xmm1, xmm5              ; xmm1=tmp12
+
+    movdqa      xmm6, xmm4
+    movdqa      xmm7, xmm0
+    psubw       xmm4, xmm5              ; xmm4=tmp3
+    psubw       xmm0, xmm1              ; xmm0=tmp2
+    paddw       xmm6, xmm5              ; xmm6=tmp0
+    paddw       xmm7, xmm1              ; xmm7=tmp1
+
+    movdqa      XMMWORD [wk(1)], xmm4   ; wk(1)=tmp3
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=tmp2
+
+    ; -- Odd part
+
+    movdqa      xmm2, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+    movdqa      xmm5, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm5, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_IFAST_MULT_TYPE)]
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm0, xmm5
+    psubw       xmm2, xmm1              ; xmm2=z12
+    psubw       xmm5, xmm3              ; xmm5=z10
+    paddw       xmm4, xmm1              ; xmm4=z11
+    paddw       xmm0, xmm3              ; xmm0=z13
+
+    movdqa      xmm1, xmm5              ; xmm1=z10(unscaled)
+    psllw       xmm2, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+
+    movdqa      xmm3, xmm4
+    psubw       xmm4, xmm0
+    paddw       xmm3, xmm0              ; xmm3=tmp7
+
+    psllw       xmm4, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm4, [GOTOFF(ebx,PW_F1414)]  ; xmm4=tmp11
+
+    ; To avoid overflow...
+    ;
+    ; (Original)
+    ; tmp12 = -2.613125930 * z10 + z5;
+    ;
+    ; (This implementation)
+    ; tmp12 = (-1.613125930 - 1) * z10 + z5;
+    ;       = -1.613125930 * z10 - z10 + z5;
+
+    movdqa      xmm0, xmm5
+    paddw       xmm5, xmm2
+    pmulhw      xmm5, [GOTOFF(ebx,PW_F1847)]   ; xmm5=z5
+    pmulhw      xmm0, [GOTOFF(ebx,PW_MF1613)]
+    pmulhw      xmm2, [GOTOFF(ebx,PW_F1082)]
+    psubw       xmm0, xmm1
+    psubw       xmm2, xmm5              ; xmm2=tmp10
+    paddw       xmm0, xmm5              ; xmm0=tmp12
+
+    ; -- Final output stage
+
+    psubw       xmm0, xmm3              ; xmm0=tmp6
+    movdqa      xmm1, xmm6
+    movdqa      xmm5, xmm7
+    paddw       xmm6, xmm3              ; xmm6=data0=(00 01 02 03 04 05 06 07)
+    paddw       xmm7, xmm0              ; xmm7=data1=(10 11 12 13 14 15 16 17)
+    psubw       xmm1, xmm3              ; xmm1=data7=(70 71 72 73 74 75 76 77)
+    psubw       xmm5, xmm0              ; xmm5=data6=(60 61 62 63 64 65 66 67)
+    psubw       xmm4, xmm0              ; xmm4=tmp5
+
+    movdqa      xmm3, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm7              ; xmm6=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm3, xmm7              ; xmm3=(04 14 05 15 06 16 07 17)
+    movdqa      xmm0, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm1              ; xmm5=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm0, xmm1              ; xmm0=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
+    movdqa      xmm1, XMMWORD [wk(1)]   ; xmm1=tmp3
+
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=(60 70 61 71 62 72 63 73)
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=(64 74 65 75 66 76 67 77)
+
+    paddw       xmm2, xmm4              ; xmm2=tmp4
+    movdqa      xmm5, xmm7
+    movdqa      xmm0, xmm1
+    paddw       xmm7, xmm4              ; xmm7=data2=(20 21 22 23 24 25 26 27)
+    paddw       xmm1, xmm2              ; xmm1=data4=(40 41 42 43 44 45 46 47)
+    psubw       xmm5, xmm4              ; xmm5=data5=(50 51 52 53 54 55 56 57)
+    psubw       xmm0, xmm2              ; xmm0=data3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm4, xmm7              ; transpose coefficients(phase 1)
+    punpcklwd   xmm7, xmm0              ; xmm7=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm4, xmm0              ; xmm4=(24 34 25 35 26 36 27 37)
+    movdqa      xmm2, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm5              ; xmm1=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm2, xmm5              ; xmm2=(44 54 45 55 46 56 47 57)
+
+    movdqa      xmm0, xmm3              ; transpose coefficients(phase 2)
+    punpckldq   xmm3, xmm4              ; xmm3=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm0, xmm4              ; xmm0=(06 16 26 36 07 17 27 37)
+    movdqa      xmm5, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm7              ; xmm6=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm5, xmm7              ; xmm5=(02 12 22 32 03 13 23 33)
+
+    movdqa      xmm4, XMMWORD [wk(0)]   ; xmm4=(60 70 61 71 62 72 63 73)
+    movdqa      xmm7, XMMWORD [wk(1)]   ; xmm7=(64 74 65 75 66 76 67 77)
+
+    movdqa      XMMWORD [wk(0)], xmm3   ; wk(0)=(04 14 24 34 05 15 25 35)
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm3, xmm1              ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm4              ; xmm1=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm3, xmm4              ; xmm3=(42 52 62 72 43 53 63 73)
+    movdqa      xmm0, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm7              ; xmm2=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm0, xmm7              ; xmm0=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm4, xmm6              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm6, xmm1              ; xmm6=col0=(00 10 20 30 40 50 60 70)
+    punpckhqdq  xmm4, xmm1              ; xmm4=col1=(01 11 21 31 41 51 61 71)
+    movdqa      xmm7, xmm5              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm5, xmm3              ; xmm5=col2=(02 12 22 32 42 52 62 72)
+    punpckhqdq  xmm7, xmm3              ; xmm7=col3=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=(04 14 24 34 05 15 25 35)
+    movdqa      xmm3, XMMWORD [wk(1)]   ; xmm3=(06 16 26 36 07 17 27 37)
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=col1
+    movdqa      XMMWORD [wk(1)], xmm7   ; wk(1)=col3
+
+    movdqa      xmm4, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm2              ; xmm1=col4=(04 14 24 34 44 54 64 74)
+    punpckhqdq  xmm4, xmm2              ; xmm4=col5=(05 15 25 35 45 55 65 75)
+    movdqa      xmm7, xmm3              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm3, xmm0              ; xmm3=col6=(06 16 26 36 46 56 66 76)
+    punpckhqdq  xmm7, xmm0              ; xmm7=col7=(07 17 27 37 47 57 67 77)
+.column_end:
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows from work array, store into output array.
+
+    mov         eax, [original_ebp]
+    mov         edi, JSAMPARRAY [output_buf(eax)]  ; (JSAMPROW *)
+    mov         eax, JDIMENSION [output_col(eax)]
+
+    ; -- Even part
+
+    ; xmm6=col0, xmm5=col2, xmm1=col4, xmm3=col6
+
+    movdqa      xmm2, xmm6
+    movdqa      xmm0, xmm5
+    psubw       xmm6, xmm1              ; xmm6=tmp11
+    psubw       xmm5, xmm3
+    paddw       xmm2, xmm1              ; xmm2=tmp10
+    paddw       xmm0, xmm3              ; xmm0=tmp13
+
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm5, [GOTOFF(ebx,PW_F1414)]
+    psubw       xmm5, xmm0              ; xmm5=tmp12
+
+    movdqa      xmm1, xmm2
+    movdqa      xmm3, xmm6
+    psubw       xmm2, xmm0              ; xmm2=tmp3
+    psubw       xmm6, xmm5              ; xmm6=tmp2
+    paddw       xmm1, xmm0              ; xmm1=tmp0
+    paddw       xmm3, xmm5              ; xmm3=tmp1
+
+    movdqa      xmm0, XMMWORD [wk(0)]   ; xmm0=col1
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=col3
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=tmp3
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp2
+
+    ; -- Odd part
+
+    ; xmm0=col1, xmm5=col3, xmm4=col5, xmm7=col7
+
+    movdqa      xmm2, xmm0
+    movdqa      xmm6, xmm4
+    psubw       xmm0, xmm7              ; xmm0=z12
+    psubw       xmm4, xmm5              ; xmm4=z10
+    paddw       xmm2, xmm7              ; xmm2=z11
+    paddw       xmm6, xmm5              ; xmm6=z13
+
+    movdqa      xmm7, xmm4              ; xmm7=z10(unscaled)
+    psllw       xmm0, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm4, PRE_MULTIPLY_SCALE_BITS
+
+    movdqa      xmm5, xmm2
+    psubw       xmm2, xmm6
+    paddw       xmm5, xmm6              ; xmm5=tmp7
+
+    psllw       xmm2, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm2, [GOTOFF(ebx,PW_F1414)]  ; xmm2=tmp11
+
+    ; To avoid overflow...
+    ;
+    ; (Original)
+    ; tmp12 = -2.613125930 * z10 + z5;
+    ;
+    ; (This implementation)
+    ; tmp12 = (-1.613125930 - 1) * z10 + z5;
+    ;       = -1.613125930 * z10 - z10 + z5;
+
+    movdqa      xmm6, xmm4
+    paddw       xmm4, xmm0
+    pmulhw      xmm4, [GOTOFF(ebx,PW_F1847)]   ; xmm4=z5
+    pmulhw      xmm6, [GOTOFF(ebx,PW_MF1613)]
+    pmulhw      xmm0, [GOTOFF(ebx,PW_F1082)]
+    psubw       xmm6, xmm7
+    psubw       xmm0, xmm4              ; xmm0=tmp10
+    paddw       xmm6, xmm4              ; xmm6=tmp12
+
+    ; -- Final output stage
+
+    psubw       xmm6, xmm5              ; xmm6=tmp6
+    movdqa      xmm7, xmm1
+    movdqa      xmm4, xmm3
+    paddw       xmm1, xmm5              ; xmm1=data0=(00 10 20 30 40 50 60 70)
+    paddw       xmm3, xmm6              ; xmm3=data1=(01 11 21 31 41 51 61 71)
+    psraw       xmm1, (PASS1_BITS+3)    ; descale
+    psraw       xmm3, (PASS1_BITS+3)    ; descale
+    psubw       xmm7, xmm5              ; xmm7=data7=(07 17 27 37 47 57 67 77)
+    psubw       xmm4, xmm6              ; xmm4=data6=(06 16 26 36 46 56 66 76)
+    psraw       xmm7, (PASS1_BITS+3)    ; descale
+    psraw       xmm4, (PASS1_BITS+3)    ; descale
+    psubw       xmm2, xmm6              ; xmm2=tmp5
+
+    packsswb    xmm1, xmm4        ; xmm1=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    packsswb    xmm3, xmm7        ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp2
+    movdqa      xmm6, XMMWORD [wk(0)]   ; xmm6=tmp3
+
+    paddw       xmm0, xmm2              ; xmm0=tmp4
+    movdqa      xmm4, xmm5
+    movdqa      xmm7, xmm6
+    paddw       xmm5, xmm2              ; xmm5=data2=(02 12 22 32 42 52 62 72)
+    paddw       xmm6, xmm0              ; xmm6=data4=(04 14 24 34 44 54 64 74)
+    psraw       xmm5, (PASS1_BITS+3)    ; descale
+    psraw       xmm6, (PASS1_BITS+3)    ; descale
+    psubw       xmm4, xmm2              ; xmm4=data5=(05 15 25 35 45 55 65 75)
+    psubw       xmm7, xmm0              ; xmm7=data3=(03 13 23 33 43 53 63 73)
+    psraw       xmm4, (PASS1_BITS+3)    ; descale
+    psraw       xmm7, (PASS1_BITS+3)    ; descale
+
+    movdqa      xmm2, [GOTOFF(ebx,PB_CENTERJSAMP)]  ; xmm2=[PB_CENTERJSAMP]
+
+    packsswb    xmm5, xmm6        ; xmm5=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
+    packsswb    xmm7, xmm4        ; xmm7=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
+
+    paddb       xmm1, xmm2
+    paddb       xmm3, xmm2
+    paddb       xmm5, xmm2
+    paddb       xmm7, xmm2
+
+    movdqa      xmm0, xmm1        ; transpose coefficients(phase 1)
+    punpcklbw   xmm1, xmm3        ; xmm1=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
+    punpckhbw   xmm0, xmm3        ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
+    movdqa      xmm6, xmm5        ; transpose coefficients(phase 1)
+    punpcklbw   xmm5, xmm7        ; xmm5=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
+    punpckhbw   xmm6, xmm7        ; xmm6=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
+
+    movdqa      xmm4, xmm1        ; transpose coefficients(phase 2)
+    punpcklwd   xmm1, xmm5        ; xmm1=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
+    punpckhwd   xmm4, xmm5        ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
+    movdqa      xmm2, xmm6        ; transpose coefficients(phase 2)
+    punpcklwd   xmm6, xmm0        ; xmm6=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
+    punpckhwd   xmm2, xmm0        ; xmm2=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
+
+    movdqa      xmm3, xmm1        ; transpose coefficients(phase 3)
+    punpckldq   xmm1, xmm6        ; xmm1=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
+    punpckhdq   xmm3, xmm6        ; xmm3=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
+    movdqa      xmm7, xmm4        ; transpose coefficients(phase 3)
+    punpckldq   xmm4, xmm2        ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
+    punpckhdq   xmm7, xmm2        ; xmm7=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
+
+    pshufd      xmm5, xmm1, 0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
+    pshufd      xmm0, xmm3, 0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
+    pshufd      xmm6, xmm4, 0x4E  ; xmm6=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
+    pshufd      xmm2, xmm7, 0x4E  ; xmm2=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
+
+    mov         edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm1
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm3
+    mov         edx, JSAMPROW [edi+4*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+6*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm4
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm7
+
+    mov         edx, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm5
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm0
+    mov         edx, JSAMPROW [edi+5*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+7*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm6
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm2
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+    poppic      ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jidctint-mmx.asm b/simd/i386/jidctint-mmx.asm
similarity index 99%
rename from simd/jidctint-mmx.asm
rename to simd/i386/jidctint-mmx.asm
index 5bd1981..6ef7ff7 100644
--- a/simd/jidctint-mmx.asm
+++ b/simd/i386/jidctint-mmx.asm
@@ -2,6 +2,7 @@
 ; jidctint.asm - accurate integer IDCT (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -64,7 +65,7 @@ F_3_072 equ     DESCALE(3299298341,30-CONST_BITS)       ; FIX(3.072711026)
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_idct_islow_mmx)
 
 EXTN(jconst_idct_islow_mmx):
@@ -81,7 +82,7 @@ PD_DESCALE_P1   times 2 dd  1 << (DESCALE_P1-1)
 PD_DESCALE_P2   times 2 dd  1 << (DESCALE_P2-1)
 PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -105,7 +106,7 @@ PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 %define workspace       wk(0)-DCTSIZE2*SIZEOF_JCOEF
                                         ; JCOEF workspace[DCTSIZE2]
 
-        align   16
+        align   32
         global  EXTN(jsimd_idct_islow_mmx)
 
 EXTN(jsimd_idct_islow_mmx):
@@ -848,4 +849,4 @@ EXTN(jsimd_idct_islow_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jidctint-sse2.asm b/simd/i386/jidctint-sse2.asm
new file mode 100644
index 0000000..441da70
--- /dev/null
+++ b/simd/i386/jidctint-sse2.asm
@@ -0,0 +1,859 @@
+;
+; jidctint.asm - accurate integer IDCT (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a slow-but-accurate integer implementation of the
+; inverse DCT (Discrete Cosine Transform). The following code is based
+; directly on the IJG's original jidctint.c; see the jidctint.c for
+; more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  13
+%define PASS1_BITS  2
+
+%define DESCALE_P1  (CONST_BITS-PASS1_BITS)
+%define DESCALE_P2  (CONST_BITS+PASS1_BITS+3)
+
+%if CONST_BITS == 13
+F_0_298 equ  2446  ; FIX(0.298631336)
+F_0_390 equ  3196  ; FIX(0.390180644)
+F_0_541 equ  4433  ; FIX(0.541196100)
+F_0_765 equ  6270  ; FIX(0.765366865)
+F_0_899 equ  7373  ; FIX(0.899976223)
+F_1_175 equ  9633  ; FIX(1.175875602)
+F_1_501 equ 12299  ; FIX(1.501321110)
+F_1_847 equ 15137  ; FIX(1.847759065)
+F_1_961 equ 16069  ; FIX(1.961570560)
+F_2_053 equ 16819  ; FIX(2.053119869)
+F_2_562 equ 20995  ; FIX(2.562915447)
+F_3_072 equ 25172  ; FIX(3.072711026)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_298 equ DESCALE( 320652955, 30-CONST_BITS)  ; FIX(0.298631336)
+F_0_390 equ DESCALE( 418953276, 30-CONST_BITS)  ; FIX(0.390180644)
+F_0_541 equ DESCALE( 581104887, 30-CONST_BITS)  ; FIX(0.541196100)
+F_0_765 equ DESCALE( 821806413, 30-CONST_BITS)  ; FIX(0.765366865)
+F_0_899 equ DESCALE( 966342111, 30-CONST_BITS)  ; FIX(0.899976223)
+F_1_175 equ DESCALE(1262586813, 30-CONST_BITS)  ; FIX(1.175875602)
+F_1_501 equ DESCALE(1612031267, 30-CONST_BITS)  ; FIX(1.501321110)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_1_961 equ DESCALE(2106220350, 30-CONST_BITS)  ; FIX(1.961570560)
+F_2_053 equ DESCALE(2204520673, 30-CONST_BITS)  ; FIX(2.053119869)
+F_2_562 equ DESCALE(2751909506, 30-CONST_BITS)  ; FIX(2.562915447)
+F_3_072 equ DESCALE(3299298341, 30-CONST_BITS)  ; FIX(3.072711026)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_idct_islow_sse2)
+
+EXTN(jconst_idct_islow_sse2):
+
+PW_F130_F054   times 4  dw  (F_0_541+F_0_765), F_0_541
+PW_F054_MF130  times 4  dw  F_0_541, (F_0_541-F_1_847)
+PW_MF078_F117  times 4  dw  (F_1_175-F_1_961), F_1_175
+PW_F117_F078   times 4  dw  F_1_175, (F_1_175-F_0_390)
+PW_MF060_MF089 times 4  dw  (F_0_298-F_0_899),-F_0_899
+PW_MF089_F060  times 4  dw -F_0_899, (F_1_501-F_0_899)
+PW_MF050_MF256 times 4  dw  (F_2_053-F_2_562),-F_2_562
+PW_MF256_F050  times 4  dw -F_2_562, (F_3_072-F_2_562)
+PD_DESCALE_P1  times 4  dd  1 << (DESCALE_P1-1)
+PD_DESCALE_P2  times 4  dd  1 << (DESCALE_P2-1)
+PB_CENTERJSAMP times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Perform dequantization and inverse DCT on one block of coefficients.
+;
+; GLOBAL(void)
+; jsimd_idct_islow_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                        JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+%define dct_table(b)   (b)+8            ; jpeg_component_info *compptr
+%define coef_block(b)  (b)+12           ; JCOEFPTR coef_block
+%define output_buf(b)  (b)+16           ; JSAMPARRAY output_buf
+%define output_col(b)  (b)+20           ; JDIMENSION output_col
+
+%define original_ebp   ebp+0
+%define wk(i)          ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM         12
+
+    align       32
+    global      EXTN(jsimd_idct_islow_sse2)
+
+EXTN(jsimd_idct_islow_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     ebx
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process columns from input.
+
+;   mov         eax, [original_ebp]
+    mov         edx, POINTER [dct_table(eax)]    ; quantptr
+    mov         esi, JCOEFPTR [coef_block(eax)]  ; inptr
+
+%ifndef NO_ZERO_COLUMN_TEST_ISLOW_SSE2
+    mov         eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    jnz         near .columnDCT
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, xmm0
+    packsswb    xmm1, xmm1
+    packsswb    xmm1, xmm1
+    movd        eax, xmm1
+    test        eax, eax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movdqa      xmm5, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm5, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    psllw       xmm5, PASS1_BITS
+
+    movdqa      xmm4, xmm5              ; xmm5=in0=(00 01 02 03 04 05 06 07)
+    punpcklwd   xmm5, xmm5              ; xmm5=(00 00 01 01 02 02 03 03)
+    punpckhwd   xmm4, xmm4              ; xmm4=(04 04 05 05 06 06 07 07)
+
+    pshufd      xmm7, xmm5, 0x00        ; xmm7=col0=(00 00 00 00 00 00 00 00)
+    pshufd      xmm6, xmm5, 0x55        ; xmm6=col1=(01 01 01 01 01 01 01 01)
+    pshufd      xmm1, xmm5, 0xAA        ; xmm1=col2=(02 02 02 02 02 02 02 02)
+    pshufd      xmm5, xmm5, 0xFF        ; xmm5=col3=(03 03 03 03 03 03 03 03)
+    pshufd      xmm0, xmm4, 0x00        ; xmm0=col4=(04 04 04 04 04 04 04 04)
+    pshufd      xmm3, xmm4, 0x55        ; xmm3=col5=(05 05 05 05 05 05 05 05)
+    pshufd      xmm2, xmm4, 0xAA        ; xmm2=col6=(06 06 06 06 06 06 06 06)
+    pshufd      xmm4, xmm4, 0xFF        ; xmm4=col7=(07 07 07 07 07 07 07 07)
+
+    movdqa      XMMWORD [wk(8)], xmm6   ; wk(8)=col1
+    movdqa      XMMWORD [wk(9)], xmm5   ; wk(9)=col3
+    movdqa      XMMWORD [wk(10)], xmm3  ; wk(10)=col5
+    movdqa      XMMWORD [wk(11)], xmm4  ; wk(11)=col7
+    jmp         near .column_end
+    alignx      16, 7
+%endif
+.columnDCT:
+
+    ; -- Even part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    ; (Original)
+    ; z1 = (z2 + z3) * 0.541196100;
+    ; tmp2 = z1 + z3 * -1.847759065;
+    ; tmp3 = z1 + z2 * 0.765366865;
+    ;
+    ; (This implementation)
+    ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
+    ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
+
+    movdqa      xmm4, xmm1              ; xmm1=in2=z2
+    movdqa      xmm5, xmm1
+    punpcklwd   xmm4, xmm3              ; xmm3=in6=z3
+    punpckhwd   xmm5, xmm3
+    movdqa      xmm1, xmm4
+    movdqa      xmm3, xmm5
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_F130_F054)]   ; xmm4=tmp3L
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F130_F054)]   ; xmm5=tmp3H
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm1=tmp2L
+    pmaddwd     xmm3, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm3=tmp2H
+
+    movdqa      xmm6, xmm0
+    paddw       xmm0, xmm2              ; xmm0=in0+in4
+    psubw       xmm6, xmm2              ; xmm6=in0-in4
+
+    pxor        xmm7, xmm7
+    pxor        xmm2, xmm2
+    punpcklwd   xmm7, xmm0              ; xmm7=tmp0L
+    punpckhwd   xmm2, xmm0              ; xmm2=tmp0H
+    psrad       xmm7, (16-CONST_BITS)   ; psrad xmm7,16 & pslld xmm7,CONST_BITS
+    psrad       xmm2, (16-CONST_BITS)   ; psrad xmm2,16 & pslld xmm2,CONST_BITS
+
+    movdqa      xmm0, xmm7
+    paddd       xmm7, xmm4              ; xmm7=tmp10L
+    psubd       xmm0, xmm4              ; xmm0=tmp13L
+    movdqa      xmm4, xmm2
+    paddd       xmm2, xmm5              ; xmm2=tmp10H
+    psubd       xmm4, xmm5              ; xmm4=tmp13H
+
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=tmp10L
+    movdqa      XMMWORD [wk(1)], xmm2   ; wk(1)=tmp10H
+    movdqa      XMMWORD [wk(2)], xmm0   ; wk(2)=tmp13L
+    movdqa      XMMWORD [wk(3)], xmm4   ; wk(3)=tmp13H
+
+    pxor        xmm5, xmm5
+    pxor        xmm7, xmm7
+    punpcklwd   xmm5, xmm6              ; xmm5=tmp1L
+    punpckhwd   xmm7, xmm6              ; xmm7=tmp1H
+    psrad       xmm5, (16-CONST_BITS)   ; psrad xmm5,16 & pslld xmm5,CONST_BITS
+    psrad       xmm7, (16-CONST_BITS)   ; psrad xmm7,16 & pslld xmm7,CONST_BITS
+
+    movdqa      xmm2, xmm5
+    paddd       xmm5, xmm1              ; xmm5=tmp11L
+    psubd       xmm2, xmm1              ; xmm2=tmp12L
+    movdqa      xmm0, xmm7
+    paddd       xmm7, xmm3              ; xmm7=tmp11H
+    psubd       xmm0, xmm3              ; xmm0=tmp12H
+
+    movdqa      XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
+    movdqa      XMMWORD [wk(5)], xmm7   ; wk(5)=tmp11H
+    movdqa      XMMWORD [wk(6)], xmm2   ; wk(6)=tmp12L
+    movdqa      XMMWORD [wk(7)], xmm0   ; wk(7)=tmp12H
+
+    ; -- Odd part
+
+    movdqa      xmm4, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm6, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm4, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm6, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    movdqa      xmm5, xmm6
+    movdqa      xmm7, xmm4
+    paddw       xmm5, xmm3              ; xmm5=z3
+    paddw       xmm7, xmm1              ; xmm7=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm2, xmm5
+    movdqa      xmm0, xmm5
+    punpcklwd   xmm2, xmm7
+    punpckhwd   xmm0, xmm7
+    movdqa      xmm5, xmm2
+    movdqa      xmm7, xmm0
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm2=z3L
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm0=z3H
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F117_F078)]   ; xmm5=z4L
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_F117_F078)]   ; xmm7=z4H
+
+    movdqa      XMMWORD [wk(10)], xmm2  ; wk(10)=z3L
+    movdqa      XMMWORD [wk(11)], xmm0  ; wk(11)=z3H
+
+    ; (Original)
+    ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
+    ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
+    ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
+    ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
+    ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
+    ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
+    ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
+    ; tmp0 += z3;  tmp1 += z4;
+    ; tmp2 += z3;  tmp3 += z4;
+
+    movdqa      xmm2, xmm3
+    movdqa      xmm0, xmm3
+    punpcklwd   xmm2, xmm4
+    punpckhwd   xmm0, xmm4
+    movdqa      xmm3, xmm2
+    movdqa      xmm4, xmm0
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm2=tmp0L
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm0=tmp0H
+    pmaddwd     xmm3, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm3=tmp3L
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm4=tmp3H
+
+    paddd       xmm2, XMMWORD [wk(10)]  ; xmm2=tmp0L
+    paddd       xmm0, XMMWORD [wk(11)]  ; xmm0=tmp0H
+    paddd       xmm3, xmm5              ; xmm3=tmp3L
+    paddd       xmm4, xmm7              ; xmm4=tmp3H
+
+    movdqa      XMMWORD [wk(8)], xmm2   ; wk(8)=tmp0L
+    movdqa      XMMWORD [wk(9)], xmm0   ; wk(9)=tmp0H
+
+    movdqa      xmm2, xmm1
+    movdqa      xmm0, xmm1
+    punpcklwd   xmm2, xmm6
+    punpckhwd   xmm0, xmm6
+    movdqa      xmm1, xmm2
+    movdqa      xmm6, xmm0
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm2=tmp1L
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm0=tmp1H
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm1=tmp2L
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm6=tmp2H
+
+    paddd       xmm2, xmm5              ; xmm2=tmp1L
+    paddd       xmm0, xmm7              ; xmm0=tmp1H
+    paddd       xmm1, XMMWORD [wk(10)]  ; xmm1=tmp2L
+    paddd       xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
+
+    movdqa      XMMWORD [wk(10)], xmm2  ; wk(10)=tmp1L
+    movdqa      XMMWORD [wk(11)], xmm0  ; wk(11)=tmp1H
+
+    ; -- Final output stage
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
+    movdqa      xmm7, XMMWORD [wk(1)]   ; xmm7=tmp10H
+
+    movdqa      xmm2, xmm5
+    movdqa      xmm0, xmm7
+    paddd       xmm5, xmm3              ; xmm5=data0L
+    paddd       xmm7, xmm4              ; xmm7=data0H
+    psubd       xmm2, xmm3              ; xmm2=data7L
+    psubd       xmm0, xmm4              ; xmm0=data7H
+
+    movdqa      xmm3, [GOTOFF(ebx,PD_DESCALE_P1)]  ; xmm3=[PD_DESCALE_P1]
+
+    paddd       xmm5, xmm3
+    paddd       xmm7, xmm3
+    psrad       xmm5, DESCALE_P1
+    psrad       xmm7, DESCALE_P1
+    paddd       xmm2, xmm3
+    paddd       xmm0, xmm3
+    psrad       xmm2, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+
+    packssdw    xmm5, xmm7              ; xmm5=data0=(00 01 02 03 04 05 06 07)
+    packssdw    xmm2, xmm0              ; xmm2=data7=(70 71 72 73 74 75 76 77)
+
+    movdqa      xmm4, XMMWORD [wk(4)]   ; xmm4=tmp11L
+    movdqa      xmm3, XMMWORD [wk(5)]   ; xmm3=tmp11H
+
+    movdqa      xmm7, xmm4
+    movdqa      xmm0, xmm3
+    paddd       xmm4, xmm1              ; xmm4=data1L
+    paddd       xmm3, xmm6              ; xmm3=data1H
+    psubd       xmm7, xmm1              ; xmm7=data6L
+    psubd       xmm0, xmm6              ; xmm0=data6H
+
+    movdqa      xmm1, [GOTOFF(ebx,PD_DESCALE_P1)]  ; xmm1=[PD_DESCALE_P1]
+
+    paddd       xmm4, xmm1
+    paddd       xmm3, xmm1
+    psrad       xmm4, DESCALE_P1
+    psrad       xmm3, DESCALE_P1
+    paddd       xmm7, xmm1
+    paddd       xmm0, xmm1
+    psrad       xmm7, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+
+    packssdw    xmm4, xmm3              ; xmm4=data1=(10 11 12 13 14 15 16 17)
+    packssdw    xmm7, xmm0              ; xmm7=data6=(60 61 62 63 64 65 66 67)
+
+    movdqa      xmm6, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm4              ; xmm5=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm6, xmm4              ; xmm6=(04 14 05 15 06 16 07 17)
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 1)
+    punpcklwd   xmm7, xmm2              ; xmm7=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm1, xmm2              ; xmm1=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm3, XMMWORD [wk(6)]   ; xmm3=tmp12L
+    movdqa      xmm0, XMMWORD [wk(7)]   ; xmm0=tmp12H
+    movdqa      xmm4, XMMWORD [wk(10)]  ; xmm4=tmp1L
+    movdqa      xmm2, XMMWORD [wk(11)]  ; xmm2=tmp1H
+
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 01 11 02 12 03 13)
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=(04 14 05 15 06 16 07 17)
+    movdqa      XMMWORD [wk(4)], xmm7   ; wk(4)=(60 70 61 71 62 72 63 73)
+    movdqa      XMMWORD [wk(5)], xmm1   ; wk(5)=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm5, xmm3
+    movdqa      xmm6, xmm0
+    paddd       xmm3, xmm4              ; xmm3=data2L
+    paddd       xmm0, xmm2              ; xmm0=data2H
+    psubd       xmm5, xmm4              ; xmm5=data5L
+    psubd       xmm6, xmm2              ; xmm6=data5H
+
+    movdqa      xmm7, [GOTOFF(ebx,PD_DESCALE_P1)]  ; xmm7=[PD_DESCALE_P1]
+
+    paddd       xmm3, xmm7
+    paddd       xmm0, xmm7
+    psrad       xmm3, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+    paddd       xmm5, xmm7
+    paddd       xmm6, xmm7
+    psrad       xmm5, DESCALE_P1
+    psrad       xmm6, DESCALE_P1
+
+    packssdw    xmm3, xmm0              ; xmm3=data2=(20 21 22 23 24 25 26 27)
+    packssdw    xmm5, xmm6              ; xmm5=data5=(50 51 52 53 54 55 56 57)
+
+    movdqa      xmm1, XMMWORD [wk(2)]   ; xmm1=tmp13L
+    movdqa      xmm4, XMMWORD [wk(3)]   ; xmm4=tmp13H
+    movdqa      xmm2, XMMWORD [wk(8)]   ; xmm2=tmp0L
+    movdqa      xmm7, XMMWORD [wk(9)]   ; xmm7=tmp0H
+
+    movdqa      xmm0, xmm1
+    movdqa      xmm6, xmm4
+    paddd       xmm1, xmm2              ; xmm1=data3L
+    paddd       xmm4, xmm7              ; xmm4=data3H
+    psubd       xmm0, xmm2              ; xmm0=data4L
+    psubd       xmm6, xmm7              ; xmm6=data4H
+
+    movdqa      xmm2, [GOTOFF(ebx,PD_DESCALE_P1)]  ; xmm2=[PD_DESCALE_P1]
+
+    paddd       xmm1, xmm2
+    paddd       xmm4, xmm2
+    psrad       xmm1, DESCALE_P1
+    psrad       xmm4, DESCALE_P1
+    paddd       xmm0, xmm2
+    paddd       xmm6, xmm2
+    psrad       xmm0, DESCALE_P1
+    psrad       xmm6, DESCALE_P1
+
+    packssdw    xmm1, xmm4              ; xmm1=data3=(30 31 32 33 34 35 36 37)
+    packssdw    xmm0, xmm6              ; xmm0=data4=(40 41 42 43 44 45 46 47)
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=(00 10 01 11 02 12 03 13)
+    movdqa      xmm2, XMMWORD [wk(1)]   ; xmm2=(04 14 05 15 06 16 07 17)
+
+    movdqa      xmm4, xmm3              ; transpose coefficients(phase 1)
+    punpcklwd   xmm3, xmm1              ; xmm3=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm4, xmm1              ; xmm4=(24 34 25 35 26 36 27 37)
+    movdqa      xmm6, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm5              ; xmm0=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm6, xmm5              ; xmm6=(44 54 45 55 46 56 47 57)
+
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 2)
+    punpckldq   xmm7, xmm3              ; xmm7=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm1, xmm3              ; xmm1=(02 12 22 32 03 13 23 33)
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm4              ; xmm2=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm5, xmm4              ; xmm5=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm3, XMMWORD [wk(4)]   ; xmm3=(60 70 61 71 62 72 63 73)
+    movdqa      xmm4, XMMWORD [wk(5)]   ; xmm4=(64 74 65 75 66 76 67 77)
+
+    movdqa      XMMWORD [wk(6)], xmm2   ; wk(6)=(04 14 24 34 05 15 25 35)
+    movdqa      XMMWORD [wk(7)], xmm5   ; wk(7)=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm2, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm3              ; xmm0=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm2, xmm3              ; xmm2=(42 52 62 72 43 53 63 73)
+    movdqa      xmm5, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm4              ; xmm6=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm5, xmm4              ; xmm5=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm3, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm0              ; xmm7=col0=(00 10 20 30 40 50 60 70)
+    punpckhqdq  xmm3, xmm0              ; xmm3=col1=(01 11 21 31 41 51 61 71)
+    movdqa      xmm4, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm2              ; xmm1=col2=(02 12 22 32 42 52 62 72)
+    punpckhqdq  xmm4, xmm2              ; xmm4=col3=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm0, XMMWORD [wk(6)]   ; xmm0=(04 14 24 34 05 15 25 35)
+    movdqa      xmm2, XMMWORD [wk(7)]   ; xmm2=(06 16 26 36 07 17 27 37)
+
+    movdqa      XMMWORD [wk(8)], xmm3   ; wk(8)=col1
+    movdqa      XMMWORD [wk(9)], xmm4   ; wk(9)=col3
+
+    movdqa      xmm3, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm6              ; xmm0=col4=(04 14 24 34 44 54 64 74)
+    punpckhqdq  xmm3, xmm6              ; xmm3=col5=(05 15 25 35 45 55 65 75)
+    movdqa      xmm4, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm5              ; xmm2=col6=(06 16 26 36 46 56 66 76)
+    punpckhqdq  xmm4, xmm5              ; xmm4=col7=(07 17 27 37 47 57 67 77)
+
+    movdqa      XMMWORD [wk(10)], xmm3  ; wk(10)=col5
+    movdqa      XMMWORD [wk(11)], xmm4  ; wk(11)=col7
+.column_end:
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows from work array, store into output array.
+
+    mov         eax, [original_ebp]
+    mov         edi, JSAMPARRAY [output_buf(eax)]  ; (JSAMPROW *)
+    mov         eax, JDIMENSION [output_col(eax)]
+
+    ; -- Even part
+
+    ; xmm7=col0, xmm1=col2, xmm0=col4, xmm2=col6
+
+    ; (Original)
+    ; z1 = (z2 + z3) * 0.541196100;
+    ; tmp2 = z1 + z3 * -1.847759065;
+    ; tmp3 = z1 + z2 * 0.765366865;
+    ;
+    ; (This implementation)
+    ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
+    ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
+
+    movdqa      xmm6, xmm1              ; xmm1=in2=z2
+    movdqa      xmm5, xmm1
+    punpcklwd   xmm6, xmm2              ; xmm2=in6=z3
+    punpckhwd   xmm5, xmm2
+    movdqa      xmm1, xmm6
+    movdqa      xmm2, xmm5
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_F130_F054)]   ; xmm6=tmp3L
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F130_F054)]   ; xmm5=tmp3H
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm1=tmp2L
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_F054_MF130)]  ; xmm2=tmp2H
+
+    movdqa      xmm3, xmm7
+    paddw       xmm7, xmm0              ; xmm7=in0+in4
+    psubw       xmm3, xmm0              ; xmm3=in0-in4
+
+    pxor        xmm4, xmm4
+    pxor        xmm0, xmm0
+    punpcklwd   xmm4, xmm7              ; xmm4=tmp0L
+    punpckhwd   xmm0, xmm7              ; xmm0=tmp0H
+    psrad       xmm4, (16-CONST_BITS)   ; psrad xmm4,16 & pslld xmm4,CONST_BITS
+    psrad       xmm0, (16-CONST_BITS)   ; psrad xmm0,16 & pslld xmm0,CONST_BITS
+
+    movdqa      xmm7, xmm4
+    paddd       xmm4, xmm6              ; xmm4=tmp10L
+    psubd       xmm7, xmm6              ; xmm7=tmp13L
+    movdqa      xmm6, xmm0
+    paddd       xmm0, xmm5              ; xmm0=tmp10H
+    psubd       xmm6, xmm5              ; xmm6=tmp13H
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=tmp10L
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=tmp10H
+    movdqa      XMMWORD [wk(2)], xmm7   ; wk(2)=tmp13L
+    movdqa      XMMWORD [wk(3)], xmm6   ; wk(3)=tmp13H
+
+    pxor        xmm5, xmm5
+    pxor        xmm4, xmm4
+    punpcklwd   xmm5, xmm3              ; xmm5=tmp1L
+    punpckhwd   xmm4, xmm3              ; xmm4=tmp1H
+    psrad       xmm5, (16-CONST_BITS)   ; psrad xmm5,16 & pslld xmm5,CONST_BITS
+    psrad       xmm4, (16-CONST_BITS)   ; psrad xmm4,16 & pslld xmm4,CONST_BITS
+
+    movdqa      xmm0, xmm5
+    paddd       xmm5, xmm1              ; xmm5=tmp11L
+    psubd       xmm0, xmm1              ; xmm0=tmp12L
+    movdqa      xmm7, xmm4
+    paddd       xmm4, xmm2              ; xmm4=tmp11H
+    psubd       xmm7, xmm2              ; xmm7=tmp12H
+
+    movdqa      XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
+    movdqa      XMMWORD [wk(5)], xmm4   ; wk(5)=tmp11H
+    movdqa      XMMWORD [wk(6)], xmm0   ; wk(6)=tmp12L
+    movdqa      XMMWORD [wk(7)], xmm7   ; wk(7)=tmp12H
+
+    ; -- Odd part
+
+    movdqa      xmm6, XMMWORD [wk(9)]   ; xmm6=col3
+    movdqa      xmm3, XMMWORD [wk(8)]   ; xmm3=col1
+    movdqa      xmm1, XMMWORD [wk(11)]  ; xmm1=col7
+    movdqa      xmm2, XMMWORD [wk(10)]  ; xmm2=col5
+
+    movdqa      xmm5, xmm6
+    movdqa      xmm4, xmm3
+    paddw       xmm5, xmm1              ; xmm5=z3
+    paddw       xmm4, xmm2              ; xmm4=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm0, xmm5
+    movdqa      xmm7, xmm5
+    punpcklwd   xmm0, xmm4
+    punpckhwd   xmm7, xmm4
+    movdqa      xmm5, xmm0
+    movdqa      xmm4, xmm7
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm0=z3L
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_MF078_F117)]  ; xmm7=z3H
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F117_F078)]   ; xmm5=z4L
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_F117_F078)]   ; xmm4=z4H
+
+    movdqa      XMMWORD [wk(10)], xmm0  ; wk(10)=z3L
+    movdqa      XMMWORD [wk(11)], xmm7  ; wk(11)=z3H
+
+    ; (Original)
+    ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
+    ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
+    ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
+    ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
+    ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
+    ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
+    ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
+    ; tmp0 += z3;  tmp1 += z4;
+    ; tmp2 += z3;  tmp3 += z4;
+
+    movdqa      xmm0, xmm1
+    movdqa      xmm7, xmm1
+    punpcklwd   xmm0, xmm3
+    punpckhwd   xmm7, xmm3
+    movdqa      xmm1, xmm0
+    movdqa      xmm3, xmm7
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm0=tmp0L
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_MF060_MF089)]  ; xmm7=tmp0H
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm1=tmp3L
+    pmaddwd     xmm3, [GOTOFF(ebx,PW_MF089_F060)]   ; xmm3=tmp3H
+
+    paddd       xmm0, XMMWORD [wk(10)]  ; xmm0=tmp0L
+    paddd       xmm7, XMMWORD [wk(11)]  ; xmm7=tmp0H
+    paddd       xmm1, xmm5              ; xmm1=tmp3L
+    paddd       xmm3, xmm4              ; xmm3=tmp3H
+
+    movdqa      XMMWORD [wk(8)], xmm0   ; wk(8)=tmp0L
+    movdqa      XMMWORD [wk(9)], xmm7   ; wk(9)=tmp0H
+
+    movdqa      xmm0, xmm2
+    movdqa      xmm7, xmm2
+    punpcklwd   xmm0, xmm6
+    punpckhwd   xmm7, xmm6
+    movdqa      xmm2, xmm0
+    movdqa      xmm6, xmm7
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm0=tmp1L
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_MF050_MF256)]  ; xmm7=tmp1H
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm2=tmp2L
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_MF256_F050)]   ; xmm6=tmp2H
+
+    paddd       xmm0, xmm5              ; xmm0=tmp1L
+    paddd       xmm7, xmm4              ; xmm7=tmp1H
+    paddd       xmm2, XMMWORD [wk(10)]  ; xmm2=tmp2L
+    paddd       xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
+
+    movdqa      XMMWORD [wk(10)], xmm0  ; wk(10)=tmp1L
+    movdqa      XMMWORD [wk(11)], xmm7  ; wk(11)=tmp1H
+
+    ; -- Final output stage
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
+    movdqa      xmm4, XMMWORD [wk(1)]   ; xmm4=tmp10H
+
+    movdqa      xmm0, xmm5
+    movdqa      xmm7, xmm4
+    paddd       xmm5, xmm1              ; xmm5=data0L
+    paddd       xmm4, xmm3              ; xmm4=data0H
+    psubd       xmm0, xmm1              ; xmm0=data7L
+    psubd       xmm7, xmm3              ; xmm7=data7H
+
+    movdqa      xmm1, [GOTOFF(ebx,PD_DESCALE_P2)]  ; xmm1=[PD_DESCALE_P2]
+
+    paddd       xmm5, xmm1
+    paddd       xmm4, xmm1
+    psrad       xmm5, DESCALE_P2
+    psrad       xmm4, DESCALE_P2
+    paddd       xmm0, xmm1
+    paddd       xmm7, xmm1
+    psrad       xmm0, DESCALE_P2
+    psrad       xmm7, DESCALE_P2
+
+    packssdw    xmm5, xmm4              ; xmm5=data0=(00 10 20 30 40 50 60 70)
+    packssdw    xmm0, xmm7              ; xmm0=data7=(07 17 27 37 47 57 67 77)
+
+    movdqa      xmm3, XMMWORD [wk(4)]   ; xmm3=tmp11L
+    movdqa      xmm1, XMMWORD [wk(5)]   ; xmm1=tmp11H
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm7, xmm1
+    paddd       xmm3, xmm2              ; xmm3=data1L
+    paddd       xmm1, xmm6              ; xmm1=data1H
+    psubd       xmm4, xmm2              ; xmm4=data6L
+    psubd       xmm7, xmm6              ; xmm7=data6H
+
+    movdqa      xmm2, [GOTOFF(ebx,PD_DESCALE_P2)]  ; xmm2=[PD_DESCALE_P2]
+
+    paddd       xmm3, xmm2
+    paddd       xmm1, xmm2
+    psrad       xmm3, DESCALE_P2
+    psrad       xmm1, DESCALE_P2
+    paddd       xmm4, xmm2
+    paddd       xmm7, xmm2
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm7, DESCALE_P2
+
+    packssdw    xmm3, xmm1              ; xmm3=data1=(01 11 21 31 41 51 61 71)
+    packssdw    xmm4, xmm7              ; xmm4=data6=(06 16 26 36 46 56 66 76)
+
+    packsswb    xmm5, xmm4              ; xmm5=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    packsswb    xmm3, xmm0              ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    movdqa      xmm6, XMMWORD [wk(6)]   ; xmm6=tmp12L
+    movdqa      xmm2, XMMWORD [wk(7)]   ; xmm2=tmp12H
+    movdqa      xmm1, XMMWORD [wk(10)]  ; xmm1=tmp1L
+    movdqa      xmm7, XMMWORD [wk(11)]  ; xmm7=tmp1H
+
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    movdqa      xmm4, xmm6
+    movdqa      xmm0, xmm2
+    paddd       xmm6, xmm1              ; xmm6=data2L
+    paddd       xmm2, xmm7              ; xmm2=data2H
+    psubd       xmm4, xmm1              ; xmm4=data5L
+    psubd       xmm0, xmm7              ; xmm0=data5H
+
+    movdqa      xmm5, [GOTOFF(ebx,PD_DESCALE_P2)]  ; xmm5=[PD_DESCALE_P2]
+
+    paddd       xmm6, xmm5
+    paddd       xmm2, xmm5
+    psrad       xmm6, DESCALE_P2
+    psrad       xmm2, DESCALE_P2
+    paddd       xmm4, xmm5
+    paddd       xmm0, xmm5
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm0, DESCALE_P2
+
+    packssdw    xmm6, xmm2              ; xmm6=data2=(02 12 22 32 42 52 62 72)
+    packssdw    xmm4, xmm0              ; xmm4=data5=(05 15 25 35 45 55 65 75)
+
+    movdqa      xmm3, XMMWORD [wk(2)]   ; xmm3=tmp13L
+    movdqa      xmm1, XMMWORD [wk(3)]   ; xmm1=tmp13H
+    movdqa      xmm7, XMMWORD [wk(8)]   ; xmm7=tmp0L
+    movdqa      xmm5, XMMWORD [wk(9)]   ; xmm5=tmp0H
+
+    movdqa      xmm2, xmm3
+    movdqa      xmm0, xmm1
+    paddd       xmm3, xmm7              ; xmm3=data3L
+    paddd       xmm1, xmm5              ; xmm1=data3H
+    psubd       xmm2, xmm7              ; xmm2=data4L
+    psubd       xmm0, xmm5              ; xmm0=data4H
+
+    movdqa      xmm7, [GOTOFF(ebx,PD_DESCALE_P2)]  ; xmm7=[PD_DESCALE_P2]
+
+    paddd       xmm3, xmm7
+    paddd       xmm1, xmm7
+    psrad       xmm3, DESCALE_P2
+    psrad       xmm1, DESCALE_P2
+    paddd       xmm2, xmm7
+    paddd       xmm0, xmm7
+    psrad       xmm2, DESCALE_P2
+    psrad       xmm0, DESCALE_P2
+
+    movdqa      xmm5, [GOTOFF(ebx,PB_CENTERJSAMP)]  ; xmm5=[PB_CENTERJSAMP]
+
+    packssdw    xmm3, xmm1             ; xmm3=data3=(03 13 23 33 43 53 63 73)
+    packssdw    xmm2, xmm0             ; xmm2=data4=(04 14 24 34 44 54 64 74)
+
+    movdqa      xmm7, XMMWORD [wk(0)]  ; xmm7=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    movdqa      xmm1, XMMWORD [wk(1)]  ; xmm1=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    packsswb    xmm6, xmm2             ; xmm6=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
+    packsswb    xmm3, xmm4             ; xmm3=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
+
+    paddb       xmm7, xmm5
+    paddb       xmm1, xmm5
+    paddb       xmm6, xmm5
+    paddb       xmm3, xmm5
+
+    movdqa      xmm0, xmm7        ; transpose coefficients(phase 1)
+    punpcklbw   xmm7, xmm1        ; xmm7=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
+    punpckhbw   xmm0, xmm1        ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
+    movdqa      xmm2, xmm6        ; transpose coefficients(phase 1)
+    punpcklbw   xmm6, xmm3        ; xmm6=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
+    punpckhbw   xmm2, xmm3        ; xmm2=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
+
+    movdqa      xmm4, xmm7        ; transpose coefficients(phase 2)
+    punpcklwd   xmm7, xmm6        ; xmm7=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
+    punpckhwd   xmm4, xmm6        ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
+    movdqa      xmm5, xmm2        ; transpose coefficients(phase 2)
+    punpcklwd   xmm2, xmm0        ; xmm2=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
+    punpckhwd   xmm5, xmm0        ; xmm5=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
+
+    movdqa      xmm1, xmm7        ; transpose coefficients(phase 3)
+    punpckldq   xmm7, xmm2        ; xmm7=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
+    punpckhdq   xmm1, xmm2        ; xmm1=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
+    movdqa      xmm3, xmm4        ; transpose coefficients(phase 3)
+    punpckldq   xmm4, xmm5        ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
+    punpckhdq   xmm3, xmm5        ; xmm3=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
+
+    pshufd      xmm6, xmm7, 0x4E  ; xmm6=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
+    pshufd      xmm0, xmm1, 0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
+    pshufd      xmm2, xmm4, 0x4E  ; xmm2=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
+    pshufd      xmm5, xmm3, 0x4E  ; xmm5=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
+
+    mov         edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm7
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm1
+    mov         edx, JSAMPROW [edi+4*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+6*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm4
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm3
+
+    mov         edx, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm6
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm0
+    mov         edx, JSAMPROW [edi+5*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+7*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm2
+    movq        XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm5
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+    poppic      ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jidctred-mmx.asm b/simd/i386/jidctred-mmx.asm
similarity index 99%
rename from simd/jidctred-mmx.asm
rename to simd/i386/jidctred-mmx.asm
index ba054e3..d5b7e2e 100644
--- a/simd/jidctred-mmx.asm
+++ b/simd/i386/jidctred-mmx.asm
@@ -2,6 +2,7 @@
 ; jidctred.asm - reduced-size IDCT (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -70,7 +71,7 @@ F_3_624 equ     DESCALE(3891787747,30-CONST_BITS)       ; FIX(3.624509785)
 ; --------------------------------------------------------------------------
         SECTION SEG_CONST
 
-        alignz  16
+        alignz  32
         global  EXTN(jconst_idct_red_mmx)
 
 EXTN(jconst_idct_red_mmx):
@@ -88,7 +89,7 @@ PD_DESCALE_P1_2 times 2 dd  1 << (DESCALE_P1_2-1)
 PD_DESCALE_P2_2 times 2 dd  1 << (DESCALE_P2_2-1)
 PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 
-        alignz  16
+        alignz  32
 
 ; --------------------------------------------------------------------------
         SECTION SEG_TEXT
@@ -113,7 +114,7 @@ PB_CENTERJSAMP  times 8 db  CENTERJSAMPLE
 %define workspace       wk(0)-DCTSIZE2*SIZEOF_JCOEF
                                         ; JCOEF workspace[DCTSIZE2]
 
-        align   16
+        align   32
         global  EXTN(jsimd_idct_4x4_mmx)
 
 EXTN(jsimd_idct_4x4_mmx):
@@ -501,7 +502,7 @@ EXTN(jsimd_idct_4x4_mmx):
 %define output_buf(b)   (b)+16          ; JSAMPARRAY output_buf
 %define output_col(b)   (b)+20          ; JDIMENSION output_col
 
-        align   16
+        align   32
         global  EXTN(jsimd_idct_2x2_mmx)
 
 EXTN(jsimd_idct_2x2_mmx):
@@ -702,4 +703,4 @@ EXTN(jsimd_idct_2x2_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jidctred-sse2.asm b/simd/i386/jidctred-sse2.asm
new file mode 100644
index 0000000..d0609ac
--- /dev/null
+++ b/simd/i386/jidctred-sse2.asm
@@ -0,0 +1,594 @@
+;
+; jidctred.asm - reduced-size IDCT (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains inverse-DCT routines that produce reduced-size
+; output: either 4x4 or 2x2 pixels from an 8x8 DCT block.
+; The following code is based directly on the IJG's original jidctred.c;
+; see the jidctred.c for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS    13
+%define PASS1_BITS    2
+
+%define DESCALE_P1_4  (CONST_BITS-PASS1_BITS+1)
+%define DESCALE_P2_4  (CONST_BITS+PASS1_BITS+3+1)
+%define DESCALE_P1_2  (CONST_BITS-PASS1_BITS+2)
+%define DESCALE_P2_2  (CONST_BITS+PASS1_BITS+3+2)
+
+%if CONST_BITS == 13
+F_0_211 equ  1730  ; FIX(0.211164243)
+F_0_509 equ  4176  ; FIX(0.509795579)
+F_0_601 equ  4926  ; FIX(0.601344887)
+F_0_720 equ  5906  ; FIX(0.720959822)
+F_0_765 equ  6270  ; FIX(0.765366865)
+F_0_850 equ  6967  ; FIX(0.850430095)
+F_0_899 equ  7373  ; FIX(0.899976223)
+F_1_061 equ  8697  ; FIX(1.061594337)
+F_1_272 equ 10426  ; FIX(1.272758580)
+F_1_451 equ 11893  ; FIX(1.451774981)
+F_1_847 equ 15137  ; FIX(1.847759065)
+F_2_172 equ 17799  ; FIX(2.172734803)
+F_2_562 equ 20995  ; FIX(2.562915447)
+F_3_624 equ 29692  ; FIX(3.624509785)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_211 equ DESCALE( 226735879, 30-CONST_BITS)  ; FIX(0.211164243)
+F_0_509 equ DESCALE( 547388834, 30-CONST_BITS)  ; FIX(0.509795579)
+F_0_601 equ DESCALE( 645689155, 30-CONST_BITS)  ; FIX(0.601344887)
+F_0_720 equ DESCALE( 774124714, 30-CONST_BITS)  ; FIX(0.720959822)
+F_0_765 equ DESCALE( 821806413, 30-CONST_BITS)  ; FIX(0.765366865)
+F_0_850 equ DESCALE( 913142361, 30-CONST_BITS)  ; FIX(0.850430095)
+F_0_899 equ DESCALE( 966342111, 30-CONST_BITS)  ; FIX(0.899976223)
+F_1_061 equ DESCALE(1139878239, 30-CONST_BITS)  ; FIX(1.061594337)
+F_1_272 equ DESCALE(1366614119, 30-CONST_BITS)  ; FIX(1.272758580)
+F_1_451 equ DESCALE(1558831516, 30-CONST_BITS)  ; FIX(1.451774981)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_2_172 equ DESCALE(2332956230, 30-CONST_BITS)  ; FIX(2.172734803)
+F_2_562 equ DESCALE(2751909506, 30-CONST_BITS)  ; FIX(2.562915447)
+F_3_624 equ DESCALE(3891787747, 30-CONST_BITS)  ; FIX(3.624509785)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_idct_red_sse2)
+
+EXTN(jconst_idct_red_sse2):
+
+PW_F184_MF076   times 4  dw  F_1_847,-F_0_765
+PW_F256_F089    times 4  dw  F_2_562, F_0_899
+PW_F106_MF217   times 4  dw  F_1_061,-F_2_172
+PW_MF060_MF050  times 4  dw -F_0_601,-F_0_509
+PW_F145_MF021   times 4  dw  F_1_451,-F_0_211
+PW_F362_MF127   times 4  dw  F_3_624,-F_1_272
+PW_F085_MF072   times 4  dw  F_0_850,-F_0_720
+PD_DESCALE_P1_4 times 4  dd  1 << (DESCALE_P1_4-1)
+PD_DESCALE_P2_4 times 4  dd  1 << (DESCALE_P2_4-1)
+PD_DESCALE_P1_2 times 4  dd  1 << (DESCALE_P1_2-1)
+PD_DESCALE_P2_2 times 4  dd  1 << (DESCALE_P2_2-1)
+PB_CENTERJSAMP  times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Perform dequantization and inverse DCT on one block of coefficients,
+; producing a reduced-size 4x4 output block.
+;
+; GLOBAL(void)
+; jsimd_idct_4x4_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                      JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+%define dct_table(b)   (b)+8            ; void *dct_table
+%define coef_block(b)  (b)+12           ; JCOEFPTR coef_block
+%define output_buf(b)  (b)+16           ; JSAMPARRAY output_buf
+%define output_col(b)  (b)+20           ; JDIMENSION output_col
+
+%define original_ebp   ebp+0
+%define wk(i)          ebp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM         2
+
+    align       32
+    global      EXTN(jsimd_idct_4x4_sse2)
+
+EXTN(jsimd_idct_4x4_sse2):
+    push        ebp
+    mov         eax, esp                     ; eax = original ebp
+    sub         esp, byte 4
+    and         esp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [esp], eax
+    mov         ebp, esp                     ; ebp = aligned ebp
+    lea         esp, [wk(0)]
+    pushpic     ebx
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process columns from input.
+
+;   mov         eax, [original_ebp]
+    mov         edx, POINTER [dct_table(eax)]    ; quantptr
+    mov         esi, JCOEFPTR [coef_block(eax)]  ; inptr
+
+%ifndef NO_ZERO_COLUMN_TEST_4X4_SSE2
+    mov         eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    jnz         short .columnDCT
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    por         xmm0, xmm1
+    packsswb    xmm0, xmm0
+    packsswb    xmm0, xmm0
+    movd        eax, xmm0
+    test        eax, eax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    psllw       xmm0, PASS1_BITS
+
+    movdqa      xmm3, xmm0        ; xmm0=in0=(00 01 02 03 04 05 06 07)
+    punpcklwd   xmm0, xmm0        ; xmm0=(00 00 01 01 02 02 03 03)
+    punpckhwd   xmm3, xmm3        ; xmm3=(04 04 05 05 06 06 07 07)
+
+    pshufd      xmm1, xmm0, 0x50  ; xmm1=[col0 col1]=(00 00 00 00 01 01 01 01)
+    pshufd      xmm0, xmm0, 0xFA  ; xmm0=[col2 col3]=(02 02 02 02 03 03 03 03)
+    pshufd      xmm6, xmm3, 0x50  ; xmm6=[col4 col5]=(04 04 04 04 05 05 05 05)
+    pshufd      xmm3, xmm3, 0xFA  ; xmm3=[col6 col7]=(06 06 06 06 07 07 07 07)
+
+    jmp         near .column_end
+    alignx      16, 7
+%endif
+.columnDCT:
+
+    ; -- Odd part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    movdqa      xmm4, xmm0
+    movdqa      xmm5, xmm0
+    punpcklwd   xmm4, xmm1
+    punpckhwd   xmm5, xmm1
+    movdqa      xmm0, xmm4
+    movdqa      xmm1, xmm5
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_F256_F089)]   ; xmm4=(tmp2L)
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F256_F089)]   ; xmm5=(tmp2H)
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_F106_MF217)]  ; xmm0=(tmp0L)
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_F106_MF217)]  ; xmm1=(tmp0H)
+
+    movdqa      xmm6, xmm2
+    movdqa      xmm7, xmm2
+    punpcklwd   xmm6, xmm3
+    punpckhwd   xmm7, xmm3
+    movdqa      xmm2, xmm6
+    movdqa      xmm3, xmm7
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_MF060_MF050)]  ; xmm6=(tmp2L)
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_MF060_MF050)]  ; xmm7=(tmp2H)
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_F145_MF021)]   ; xmm2=(tmp0L)
+    pmaddwd     xmm3, [GOTOFF(ebx,PW_F145_MF021)]   ; xmm3=(tmp0H)
+
+    paddd       xmm6, xmm4              ; xmm6=tmp2L
+    paddd       xmm7, xmm5              ; xmm7=tmp2H
+    paddd       xmm2, xmm0              ; xmm2=tmp0L
+    paddd       xmm3, xmm1              ; xmm3=tmp0H
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=tmp0L
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=tmp0H
+
+    ; -- Even part
+
+    movdqa      xmm4, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm5, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm0, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm4, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm5, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    pxor        xmm1, xmm1
+    pxor        xmm2, xmm2
+    punpcklwd   xmm1, xmm4               ; xmm1=tmp0L
+    punpckhwd   xmm2, xmm4               ; xmm2=tmp0H
+    psrad       xmm1, (16-CONST_BITS-1)  ; psrad xmm1,16 & pslld xmm1,CONST_BITS+1
+    psrad       xmm2, (16-CONST_BITS-1)  ; psrad xmm2,16 & pslld xmm2,CONST_BITS+1
+
+    movdqa      xmm3, xmm5              ; xmm5=in2=z2
+    punpcklwd   xmm5, xmm0              ; xmm0=in6=z3
+    punpckhwd   xmm3, xmm0
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F184_MF076)]  ; xmm5=tmp2L
+    pmaddwd     xmm3, [GOTOFF(ebx,PW_F184_MF076)]  ; xmm3=tmp2H
+
+    movdqa      xmm4, xmm1
+    movdqa      xmm0, xmm2
+    paddd       xmm1, xmm5              ; xmm1=tmp10L
+    paddd       xmm2, xmm3              ; xmm2=tmp10H
+    psubd       xmm4, xmm5              ; xmm4=tmp12L
+    psubd       xmm0, xmm3              ; xmm0=tmp12H
+
+    ; -- Final output stage
+
+    movdqa      xmm5, xmm1
+    movdqa      xmm3, xmm2
+    paddd       xmm1, xmm6              ; xmm1=data0L
+    paddd       xmm2, xmm7              ; xmm2=data0H
+    psubd       xmm5, xmm6              ; xmm5=data3L
+    psubd       xmm3, xmm7              ; xmm3=data3H
+
+    movdqa      xmm6, [GOTOFF(ebx,PD_DESCALE_P1_4)]  ; xmm6=[PD_DESCALE_P1_4]
+
+    paddd       xmm1, xmm6
+    paddd       xmm2, xmm6
+    psrad       xmm1, DESCALE_P1_4
+    psrad       xmm2, DESCALE_P1_4
+    paddd       xmm5, xmm6
+    paddd       xmm3, xmm6
+    psrad       xmm5, DESCALE_P1_4
+    psrad       xmm3, DESCALE_P1_4
+
+    packssdw    xmm1, xmm2              ; xmm1=data0=(00 01 02 03 04 05 06 07)
+    packssdw    xmm5, xmm3              ; xmm5=data3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp0L
+    movdqa      xmm6, XMMWORD [wk(1)]   ; xmm6=tmp0H
+
+    movdqa      xmm2, xmm4
+    movdqa      xmm3, xmm0
+    paddd       xmm4, xmm7              ; xmm4=data1L
+    paddd       xmm0, xmm6              ; xmm0=data1H
+    psubd       xmm2, xmm7              ; xmm2=data2L
+    psubd       xmm3, xmm6              ; xmm3=data2H
+
+    movdqa      xmm7, [GOTOFF(ebx,PD_DESCALE_P1_4)]  ; xmm7=[PD_DESCALE_P1_4]
+
+    paddd       xmm4, xmm7
+    paddd       xmm0, xmm7
+    psrad       xmm4, DESCALE_P1_4
+    psrad       xmm0, DESCALE_P1_4
+    paddd       xmm2, xmm7
+    paddd       xmm3, xmm7
+    psrad       xmm2, DESCALE_P1_4
+    psrad       xmm3, DESCALE_P1_4
+
+    packssdw    xmm4, xmm0        ; xmm4=data1=(10 11 12 13 14 15 16 17)
+    packssdw    xmm2, xmm3        ; xmm2=data2=(20 21 22 23 24 25 26 27)
+
+    movdqa      xmm6, xmm1        ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm4        ; xmm1=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm6, xmm4        ; xmm6=(04 14 05 15 06 16 07 17)
+    movdqa      xmm7, xmm2        ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm5        ; xmm2=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm7, xmm5        ; xmm7=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm0, xmm1        ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm2        ; xmm1=[col0 col1]=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm0, xmm2        ; xmm0=[col2 col3]=(02 12 22 32 03 13 23 33)
+    movdqa      xmm3, xmm6        ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm7        ; xmm6=[col4 col5]=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm3, xmm7        ; xmm3=[col6 col7]=(06 16 26 36 07 17 27 37)
+.column_end:
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows, store into output array.
+
+    mov         eax, [original_ebp]
+    mov         edi, JSAMPARRAY [output_buf(eax)]  ; (JSAMPROW *)
+    mov         eax, JDIMENSION [output_col(eax)]
+
+    ; -- Even part
+
+    pxor        xmm4, xmm4
+    punpcklwd   xmm4, xmm1               ; xmm4=tmp0
+    psrad       xmm4, (16-CONST_BITS-1)  ; psrad xmm4,16 & pslld xmm4,CONST_BITS+1
+
+    ; -- Odd part
+
+    punpckhwd   xmm1, xmm0
+    punpckhwd   xmm6, xmm3
+    movdqa      xmm5, xmm1
+    movdqa      xmm2, xmm6
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_F256_F089)]    ; xmm1=(tmp2)
+    pmaddwd     xmm6, [GOTOFF(ebx,PW_MF060_MF050)]  ; xmm6=(tmp2)
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F106_MF217)]   ; xmm5=(tmp0)
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_F145_MF021)]   ; xmm2=(tmp0)
+
+    paddd       xmm6, xmm1              ; xmm6=tmp2
+    paddd       xmm2, xmm5              ; xmm2=tmp0
+
+    ; -- Even part
+
+    punpcklwd   xmm0, xmm3
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_F184_MF076)]  ; xmm0=tmp2
+
+    movdqa      xmm7, xmm4
+    paddd       xmm4, xmm0              ; xmm4=tmp10
+    psubd       xmm7, xmm0              ; xmm7=tmp12
+
+    ; -- Final output stage
+
+    movdqa      xmm1, [GOTOFF(ebx,PD_DESCALE_P2_4)]  ; xmm1=[PD_DESCALE_P2_4]
+
+    movdqa      xmm5, xmm4
+    movdqa      xmm3, xmm7
+    paddd       xmm4, xmm6              ; xmm4=data0=(00 10 20 30)
+    paddd       xmm7, xmm2              ; xmm7=data1=(01 11 21 31)
+    psubd       xmm5, xmm6              ; xmm5=data3=(03 13 23 33)
+    psubd       xmm3, xmm2              ; xmm3=data2=(02 12 22 32)
+
+    paddd       xmm4, xmm1
+    paddd       xmm7, xmm1
+    psrad       xmm4, DESCALE_P2_4
+    psrad       xmm7, DESCALE_P2_4
+    paddd       xmm5, xmm1
+    paddd       xmm3, xmm1
+    psrad       xmm5, DESCALE_P2_4
+    psrad       xmm3, DESCALE_P2_4
+
+    packssdw    xmm4, xmm3              ; xmm4=(00 10 20 30 02 12 22 32)
+    packssdw    xmm7, xmm5              ; xmm7=(01 11 21 31 03 13 23 33)
+
+    movdqa      xmm0, xmm4              ; transpose coefficients(phase 1)
+    punpcklwd   xmm4, xmm7              ; xmm4=(00 01 10 11 20 21 30 31)
+    punpckhwd   xmm0, xmm7              ; xmm0=(02 03 12 13 22 23 32 33)
+
+    movdqa      xmm6, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm0              ; xmm4=(00 01 02 03 10 11 12 13)
+    punpckhdq   xmm6, xmm0              ; xmm6=(20 21 22 23 30 31 32 33)
+
+    packsswb    xmm4, xmm6              ; xmm4=(00 01 02 03 10 11 12 13 20 ..)
+    paddb       xmm4, [GOTOFF(ebx,PB_CENTERJSAMP)]
+
+    pshufd      xmm2, xmm4, 0x39        ; xmm2=(10 11 12 13 20 21 22 23 30 ..)
+    pshufd      xmm1, xmm4, 0x4E        ; xmm1=(20 21 22 23 30 31 32 33 00 ..)
+    pshufd      xmm3, xmm4, 0x93        ; xmm3=(30 31 32 33 00 01 02 03 10 ..)
+
+    mov         edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
+    movd        XMM_DWORD [edx+eax*SIZEOF_JSAMPLE], xmm4
+    movd        XMM_DWORD [esi+eax*SIZEOF_JSAMPLE], xmm2
+    mov         edx, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
+    movd        XMM_DWORD [edx+eax*SIZEOF_JSAMPLE], xmm1
+    movd        XMM_DWORD [esi+eax*SIZEOF_JSAMPLE], xmm3
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+    poppic      ebx
+    mov         esp, ebp                ; esp <- aligned ebp
+    pop         esp                     ; esp <- original ebp
+    pop         ebp
+    ret
+
+
+; --------------------------------------------------------------------------
+;
+; Perform dequantization and inverse DCT on one block of coefficients,
+; producing a reduced-size 2x2 output block.
+;
+; GLOBAL(void)
+; jsimd_idct_2x2_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                      JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+%define dct_table(b)   (b)+8            ; void *dct_table
+%define coef_block(b)  (b)+12           ; JCOEFPTR coef_block
+%define output_buf(b)  (b)+16           ; JSAMPARRAY output_buf
+%define output_col(b)  (b)+20           ; JDIMENSION output_col
+
+    align       32
+    global      EXTN(jsimd_idct_2x2_sse2)
+
+EXTN(jsimd_idct_2x2_sse2):
+    push        ebp
+    mov         ebp, esp
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    get_GOT     ebx                     ; get GOT address
+
+    ; ---- Pass 1: process columns from input.
+
+    mov         edx, POINTER [dct_table(ebp)]    ; quantptr
+    mov         esi, JCOEFPTR [coef_block(ebp)]  ; inptr
+
+    ; | input:                  | result:        |
+    ; | 00 01 ** 03 ** 05 ** 07 |                |
+    ; | 10 11 ** 13 ** 15 ** 17 |                |
+    ; | ** ** ** ** ** ** ** ** |                |
+    ; | 30 31 ** 33 ** 35 ** 37 | A0 A1 A3 A5 A7 |
+    ; | ** ** ** ** ** ** ** ** | B0 B1 B3 B5 B7 |
+    ; | 50 51 ** 53 ** 55 ** 57 |                |
+    ; | ** ** ** ** ** ** ** ** |                |
+    ; | 70 71 ** 73 ** 75 ** 77 |                |
+
+    ; -- Odd part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    ; xmm0=(10 11 ** 13 ** 15 ** 17), xmm1=(30 31 ** 33 ** 35 ** 37)
+    ; xmm2=(50 51 ** 53 ** 55 ** 57), xmm3=(70 71 ** 73 ** 75 ** 77)
+
+    pcmpeqd     xmm7, xmm7
+    pslld       xmm7, WORD_BIT          ; xmm7={0x0000 0xFFFF 0x0000 0xFFFF ..}
+
+    movdqa      xmm4, xmm0              ; xmm4=(10 11 ** 13 ** 15 ** 17)
+    movdqa      xmm5, xmm2              ; xmm5=(50 51 ** 53 ** 55 ** 57)
+    punpcklwd   xmm4, xmm1              ; xmm4=(10 30 11 31 ** ** 13 33)
+    punpcklwd   xmm5, xmm3              ; xmm5=(50 70 51 71 ** ** 53 73)
+    pmaddwd     xmm4, [GOTOFF(ebx,PW_F362_MF127)]
+    pmaddwd     xmm5, [GOTOFF(ebx,PW_F085_MF072)]
+
+    psrld       xmm0, WORD_BIT          ; xmm0=(11 -- 13 -- 15 -- 17 --)
+    pand        xmm1, xmm7              ; xmm1=(-- 31 -- 33 -- 35 -- 37)
+    psrld       xmm2, WORD_BIT          ; xmm2=(51 -- 53 -- 55 -- 57 --)
+    pand        xmm3, xmm7              ; xmm3=(-- 71 -- 73 -- 75 -- 77)
+    por         xmm0, xmm1              ; xmm0=(11 31 13 33 15 35 17 37)
+    por         xmm2, xmm3              ; xmm2=(51 71 53 73 55 75 57 77)
+    pmaddwd     xmm0, [GOTOFF(ebx,PW_F362_MF127)]
+    pmaddwd     xmm2, [GOTOFF(ebx,PW_F085_MF072)]
+
+    paddd       xmm4, xmm5              ; xmm4=tmp0[col0 col1 **** col3]
+    paddd       xmm0, xmm2              ; xmm0=tmp0[col1 col3 col5 col7]
+
+    ; -- Even part
+
+    movdqa      xmm6, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
+    pmullw      xmm6, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    ; xmm6=(00 01 ** 03 ** 05 ** 07)
+
+    movdqa      xmm1, xmm6              ; xmm1=(00 01 ** 03 ** 05 ** 07)
+    pslld       xmm6, WORD_BIT          ; xmm6=(-- 00 -- ** -- ** -- **)
+    pand        xmm1, xmm7              ; xmm1=(-- 01 -- 03 -- 05 -- 07)
+    psrad       xmm6, (WORD_BIT-CONST_BITS-2)  ; xmm6=tmp10[col0 **** **** ****]
+    psrad       xmm1, (WORD_BIT-CONST_BITS-2)  ; xmm1=tmp10[col1 col3 col5 col7]
+
+    ; -- Final output stage
+
+    movdqa      xmm3, xmm6
+    movdqa      xmm5, xmm1
+    paddd       xmm6, xmm4      ; xmm6=data0[col0 **** **** ****]=(A0 ** ** **)
+    paddd       xmm1, xmm0      ; xmm1=data0[col1 col3 col5 col7]=(A1 A3 A5 A7)
+    psubd       xmm3, xmm4      ; xmm3=data1[col0 **** **** ****]=(B0 ** ** **)
+    psubd       xmm5, xmm0      ; xmm5=data1[col1 col3 col5 col7]=(B1 B3 B5 B7)
+
+    movdqa      xmm2, [GOTOFF(ebx,PD_DESCALE_P1_2)]  ; xmm2=[PD_DESCALE_P1_2]
+
+    punpckldq   xmm6, xmm3              ; xmm6=(A0 B0 ** **)
+
+    movdqa      xmm7, xmm1
+    punpcklqdq  xmm1, xmm5              ; xmm1=(A1 A3 B1 B3)
+    punpckhqdq  xmm7, xmm5              ; xmm7=(A5 A7 B5 B7)
+
+    paddd       xmm6, xmm2
+    psrad       xmm6, DESCALE_P1_2
+
+    paddd       xmm1, xmm2
+    paddd       xmm7, xmm2
+    psrad       xmm1, DESCALE_P1_2
+    psrad       xmm7, DESCALE_P1_2
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows, store into output array.
+
+    mov         edi, JSAMPARRAY [output_buf(ebp)]  ; (JSAMPROW *)
+    mov         eax, JDIMENSION [output_col(ebp)]
+
+    ; | input:| result:|
+    ; | A0 B0 |        |
+    ; | A1 B1 | C0 C1  |
+    ; | A3 B3 | D0 D1  |
+    ; | A5 B5 |        |
+    ; | A7 B7 |        |
+
+    ; -- Odd part
+
+    packssdw    xmm1, xmm1              ; xmm1=(A1 A3 B1 B3 A1 A3 B1 B3)
+    packssdw    xmm7, xmm7              ; xmm7=(A5 A7 B5 B7 A5 A7 B5 B7)
+    pmaddwd     xmm1, [GOTOFF(ebx,PW_F362_MF127)]
+    pmaddwd     xmm7, [GOTOFF(ebx,PW_F085_MF072)]
+
+    paddd       xmm1, xmm7              ; xmm1=tmp0[row0 row1 row0 row1]
+
+    ; -- Even part
+
+    pslld       xmm6, (CONST_BITS+2)    ; xmm6=tmp10[row0 row1 **** ****]
+
+    ; -- Final output stage
+
+    movdqa      xmm4, xmm6
+    paddd       xmm6, xmm1     ; xmm6=data0[row0 row1 **** ****]=(C0 C1 ** **)
+    psubd       xmm4, xmm1     ; xmm4=data1[row0 row1 **** ****]=(D0 D1 ** **)
+
+    punpckldq   xmm6, xmm4     ; xmm6=(C0 D0 C1 D1)
+
+    paddd       xmm6, [GOTOFF(ebx,PD_DESCALE_P2_2)]
+    psrad       xmm6, DESCALE_P2_2
+
+    packssdw    xmm6, xmm6              ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1)
+    packsswb    xmm6, xmm6              ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1 ..)
+    paddb       xmm6, [GOTOFF(ebx,PB_CENTERJSAMP)]
+
+    pextrw      ebx, xmm6, 0x00         ; ebx=(C0 D0 -- --)
+    pextrw      ecx, xmm6, 0x01         ; ecx=(C1 D1 -- --)
+
+    mov         edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
+    mov         esi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
+    mov         WORD [edx+eax*SIZEOF_JSAMPLE], bx
+    mov         WORD [esi+eax*SIZEOF_JSAMPLE], cx
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jquant-3dn.asm b/simd/i386/jquant-3dn.asm
similarity index 98%
rename from simd/jquant-3dn.asm
rename to simd/i386/jquant-3dn.asm
index 0b4164b..73c02cd 100644
--- a/simd/jquant-3dn.asm
+++ b/simd/i386/jquant-3dn.asm
@@ -2,6 +2,7 @@
 ; jquant.asm - sample data conversion and quantization (3DNow! & MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -33,7 +34,7 @@
 %define start_col       ebp+12          ; JDIMENSION start_col
 %define workspace       ebp+16          ; FAST_FLOAT *workspace
 
-        align   16
+        align   32
         global  EXTN(jsimd_convsamp_float_3dnow)
 
 EXTN(jsimd_convsamp_float_3dnow):
@@ -136,7 +137,7 @@ EXTN(jsimd_convsamp_float_3dnow):
 %define divisors        ebp+12          ; FAST_FLOAT *divisors
 %define workspace       ebp+16          ; FAST_FLOAT *workspace
 
-        align   16
+        align   32
         global  EXTN(jsimd_quantize_float_3dnow)
 
 EXTN(jsimd_quantize_float_3dnow):
@@ -229,4 +230,4 @@ EXTN(jsimd_quantize_float_3dnow):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/jquant-mmx.asm b/simd/i386/jquant-mmx.asm
similarity index 98%
rename from simd/jquant-mmx.asm
rename to simd/i386/jquant-mmx.asm
index aed6071..93dea31 100644
--- a/simd/jquant-mmx.asm
+++ b/simd/i386/jquant-mmx.asm
@@ -2,6 +2,7 @@
 ; jquant.asm - sample data conversion and quantization (MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -33,7 +34,7 @@
 %define start_col       ebp+12          ; JDIMENSION start_col
 %define workspace       ebp+16          ; DCTELEM *workspace
 
-        align   16
+        align   32
         global  EXTN(jsimd_convsamp_mmx)
 
 EXTN(jsimd_convsamp_mmx):
@@ -138,7 +139,7 @@ EXTN(jsimd_convsamp_mmx):
 %define divisors        ebp+12          ; DCTELEM *divisors
 %define workspace       ebp+16          ; DCTELEM *workspace
 
-        align   16
+        align   32
         global  EXTN(jsimd_quantize_mmx)
 
 EXTN(jsimd_quantize_mmx):
@@ -270,4 +271,4 @@ EXTN(jsimd_quantize_mmx):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/jquant-sse.asm b/simd/i386/jquant-sse.asm
similarity index 98%
rename from simd/jquant-sse.asm
rename to simd/i386/jquant-sse.asm
index 1baf88f..d6ab943 100644
--- a/simd/jquant-sse.asm
+++ b/simd/i386/jquant-sse.asm
@@ -2,6 +2,7 @@
 ; jquant.asm - sample data conversion and quantization (SSE & MMX)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -33,7 +34,7 @@
 %define start_col       ebp+12          ; JDIMENSION start_col
 %define workspace       ebp+16          ; FAST_FLOAT *workspace
 
-        align   16
+        align   32
         global  EXTN(jsimd_convsamp_float_sse)
 
 EXTN(jsimd_convsamp_float_sse):
@@ -136,7 +137,7 @@ EXTN(jsimd_convsamp_float_sse):
 %define divisors        ebp+12          ; FAST_FLOAT *divisors
 %define workspace       ebp+16          ; FAST_FLOAT *workspace
 
-        align   16
+        align   32
         global  EXTN(jsimd_quantize_float_sse)
 
 EXTN(jsimd_quantize_float_sse):
@@ -207,4 +208,4 @@ EXTN(jsimd_quantize_float_sse):
 
 ; For some reason, the OS X linker does not honor the request to align the
 ; segment unless we do this.
-        align   16
+        align   32
diff --git a/simd/i386/jquantf-sse2.asm b/simd/i386/jquantf-sse2.asm
new file mode 100644
index 0000000..3c0000e
--- /dev/null
+++ b/simd/i386/jquantf-sse2.asm
@@ -0,0 +1,171 @@
+;
+; jquantf.asm - sample data conversion and quantization (SSE & SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Load data into workspace, applying unsigned->signed conversion
+;
+; GLOBAL(void)
+; jsimd_convsamp_float_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
+;                            FAST_FLOAT *workspace);
+;
+
+%define sample_data  ebp+8              ; JSAMPARRAY sample_data
+%define start_col    ebp+12             ; JDIMENSION start_col
+%define workspace    ebp+16             ; FAST_FLOAT *workspace
+
+    align       32
+    global      EXTN(jsimd_convsamp_float_sse2)
+
+EXTN(jsimd_convsamp_float_sse2):
+    push        ebp
+    mov         ebp, esp
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    pcmpeqw     xmm7, xmm7
+    psllw       xmm7, 7
+    packsswb    xmm7, xmm7              ; xmm7 = PB_CENTERJSAMPLE (0x808080..)
+
+    mov         esi, JSAMPARRAY [sample_data]  ; (JSAMPROW *)
+    mov         eax, JDIMENSION [start_col]
+    mov         edi, POINTER [workspace]       ; (DCTELEM *)
+    mov         ecx, DCTSIZE/2
+    alignx      16, 7
+.convloop:
+    mov         ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+    mov         edx, JSAMPROW [esi+1*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+
+    movq        xmm0, XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE]
+    movq        xmm1, XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE]
+
+    psubb       xmm0, xmm7              ; xmm0=(01234567)
+    psubb       xmm1, xmm7              ; xmm1=(89ABCDEF)
+
+    punpcklbw   xmm0, xmm0              ; xmm0=(*0*1*2*3*4*5*6*7)
+    punpcklbw   xmm1, xmm1              ; xmm1=(*8*9*A*B*C*D*E*F)
+
+    punpcklwd   xmm2, xmm0              ; xmm2=(***0***1***2***3)
+    punpckhwd   xmm0, xmm0              ; xmm0=(***4***5***6***7)
+    punpcklwd   xmm3, xmm1              ; xmm3=(***8***9***A***B)
+    punpckhwd   xmm1, xmm1              ; xmm1=(***C***D***E***F)
+
+    psrad       xmm2, (DWORD_BIT-BYTE_BIT)  ; xmm2=(0123)
+    psrad       xmm0, (DWORD_BIT-BYTE_BIT)  ; xmm0=(4567)
+    cvtdq2ps    xmm2, xmm2                  ; xmm2=(0123)
+    cvtdq2ps    xmm0, xmm0                  ; xmm0=(4567)
+    psrad       xmm3, (DWORD_BIT-BYTE_BIT)  ; xmm3=(89AB)
+    psrad       xmm1, (DWORD_BIT-BYTE_BIT)  ; xmm1=(CDEF)
+    cvtdq2ps    xmm3, xmm3                  ; xmm3=(89AB)
+    cvtdq2ps    xmm1, xmm1                  ; xmm1=(CDEF)
+
+    movaps      XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_FAST_FLOAT)], xmm2
+    movaps      XMMWORD [XMMBLOCK(0,1,edi,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_FAST_FLOAT)], xmm3
+    movaps      XMMWORD [XMMBLOCK(1,1,edi,SIZEOF_FAST_FLOAT)], xmm1
+
+    add         esi, byte 2*SIZEOF_JSAMPROW
+    add         edi, byte 2*DCTSIZE*SIZEOF_FAST_FLOAT
+    dec         ecx
+    jnz         short .convloop
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    pop         ebp
+    ret
+
+
+; --------------------------------------------------------------------------
+;
+; Quantize/descale the coefficients, and store into coef_block
+;
+; GLOBAL(void)
+; jsimd_quantize_float_sse2 (JCOEFPTR coef_block, FAST_FLOAT *divisors,
+;                            FAST_FLOAT *workspace);
+;
+
+%define coef_block  ebp+8               ; JCOEFPTR coef_block
+%define divisors    ebp+12              ; FAST_FLOAT *divisors
+%define workspace   ebp+16              ; FAST_FLOAT *workspace
+
+    align       32
+    global      EXTN(jsimd_quantize_float_sse2)
+
+EXTN(jsimd_quantize_float_sse2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         esi, POINTER [workspace]
+    mov         edx, POINTER [divisors]
+    mov         edi, JCOEFPTR [coef_block]
+    mov         eax, DCTSIZE2/16
+    alignx      16, 7
+.quantloop:
+    movaps      xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(0,1,esi,SIZEOF_FAST_FLOAT)]
+    mulps       xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)]
+    mulps       xmm1, XMMWORD [XMMBLOCK(0,1,edx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(1,1,esi,SIZEOF_FAST_FLOAT)]
+    mulps       xmm2, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)]
+    mulps       xmm3, XMMWORD [XMMBLOCK(1,1,edx,SIZEOF_FAST_FLOAT)]
+
+    cvtps2dq    xmm0, xmm0
+    cvtps2dq    xmm1, xmm1
+    cvtps2dq    xmm2, xmm2
+    cvtps2dq    xmm3, xmm3
+
+    packssdw    xmm0, xmm1
+    packssdw    xmm2, xmm3
+
+    movdqa      XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_JCOEF)], xmm0
+    movdqa      XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_JCOEF)], xmm2
+
+    add         esi, byte 16*SIZEOF_FAST_FLOAT
+    add         edx, byte 16*SIZEOF_FAST_FLOAT
+    add         edi, byte 16*SIZEOF_JCOEF
+    dec         eax
+    jnz         short .quantloop
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jquanti-avx2.asm b/simd/i386/jquanti-avx2.asm
new file mode 100644
index 0000000..0356185
--- /dev/null
+++ b/simd/i386/jquanti-avx2.asm
@@ -0,0 +1,107 @@
+;
+; jquanti.asm - sample quantization (AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+; Copyright (C) 2016, Matthieu Darbois.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+
+; --------------------------------------------------------------------------
+;
+; Quantize/descale the coefficients, and store into coef_block
+;
+; This implementation is based on an algorithm described in
+;   "How to optimize for the Pentium family of microprocessors"
+;   (http://www.agner.org/assem/).
+;
+; GLOBAL(void)
+; jsimd_quantize_avx2 (JCOEFPTR coef_block, DCTELEM *divisors,
+;                      DCTELEM *workspace);
+;
+
+%define RECIPROCAL(m,n,b)  XMMBLOCK(DCTSIZE*0+(m),(n),(b),SIZEOF_DCTELEM)
+%define CORRECTION(m,n,b)  XMMBLOCK(DCTSIZE*1+(m),(n),(b),SIZEOF_DCTELEM)
+%define SCALE(m,n,b)       XMMBLOCK(DCTSIZE*2+(m),(n),(b),SIZEOF_DCTELEM)
+
+%define coef_block  ebp+8               ; JCOEFPTR coef_block
+%define divisors    ebp+12              ; DCTELEM *divisors
+%define workspace   ebp+16              ; DCTELEM *workspace
+
+    align       32
+    global      EXTN(jsimd_quantize_avx2)
+
+EXTN(jsimd_quantize_avx2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         esi, POINTER [workspace]
+    mov         edx, POINTER [divisors]
+    mov         edi, JCOEFPTR [coef_block]
+
+    vmovdqu     ymm4, [XMMBLOCK(0,0,esi,SIZEOF_DCTELEM)]
+    vmovdqu     ymm5, [XMMBLOCK(2,0,esi,SIZEOF_DCTELEM)]
+    vmovdqu     ymm6, [XMMBLOCK(4,0,esi,SIZEOF_DCTELEM)]
+    vmovdqu     ymm7, [XMMBLOCK(6,0,esi,SIZEOF_DCTELEM)]
+    vpabsw      ymm0, ymm4
+    vpabsw      ymm1, ymm5
+    vpabsw      ymm2, ymm6
+    vpabsw      ymm3, ymm7
+
+    vpaddw      ymm0, YMMWORD [CORRECTION(0,0,edx)]  ; correction + roundfactor
+    vpaddw      ymm1, YMMWORD [CORRECTION(2,0,edx)]
+    vpaddw      ymm2, YMMWORD [CORRECTION(4,0,edx)]
+    vpaddw      ymm3, YMMWORD [CORRECTION(6,0,edx)]
+    vpmulhuw    ymm0, YMMWORD [RECIPROCAL(0,0,edx)]  ; reciprocal
+    vpmulhuw    ymm1, YMMWORD [RECIPROCAL(2,0,edx)]
+    vpmulhuw    ymm2, YMMWORD [RECIPROCAL(4,0,edx)]
+    vpmulhuw    ymm3, YMMWORD [RECIPROCAL(6,0,edx)]
+    vpmulhuw    ymm0, YMMWORD [SCALE(0,0,edx)]       ; scale
+    vpmulhuw    ymm1, YMMWORD [SCALE(2,0,edx)]
+    vpmulhuw    ymm2, YMMWORD [SCALE(4,0,edx)]
+    vpmulhuw    ymm3, YMMWORD [SCALE(6,0,edx)]
+
+    vpsignw     ymm0, ymm0, ymm4
+    vpsignw     ymm1, ymm1, ymm5
+    vpsignw     ymm2, ymm2, ymm6
+    vpsignw     ymm3, ymm3, ymm7
+
+    vmovdqu     [XMMBLOCK(0,0,edi,SIZEOF_DCTELEM)], ymm0
+    vmovdqu     [XMMBLOCK(2,0,edi,SIZEOF_DCTELEM)], ymm1
+    vmovdqu     [XMMBLOCK(4,0,edi,SIZEOF_DCTELEM)], ymm2
+    vmovdqu     [XMMBLOCK(6,0,edi,SIZEOF_DCTELEM)], ymm3
+
+    vzeroupper
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/i386/jquanti-sse2.asm b/simd/i386/jquanti-sse2.asm
new file mode 100644
index 0000000..6f42947
--- /dev/null
+++ b/simd/i386/jquanti-sse2.asm
@@ -0,0 +1,200 @@
+;
+; jquanti.asm - sample data conversion and quantization (SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Load data into workspace, applying unsigned->signed conversion
+;
+; GLOBAL(void)
+; jsimd_convsamp_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
+;                      DCTELEM *workspace);
+;
+
+%define sample_data  ebp+8              ; JSAMPARRAY sample_data
+%define start_col    ebp+12             ; JDIMENSION start_col
+%define workspace    ebp+16             ; DCTELEM *workspace
+
+    align       32
+    global      EXTN(jsimd_convsamp_sse2)
+
+EXTN(jsimd_convsamp_sse2):
+    push        ebp
+    mov         ebp, esp
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    pxor        xmm6, xmm6              ; xmm6=(all 0's)
+    pcmpeqw     xmm7, xmm7
+    psllw       xmm7, 7                 ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    mov         esi, JSAMPARRAY [sample_data]  ; (JSAMPROW *)
+    mov         eax, JDIMENSION [start_col]
+    mov         edi, POINTER [workspace]       ; (DCTELEM *)
+    mov         ecx, DCTSIZE/4
+    alignx      16, 7
+.convloop:
+    mov         ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+    mov         edx, JSAMPROW [esi+1*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+
+    movq        xmm0, XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE]  ; xmm0=(01234567)
+    movq        xmm1, XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE]  ; xmm1=(89ABCDEF)
+
+    mov         ebx, JSAMPROW [esi+2*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+    mov         edx, JSAMPROW [esi+3*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+
+    movq        xmm2, XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE]  ; xmm2=(GHIJKLMN)
+    movq        xmm3, XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE]  ; xmm3=(OPQRSTUV)
+
+    punpcklbw   xmm0, xmm6              ; xmm0=(01234567)
+    punpcklbw   xmm1, xmm6              ; xmm1=(89ABCDEF)
+    paddw       xmm0, xmm7
+    paddw       xmm1, xmm7
+    punpcklbw   xmm2, xmm6              ; xmm2=(GHIJKLMN)
+    punpcklbw   xmm3, xmm6              ; xmm3=(OPQRSTUV)
+    paddw       xmm2, xmm7
+    paddw       xmm3, xmm7
+
+    movdqa      XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_DCTELEM)], xmm0
+    movdqa      XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_DCTELEM)], xmm1
+    movdqa      XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_DCTELEM)], xmm2
+    movdqa      XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_DCTELEM)], xmm3
+
+    add         esi, byte 4*SIZEOF_JSAMPROW
+    add         edi, byte 4*DCTSIZE*SIZEOF_DCTELEM
+    dec         ecx
+    jnz         short .convloop
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    pop         ebp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Quantize/descale the coefficients, and store into coef_block
+;
+; This implementation is based on an algorithm described in
+;   "How to optimize for the Pentium family of microprocessors"
+;   (http://www.agner.org/assem/).
+;
+; GLOBAL(void)
+; jsimd_quantize_sse2 (JCOEFPTR coef_block, DCTELEM *divisors,
+;                      DCTELEM *workspace);
+;
+
+%define RECIPROCAL(m,n,b)  XMMBLOCK(DCTSIZE*0+(m),(n),(b),SIZEOF_DCTELEM)
+%define CORRECTION(m,n,b)  XMMBLOCK(DCTSIZE*1+(m),(n),(b),SIZEOF_DCTELEM)
+%define SCALE(m,n,b)       XMMBLOCK(DCTSIZE*2+(m),(n),(b),SIZEOF_DCTELEM)
+
+%define coef_block  ebp+8               ; JCOEFPTR coef_block
+%define divisors    ebp+12              ; DCTELEM *divisors
+%define workspace   ebp+16              ; DCTELEM *workspace
+
+    align       32
+    global      EXTN(jsimd_quantize_sse2)
+
+EXTN(jsimd_quantize_sse2):
+    push        ebp
+    mov         ebp, esp
+;   push        ebx                     ; unused
+;   push        ecx                     ; unused
+;   push        edx                     ; need not be preserved
+    push        esi
+    push        edi
+
+    mov         esi, POINTER [workspace]
+    mov         edx, POINTER [divisors]
+    mov         edi, JCOEFPTR [coef_block]
+    mov         eax, DCTSIZE2/32
+    alignx      16, 7
+.quantloop:
+    movdqa      xmm4, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_DCTELEM)]
+    movdqa      xmm5, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_DCTELEM)]
+    movdqa      xmm6, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_DCTELEM)]
+    movdqa      xmm7, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_DCTELEM)]
+    movdqa      xmm0, xmm4
+    movdqa      xmm1, xmm5
+    movdqa      xmm2, xmm6
+    movdqa      xmm3, xmm7
+    psraw       xmm4, (WORD_BIT-1)
+    psraw       xmm5, (WORD_BIT-1)
+    psraw       xmm6, (WORD_BIT-1)
+    psraw       xmm7, (WORD_BIT-1)
+    pxor        xmm0, xmm4
+    pxor        xmm1, xmm5
+    pxor        xmm2, xmm6
+    pxor        xmm3, xmm7
+    psubw       xmm0, xmm4              ; if (xmm0 < 0) xmm0 = -xmm0;
+    psubw       xmm1, xmm5              ; if (xmm1 < 0) xmm1 = -xmm1;
+    psubw       xmm2, xmm6              ; if (xmm2 < 0) xmm2 = -xmm2;
+    psubw       xmm3, xmm7              ; if (xmm3 < 0) xmm3 = -xmm3;
+
+    paddw       xmm0, XMMWORD [CORRECTION(0,0,edx)]  ; correction + roundfactor
+    paddw       xmm1, XMMWORD [CORRECTION(1,0,edx)]
+    paddw       xmm2, XMMWORD [CORRECTION(2,0,edx)]
+    paddw       xmm3, XMMWORD [CORRECTION(3,0,edx)]
+    pmulhuw     xmm0, XMMWORD [RECIPROCAL(0,0,edx)]  ; reciprocal
+    pmulhuw     xmm1, XMMWORD [RECIPROCAL(1,0,edx)]
+    pmulhuw     xmm2, XMMWORD [RECIPROCAL(2,0,edx)]
+    pmulhuw     xmm3, XMMWORD [RECIPROCAL(3,0,edx)]
+    pmulhuw     xmm0, XMMWORD [SCALE(0,0,edx)]       ; scale
+    pmulhuw     xmm1, XMMWORD [SCALE(1,0,edx)]
+    pmulhuw     xmm2, XMMWORD [SCALE(2,0,edx)]
+    pmulhuw     xmm3, XMMWORD [SCALE(3,0,edx)]
+
+    pxor        xmm0, xmm4
+    pxor        xmm1, xmm5
+    pxor        xmm2, xmm6
+    pxor        xmm3, xmm7
+    psubw       xmm0, xmm4
+    psubw       xmm1, xmm5
+    psubw       xmm2, xmm6
+    psubw       xmm3, xmm7
+    movdqa      XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_DCTELEM)], xmm0
+    movdqa      XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_DCTELEM)], xmm1
+    movdqa      XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_DCTELEM)], xmm2
+    movdqa      XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_DCTELEM)], xmm3
+
+    add         esi, byte 32*SIZEOF_DCTELEM
+    add         edx, byte 32*SIZEOF_DCTELEM
+    add         edi, byte 32*SIZEOF_JCOEF
+    dec         eax
+    jnz         near .quantloop
+
+    pop         edi
+    pop         esi
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; unused
+;   pop         ebx                     ; unused
+    pop         ebp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jsimd_i386.c b/simd/i386/jsimd.c
similarity index 83%
rename from simd/jsimd_i386.c
rename to simd/i386/jsimd.c
index 6da8bd8..4135123 100644
--- a/simd/jsimd_i386.c
+++ b/simd/i386/jsimd.c
@@ -15,12 +15,12 @@
  */
 
 #define JPEG_INTERNALS
-#include "../jinclude.h"
-#include "../jpeglib.h"
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "../jdct.h"
-#include "../jsimddct.h"
-#include "jsimd.h"
 
 /*
  * In the PIC cases, we have no guarantee that constants will keep
@@ -29,6 +29,7 @@
 #define IS_ALIGNED(ptr, order) (((unsigned)ptr & ((1 << order) - 1)) == 0)
 
 #define IS_ALIGNED_SSE(ptr) (IS_ALIGNED(ptr, 4)) /* 16 byte alignment */
+#define IS_ALIGNED_AVX(ptr) (IS_ALIGNED(ptr, 5)) /* 32 byte alignment */
 
 static unsigned int simd_support = ~0;
 static unsigned int simd_huffman = 1;
@@ -61,6 +62,9 @@ init_simd (void)
   env = getenv("JSIMD_FORCESSE2");
   if ((env != NULL) && (strcmp(env, "1") == 0))
     simd_support &= JSIMD_SSE2;
+  env = getenv("JSIMD_FORCEAVX2");
+  if ((env != NULL) && (strcmp(env, "1") == 0))
+    simd_support &= JSIMD_AVX2;
   env = getenv("JSIMD_FORCENONE");
   if ((env != NULL) && (strcmp(env, "1") == 0))
     simd_support = 0;
@@ -82,6 +86,9 @@ jsimd_can_rgb_ycc (void)
   if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_rgb_ycc_convert_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_rgb_ycc_convert_sse2))
     return 1;
@@ -104,6 +111,9 @@ jsimd_can_rgb_gray (void)
   if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_rgb_gray_convert_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_rgb_gray_convert_sse2))
     return 1;
@@ -126,6 +136,9 @@ jsimd_can_ycc_rgb (void)
   if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_ycc_rgb_convert_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_ycc_rgb_convert_sse2))
     return 1;
@@ -146,46 +159,55 @@ jsimd_rgb_ycc_convert (j_compress_ptr cinfo,
                        JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
                        JDIMENSION output_row, int num_rows)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*sse2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*mmxfct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
   switch(cinfo->in_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_extrgb_ycc_convert_avx2;
       sse2fct=jsimd_extrgb_ycc_convert_sse2;
       mmxfct=jsimd_extrgb_ycc_convert_mmx;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_extrgbx_ycc_convert_avx2;
       sse2fct=jsimd_extrgbx_ycc_convert_sse2;
       mmxfct=jsimd_extrgbx_ycc_convert_mmx;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_extbgr_ycc_convert_avx2;
       sse2fct=jsimd_extbgr_ycc_convert_sse2;
       mmxfct=jsimd_extbgr_ycc_convert_mmx;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_extbgrx_ycc_convert_avx2;
       sse2fct=jsimd_extbgrx_ycc_convert_sse2;
       mmxfct=jsimd_extbgrx_ycc_convert_mmx;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_extxbgr_ycc_convert_avx2;
       sse2fct=jsimd_extxbgr_ycc_convert_sse2;
       mmxfct=jsimd_extxbgr_ycc_convert_mmx;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_extxrgb_ycc_convert_avx2;
       sse2fct=jsimd_extxrgb_ycc_convert_sse2;
       mmxfct=jsimd_extxrgb_ycc_convert_mmx;
       break;
     default:
+      avx2fct=jsimd_rgb_ycc_convert_avx2;
       sse2fct=jsimd_rgb_ycc_convert_sse2;
       mmxfct=jsimd_rgb_ycc_convert_mmx;
       break;
   }
 
-  if ((simd_support & JSIMD_SSE2) &&
-      IS_ALIGNED_SSE(jconst_rgb_ycc_convert_sse2))
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+  else if (simd_support & JSIMD_SSE2)
     sse2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
   else if (simd_support & JSIMD_MMX)
     mmxfct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
@@ -196,46 +218,55 @@ jsimd_rgb_gray_convert (j_compress_ptr cinfo,
                         JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
                         JDIMENSION output_row, int num_rows)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*sse2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*mmxfct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
   switch(cinfo->in_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_extrgb_gray_convert_avx2;
       sse2fct=jsimd_extrgb_gray_convert_sse2;
       mmxfct=jsimd_extrgb_gray_convert_mmx;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_extrgbx_gray_convert_avx2;
       sse2fct=jsimd_extrgbx_gray_convert_sse2;
       mmxfct=jsimd_extrgbx_gray_convert_mmx;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_extbgr_gray_convert_avx2;
       sse2fct=jsimd_extbgr_gray_convert_sse2;
       mmxfct=jsimd_extbgr_gray_convert_mmx;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_extbgrx_gray_convert_avx2;
       sse2fct=jsimd_extbgrx_gray_convert_sse2;
       mmxfct=jsimd_extbgrx_gray_convert_mmx;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_extxbgr_gray_convert_avx2;
       sse2fct=jsimd_extxbgr_gray_convert_sse2;
       mmxfct=jsimd_extxbgr_gray_convert_mmx;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_extxrgb_gray_convert_avx2;
       sse2fct=jsimd_extxrgb_gray_convert_sse2;
       mmxfct=jsimd_extxrgb_gray_convert_mmx;
       break;
     default:
+      avx2fct=jsimd_rgb_gray_convert_avx2;
       sse2fct=jsimd_rgb_gray_convert_sse2;
       mmxfct=jsimd_rgb_gray_convert_mmx;
       break;
   }
 
-  if ((simd_support & JSIMD_SSE2) &&
-      IS_ALIGNED_SSE(jconst_rgb_gray_convert_sse2))
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+  else if (simd_support & JSIMD_SSE2)
     sse2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
   else if (simd_support & JSIMD_MMX)
     mmxfct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
@@ -246,46 +277,55 @@ jsimd_ycc_rgb_convert (j_decompress_ptr cinfo,
                        JSAMPIMAGE input_buf, JDIMENSION input_row,
                        JSAMPARRAY output_buf, int num_rows)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
   void (*sse2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
   void (*mmxfct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
 
   switch(cinfo->out_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_ycc_extrgb_convert_avx2;
       sse2fct=jsimd_ycc_extrgb_convert_sse2;
       mmxfct=jsimd_ycc_extrgb_convert_mmx;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_ycc_extrgbx_convert_avx2;
       sse2fct=jsimd_ycc_extrgbx_convert_sse2;
       mmxfct=jsimd_ycc_extrgbx_convert_mmx;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_ycc_extbgr_convert_avx2;
       sse2fct=jsimd_ycc_extbgr_convert_sse2;
       mmxfct=jsimd_ycc_extbgr_convert_mmx;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_ycc_extbgrx_convert_avx2;
       sse2fct=jsimd_ycc_extbgrx_convert_sse2;
       mmxfct=jsimd_ycc_extbgrx_convert_mmx;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_ycc_extxbgr_convert_avx2;
       sse2fct=jsimd_ycc_extxbgr_convert_sse2;
       mmxfct=jsimd_ycc_extxbgr_convert_mmx;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_ycc_extxrgb_convert_avx2;
       sse2fct=jsimd_ycc_extxrgb_convert_sse2;
       mmxfct=jsimd_ycc_extxrgb_convert_mmx;
       break;
     default:
+      avx2fct=jsimd_ycc_rgb_convert_avx2;
       sse2fct=jsimd_ycc_rgb_convert_sse2;
       mmxfct=jsimd_ycc_rgb_convert_mmx;
       break;
   }
 
-  if ((simd_support & JSIMD_SSE2) &&
-      IS_ALIGNED_SSE(jconst_ycc_rgb_convert_sse2))
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->output_width, input_buf, input_row, output_buf, num_rows);
+  else if (simd_support & JSIMD_SSE2)
     sse2fct(cinfo->output_width, input_buf, input_row, output_buf, num_rows);
   else if (simd_support & JSIMD_MMX)
     mmxfct(cinfo->output_width, input_buf, input_row, output_buf, num_rows);
@@ -309,6 +349,8 @@ jsimd_can_h2v2_downsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
   if (simd_support & JSIMD_MMX)
@@ -328,6 +370,8 @@ jsimd_can_h2v1_downsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
   if (simd_support & JSIMD_MMX)
@@ -340,7 +384,12 @@ GLOBAL(void)
 jsimd_h2v2_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
                        JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
-  if (simd_support & JSIMD_SSE2)
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v2_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
+                               compptr->v_samp_factor,
+                               compptr->width_in_blocks, input_data,
+                               output_data);
+  else if (simd_support & JSIMD_SSE2)
     jsimd_h2v2_downsample_sse2(cinfo->image_width, cinfo->max_v_samp_factor,
                                compptr->v_samp_factor,
                                compptr->width_in_blocks, input_data,
@@ -355,7 +404,12 @@ GLOBAL(void)
 jsimd_h2v1_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
                        JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
-  if (simd_support & JSIMD_SSE2)
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v1_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
+                               compptr->v_samp_factor,
+                               compptr->width_in_blocks, input_data,
+                               output_data);
+  else if (simd_support & JSIMD_SSE2)
     jsimd_h2v1_downsample_sse2(cinfo->image_width, cinfo->max_v_samp_factor,
                                compptr->v_samp_factor,
                                compptr->width_in_blocks, input_data,
@@ -377,6 +431,8 @@ jsimd_can_h2v2_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
   if (simd_support & JSIMD_MMX)
@@ -396,6 +452,8 @@ jsimd_can_h2v1_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
   if (simd_support & JSIMD_MMX)
@@ -410,7 +468,10 @@ jsimd_h2v2_upsample (j_decompress_ptr cinfo,
                      JSAMPARRAY input_data,
                      JSAMPARRAY *output_data_ptr)
 {
-  if (simd_support & JSIMD_SSE2)
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v2_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
+                             input_data, output_data_ptr);
+  else if (simd_support & JSIMD_SSE2)
     jsimd_h2v2_upsample_sse2(cinfo->max_v_samp_factor, cinfo->output_width,
                              input_data, output_data_ptr);
   else if (simd_support & JSIMD_MMX)
@@ -424,7 +485,10 @@ jsimd_h2v1_upsample (j_decompress_ptr cinfo,
                      JSAMPARRAY input_data,
                      JSAMPARRAY *output_data_ptr)
 {
-  if (simd_support & JSIMD_SSE2)
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v1_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
+                             input_data, output_data_ptr);
+  else if (simd_support & JSIMD_SSE2)
     jsimd_h2v1_upsample_sse2(cinfo->max_v_samp_factor, cinfo->output_width,
                              input_data, output_data_ptr);
   else if (simd_support & JSIMD_MMX)
@@ -443,6 +507,9 @@ jsimd_can_h2v2_fancy_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_fancy_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
     return 1;
@@ -463,6 +530,9 @@ jsimd_can_h2v1_fancy_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_fancy_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
     return 1;
@@ -478,8 +548,11 @@ jsimd_h2v2_fancy_upsample (j_decompress_ptr cinfo,
                            JSAMPARRAY input_data,
                            JSAMPARRAY *output_data_ptr)
 {
-  if ((simd_support & JSIMD_SSE2) &&
-      IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v2_fancy_upsample_avx2(cinfo->max_v_samp_factor,
+                                   compptr->downsampled_width, input_data,
+                                   output_data_ptr);
+  else if (simd_support & JSIMD_SSE2)
     jsimd_h2v2_fancy_upsample_sse2(cinfo->max_v_samp_factor,
                                    compptr->downsampled_width, input_data,
                                    output_data_ptr);
@@ -495,8 +568,11 @@ jsimd_h2v1_fancy_upsample (j_decompress_ptr cinfo,
                            JSAMPARRAY input_data,
                            JSAMPARRAY *output_data_ptr)
 {
-  if ((simd_support & JSIMD_SSE2) &&
-      IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v1_fancy_upsample_avx2(cinfo->max_v_samp_factor,
+                                   compptr->downsampled_width, input_data,
+                                   output_data_ptr);
+  else if (simd_support & JSIMD_SSE2)
     jsimd_h2v1_fancy_upsample_sse2(cinfo->max_v_samp_factor,
                                    compptr->downsampled_width, input_data,
                                    output_data_ptr);
@@ -517,6 +593,9 @@ jsimd_can_h2v2_merged_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_merged_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_merged_upsample_sse2))
     return 1;
@@ -537,6 +616,9 @@ jsimd_can_h2v1_merged_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_merged_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_merged_upsample_sse2))
     return 1;
@@ -552,46 +634,55 @@ jsimd_h2v2_merged_upsample (j_decompress_ptr cinfo,
                             JDIMENSION in_row_group_ctr,
                             JSAMPARRAY output_buf)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*sse2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*mmxfct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
   switch(cinfo->out_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_h2v2_extrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extrgb_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extrgb_merged_upsample_mmx;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_h2v2_extrgbx_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extrgbx_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extrgbx_merged_upsample_mmx;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_h2v2_extbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extbgr_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_h2v2_extbgrx_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extbgrx_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extbgrx_merged_upsample_mmx;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_h2v2_extxbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extxbgr_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extxbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_h2v2_extxrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extxrgb_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_extxrgb_merged_upsample_mmx;
       break;
     default:
+      avx2fct=jsimd_h2v2_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_merged_upsample_sse2;
       mmxfct=jsimd_h2v2_merged_upsample_mmx;
       break;
   }
 
-  if ((simd_support & JSIMD_SSE2) &&
-      IS_ALIGNED_SSE(jconst_merged_upsample_sse2))
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+  else if (simd_support & JSIMD_SSE2)
     sse2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
   else if (simd_support & JSIMD_MMX)
     mmxfct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
@@ -603,46 +694,55 @@ jsimd_h2v1_merged_upsample (j_decompress_ptr cinfo,
                             JDIMENSION in_row_group_ctr,
                             JSAMPARRAY output_buf)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*sse2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*mmxfct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
   switch(cinfo->out_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_h2v1_extrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extrgb_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extrgb_merged_upsample_mmx;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_h2v1_extrgbx_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extrgbx_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extrgbx_merged_upsample_mmx;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_h2v1_extbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extbgr_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_h2v1_extbgrx_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extbgrx_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extbgrx_merged_upsample_mmx;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_h2v1_extxbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extxbgr_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extxbgr_merged_upsample_mmx;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_h2v1_extxrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extxrgb_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_extxrgb_merged_upsample_mmx;
       break;
     default:
+      avx2fct=jsimd_h2v1_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_merged_upsample_sse2;
       mmxfct=jsimd_h2v1_merged_upsample_mmx;
       break;
   }
 
-  if ((simd_support & JSIMD_SSE2) &&
-      IS_ALIGNED_SSE(jconst_merged_upsample_sse2))
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+  else if (simd_support & JSIMD_SSE2)
     sse2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
   else if (simd_support & JSIMD_MMX)
     mmxfct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
@@ -815,6 +915,8 @@ jsimd_can_quantize (void)
   if (sizeof(DCTELEM) != 2)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
   if (simd_support & JSIMD_MMX)
@@ -850,7 +952,9 @@ GLOBAL(void)
 jsimd_quantize (JCOEFPTR coef_block, DCTELEM *divisors,
                 DCTELEM *workspace)
 {
-  if (simd_support & JSIMD_SSE2)
+  if (simd_support & JSIMD_AVX2)
+    jsimd_quantize_avx2(coef_block, divisors, workspace);
+  else if (simd_support & JSIMD_SSE2)
     jsimd_quantize_sse2(coef_block, divisors, workspace);
   else if (simd_support & JSIMD_MMX)
     jsimd_quantize_mmx(coef_block, divisors, workspace);
diff --git a/simd/i386/jsimdcpu.asm b/simd/i386/jsimdcpu.asm
new file mode 100644
index 0000000..827aefe
--- /dev/null
+++ b/simd/i386/jsimdcpu.asm
@@ -0,0 +1,131 @@
+;
+; jsimdcpu.asm - SIMD instruction support check
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        32
+;
+; Check if the CPU supports SIMD instructions
+;
+; GLOBAL(unsigned int)
+; jpeg_simd_cpu_support (void)
+;
+
+    align       32
+    global      EXTN(jpeg_simd_cpu_support)
+
+EXTN(jpeg_simd_cpu_support):
+    push        ebx
+;   push        ecx                     ; need not be preserved
+;   push        edx                     ; need not be preserved
+;   push        esi                     ; unused
+    push        edi
+
+    xor         edi, edi                ; simd support flag
+
+    pushfd
+    pop         eax
+    mov         edx, eax
+    xor         eax, 1<<21              ; flip ID bit in EFLAGS
+    push        eax
+    popfd
+    pushfd
+    pop         eax
+    xor         eax, edx
+    jz          near .return            ; CPUID is not supported
+
+    ; Check for MMX instruction support
+    xor         eax, eax
+    cpuid
+    test        eax, eax
+    jz          near .return
+
+    xor         eax, eax
+    inc         eax
+    cpuid
+    mov         eax, edx                ; eax = Standard feature flags
+
+    test        eax, 1<<23              ; bit23:MMX
+    jz          short .no_mmx
+    or          edi, byte JSIMD_MMX
+.no_mmx:
+    test        eax, 1<<25              ; bit25:SSE
+    jz          short .no_sse
+    or          edi, byte JSIMD_SSE
+.no_sse:
+    test        eax, 1<<26              ; bit26:SSE2
+    jz          short .no_sse2
+    or          edi, byte JSIMD_SSE2
+.no_sse2:
+
+    ; Check for AVX2 instruction support
+    mov         eax, 7
+    xor         ecx, ecx
+    cpuid
+    mov         eax, ebx
+    test        eax, 1<<5               ; bit5:AVX2
+    jz          short .no_avx2
+
+    ; Check for AVX2 O/S support
+    mov         eax, 1
+    xor         ecx, ecx
+    cpuid
+    test        ecx, 1<<27
+    jz          short .no_avx2          ; O/S does not support XSAVE
+    test        ecx, 1<<28
+    jz          short .no_avx2          ; CPU does not support AVX2
+
+    xor         ecx, ecx
+    xgetbv
+    test        eax, 6                  ; O/S does not manage XMM/YMM state
+                                        ; using XSAVE
+    jz          short .no_avx2
+
+    or          edi, JSIMD_AVX2
+.no_avx2:
+
+    ; Check for 3DNow! instruction support
+    mov         eax, 0x80000000
+    cpuid
+    cmp         eax, 0x80000000
+    jbe         short .return
+
+    mov         eax, 0x80000001
+    cpuid
+    mov         eax, edx                ; eax = Extended feature flags
+
+    test        eax, 1<<31              ; bit31:3DNow!(vendor independent)
+    jz          short .no_3dnow
+    or          edi, byte JSIMD_3DNOW
+.no_3dnow:
+
+.return:
+    mov         eax, edi
+
+    pop         edi
+;   pop         esi                     ; unused
+;   pop         edx                     ; need not be preserved
+;   pop         ecx                     ; need not be preserved
+    pop         ebx
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jccolext-sse2-64.asm b/simd/jccolext-sse2-64.asm
deleted file mode 100644
index 8e4642d..0000000
--- a/simd/jccolext-sse2-64.asm
+++ /dev/null
@@ -1,486 +0,0 @@
-;
-; jccolext.asm - colorspace conversion (64-bit SSE2)
-;
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Convert some rows of samples to the output colorspace.
-;
-; GLOBAL(void)
-; jsimd_rgb_ycc_convert_sse2 (JDIMENSION img_width,
-;                             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
-;                             JDIMENSION output_row, int num_rows);
-;
-
-; r10 = JDIMENSION img_width
-; r11 = JSAMPARRAY input_buf
-; r12 = JSAMPIMAGE output_buf
-; r13 = JDIMENSION output_row
-; r14 = int num_rows
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          8
-
-        align   16
-
-        global  EXTN(jsimd_rgb_ycc_convert_sse2)
-
-EXTN(jsimd_rgb_ycc_convert_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-        push    rbx
-
-        mov     ecx, r10d
-        test    rcx,rcx
-        jz      near .return
-
-        push    rcx
-
-        mov rsi, r12
-        mov ecx, r13d
-        mov     rdi, JSAMPARRAY [rsi+0*SIZEOF_JSAMPARRAY]
-        mov     rbx, JSAMPARRAY [rsi+1*SIZEOF_JSAMPARRAY]
-        mov     rdx, JSAMPARRAY [rsi+2*SIZEOF_JSAMPARRAY]
-        lea     rdi, [rdi+rcx*SIZEOF_JSAMPROW]
-        lea     rbx, [rbx+rcx*SIZEOF_JSAMPROW]
-        lea     rdx, [rdx+rcx*SIZEOF_JSAMPROW]
-
-        pop     rcx
-
-        mov rsi, r11
-        mov     eax, r14d
-        test    rax,rax
-        jle     near .return
-.rowloop:
-        push    rdx
-        push    rbx
-        push    rdi
-        push    rsi
-        push    rcx                     ; col
-
-        mov     rsi, JSAMPROW [rsi]     ; inptr
-        mov     rdi, JSAMPROW [rdi]     ; outptr0
-        mov     rbx, JSAMPROW [rbx]     ; outptr1
-        mov     rdx, JSAMPROW [rdx]     ; outptr2
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-.column_ld1:
-        push    rax
-        push    rdx
-        lea     rcx,[rcx+rcx*2]         ; imul ecx,RGB_PIXELSIZE
-        test    cl, SIZEOF_BYTE
-        jz      short .column_ld2
-        sub     rcx, byte SIZEOF_BYTE
-        movzx   rax, BYTE [rsi+rcx]
-.column_ld2:
-        test    cl, SIZEOF_WORD
-        jz      short .column_ld4
-        sub     rcx, byte SIZEOF_WORD
-        movzx   rdx, WORD [rsi+rcx]
-        shl     rax, WORD_BIT
-        or      rax,rdx
-.column_ld4:
-        movd    xmmA,eax
-        pop     rdx
-        pop     rax
-        test    cl, SIZEOF_DWORD
-        jz      short .column_ld8
-        sub     rcx, byte SIZEOF_DWORD
-        movd    xmmF, XMM_DWORD [rsi+rcx]
-        pslldq  xmmA, SIZEOF_DWORD
-        por     xmmA,xmmF
-.column_ld8:
-        test    cl, SIZEOF_MMWORD
-        jz      short .column_ld16
-        sub     rcx, byte SIZEOF_MMWORD
-        movq    xmmB, XMM_MMWORD [rsi+rcx]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmB
-.column_ld16:
-        test    cl, SIZEOF_XMMWORD
-        jz      short .column_ld32
-        movdqa  xmmF,xmmA
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        mov     rcx, SIZEOF_XMMWORD
-        jmp     short .rgb_ycc_cnv
-.column_ld32:
-        test    cl, 2*SIZEOF_XMMWORD
-        mov     rcx, SIZEOF_XMMWORD
-        jz      short .rgb_ycc_cnv
-        movdqa  xmmB,xmmA
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_ycc_cnv
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        movdqu  xmmB, XMMWORD [rsi+2*SIZEOF_XMMWORD]
-
-.rgb_ycc_cnv:
-        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        movdqa    xmmG,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
-        psrldq    xmmG,8        ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmF     ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
-        pslldq    xmmF,8        ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
-
-        punpcklbw xmmG,xmmB     ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
-        punpckhbw xmmF,xmmB     ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
-
-        movdqa    xmmD,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
-        psrldq    xmmD,8        ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmG     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
-        pslldq    xmmG,8        ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
-
-        punpcklbw xmmD,xmmF     ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
-        punpckhbw xmmG,xmmF     ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
-
-        movdqa    xmmE,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
-        psrldq    xmmE,8        ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        pslldq    xmmD,8        ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
-
-        punpcklbw xmmE,xmmG     ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmG     ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
-
-        pxor      xmmH,xmmH
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmH     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmH     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmB,xmmE
-        punpcklbw xmmE,xmmH     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmB,xmmH     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-
-        movdqa    xmmF,xmmD
-        punpcklbw xmmD,xmmH     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmF,xmmH     ; xmmF=(21 23 25 27 29 2B 2D 2F)
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-.column_ld1:
-        test    cl, SIZEOF_XMMWORD/16
-        jz      short .column_ld2
-        sub     rcx, byte SIZEOF_XMMWORD/16
-        movd    xmmA, XMM_DWORD [rsi+rcx*RGB_PIXELSIZE]
-.column_ld2:
-        test    cl, SIZEOF_XMMWORD/8
-        jz      short .column_ld4
-        sub     rcx, byte SIZEOF_XMMWORD/8
-        movq    xmmE, XMM_MMWORD [rsi+rcx*RGB_PIXELSIZE]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmE
-.column_ld4:
-        test    cl, SIZEOF_XMMWORD/4
-        jz      short .column_ld8
-        sub     rcx, byte SIZEOF_XMMWORD/4
-        movdqa  xmmE,xmmA
-        movdqu  xmmA, XMMWORD [rsi+rcx*RGB_PIXELSIZE]
-.column_ld8:
-        test    cl, SIZEOF_XMMWORD/2
-        mov     rcx, SIZEOF_XMMWORD
-        jz      short .rgb_ycc_cnv
-        movdqa  xmmF,xmmA
-        movdqa  xmmH,xmmE
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_ycc_cnv
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [rsi+2*SIZEOF_XMMWORD]
-        movdqu  xmmH, XMMWORD [rsi+3*SIZEOF_XMMWORD]
-
-.rgb_ycc_cnv:
-        ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpcklbw xmmA,xmmE     ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
-        punpckhbw xmmD,xmmE     ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
-
-        movdqa    xmmC,xmmF
-        punpcklbw xmmF,xmmH     ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
-        punpckhbw xmmC,xmmH     ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
-
-        movdqa    xmmB,xmmA
-        punpcklwd xmmA,xmmF     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
-        punpckhwd xmmB,xmmF     ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
-
-        movdqa    xmmG,xmmD
-        punpcklwd xmmD,xmmC     ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
-        punpckhwd xmmG,xmmC     ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
-
-        movdqa    xmmE,xmmA
-        punpcklbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        punpckhbw xmmE,xmmD     ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
-
-        movdqa    xmmH,xmmB
-        punpcklbw xmmB,xmmG     ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmH,xmmG     ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
-
-        pxor      xmmF,xmmF
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmF     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmF     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmD,xmmB
-        punpcklbw xmmB,xmmF     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmF     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-
-        movdqa    xmmG,xmmE
-        punpcklbw xmmE,xmmF     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmG,xmmF     ; xmmG=(30 32 34 36 38 3A 3C 3E)
-
-        punpcklbw xmmF,xmmH
-        punpckhbw xmmH,xmmH
-        psrlw     xmmF,BYTE_BIT ; xmmF=(21 23 25 27 29 2B 2D 2F)
-        psrlw     xmmH,BYTE_BIT ; xmmH=(31 33 35 37 39 3B 3D 3F)
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-        ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
-        ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
-
-        ; (Original)
-        ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
-        ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
-        ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
-        ;
-        ; (This implementation)
-        ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
-        ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
-        ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
-
-        movdqa    XMMWORD [wk(0)], xmm0 ; wk(0)=RE
-        movdqa    XMMWORD [wk(1)], xmm1 ; wk(1)=RO
-        movdqa    XMMWORD [wk(2)], xmm4 ; wk(2)=BE
-        movdqa    XMMWORD [wk(3)], xmm5 ; wk(3)=BO
-
-        movdqa    xmm6,xmm1
-        punpcklwd xmm1,xmm3
-        punpckhwd xmm6,xmm3
-        movdqa    xmm7,xmm1
-        movdqa    xmm4,xmm6
-        pmaddwd   xmm1,[rel PW_F0299_F0337] ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
-        pmaddwd   xmm6,[rel PW_F0299_F0337] ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
-        pmaddwd   xmm7,[rel PW_MF016_MF033] ; xmm7=ROL*-FIX(0.168)+GOL*-FIX(0.331)
-        pmaddwd   xmm4,[rel PW_MF016_MF033] ; xmm4=ROH*-FIX(0.168)+GOH*-FIX(0.331)
-
-        movdqa    XMMWORD [wk(4)], xmm1 ; wk(4)=ROL*FIX(0.299)+GOL*FIX(0.337)
-        movdqa    XMMWORD [wk(5)], xmm6 ; wk(5)=ROH*FIX(0.299)+GOH*FIX(0.337)
-
-        pxor      xmm1,xmm1
-        pxor      xmm6,xmm6
-        punpcklwd xmm1,xmm5             ; xmm1=BOL
-        punpckhwd xmm6,xmm5             ; xmm6=BOH
-        psrld     xmm1,1                ; xmm1=BOL*FIX(0.500)
-        psrld     xmm6,1                ; xmm6=BOH*FIX(0.500)
-
-        movdqa    xmm5,[rel PD_ONEHALFM1_CJ] ; xmm5=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm7,xmm1
-        paddd     xmm4,xmm6
-        paddd     xmm7,xmm5
-        paddd     xmm4,xmm5
-        psrld     xmm7,SCALEBITS        ; xmm7=CbOL
-        psrld     xmm4,SCALEBITS        ; xmm4=CbOH
-        packssdw  xmm7,xmm4             ; xmm7=CbO
-
-        movdqa    xmm1, XMMWORD [wk(2)] ; xmm1=BE
-
-        movdqa    xmm6,xmm0
-        punpcklwd xmm0,xmm2
-        punpckhwd xmm6,xmm2
-        movdqa    xmm5,xmm0
-        movdqa    xmm4,xmm6
-        pmaddwd   xmm0,[rel PW_F0299_F0337] ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
-        pmaddwd   xmm6,[rel PW_F0299_F0337] ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
-        pmaddwd   xmm5,[rel PW_MF016_MF033] ; xmm5=REL*-FIX(0.168)+GEL*-FIX(0.331)
-        pmaddwd   xmm4,[rel PW_MF016_MF033] ; xmm4=REH*-FIX(0.168)+GEH*-FIX(0.331)
-
-        movdqa    XMMWORD [wk(6)], xmm0 ; wk(6)=REL*FIX(0.299)+GEL*FIX(0.337)
-        movdqa    XMMWORD [wk(7)], xmm6 ; wk(7)=REH*FIX(0.299)+GEH*FIX(0.337)
-
-        pxor      xmm0,xmm0
-        pxor      xmm6,xmm6
-        punpcklwd xmm0,xmm1             ; xmm0=BEL
-        punpckhwd xmm6,xmm1             ; xmm6=BEH
-        psrld     xmm0,1                ; xmm0=BEL*FIX(0.500)
-        psrld     xmm6,1                ; xmm6=BEH*FIX(0.500)
-
-        movdqa    xmm1,[rel PD_ONEHALFM1_CJ] ; xmm1=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm5,xmm0
-        paddd     xmm4,xmm6
-        paddd     xmm5,xmm1
-        paddd     xmm4,xmm1
-        psrld     xmm5,SCALEBITS        ; xmm5=CbEL
-        psrld     xmm4,SCALEBITS        ; xmm4=CbEH
-        packssdw  xmm5,xmm4             ; xmm5=CbE
-
-        psllw     xmm7,BYTE_BIT
-        por       xmm5,xmm7             ; xmm5=Cb
-        movdqa    XMMWORD [rbx], xmm5   ; Save Cb
-
-        movdqa    xmm0, XMMWORD [wk(3)] ; xmm0=BO
-        movdqa    xmm6, XMMWORD [wk(2)] ; xmm6=BE
-        movdqa    xmm1, XMMWORD [wk(1)] ; xmm1=RO
-
-        movdqa    xmm4,xmm0
-        punpcklwd xmm0,xmm3
-        punpckhwd xmm4,xmm3
-        movdqa    xmm7,xmm0
-        movdqa    xmm5,xmm4
-        pmaddwd   xmm0,[rel PW_F0114_F0250] ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
-        pmaddwd   xmm4,[rel PW_F0114_F0250] ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
-        pmaddwd   xmm7,[rel PW_MF008_MF041] ; xmm7=BOL*-FIX(0.081)+GOL*-FIX(0.418)
-        pmaddwd   xmm5,[rel PW_MF008_MF041] ; xmm5=BOH*-FIX(0.081)+GOH*-FIX(0.418)
-
-        movdqa    xmm3,[rel PD_ONEHALF] ; xmm3=[PD_ONEHALF]
-
-        paddd     xmm0, XMMWORD [wk(4)]
-        paddd     xmm4, XMMWORD [wk(5)]
-        paddd     xmm0,xmm3
-        paddd     xmm4,xmm3
-        psrld     xmm0,SCALEBITS        ; xmm0=YOL
-        psrld     xmm4,SCALEBITS        ; xmm4=YOH
-        packssdw  xmm0,xmm4             ; xmm0=YO
-
-        pxor      xmm3,xmm3
-        pxor      xmm4,xmm4
-        punpcklwd xmm3,xmm1             ; xmm3=ROL
-        punpckhwd xmm4,xmm1             ; xmm4=ROH
-        psrld     xmm3,1                ; xmm3=ROL*FIX(0.500)
-        psrld     xmm4,1                ; xmm4=ROH*FIX(0.500)
-
-        movdqa    xmm1,[rel PD_ONEHALFM1_CJ] ; xmm1=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm7,xmm3
-        paddd     xmm5,xmm4
-        paddd     xmm7,xmm1
-        paddd     xmm5,xmm1
-        psrld     xmm7,SCALEBITS        ; xmm7=CrOL
-        psrld     xmm5,SCALEBITS        ; xmm5=CrOH
-        packssdw  xmm7,xmm5             ; xmm7=CrO
-
-        movdqa    xmm3, XMMWORD [wk(0)] ; xmm3=RE
-
-        movdqa    xmm4,xmm6
-        punpcklwd xmm6,xmm2
-        punpckhwd xmm4,xmm2
-        movdqa    xmm1,xmm6
-        movdqa    xmm5,xmm4
-        pmaddwd   xmm6,[rel PW_F0114_F0250] ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
-        pmaddwd   xmm4,[rel PW_F0114_F0250] ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
-        pmaddwd   xmm1,[rel PW_MF008_MF041] ; xmm1=BEL*-FIX(0.081)+GEL*-FIX(0.418)
-        pmaddwd   xmm5,[rel PW_MF008_MF041] ; xmm5=BEH*-FIX(0.081)+GEH*-FIX(0.418)
-
-        movdqa    xmm2,[rel PD_ONEHALF] ; xmm2=[PD_ONEHALF]
-
-        paddd     xmm6, XMMWORD [wk(6)]
-        paddd     xmm4, XMMWORD [wk(7)]
-        paddd     xmm6,xmm2
-        paddd     xmm4,xmm2
-        psrld     xmm6,SCALEBITS        ; xmm6=YEL
-        psrld     xmm4,SCALEBITS        ; xmm4=YEH
-        packssdw  xmm6,xmm4             ; xmm6=YE
-
-        psllw     xmm0,BYTE_BIT
-        por       xmm6,xmm0             ; xmm6=Y
-        movdqa    XMMWORD [rdi], xmm6   ; Save Y
-
-        pxor      xmm2,xmm2
-        pxor      xmm4,xmm4
-        punpcklwd xmm2,xmm3             ; xmm2=REL
-        punpckhwd xmm4,xmm3             ; xmm4=REH
-        psrld     xmm2,1                ; xmm2=REL*FIX(0.500)
-        psrld     xmm4,1                ; xmm4=REH*FIX(0.500)
-
-        movdqa    xmm0,[rel PD_ONEHALFM1_CJ] ; xmm0=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm1,xmm2
-        paddd     xmm5,xmm4
-        paddd     xmm1,xmm0
-        paddd     xmm5,xmm0
-        psrld     xmm1,SCALEBITS        ; xmm1=CrEL
-        psrld     xmm5,SCALEBITS        ; xmm5=CrEH
-        packssdw  xmm1,xmm5             ; xmm1=CrE
-
-        psllw     xmm7,BYTE_BIT
-        por       xmm1,xmm7             ; xmm1=Cr
-        movdqa    XMMWORD [rdx], xmm1   ; Save Cr
-
-        sub     rcx, byte SIZEOF_XMMWORD
-        add     rsi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
-        add     rdi, byte SIZEOF_XMMWORD                ; outptr0
-        add     rbx, byte SIZEOF_XMMWORD                ; outptr1
-        add     rdx, byte SIZEOF_XMMWORD                ; outptr2
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        test    rcx,rcx
-        jnz     near .column_ld1
-
-        pop     rcx                     ; col
-        pop     rsi
-        pop     rdi
-        pop     rbx
-        pop     rdx
-
-        add     rsi, byte SIZEOF_JSAMPROW       ; input_buf
-        add     rdi, byte SIZEOF_JSAMPROW
-        add     rbx, byte SIZEOF_JSAMPROW
-        add     rdx, byte SIZEOF_JSAMPROW
-        dec     rax                             ; num_rows
-        jg      near .rowloop
-
-.return:
-        pop     rbx
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jccolext-sse2.asm b/simd/jccolext-sse2.asm
deleted file mode 100644
index cc38e98..0000000
--- a/simd/jccolext-sse2.asm
+++ /dev/null
@@ -1,503 +0,0 @@
-;
-; jccolext.asm - colorspace conversion (SSE2)
-;
-; x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Convert some rows of samples to the output colorspace.
-;
-; GLOBAL(void)
-; jsimd_rgb_ycc_convert_sse2 (JDIMENSION img_width,
-;                             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
-;                             JDIMENSION output_row, int num_rows);
-;
-
-%define img_width(b)    (b)+8           ; JDIMENSION img_width
-%define input_buf(b)    (b)+12          ; JSAMPARRAY input_buf
-%define output_buf(b)   (b)+16          ; JSAMPIMAGE output_buf
-%define output_row(b)   (b)+20          ; JDIMENSION output_row
-%define num_rows(b)     (b)+24          ; int num_rows
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          8
-%define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
-
-        align   16
-
-        global  EXTN(jsimd_rgb_ycc_convert_sse2)
-
-EXTN(jsimd_rgb_ycc_convert_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic eax             ; make a room for GOT address
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx                     ; get GOT address
-        movpic  POINTER [gotptr], ebx   ; save GOT address
-
-        mov     ecx, JDIMENSION [img_width(eax)]
-        test    ecx,ecx
-        jz      near .return
-
-        push    ecx
-
-        mov     esi, JSAMPIMAGE [output_buf(eax)]
-        mov     ecx, JDIMENSION [output_row(eax)]
-        mov     edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
-        mov     ebx, JSAMPARRAY [esi+1*SIZEOF_JSAMPARRAY]
-        mov     edx, JSAMPARRAY [esi+2*SIZEOF_JSAMPARRAY]
-        lea     edi, [edi+ecx*SIZEOF_JSAMPROW]
-        lea     ebx, [ebx+ecx*SIZEOF_JSAMPROW]
-        lea     edx, [edx+ecx*SIZEOF_JSAMPROW]
-
-        pop     ecx
-
-        mov     esi, JSAMPARRAY [input_buf(eax)]
-        mov     eax, INT [num_rows(eax)]
-        test    eax,eax
-        jle     near .return
-        alignx  16,7
-.rowloop:
-        pushpic eax
-        push    edx
-        push    ebx
-        push    edi
-        push    esi
-        push    ecx                     ; col
-
-        mov     esi, JSAMPROW [esi]     ; inptr
-        mov     edi, JSAMPROW [edi]     ; outptr0
-        mov     ebx, JSAMPROW [ebx]     ; outptr1
-        mov     edx, JSAMPROW [edx]     ; outptr2
-        movpic  eax, POINTER [gotptr]   ; load GOT address (eax)
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        alignx  16,7
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-.column_ld1:
-        push    eax
-        push    edx
-        lea     ecx,[ecx+ecx*2]         ; imul ecx,RGB_PIXELSIZE
-        test    cl, SIZEOF_BYTE
-        jz      short .column_ld2
-        sub     ecx, byte SIZEOF_BYTE
-        movzx   eax, BYTE [esi+ecx]
-.column_ld2:
-        test    cl, SIZEOF_WORD
-        jz      short .column_ld4
-        sub     ecx, byte SIZEOF_WORD
-        movzx   edx, WORD [esi+ecx]
-        shl     eax, WORD_BIT
-        or      eax,edx
-.column_ld4:
-        movd    xmmA,eax
-        pop     edx
-        pop     eax
-        test    cl, SIZEOF_DWORD
-        jz      short .column_ld8
-        sub     ecx, byte SIZEOF_DWORD
-        movd    xmmF, XMM_DWORD [esi+ecx]
-        pslldq  xmmA, SIZEOF_DWORD
-        por     xmmA,xmmF
-.column_ld8:
-        test    cl, SIZEOF_MMWORD
-        jz      short .column_ld16
-        sub     ecx, byte SIZEOF_MMWORD
-        movq    xmmB, XMM_MMWORD [esi+ecx]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmB
-.column_ld16:
-        test    cl, SIZEOF_XMMWORD
-        jz      short .column_ld32
-        movdqa  xmmF,xmmA
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        mov     ecx, SIZEOF_XMMWORD
-        jmp     short .rgb_ycc_cnv
-.column_ld32:
-        test    cl, 2*SIZEOF_XMMWORD
-        mov     ecx, SIZEOF_XMMWORD
-        jz      short .rgb_ycc_cnv
-        movdqa  xmmB,xmmA
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_ycc_cnv
-        alignx  16,7
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        movdqu  xmmB, XMMWORD [esi+2*SIZEOF_XMMWORD]
-
-.rgb_ycc_cnv:
-        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        movdqa    xmmG,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
-        psrldq    xmmG,8        ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmF     ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
-        pslldq    xmmF,8        ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
-
-        punpcklbw xmmG,xmmB     ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
-        punpckhbw xmmF,xmmB     ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
-
-        movdqa    xmmD,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
-        psrldq    xmmD,8        ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmG     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
-        pslldq    xmmG,8        ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
-
-        punpcklbw xmmD,xmmF     ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
-        punpckhbw xmmG,xmmF     ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
-
-        movdqa    xmmE,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
-        psrldq    xmmE,8        ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        pslldq    xmmD,8        ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
-
-        punpcklbw xmmE,xmmG     ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmG     ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
-
-        pxor      xmmH,xmmH
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmH     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmH     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmB,xmmE
-        punpcklbw xmmE,xmmH     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmB,xmmH     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-
-        movdqa    xmmF,xmmD
-        punpcklbw xmmD,xmmH     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmF,xmmH     ; xmmF=(21 23 25 27 29 2B 2D 2F)
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-.column_ld1:
-        test    cl, SIZEOF_XMMWORD/16
-        jz      short .column_ld2
-        sub     ecx, byte SIZEOF_XMMWORD/16
-        movd    xmmA, XMM_DWORD [esi+ecx*RGB_PIXELSIZE]
-.column_ld2:
-        test    cl, SIZEOF_XMMWORD/8
-        jz      short .column_ld4
-        sub     ecx, byte SIZEOF_XMMWORD/8
-        movq    xmmE, XMM_MMWORD [esi+ecx*RGB_PIXELSIZE]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmE
-.column_ld4:
-        test    cl, SIZEOF_XMMWORD/4
-        jz      short .column_ld8
-        sub     ecx, byte SIZEOF_XMMWORD/4
-        movdqa  xmmE,xmmA
-        movdqu  xmmA, XMMWORD [esi+ecx*RGB_PIXELSIZE]
-.column_ld8:
-        test    cl, SIZEOF_XMMWORD/2
-        mov     ecx, SIZEOF_XMMWORD
-        jz      short .rgb_ycc_cnv
-        movdqa  xmmF,xmmA
-        movdqa  xmmH,xmmE
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_ycc_cnv
-        alignx  16,7
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [esi+2*SIZEOF_XMMWORD]
-        movdqu  xmmH, XMMWORD [esi+3*SIZEOF_XMMWORD]
-
-.rgb_ycc_cnv:
-        ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpcklbw xmmA,xmmE     ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
-        punpckhbw xmmD,xmmE     ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
-
-        movdqa    xmmC,xmmF
-        punpcklbw xmmF,xmmH     ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
-        punpckhbw xmmC,xmmH     ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
-
-        movdqa    xmmB,xmmA
-        punpcklwd xmmA,xmmF     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
-        punpckhwd xmmB,xmmF     ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
-
-        movdqa    xmmG,xmmD
-        punpcklwd xmmD,xmmC     ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
-        punpckhwd xmmG,xmmC     ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
-
-        movdqa    xmmE,xmmA
-        punpcklbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        punpckhbw xmmE,xmmD     ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
-
-        movdqa    xmmH,xmmB
-        punpcklbw xmmB,xmmG     ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmH,xmmG     ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
-
-        pxor      xmmF,xmmF
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmF     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmF     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmD,xmmB
-        punpcklbw xmmB,xmmF     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmF     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-
-        movdqa    xmmG,xmmE
-        punpcklbw xmmE,xmmF     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmG,xmmF     ; xmmG=(30 32 34 36 38 3A 3C 3E)
-
-        punpcklbw xmmF,xmmH
-        punpckhbw xmmH,xmmH
-        psrlw     xmmF,BYTE_BIT ; xmmF=(21 23 25 27 29 2B 2D 2F)
-        psrlw     xmmH,BYTE_BIT ; xmmH=(31 33 35 37 39 3B 3D 3F)
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-        ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
-        ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
-
-        ; (Original)
-        ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
-        ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
-        ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
-        ;
-        ; (This implementation)
-        ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
-        ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
-        ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
-
-        movdqa    XMMWORD [wk(0)], xmm0 ; wk(0)=RE
-        movdqa    XMMWORD [wk(1)], xmm1 ; wk(1)=RO
-        movdqa    XMMWORD [wk(2)], xmm4 ; wk(2)=BE
-        movdqa    XMMWORD [wk(3)], xmm5 ; wk(3)=BO
-
-        movdqa    xmm6,xmm1
-        punpcklwd xmm1,xmm3
-        punpckhwd xmm6,xmm3
-        movdqa    xmm7,xmm1
-        movdqa    xmm4,xmm6
-        pmaddwd   xmm1,[GOTOFF(eax,PW_F0299_F0337)] ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
-        pmaddwd   xmm6,[GOTOFF(eax,PW_F0299_F0337)] ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
-        pmaddwd   xmm7,[GOTOFF(eax,PW_MF016_MF033)] ; xmm7=ROL*-FIX(0.168)+GOL*-FIX(0.331)
-        pmaddwd   xmm4,[GOTOFF(eax,PW_MF016_MF033)] ; xmm4=ROH*-FIX(0.168)+GOH*-FIX(0.331)
-
-        movdqa    XMMWORD [wk(4)], xmm1 ; wk(4)=ROL*FIX(0.299)+GOL*FIX(0.337)
-        movdqa    XMMWORD [wk(5)], xmm6 ; wk(5)=ROH*FIX(0.299)+GOH*FIX(0.337)
-
-        pxor      xmm1,xmm1
-        pxor      xmm6,xmm6
-        punpcklwd xmm1,xmm5             ; xmm1=BOL
-        punpckhwd xmm6,xmm5             ; xmm6=BOH
-        psrld     xmm1,1                ; xmm1=BOL*FIX(0.500)
-        psrld     xmm6,1                ; xmm6=BOH*FIX(0.500)
-
-        movdqa    xmm5,[GOTOFF(eax,PD_ONEHALFM1_CJ)] ; xmm5=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm7,xmm1
-        paddd     xmm4,xmm6
-        paddd     xmm7,xmm5
-        paddd     xmm4,xmm5
-        psrld     xmm7,SCALEBITS        ; xmm7=CbOL
-        psrld     xmm4,SCALEBITS        ; xmm4=CbOH
-        packssdw  xmm7,xmm4             ; xmm7=CbO
-
-        movdqa    xmm1, XMMWORD [wk(2)] ; xmm1=BE
-
-        movdqa    xmm6,xmm0
-        punpcklwd xmm0,xmm2
-        punpckhwd xmm6,xmm2
-        movdqa    xmm5,xmm0
-        movdqa    xmm4,xmm6
-        pmaddwd   xmm0,[GOTOFF(eax,PW_F0299_F0337)] ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
-        pmaddwd   xmm6,[GOTOFF(eax,PW_F0299_F0337)] ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
-        pmaddwd   xmm5,[GOTOFF(eax,PW_MF016_MF033)] ; xmm5=REL*-FIX(0.168)+GEL*-FIX(0.331)
-        pmaddwd   xmm4,[GOTOFF(eax,PW_MF016_MF033)] ; xmm4=REH*-FIX(0.168)+GEH*-FIX(0.331)
-
-        movdqa    XMMWORD [wk(6)], xmm0 ; wk(6)=REL*FIX(0.299)+GEL*FIX(0.337)
-        movdqa    XMMWORD [wk(7)], xmm6 ; wk(7)=REH*FIX(0.299)+GEH*FIX(0.337)
-
-        pxor      xmm0,xmm0
-        pxor      xmm6,xmm6
-        punpcklwd xmm0,xmm1             ; xmm0=BEL
-        punpckhwd xmm6,xmm1             ; xmm6=BEH
-        psrld     xmm0,1                ; xmm0=BEL*FIX(0.500)
-        psrld     xmm6,1                ; xmm6=BEH*FIX(0.500)
-
-        movdqa    xmm1,[GOTOFF(eax,PD_ONEHALFM1_CJ)] ; xmm1=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm5,xmm0
-        paddd     xmm4,xmm6
-        paddd     xmm5,xmm1
-        paddd     xmm4,xmm1
-        psrld     xmm5,SCALEBITS        ; xmm5=CbEL
-        psrld     xmm4,SCALEBITS        ; xmm4=CbEH
-        packssdw  xmm5,xmm4             ; xmm5=CbE
-
-        psllw     xmm7,BYTE_BIT
-        por       xmm5,xmm7             ; xmm5=Cb
-        movdqa    XMMWORD [ebx], xmm5   ; Save Cb
-
-        movdqa    xmm0, XMMWORD [wk(3)] ; xmm0=BO
-        movdqa    xmm6, XMMWORD [wk(2)] ; xmm6=BE
-        movdqa    xmm1, XMMWORD [wk(1)] ; xmm1=RO
-
-        movdqa    xmm4,xmm0
-        punpcklwd xmm0,xmm3
-        punpckhwd xmm4,xmm3
-        movdqa    xmm7,xmm0
-        movdqa    xmm5,xmm4
-        pmaddwd   xmm0,[GOTOFF(eax,PW_F0114_F0250)] ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
-        pmaddwd   xmm4,[GOTOFF(eax,PW_F0114_F0250)] ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
-        pmaddwd   xmm7,[GOTOFF(eax,PW_MF008_MF041)] ; xmm7=BOL*-FIX(0.081)+GOL*-FIX(0.418)
-        pmaddwd   xmm5,[GOTOFF(eax,PW_MF008_MF041)] ; xmm5=BOH*-FIX(0.081)+GOH*-FIX(0.418)
-
-        movdqa    xmm3,[GOTOFF(eax,PD_ONEHALF)] ; xmm3=[PD_ONEHALF]
-
-        paddd     xmm0, XMMWORD [wk(4)]
-        paddd     xmm4, XMMWORD [wk(5)]
-        paddd     xmm0,xmm3
-        paddd     xmm4,xmm3
-        psrld     xmm0,SCALEBITS        ; xmm0=YOL
-        psrld     xmm4,SCALEBITS        ; xmm4=YOH
-        packssdw  xmm0,xmm4             ; xmm0=YO
-
-        pxor      xmm3,xmm3
-        pxor      xmm4,xmm4
-        punpcklwd xmm3,xmm1             ; xmm3=ROL
-        punpckhwd xmm4,xmm1             ; xmm4=ROH
-        psrld     xmm3,1                ; xmm3=ROL*FIX(0.500)
-        psrld     xmm4,1                ; xmm4=ROH*FIX(0.500)
-
-        movdqa    xmm1,[GOTOFF(eax,PD_ONEHALFM1_CJ)] ; xmm1=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm7,xmm3
-        paddd     xmm5,xmm4
-        paddd     xmm7,xmm1
-        paddd     xmm5,xmm1
-        psrld     xmm7,SCALEBITS        ; xmm7=CrOL
-        psrld     xmm5,SCALEBITS        ; xmm5=CrOH
-        packssdw  xmm7,xmm5             ; xmm7=CrO
-
-        movdqa    xmm3, XMMWORD [wk(0)] ; xmm3=RE
-
-        movdqa    xmm4,xmm6
-        punpcklwd xmm6,xmm2
-        punpckhwd xmm4,xmm2
-        movdqa    xmm1,xmm6
-        movdqa    xmm5,xmm4
-        pmaddwd   xmm6,[GOTOFF(eax,PW_F0114_F0250)] ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
-        pmaddwd   xmm4,[GOTOFF(eax,PW_F0114_F0250)] ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
-        pmaddwd   xmm1,[GOTOFF(eax,PW_MF008_MF041)] ; xmm1=BEL*-FIX(0.081)+GEL*-FIX(0.418)
-        pmaddwd   xmm5,[GOTOFF(eax,PW_MF008_MF041)] ; xmm5=BEH*-FIX(0.081)+GEH*-FIX(0.418)
-
-        movdqa    xmm2,[GOTOFF(eax,PD_ONEHALF)] ; xmm2=[PD_ONEHALF]
-
-        paddd     xmm6, XMMWORD [wk(6)]
-        paddd     xmm4, XMMWORD [wk(7)]
-        paddd     xmm6,xmm2
-        paddd     xmm4,xmm2
-        psrld     xmm6,SCALEBITS        ; xmm6=YEL
-        psrld     xmm4,SCALEBITS        ; xmm4=YEH
-        packssdw  xmm6,xmm4             ; xmm6=YE
-
-        psllw     xmm0,BYTE_BIT
-        por       xmm6,xmm0             ; xmm6=Y
-        movdqa    XMMWORD [edi], xmm6   ; Save Y
-
-        pxor      xmm2,xmm2
-        pxor      xmm4,xmm4
-        punpcklwd xmm2,xmm3             ; xmm2=REL
-        punpckhwd xmm4,xmm3             ; xmm4=REH
-        psrld     xmm2,1                ; xmm2=REL*FIX(0.500)
-        psrld     xmm4,1                ; xmm4=REH*FIX(0.500)
-
-        movdqa    xmm0,[GOTOFF(eax,PD_ONEHALFM1_CJ)] ; xmm0=[PD_ONEHALFM1_CJ]
-
-        paddd     xmm1,xmm2
-        paddd     xmm5,xmm4
-        paddd     xmm1,xmm0
-        paddd     xmm5,xmm0
-        psrld     xmm1,SCALEBITS        ; xmm1=CrEL
-        psrld     xmm5,SCALEBITS        ; xmm5=CrEH
-        packssdw  xmm1,xmm5             ; xmm1=CrE
-
-        psllw     xmm7,BYTE_BIT
-        por       xmm1,xmm7             ; xmm1=Cr
-        movdqa    XMMWORD [edx], xmm1   ; Save Cr
-
-        sub     ecx, byte SIZEOF_XMMWORD
-        add     esi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
-        add     edi, byte SIZEOF_XMMWORD                ; outptr0
-        add     ebx, byte SIZEOF_XMMWORD                ; outptr1
-        add     edx, byte SIZEOF_XMMWORD                ; outptr2
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        test    ecx,ecx
-        jnz     near .column_ld1
-
-        pop     ecx                     ; col
-        pop     esi
-        pop     edi
-        pop     ebx
-        pop     edx
-        poppic  eax
-
-        add     esi, byte SIZEOF_JSAMPROW       ; input_buf
-        add     edi, byte SIZEOF_JSAMPROW
-        add     ebx, byte SIZEOF_JSAMPROW
-        add     edx, byte SIZEOF_JSAMPROW
-        dec     eax                             ; num_rows
-        jg      near .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jcgryext-sse2-64.asm b/simd/jcgryext-sse2-64.asm
deleted file mode 100644
index 541355a..0000000
--- a/simd/jcgryext-sse2-64.asm
+++ /dev/null
@@ -1,365 +0,0 @@
-;
-; jcgryext.asm - grayscale colorspace conversion (64-bit SSE2)
-;
-; Copyright (C) 2011, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Convert some rows of samples to the output colorspace.
-;
-; GLOBAL(void)
-; jsimd_rgb_gray_convert_sse2 (JDIMENSION img_width,
-;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
-;                              JDIMENSION output_row, int num_rows);
-;
-
-; r10 = JDIMENSION img_width
-; r11 = JSAMPARRAY input_buf
-; r12 = JSAMPIMAGE output_buf
-; r13 = JDIMENSION output_row
-; r14 = int num_rows
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-
-        global  EXTN(jsimd_rgb_gray_convert_sse2)
-
-EXTN(jsimd_rgb_gray_convert_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-        push    rbx
-
-        mov     ecx, r10d
-        test    rcx,rcx
-        jz      near .return
-
-        push    rcx
-
-        mov rsi, r12
-        mov ecx, r13d
-        mov     rdi, JSAMPARRAY [rsi+0*SIZEOF_JSAMPARRAY]
-        lea     rdi, [rdi+rcx*SIZEOF_JSAMPROW]
-
-        pop     rcx
-
-        mov rsi, r11
-        mov     eax, r14d
-        test    rax,rax
-        jle     near .return
-.rowloop:
-        push    rdi
-        push    rsi
-        push    rcx                     ; col
-
-        mov     rsi, JSAMPROW [rsi]     ; inptr
-        mov     rdi, JSAMPROW [rdi]     ; outptr0
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-.column_ld1:
-        push    rax
-        push    rdx
-        lea     rcx,[rcx+rcx*2]         ; imul ecx,RGB_PIXELSIZE
-        test    cl, SIZEOF_BYTE
-        jz      short .column_ld2
-        sub     rcx, byte SIZEOF_BYTE
-        movzx   rax, BYTE [rsi+rcx]
-.column_ld2:
-        test    cl, SIZEOF_WORD
-        jz      short .column_ld4
-        sub     rcx, byte SIZEOF_WORD
-        movzx   rdx, WORD [rsi+rcx]
-        shl     rax, WORD_BIT
-        or      rax,rdx
-.column_ld4:
-        movd    xmmA,eax
-        pop     rdx
-        pop     rax
-        test    cl, SIZEOF_DWORD
-        jz      short .column_ld8
-        sub     rcx, byte SIZEOF_DWORD
-        movd    xmmF, XMM_DWORD [rsi+rcx]
-        pslldq  xmmA, SIZEOF_DWORD
-        por     xmmA,xmmF
-.column_ld8:
-        test    cl, SIZEOF_MMWORD
-        jz      short .column_ld16
-        sub     rcx, byte SIZEOF_MMWORD
-        movq    xmmB, XMM_MMWORD [rsi+rcx]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmB
-.column_ld16:
-        test    cl, SIZEOF_XMMWORD
-        jz      short .column_ld32
-        movdqa  xmmF,xmmA
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        mov     rcx, SIZEOF_XMMWORD
-        jmp     short .rgb_gray_cnv
-.column_ld32:
-        test    cl, 2*SIZEOF_XMMWORD
-        mov     rcx, SIZEOF_XMMWORD
-        jz      short .rgb_gray_cnv
-        movdqa  xmmB,xmmA
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_gray_cnv
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        movdqu  xmmB, XMMWORD [rsi+2*SIZEOF_XMMWORD]
-
-.rgb_gray_cnv:
-        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        movdqa    xmmG,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
-        psrldq    xmmG,8        ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmF     ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
-        pslldq    xmmF,8        ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
-
-        punpcklbw xmmG,xmmB     ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
-        punpckhbw xmmF,xmmB     ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
-
-        movdqa    xmmD,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
-        psrldq    xmmD,8        ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmG     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
-        pslldq    xmmG,8        ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
-
-        punpcklbw xmmD,xmmF     ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
-        punpckhbw xmmG,xmmF     ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
-
-        movdqa    xmmE,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
-        psrldq    xmmE,8        ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        pslldq    xmmD,8        ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
-
-        punpcklbw xmmE,xmmG     ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmG     ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
-
-        pxor      xmmH,xmmH
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmH     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmH     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmB,xmmE
-        punpcklbw xmmE,xmmH     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmB,xmmH     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-
-        movdqa    xmmF,xmmD
-        punpcklbw xmmD,xmmH     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmF,xmmH     ; xmmF=(21 23 25 27 29 2B 2D 2F)
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-.column_ld1:
-        test    cl, SIZEOF_XMMWORD/16
-        jz      short .column_ld2
-        sub     rcx, byte SIZEOF_XMMWORD/16
-        movd    xmmA, XMM_DWORD [rsi+rcx*RGB_PIXELSIZE]
-.column_ld2:
-        test    cl, SIZEOF_XMMWORD/8
-        jz      short .column_ld4
-        sub     rcx, byte SIZEOF_XMMWORD/8
-        movq    xmmE, XMM_MMWORD [rsi+rcx*RGB_PIXELSIZE]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmE
-.column_ld4:
-        test    cl, SIZEOF_XMMWORD/4
-        jz      short .column_ld8
-        sub     rcx, byte SIZEOF_XMMWORD/4
-        movdqa  xmmE,xmmA
-        movdqu  xmmA, XMMWORD [rsi+rcx*RGB_PIXELSIZE]
-.column_ld8:
-        test    cl, SIZEOF_XMMWORD/2
-        mov     rcx, SIZEOF_XMMWORD
-        jz      short .rgb_gray_cnv
-        movdqa  xmmF,xmmA
-        movdqa  xmmH,xmmE
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_gray_cnv
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [rsi+2*SIZEOF_XMMWORD]
-        movdqu  xmmH, XMMWORD [rsi+3*SIZEOF_XMMWORD]
-
-.rgb_gray_cnv:
-        ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpcklbw xmmA,xmmE     ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
-        punpckhbw xmmD,xmmE     ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
-
-        movdqa    xmmC,xmmF
-        punpcklbw xmmF,xmmH     ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
-        punpckhbw xmmC,xmmH     ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
-
-        movdqa    xmmB,xmmA
-        punpcklwd xmmA,xmmF     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
-        punpckhwd xmmB,xmmF     ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
-
-        movdqa    xmmG,xmmD
-        punpcklwd xmmD,xmmC     ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
-        punpckhwd xmmG,xmmC     ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
-
-        movdqa    xmmE,xmmA
-        punpcklbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        punpckhbw xmmE,xmmD     ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
-
-        movdqa    xmmH,xmmB
-        punpcklbw xmmB,xmmG     ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmH,xmmG     ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
-
-        pxor      xmmF,xmmF
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmF     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmF     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmD,xmmB
-        punpcklbw xmmB,xmmF     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmF     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-
-        movdqa    xmmG,xmmE
-        punpcklbw xmmE,xmmF     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmG,xmmF     ; xmmG=(30 32 34 36 38 3A 3C 3E)
-
-        punpcklbw xmmF,xmmH
-        punpckhbw xmmH,xmmH
-        psrlw     xmmF,BYTE_BIT ; xmmF=(21 23 25 27 29 2B 2D 2F)
-        psrlw     xmmH,BYTE_BIT ; xmmH=(31 33 35 37 39 3B 3D 3F)
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-        ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
-        ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
-
-        ; (Original)
-        ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
-        ;
-        ; (This implementation)
-        ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
-
-        movdqa    xmm6,xmm1
-        punpcklwd xmm1,xmm3
-        punpckhwd xmm6,xmm3
-        pmaddwd   xmm1,[rel PW_F0299_F0337] ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
-        pmaddwd   xmm6,[rel PW_F0299_F0337] ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
-
-        movdqa    xmm7, xmm6    ; xmm7=ROH*FIX(0.299)+GOH*FIX(0.337)
-
-        movdqa    xmm6,xmm0
-        punpcklwd xmm0,xmm2
-        punpckhwd xmm6,xmm2
-        pmaddwd   xmm0,[rel PW_F0299_F0337] ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
-        pmaddwd   xmm6,[rel PW_F0299_F0337] ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
-
-        movdqa    XMMWORD [wk(0)], xmm0 ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
-        movdqa    XMMWORD [wk(1)], xmm6 ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
-
-        movdqa    xmm0, xmm5    ; xmm0=BO
-        movdqa    xmm6, xmm4    ; xmm6=BE
-
-        movdqa    xmm4,xmm0
-        punpcklwd xmm0,xmm3
-        punpckhwd xmm4,xmm3
-        pmaddwd   xmm0,[rel PW_F0114_F0250] ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
-        pmaddwd   xmm4,[rel PW_F0114_F0250] ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
-
-        movdqa    xmm3,[rel PD_ONEHALF] ; xmm3=[PD_ONEHALF]
-
-        paddd     xmm0, xmm1
-        paddd     xmm4, xmm7
-        paddd     xmm0,xmm3
-        paddd     xmm4,xmm3
-        psrld     xmm0,SCALEBITS        ; xmm0=YOL
-        psrld     xmm4,SCALEBITS        ; xmm4=YOH
-        packssdw  xmm0,xmm4             ; xmm0=YO
-
-        movdqa    xmm4,xmm6
-        punpcklwd xmm6,xmm2
-        punpckhwd xmm4,xmm2
-        pmaddwd   xmm6,[rel PW_F0114_F0250] ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
-        pmaddwd   xmm4,[rel PW_F0114_F0250] ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
-
-        movdqa    xmm2,[rel PD_ONEHALF] ; xmm2=[PD_ONEHALF]
-
-        paddd     xmm6, XMMWORD [wk(0)]
-        paddd     xmm4, XMMWORD [wk(1)]
-        paddd     xmm6,xmm2
-        paddd     xmm4,xmm2
-        psrld     xmm6,SCALEBITS        ; xmm6=YEL
-        psrld     xmm4,SCALEBITS        ; xmm4=YEH
-        packssdw  xmm6,xmm4             ; xmm6=YE
-
-        psllw     xmm0,BYTE_BIT
-        por       xmm6,xmm0             ; xmm6=Y
-        movdqa    XMMWORD [rdi], xmm6   ; Save Y
-
-        sub     rcx, byte SIZEOF_XMMWORD
-        add     rsi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
-        add     rdi, byte SIZEOF_XMMWORD                ; outptr0
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        test    rcx,rcx
-        jnz     near .column_ld1
-
-        pop     rcx                     ; col
-        pop     rsi
-        pop     rdi
-
-        add     rsi, byte SIZEOF_JSAMPROW       ; input_buf
-        add     rdi, byte SIZEOF_JSAMPROW
-        dec     rax                             ; num_rows
-        jg      near .rowloop
-
-.return:
-        pop     rbx
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jcgryext-sse2.asm b/simd/jcgryext-sse2.asm
deleted file mode 100644
index cd16dd1..0000000
--- a/simd/jcgryext-sse2.asm
+++ /dev/null
@@ -1,384 +0,0 @@
-;
-; jcgryext.asm - grayscale colorspace conversion (SSE2)
-;
-; Copyright (C) 2011, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Convert some rows of samples to the output colorspace.
-;
-; GLOBAL(void)
-; jsimd_rgb_gray_convert_sse2 (JDIMENSION img_width,
-;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
-;                              JDIMENSION output_row, int num_rows);
-;
-
-%define img_width(b)    (b)+8           ; JDIMENSION img_width
-%define input_buf(b)    (b)+12          ; JSAMPARRAY input_buf
-%define output_buf(b)   (b)+16          ; JSAMPIMAGE output_buf
-%define output_row(b)   (b)+20          ; JDIMENSION output_row
-%define num_rows(b)     (b)+24          ; int num_rows
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-%define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
-
-        align   16
-
-        global  EXTN(jsimd_rgb_gray_convert_sse2)
-
-EXTN(jsimd_rgb_gray_convert_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic eax             ; make a room for GOT address
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx                     ; get GOT address
-        movpic  POINTER [gotptr], ebx   ; save GOT address
-
-        mov     ecx, JDIMENSION [img_width(eax)]
-        test    ecx,ecx
-        jz      near .return
-
-        push    ecx
-
-        mov     esi, JSAMPIMAGE [output_buf(eax)]
-        mov     ecx, JDIMENSION [output_row(eax)]
-        mov     edi, JSAMPARRAY [esi+0*SIZEOF_JSAMPARRAY]
-        lea     edi, [edi+ecx*SIZEOF_JSAMPROW]
-
-        pop     ecx
-
-        mov     esi, JSAMPARRAY [input_buf(eax)]
-        mov     eax, INT [num_rows(eax)]
-        test    eax,eax
-        jle     near .return
-        alignx  16,7
-.rowloop:
-        pushpic eax
-        push    edi
-        push    esi
-        push    ecx                     ; col
-
-        mov     esi, JSAMPROW [esi]     ; inptr
-        mov     edi, JSAMPROW [edi]     ; outptr0
-        movpic  eax, POINTER [gotptr]   ; load GOT address (eax)
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        alignx  16,7
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-.column_ld1:
-        push    eax
-        push    edx
-        lea     ecx,[ecx+ecx*2]         ; imul ecx,RGB_PIXELSIZE
-        test    cl, SIZEOF_BYTE
-        jz      short .column_ld2
-        sub     ecx, byte SIZEOF_BYTE
-        movzx   eax, BYTE [esi+ecx]
-.column_ld2:
-        test    cl, SIZEOF_WORD
-        jz      short .column_ld4
-        sub     ecx, byte SIZEOF_WORD
-        movzx   edx, WORD [esi+ecx]
-        shl     eax, WORD_BIT
-        or      eax,edx
-.column_ld4:
-        movd    xmmA,eax
-        pop     edx
-        pop     eax
-        test    cl, SIZEOF_DWORD
-        jz      short .column_ld8
-        sub     ecx, byte SIZEOF_DWORD
-        movd    xmmF, XMM_DWORD [esi+ecx]
-        pslldq  xmmA, SIZEOF_DWORD
-        por     xmmA,xmmF
-.column_ld8:
-        test    cl, SIZEOF_MMWORD
-        jz      short .column_ld16
-        sub     ecx, byte SIZEOF_MMWORD
-        movq    xmmB, XMM_MMWORD [esi+ecx]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmB
-.column_ld16:
-        test    cl, SIZEOF_XMMWORD
-        jz      short .column_ld32
-        movdqa  xmmF,xmmA
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        mov     ecx, SIZEOF_XMMWORD
-        jmp     short .rgb_gray_cnv
-.column_ld32:
-        test    cl, 2*SIZEOF_XMMWORD
-        mov     ecx, SIZEOF_XMMWORD
-        jz      short .rgb_gray_cnv
-        movdqa  xmmB,xmmA
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_gray_cnv
-        alignx  16,7
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        movdqu  xmmB, XMMWORD [esi+2*SIZEOF_XMMWORD]
-
-.rgb_gray_cnv:
-        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        movdqa    xmmG,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
-        psrldq    xmmG,8        ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmF     ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
-        pslldq    xmmF,8        ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
-
-        punpcklbw xmmG,xmmB     ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
-        punpckhbw xmmF,xmmB     ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
-
-        movdqa    xmmD,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
-        psrldq    xmmD,8        ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmG     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
-        pslldq    xmmG,8        ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
-
-        punpcklbw xmmD,xmmF     ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
-        punpckhbw xmmG,xmmF     ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
-
-        movdqa    xmmE,xmmA
-        pslldq    xmmA,8        ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
-        psrldq    xmmE,8        ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
-
-        punpckhbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        pslldq    xmmD,8        ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
-
-        punpcklbw xmmE,xmmG     ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmG     ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
-
-        pxor      xmmH,xmmH
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmH     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmH     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmB,xmmE
-        punpcklbw xmmE,xmmH     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmB,xmmH     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-
-        movdqa    xmmF,xmmD
-        punpcklbw xmmD,xmmH     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmF,xmmH     ; xmmF=(21 23 25 27 29 2B 2D 2F)
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-.column_ld1:
-        test    cl, SIZEOF_XMMWORD/16
-        jz      short .column_ld2
-        sub     ecx, byte SIZEOF_XMMWORD/16
-        movd    xmmA, XMM_DWORD [esi+ecx*RGB_PIXELSIZE]
-.column_ld2:
-        test    cl, SIZEOF_XMMWORD/8
-        jz      short .column_ld4
-        sub     ecx, byte SIZEOF_XMMWORD/8
-        movq    xmmE, XMM_MMWORD [esi+ecx*RGB_PIXELSIZE]
-        pslldq  xmmA, SIZEOF_MMWORD
-        por     xmmA,xmmE
-.column_ld4:
-        test    cl, SIZEOF_XMMWORD/4
-        jz      short .column_ld8
-        sub     ecx, byte SIZEOF_XMMWORD/4
-        movdqa  xmmE,xmmA
-        movdqu  xmmA, XMMWORD [esi+ecx*RGB_PIXELSIZE]
-.column_ld8:
-        test    cl, SIZEOF_XMMWORD/2
-        mov     ecx, SIZEOF_XMMWORD
-        jz      short .rgb_gray_cnv
-        movdqa  xmmF,xmmA
-        movdqa  xmmH,xmmE
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        jmp     short .rgb_gray_cnv
-        alignx  16,7
-
-.columnloop:
-        movdqu  xmmA, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqu  xmmE, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        movdqu  xmmF, XMMWORD [esi+2*SIZEOF_XMMWORD]
-        movdqu  xmmH, XMMWORD [esi+3*SIZEOF_XMMWORD]
-
-.rgb_gray_cnv:
-        ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpcklbw xmmA,xmmE     ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
-        punpckhbw xmmD,xmmE     ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
-
-        movdqa    xmmC,xmmF
-        punpcklbw xmmF,xmmH     ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
-        punpckhbw xmmC,xmmH     ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
-
-        movdqa    xmmB,xmmA
-        punpcklwd xmmA,xmmF     ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
-        punpckhwd xmmB,xmmF     ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
-
-        movdqa    xmmG,xmmD
-        punpcklwd xmmD,xmmC     ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
-        punpckhwd xmmG,xmmC     ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
-
-        movdqa    xmmE,xmmA
-        punpcklbw xmmA,xmmD     ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
-        punpckhbw xmmE,xmmD     ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
-
-        movdqa    xmmH,xmmB
-        punpcklbw xmmB,xmmG     ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
-        punpckhbw xmmH,xmmG     ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
-
-        pxor      xmmF,xmmF
-
-        movdqa    xmmC,xmmA
-        punpcklbw xmmA,xmmF     ; xmmA=(00 02 04 06 08 0A 0C 0E)
-        punpckhbw xmmC,xmmF     ; xmmC=(10 12 14 16 18 1A 1C 1E)
-
-        movdqa    xmmD,xmmB
-        punpcklbw xmmB,xmmF     ; xmmB=(01 03 05 07 09 0B 0D 0F)
-        punpckhbw xmmD,xmmF     ; xmmD=(11 13 15 17 19 1B 1D 1F)
-
-        movdqa    xmmG,xmmE
-        punpcklbw xmmE,xmmF     ; xmmE=(20 22 24 26 28 2A 2C 2E)
-        punpckhbw xmmG,xmmF     ; xmmG=(30 32 34 36 38 3A 3C 3E)
-
-        punpcklbw xmmF,xmmH
-        punpckhbw xmmH,xmmH
-        psrlw     xmmF,BYTE_BIT ; xmmF=(21 23 25 27 29 2B 2D 2F)
-        psrlw     xmmH,BYTE_BIT ; xmmH=(31 33 35 37 39 3B 3D 3F)
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-        ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
-        ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
-
-        ; (Original)
-        ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
-        ;
-        ; (This implementation)
-        ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
-
-        movdqa    xmm6,xmm1
-        punpcklwd xmm1,xmm3
-        punpckhwd xmm6,xmm3
-        pmaddwd   xmm1,[GOTOFF(eax,PW_F0299_F0337)] ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
-        pmaddwd   xmm6,[GOTOFF(eax,PW_F0299_F0337)] ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
-
-        movdqa    xmm7, xmm6    ; xmm7=ROH*FIX(0.299)+GOH*FIX(0.337)
-
-        movdqa    xmm6,xmm0
-        punpcklwd xmm0,xmm2
-        punpckhwd xmm6,xmm2
-        pmaddwd   xmm0,[GOTOFF(eax,PW_F0299_F0337)] ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
-        pmaddwd   xmm6,[GOTOFF(eax,PW_F0299_F0337)] ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
-
-        movdqa    XMMWORD [wk(0)], xmm0 ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
-        movdqa    XMMWORD [wk(1)], xmm6 ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
-
-        movdqa    xmm0, xmm5    ; xmm0=BO
-        movdqa    xmm6, xmm4    ; xmm6=BE
-
-        movdqa    xmm4,xmm0
-        punpcklwd xmm0,xmm3
-        punpckhwd xmm4,xmm3
-        pmaddwd   xmm0,[GOTOFF(eax,PW_F0114_F0250)] ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
-        pmaddwd   xmm4,[GOTOFF(eax,PW_F0114_F0250)] ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
-
-        movdqa    xmm3,[GOTOFF(eax,PD_ONEHALF)] ; xmm3=[PD_ONEHALF]
-
-        paddd     xmm0, xmm1
-        paddd     xmm4, xmm7
-        paddd     xmm0,xmm3
-        paddd     xmm4,xmm3
-        psrld     xmm0,SCALEBITS        ; xmm0=YOL
-        psrld     xmm4,SCALEBITS        ; xmm4=YOH
-        packssdw  xmm0,xmm4             ; xmm0=YO
-
-        movdqa    xmm4,xmm6
-        punpcklwd xmm6,xmm2
-        punpckhwd xmm4,xmm2
-        pmaddwd   xmm6,[GOTOFF(eax,PW_F0114_F0250)] ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
-        pmaddwd   xmm4,[GOTOFF(eax,PW_F0114_F0250)] ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
-
-        movdqa    xmm2,[GOTOFF(eax,PD_ONEHALF)] ; xmm2=[PD_ONEHALF]
-
-        paddd     xmm6, XMMWORD [wk(0)]
-        paddd     xmm4, XMMWORD [wk(1)]
-        paddd     xmm6,xmm2
-        paddd     xmm4,xmm2
-        psrld     xmm6,SCALEBITS        ; xmm6=YEL
-        psrld     xmm4,SCALEBITS        ; xmm4=YEH
-        packssdw  xmm6,xmm4             ; xmm6=YE
-
-        psllw     xmm0,BYTE_BIT
-        por       xmm6,xmm0             ; xmm6=Y
-        movdqa    XMMWORD [edi], xmm6   ; Save Y
-
-        sub     ecx, byte SIZEOF_XMMWORD
-        add     esi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
-        add     edi, byte SIZEOF_XMMWORD                ; outptr0
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        test    ecx,ecx
-        jnz     near .column_ld1
-
-        pop     ecx                     ; col
-        pop     esi
-        pop     edi
-        poppic  eax
-
-        add     esi, byte SIZEOF_JSAMPROW       ; input_buf
-        add     edi, byte SIZEOF_JSAMPROW
-        dec     eax                             ; num_rows
-        jg      near .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jchuff-sse2-64.asm b/simd/jchuff-sse2-64.asm
deleted file mode 100644
index b1144d1..0000000
--- a/simd/jchuff-sse2-64.asm
+++ /dev/null
@@ -1,360 +0,0 @@
-;
-; jchuff-sse2-64.asm - Huffman entropy encoding (64-bit SSE2)
-;
-; Copyright (C) 2009-2011, 2014-2016, D. R. Commander.
-; Copyright (C) 2015, Matthieu Darbois.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains an SSE2 implementation for Huffman coding of one block.
-; The following code is based directly on jchuff.c; see jchuff.c for more
-; details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_huff_encode_one_block)
-
-EXTN(jconst_huff_encode_one_block):
-
-%include "jpeg_nbits_table.inc"
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-
-; These macros perform the same task as the emit_bits() function in the
-; original libjpeg code.  In addition to reducing overhead by explicitly
-; inlining the code, additional performance is achieved by taking into
-; account the size of the bit buffer and waiting until it is almost full
-; before emptying it.  This mostly benefits 64-bit platforms, since 6
-; bytes can be stored in a 64-bit bit buffer before it has to be emptied.
-
-%macro EMIT_BYTE 0
-        sub put_bits, 8  ; put_bits -= 8;
-        mov rdx, put_buffer
-        mov ecx, put_bits
-        shr rdx, cl  ; c = (JOCTET)GETJOCTET(put_buffer >> put_bits);
-        mov byte [buffer], dl  ; *buffer++ = c;
-        add buffer, 1
-        cmp dl, 0xFF  ; need to stuff a zero byte?
-        jne %%.EMIT_BYTE_END
-        mov byte [buffer], 0  ; *buffer++ = 0;
-        add buffer, 1
-%%.EMIT_BYTE_END:
-%endmacro
-
-%macro PUT_BITS 1
-        add put_bits, ecx  ; put_bits += size;
-        shl put_buffer, cl  ; put_buffer = (put_buffer << size);
-        or  put_buffer, %1
-%endmacro
-
-%macro CHECKBUF31 0
-        cmp put_bits, 32  ; if (put_bits > 31) {
-        jl %%.CHECKBUF31_END
-        EMIT_BYTE
-        EMIT_BYTE
-        EMIT_BYTE
-        EMIT_BYTE
-%%.CHECKBUF31_END:
-%endmacro
-
-%macro CHECKBUF47 0
-        cmp put_bits, 48  ; if (put_bits > 47) {
-        jl %%.CHECKBUF47_END
-        EMIT_BYTE
-        EMIT_BYTE
-        EMIT_BYTE
-        EMIT_BYTE
-        EMIT_BYTE
-        EMIT_BYTE
-%%.CHECKBUF47_END:
-%endmacro
-
-%macro EMIT_BITS 2
-        CHECKBUF47
-        mov ecx, %2
-        PUT_BITS %1
-%endmacro
-
-%macro kloop_prepare 37  ;(ko, jno0, ..., jno31, xmm0, xmm1, xmm2, xmm3)
-    pxor xmm8, xmm8  ; __m128i neg = _mm_setzero_si128();
-    pxor xmm9, xmm9  ; __m128i neg = _mm_setzero_si128();
-    pxor xmm10, xmm10  ; __m128i neg = _mm_setzero_si128();
-    pxor xmm11, xmm11  ; __m128i neg = _mm_setzero_si128();
-    pinsrw %34, word [r12 + %2  * SIZEOF_WORD], 0  ; xmm_shadow[0] = block[jno0];
-    pinsrw %35, word [r12 + %10 * SIZEOF_WORD], 0  ; xmm_shadow[8] = block[jno8];
-    pinsrw %36, word [r12 + %18 * SIZEOF_WORD], 0  ; xmm_shadow[16] = block[jno16];
-    pinsrw %37, word [r12 + %26 * SIZEOF_WORD], 0  ; xmm_shadow[24] = block[jno24];
-    pinsrw %34, word [r12 + %3  * SIZEOF_WORD], 1  ; xmm_shadow[1] = block[jno1];
-    pinsrw %35, word [r12 + %11 * SIZEOF_WORD], 1  ; xmm_shadow[9] = block[jno9];
-    pinsrw %36, word [r12 + %19 * SIZEOF_WORD], 1  ; xmm_shadow[17] = block[jno17];
-    pinsrw %37, word [r12 + %27 * SIZEOF_WORD], 1  ; xmm_shadow[25] = block[jno25];
-    pinsrw %34, word [r12 + %4  * SIZEOF_WORD], 2  ; xmm_shadow[2] = block[jno2];
-    pinsrw %35, word [r12 + %12 * SIZEOF_WORD], 2  ; xmm_shadow[10] = block[jno10];
-    pinsrw %36, word [r12 + %20 * SIZEOF_WORD], 2  ; xmm_shadow[18] = block[jno18];
-    pinsrw %37, word [r12 + %28 * SIZEOF_WORD], 2  ; xmm_shadow[26] = block[jno26];
-    pinsrw %34, word [r12 + %5  * SIZEOF_WORD], 3  ; xmm_shadow[3] = block[jno3];
-    pinsrw %35, word [r12 + %13 * SIZEOF_WORD], 3  ; xmm_shadow[11] = block[jno11];
-    pinsrw %36, word [r12 + %21 * SIZEOF_WORD], 3  ; xmm_shadow[19] = block[jno19];
-    pinsrw %37, word [r12 + %29 * SIZEOF_WORD], 3  ; xmm_shadow[27] = block[jno27];
-    pinsrw %34, word [r12 + %6  * SIZEOF_WORD], 4  ; xmm_shadow[4] = block[jno4];
-    pinsrw %35, word [r12 + %14 * SIZEOF_WORD], 4  ; xmm_shadow[12] = block[jno12];
-    pinsrw %36, word [r12 + %22 * SIZEOF_WORD], 4  ; xmm_shadow[20] = block[jno20];
-    pinsrw %37, word [r12 + %30 * SIZEOF_WORD], 4  ; xmm_shadow[28] = block[jno28];
-    pinsrw %34, word [r12 + %7  * SIZEOF_WORD], 5  ; xmm_shadow[5] = block[jno5];
-    pinsrw %35, word [r12 + %15 * SIZEOF_WORD], 5  ; xmm_shadow[13] = block[jno13];
-    pinsrw %36, word [r12 + %23 * SIZEOF_WORD], 5  ; xmm_shadow[21] = block[jno21];
-    pinsrw %37, word [r12 + %31 * SIZEOF_WORD], 5  ; xmm_shadow[29] = block[jno29];
-    pinsrw %34, word [r12 + %8  * SIZEOF_WORD], 6  ; xmm_shadow[6] = block[jno6];
-    pinsrw %35, word [r12 + %16 * SIZEOF_WORD], 6  ; xmm_shadow[14] = block[jno14];
-    pinsrw %36, word [r12 + %24 * SIZEOF_WORD], 6  ; xmm_shadow[22] = block[jno22];
-    pinsrw %37, word [r12 + %32 * SIZEOF_WORD], 6  ; xmm_shadow[30] = block[jno30];
-    pinsrw %34, word [r12 + %9  * SIZEOF_WORD], 7  ; xmm_shadow[7] = block[jno7];
-    pinsrw %35, word [r12 + %17 * SIZEOF_WORD], 7  ; xmm_shadow[15] = block[jno15];
-    pinsrw %36, word [r12 + %25 * SIZEOF_WORD], 7  ; xmm_shadow[23] = block[jno23];
-%if %1 != 32
-    pinsrw %37, word [r12 + %33 * SIZEOF_WORD], 7  ; xmm_shadow[31] = block[jno31];
-%else
-    pinsrw %37, ebx, 7  ; xmm_shadow[31] = block[jno31];
-%endif
-    pcmpgtw xmm8, %34  ; neg = _mm_cmpgt_epi16(neg, x1);
-    pcmpgtw xmm9, %35  ; neg = _mm_cmpgt_epi16(neg, x1);
-    pcmpgtw xmm10, %36  ; neg = _mm_cmpgt_epi16(neg, x1);
-    pcmpgtw xmm11, %37  ; neg = _mm_cmpgt_epi16(neg, x1);
-    paddw %34, xmm8   ; x1 = _mm_add_epi16(x1, neg);
-    paddw %35, xmm9   ; x1 = _mm_add_epi16(x1, neg);
-    paddw %36, xmm10  ; x1 = _mm_add_epi16(x1, neg);
-    paddw %37, xmm11  ; x1 = _mm_add_epi16(x1, neg);
-    pxor %34, xmm8    ; x1 = _mm_xor_si128(x1, neg);
-    pxor %35, xmm9    ; x1 = _mm_xor_si128(x1, neg);
-    pxor %36, xmm10   ; x1 = _mm_xor_si128(x1, neg);
-    pxor %37, xmm11   ; x1 = _mm_xor_si128(x1, neg);
-    pxor xmm8, %34    ; neg = _mm_xor_si128(neg, x1);
-    pxor xmm9, %35    ; neg = _mm_xor_si128(neg, x1);
-    pxor xmm10, %36   ; neg = _mm_xor_si128(neg, x1);
-    pxor xmm11, %37   ; neg = _mm_xor_si128(neg, x1);
-    movdqa XMMWORD [t1 + %1 * SIZEOF_WORD], %34  ; _mm_storeu_si128((__m128i *)(t1 + ko), x1);
-    movdqa XMMWORD [t1 + (%1 + 8) * SIZEOF_WORD], %35  ; _mm_storeu_si128((__m128i *)(t1 + ko + 8), x1);
-    movdqa XMMWORD [t1 + (%1 + 16) * SIZEOF_WORD], %36  ; _mm_storeu_si128((__m128i *)(t1 + ko + 16), x1);
-    movdqa XMMWORD [t1 + (%1 + 24) * SIZEOF_WORD], %37  ; _mm_storeu_si128((__m128i *)(t1 + ko + 24), x1);
-    movdqa XMMWORD [t2 + %1 * SIZEOF_WORD], xmm8  ; _mm_storeu_si128((__m128i *)(t2 + ko), neg);
-    movdqa XMMWORD [t2 + (%1 + 8) * SIZEOF_WORD], xmm9  ; _mm_storeu_si128((__m128i *)(t2 + ko + 8), neg);
-    movdqa XMMWORD [t2 + (%1 + 16) * SIZEOF_WORD], xmm10  ; _mm_storeu_si128((__m128i *)(t2 + ko + 16), neg);
-    movdqa XMMWORD [t2 + (%1 + 24) * SIZEOF_WORD], xmm11  ; _mm_storeu_si128((__m128i *)(t2 + ko + 24), neg);
-%endmacro
-
-;
-; Encode a single block's worth of coefficients.
-;
-; GLOBAL(JOCTET*)
-; jsimd_huff_encode_one_block_sse2 (working_state *state, JOCTET *buffer,
-;                                   JCOEFPTR block, int last_dc_val,
-;                                   c_derived_tbl *dctbl, c_derived_tbl *actbl)
-;
-
-; r10 = working_state *state
-; r11 = JOCTET *buffer
-; r12 = JCOEFPTR block
-; r13 = int last_dc_val
-; r14 = c_derived_tbl *dctbl
-; r15 = c_derived_tbl *actbl
-
-%define t1              rbp-(DCTSIZE2*SIZEOF_WORD)
-%define t2              t1-(DCTSIZE2*SIZEOF_WORD)
-%define put_buffer      r8
-%define put_bits        r9d
-%define buffer          rax
-
-        align   16
-        global  EXTN(jsimd_huff_encode_one_block_sse2)
-
-EXTN(jsimd_huff_encode_one_block_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [t2]
-        collect_args
-%ifdef WIN64
-        movaps  XMMWORD [rsp-1*SIZEOF_XMMWORD], xmm8
-        movaps  XMMWORD [rsp-2*SIZEOF_XMMWORD], xmm9
-        movaps  XMMWORD [rsp-3*SIZEOF_XMMWORD], xmm10
-        movaps  XMMWORD [rsp-4*SIZEOF_XMMWORD], xmm11
-        sub     rsp, 4*SIZEOF_XMMWORD
-%endif
-        push rbx
-
-        mov buffer, r11  ; r11 is now sratch
-
-        mov put_buffer, MMWORD [r10+16]  ; put_buffer = state->cur.put_buffer;
-        mov put_bits,    DWORD [r10+24]  ; put_bits = state->cur.put_bits;
-        push r10  ; r10 is now scratch
-
-        ; Encode the DC coefficient difference per section F.1.2.1
-        movsx edi, word [r12]  ; temp = temp2 = block[0] - last_dc_val;
-        sub   edi, r13d  ; r13 is not used anymore
-        mov   ebx, edi
-
-        ; This is a well-known technique for obtaining the absolute value
-        ; without a branch.  It is derived from an assembly language technique
-        ; presented in "How to Optimize for the Pentium Processors",
-        ; Copyright (c) 1996, 1997 by Agner Fog.
-        mov esi, edi
-        sar esi, 31   ; temp3 = temp >> (CHAR_BIT * sizeof(int) - 1);
-        xor edi, esi  ; temp ^= temp3;
-        sub edi, esi  ; temp -= temp3;
-
-        ; For a negative input, want temp2 = bitwise complement of abs(input)
-        ; This code assumes we are on a two's complement machine
-        add ebx, esi  ; temp2 += temp3;
-
-        ; Find the number of bits needed for the magnitude of the coefficient
-        lea   r11, [rel jpeg_nbits_table]
-        movzx rdi, byte [r11 + rdi]  ; nbits = JPEG_NBITS(temp);
-        ; Emit the Huffman-coded symbol for the number of bits
-        mov   r11d,  INT [r14 + rdi * 4]  ; code = dctbl->ehufco[nbits];
-        movzx  esi, byte [r14 + rdi + 1024]  ; size = dctbl->ehufsi[nbits];
-        EMIT_BITS r11, esi  ; EMIT_BITS(code, size)
-
-        ; Mask off any extra bits in code
-        mov esi, 1
-        mov ecx, edi
-        shl esi, cl
-        dec esi
-        and ebx, esi  ; temp2 &= (((JLONG) 1)<<nbits) - 1;
-
-        ; Emit that number of bits of the value, if positive,
-        ; or the complement of its magnitude, if negative.
-        EMIT_BITS rbx, edi  ; EMIT_BITS(temp2, nbits)
-
-        ; Prepare data
-        xor ebx, ebx
-        kloop_prepare  0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, \
-                       18, 11, 4,  5,  12, 19, 26, 33, 40, 48, 41, 34, \
-                       27, 20, 13, 6,  7,  14, 21, 28, 35, \
-                       xmm0, xmm1, xmm2, xmm3
-        kloop_prepare  32, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, \
-                       30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, \
-                       53, 60, 61, 54, 47, 55, 62, 63, 63, \
-                       xmm4, xmm5, xmm6, xmm7
-
-        pxor xmm8, xmm8
-        pcmpeqw xmm0, xmm8  ; tmp0 = _mm_cmpeq_epi16(tmp0, zero);
-        pcmpeqw xmm1, xmm8  ; tmp1 = _mm_cmpeq_epi16(tmp1, zero);
-        pcmpeqw xmm2, xmm8  ; tmp2 = _mm_cmpeq_epi16(tmp2, zero);
-        pcmpeqw xmm3, xmm8  ; tmp3 = _mm_cmpeq_epi16(tmp3, zero);
-        pcmpeqw xmm4, xmm8  ; tmp4 = _mm_cmpeq_epi16(tmp4, zero);
-        pcmpeqw xmm5, xmm8  ; tmp5 = _mm_cmpeq_epi16(tmp5, zero);
-        pcmpeqw xmm6, xmm8  ; tmp6 = _mm_cmpeq_epi16(tmp6, zero);
-        pcmpeqw xmm7, xmm8  ; tmp7 = _mm_cmpeq_epi16(tmp7, zero);
-        packsswb xmm0, xmm1  ; tmp0 = _mm_packs_epi16(tmp0, tmp1);
-        packsswb xmm2, xmm3  ; tmp2 = _mm_packs_epi16(tmp2, tmp3);
-        packsswb xmm4, xmm5  ; tmp4 = _mm_packs_epi16(tmp4, tmp5);
-        packsswb xmm6, xmm7  ; tmp6 = _mm_packs_epi16(tmp6, tmp7);
-        pmovmskb r11d, xmm0  ; index  = ((uint64_t)_mm_movemask_epi8(tmp0)) << 0;
-        pmovmskb r12d, xmm2  ; index  = ((uint64_t)_mm_movemask_epi8(tmp2)) << 16;
-        pmovmskb r13d, xmm4  ; index  = ((uint64_t)_mm_movemask_epi8(tmp4)) << 32;
-        pmovmskb r14d, xmm6  ; index  = ((uint64_t)_mm_movemask_epi8(tmp6)) << 48;
-        shl r12, 16
-        shl r14, 16
-        or  r11, r12
-        or  r13, r14
-        shl r13, 32
-        or  r11, r13
-        not r11  ; index = ~index;
-
-        ;mov MMWORD [ t1 + DCTSIZE2 * SIZEOF_WORD ], r11
-        ;jmp .EFN
-
-        mov   r13d,  INT [r15 + 240 * 4]  ; code_0xf0 = actbl->ehufco[0xf0];
-        movzx r14d, byte [r15 + 1024 + 240]  ; size_0xf0 = actbl->ehufsi[0xf0];
-        lea rsi, [t1]
-.BLOOP:
-        bsf r12, r11  ; r = __builtin_ctzl(index);
-        jz .ELOOP
-        mov rcx, r12
-        lea rsi, [rsi+r12*2]  ; k += r;
-        shr r11, cl  ; index >>= r;
-        movzx rdi, word [rsi]  ; temp = t1[k];
-        lea   rbx, [rel jpeg_nbits_table]
-        movzx rdi, byte [rbx + rdi]  ; nbits = JPEG_NBITS(temp);
-.BRLOOP:
-        cmp r12, 16  ; while (r > 15) {
-        jl .ERLOOP
-        EMIT_BITS r13, r14d  ; EMIT_BITS(code_0xf0, size_0xf0)
-        sub r12, 16  ; r -= 16;
-        jmp .BRLOOP
-.ERLOOP:
-        ; Emit Huffman symbol for run length / number of bits
-        CHECKBUF31  ; uses rcx, rdx
-
-        shl r12, 4  ; temp3 = (r << 4) + nbits;
-        add r12, rdi
-        mov   ebx,  INT [r15 + r12 * 4]  ; code = actbl->ehufco[temp3];
-        movzx ecx, byte [r15 + r12 + 1024]  ; size = actbl->ehufsi[temp3];
-        PUT_BITS rbx
-
-        ;EMIT_CODE(code, size)
-
-        movsx ebx, word [rsi-DCTSIZE2*2]  ; temp2 = t2[k];
-        ; Mask off any extra bits in code
-        mov rcx, rdi
-        mov rdx, 1
-        shl rdx, cl
-        dec rdx
-        and rbx, rdx  ; temp2 &= (((JLONG) 1)<<nbits) - 1;
-        PUT_BITS rbx  ; PUT_BITS(temp2, nbits)
-
-        shr r11, 1  ; index >>= 1;
-        add rsi, 2  ; ++k;
-        jmp .BLOOP
-.ELOOP:
-        ; If the last coef(s) were zero, emit an end-of-block code
-        lea rdi, [t1 + (DCTSIZE2-1) * 2]  ; r = DCTSIZE2-1-k;
-        cmp rdi, rsi  ; if (r > 0) {
-        je .EFN
-        mov   ebx,  INT [r15]  ; code = actbl->ehufco[0];
-        movzx r12d, byte [r15 + 1024]  ; size = actbl->ehufsi[0];
-        EMIT_BITS rbx, r12d
-.EFN:
-        pop r10
-        ; Save put_buffer & put_bits
-        mov MMWORD [r10+16], put_buffer  ; state->cur.put_buffer = put_buffer;
-        mov DWORD  [r10+24], put_bits  ; state->cur.put_bits = put_bits;
-
-        pop rbx
-%ifdef WIN64
-        movaps  xmm11, XMMWORD [rsp+0*SIZEOF_XMMWORD]
-        movaps  xmm10, XMMWORD [rsp+1*SIZEOF_XMMWORD]
-        movaps  xmm9, XMMWORD [rsp+2*SIZEOF_XMMWORD]
-        movaps  xmm8, XMMWORD [rsp+3*SIZEOF_XMMWORD]
-        add     rsp, 4*SIZEOF_XMMWORD
-%endif
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jchuff-sse2.asm b/simd/jchuff-sse2.asm
deleted file mode 100644
index 36d1f2d..0000000
--- a/simd/jchuff-sse2.asm
+++ /dev/null
@@ -1,426 +0,0 @@
-;
-; jchuff-sse2.asm - Huffman entropy encoding (SSE2)
-;
-; Copyright (C) 2009-2011, 2014-2016, D. R. Commander.
-; Copyright (C) 2015, Matthieu Darbois.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains an SSE2 implementation for Huffman coding of one block.
-; The following code is based directly on jchuff.c; see jchuff.c for more
-; details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_huff_encode_one_block)
-
-EXTN(jconst_huff_encode_one_block):
-
-%include "jpeg_nbits_table.inc"
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-
-; These macros perform the same task as the emit_bits() function in the
-; original libjpeg code.  In addition to reducing overhead by explicitly
-; inlining the code, additional performance is achieved by taking into
-; account the size of the bit buffer and waiting until it is almost full
-; before emptying it.  This mostly benefits 64-bit platforms, since 6
-; bytes can be stored in a 64-bit bit buffer before it has to be emptied.
-
-%macro EMIT_BYTE 0
-        sub put_bits, 8  ; put_bits -= 8;
-        mov edx, put_buffer
-        mov ecx, put_bits
-        shr edx, cl  ; c = (JOCTET)GETJOCTET(put_buffer >> put_bits);
-        mov byte [eax], dl  ; *buffer++ = c;
-        add eax, 1
-        cmp dl, 0xFF  ; need to stuff a zero byte?
-        jne %%.EMIT_BYTE_END
-        mov byte [eax], 0  ; *buffer++ = 0;
-        add eax, 1
-%%.EMIT_BYTE_END:
-%endmacro
-
-%macro PUT_BITS 1
-        add put_bits, ecx  ; put_bits += size;
-        shl put_buffer, cl  ; put_buffer = (put_buffer << size);
-        or  put_buffer, %1
-%endmacro
-
-%macro CHECKBUF15 0
-        cmp put_bits, 16  ; if (put_bits > 31) {
-        jl %%.CHECKBUF15_END
-        mov eax, POINTER [esp+buffer]
-        EMIT_BYTE
-        EMIT_BYTE
-        mov POINTER [esp+buffer], eax
-%%.CHECKBUF15_END:
-%endmacro
-
-%macro EMIT_BITS 1
-        PUT_BITS %1
-        CHECKBUF15
-%endmacro
-
-%macro kloop_prepare 37  ;(ko, jno0, ..., jno31, xmm0, xmm1, xmm2, xmm3)
-    pxor xmm4, xmm4  ; __m128i neg = _mm_setzero_si128();
-    pxor xmm5, xmm5  ; __m128i neg = _mm_setzero_si128();
-    pxor xmm6, xmm6  ; __m128i neg = _mm_setzero_si128();
-    pxor xmm7, xmm7  ; __m128i neg = _mm_setzero_si128();
-    pinsrw %34, word [esi + %2  * SIZEOF_WORD], 0  ; xmm_shadow[0] = block[jno0];
-    pinsrw %35, word [esi + %10 * SIZEOF_WORD], 0  ; xmm_shadow[8] = block[jno8];
-    pinsrw %36, word [esi + %18 * SIZEOF_WORD], 0  ; xmm_shadow[16] = block[jno16];
-    pinsrw %37, word [esi + %26 * SIZEOF_WORD], 0  ; xmm_shadow[24] = block[jno24];
-    pinsrw %34, word [esi + %3  * SIZEOF_WORD], 1  ; xmm_shadow[1] = block[jno1];
-    pinsrw %35, word [esi + %11 * SIZEOF_WORD], 1  ; xmm_shadow[9] = block[jno9];
-    pinsrw %36, word [esi + %19 * SIZEOF_WORD], 1  ; xmm_shadow[17] = block[jno17];
-    pinsrw %37, word [esi + %27 * SIZEOF_WORD], 1  ; xmm_shadow[25] = block[jno25];
-    pinsrw %34, word [esi + %4  * SIZEOF_WORD], 2  ; xmm_shadow[2] = block[jno2];
-    pinsrw %35, word [esi + %12 * SIZEOF_WORD], 2  ; xmm_shadow[10] = block[jno10];
-    pinsrw %36, word [esi + %20 * SIZEOF_WORD], 2  ; xmm_shadow[18] = block[jno18];
-    pinsrw %37, word [esi + %28 * SIZEOF_WORD], 2  ; xmm_shadow[26] = block[jno26];
-    pinsrw %34, word [esi + %5  * SIZEOF_WORD], 3  ; xmm_shadow[3] = block[jno3];
-    pinsrw %35, word [esi + %13 * SIZEOF_WORD], 3  ; xmm_shadow[11] = block[jno11];
-    pinsrw %36, word [esi + %21 * SIZEOF_WORD], 3  ; xmm_shadow[19] = block[jno19];
-    pinsrw %37, word [esi + %29 * SIZEOF_WORD], 3  ; xmm_shadow[27] = block[jno27];
-    pinsrw %34, word [esi + %6  * SIZEOF_WORD], 4  ; xmm_shadow[4] = block[jno4];
-    pinsrw %35, word [esi + %14 * SIZEOF_WORD], 4  ; xmm_shadow[12] = block[jno12];
-    pinsrw %36, word [esi + %22 * SIZEOF_WORD], 4  ; xmm_shadow[20] = block[jno20];
-    pinsrw %37, word [esi + %30 * SIZEOF_WORD], 4  ; xmm_shadow[28] = block[jno28];
-    pinsrw %34, word [esi + %7  * SIZEOF_WORD], 5  ; xmm_shadow[5] = block[jno5];
-    pinsrw %35, word [esi + %15 * SIZEOF_WORD], 5  ; xmm_shadow[13] = block[jno13];
-    pinsrw %36, word [esi + %23 * SIZEOF_WORD], 5  ; xmm_shadow[21] = block[jno21];
-    pinsrw %37, word [esi + %31 * SIZEOF_WORD], 5  ; xmm_shadow[29] = block[jno29];
-    pinsrw %34, word [esi + %8  * SIZEOF_WORD], 6  ; xmm_shadow[6] = block[jno6];
-    pinsrw %35, word [esi + %16 * SIZEOF_WORD], 6  ; xmm_shadow[14] = block[jno14];
-    pinsrw %36, word [esi + %24 * SIZEOF_WORD], 6  ; xmm_shadow[22] = block[jno22];
-    pinsrw %37, word [esi + %32 * SIZEOF_WORD], 6  ; xmm_shadow[30] = block[jno30];
-    pinsrw %34, word [esi + %9  * SIZEOF_WORD], 7  ; xmm_shadow[7] = block[jno7];
-    pinsrw %35, word [esi + %17 * SIZEOF_WORD], 7  ; xmm_shadow[15] = block[jno15];
-    pinsrw %36, word [esi + %25 * SIZEOF_WORD], 7  ; xmm_shadow[23] = block[jno23];
-%if %1 != 32
-    pinsrw %37, word [esi + %33 * SIZEOF_WORD], 7  ; xmm_shadow[31] = block[jno31];
-%else
-    pinsrw %37, ecx, 7  ; xmm_shadow[31] = block[jno31];
-%endif
-    pcmpgtw xmm4, %34  ; neg = _mm_cmpgt_epi16(neg, x1);
-    pcmpgtw xmm5, %35  ; neg = _mm_cmpgt_epi16(neg, x1);
-    pcmpgtw xmm6, %36  ; neg = _mm_cmpgt_epi16(neg, x1);
-    pcmpgtw xmm7, %37  ; neg = _mm_cmpgt_epi16(neg, x1);
-    paddw %34, xmm4   ; x1 = _mm_add_epi16(x1, neg);
-    paddw %35, xmm5   ; x1 = _mm_add_epi16(x1, neg);
-    paddw %36, xmm6  ; x1 = _mm_add_epi16(x1, neg);
-    paddw %37, xmm7  ; x1 = _mm_add_epi16(x1, neg);
-    pxor %34, xmm4    ; x1 = _mm_xor_si128(x1, neg);
-    pxor %35, xmm5    ; x1 = _mm_xor_si128(x1, neg);
-    pxor %36, xmm6   ; x1 = _mm_xor_si128(x1, neg);
-    pxor %37, xmm7   ; x1 = _mm_xor_si128(x1, neg);
-    pxor xmm4, %34    ; neg = _mm_xor_si128(neg, x1);
-    pxor xmm5, %35    ; neg = _mm_xor_si128(neg, x1);
-    pxor xmm6, %36   ; neg = _mm_xor_si128(neg, x1);
-    pxor xmm7, %37   ; neg = _mm_xor_si128(neg, x1);
-    movdqa XMMWORD [esp + t1 + %1 * SIZEOF_WORD], %34  ; _mm_storeu_si128((__m128i *)(t1 + ko), x1);
-    movdqa XMMWORD [esp + t1 + (%1 + 8) * SIZEOF_WORD], %35  ; _mm_storeu_si128((__m128i *)(t1 + ko + 8), x1);
-    movdqa XMMWORD [esp + t1 + (%1 + 16) * SIZEOF_WORD], %36  ; _mm_storeu_si128((__m128i *)(t1 + ko + 16), x1);
-    movdqa XMMWORD [esp + t1 + (%1 + 24) * SIZEOF_WORD], %37  ; _mm_storeu_si128((__m128i *)(t1 + ko + 24), x1);
-    movdqa XMMWORD [esp + t2 + %1 * SIZEOF_WORD], xmm4  ; _mm_storeu_si128((__m128i *)(t2 + ko), neg);
-    movdqa XMMWORD [esp + t2 + (%1 + 8) * SIZEOF_WORD], xmm5  ; _mm_storeu_si128((__m128i *)(t2 + ko + 8), neg);
-    movdqa XMMWORD [esp + t2 + (%1 + 16) * SIZEOF_WORD], xmm6  ; _mm_storeu_si128((__m128i *)(t2 + ko + 16), neg);
-    movdqa XMMWORD [esp + t2 + (%1 + 24) * SIZEOF_WORD], xmm7  ; _mm_storeu_si128((__m128i *)(t2 + ko + 24), neg);
-%endmacro
-
-;
-; Encode a single block's worth of coefficients.
-;
-; GLOBAL(JOCTET*)
-; jsimd_huff_encode_one_block_sse2 (working_state *state, JOCTET *buffer,
-;                                   JCOEFPTR block, int last_dc_val,
-;                                   c_derived_tbl *dctbl, c_derived_tbl *actbl)
-;
-
-; eax + 8 = working_state *state
-; eax + 12 = JOCTET *buffer
-; eax + 16 = JCOEFPTR block
-; eax + 20 = int last_dc_val
-; eax + 24 = c_derived_tbl *dctbl
-; eax + 28 = c_derived_tbl *actbl
-
-%define pad             6*SIZEOF_DWORD  ; Align to 16 bytes
-%define t1              pad
-%define t2              t1+(DCTSIZE2*SIZEOF_WORD)
-%define block           t2+(DCTSIZE2*SIZEOF_WORD)
-%define actbl           block+SIZEOF_DWORD
-%define buffer          actbl+SIZEOF_DWORD
-%define temp            buffer+SIZEOF_DWORD
-%define temp2           temp+SIZEOF_DWORD
-%define temp3           temp2+SIZEOF_DWORD
-%define temp4           temp3+SIZEOF_DWORD
-%define temp5           temp4+SIZEOF_DWORD
-%define gotptr          temp5+SIZEOF_DWORD  ; void *gotptr
-%define put_buffer      ebx
-%define put_bits        edi
-
-        align   16
-        global  EXTN(jsimd_huff_encode_one_block_sse2)
-
-EXTN(jsimd_huff_encode_one_block_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        sub     esp, temp5+9*SIZEOF_DWORD-pad
-        push    ebx
-        push    ecx
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-        push    ebp
-
-        mov esi, POINTER [eax+8]        ; (working_state *state)
-        mov put_buffer,  DWORD [esi+8]  ; put_buffer = state->cur.put_buffer;
-        mov put_bits,    DWORD [esi+12]  ; put_bits = state->cur.put_bits;
-        push esi  ; esi is now scratch
-
-        get_GOT edx                       ; get GOT address
-        movpic POINTER [esp+gotptr], edx  ; save GOT address
-
-        mov ecx, POINTER [eax+28]
-        mov edx, POINTER [eax+16]
-        mov esi, POINTER [eax+12]
-        mov POINTER [esp+actbl],  ecx
-        mov POINTER [esp+block],  edx
-        mov POINTER [esp+buffer], esi
-
-        ; Encode the DC coefficient difference per section F.1.2.1
-        mov esi, POINTER [esp+block]        ; block
-        movsx ecx, word [esi]  ; temp = temp2 = block[0] - last_dc_val;
-        sub   ecx, DWORD [eax+20]
-        mov   esi, ecx
-
-        ; This is a well-known technique for obtaining the absolute value
-        ; without a branch.  It is derived from an assembly language technique
-        ; presented in "How to Optimize for the Pentium Processors",
-        ; Copyright (c) 1996, 1997 by Agner Fog.
-        mov edx, ecx
-        sar edx, 31   ; temp3 = temp >> (CHAR_BIT * sizeof(int) - 1);
-        xor ecx, edx ; temp ^= temp3;
-        sub ecx, edx ; temp -= temp3;
-
-        ; For a negative input, want temp2 = bitwise complement of abs(input)
-        ; This code assumes we are on a two's complement machine
-        add esi, edx  ; temp2 += temp3;
-        mov DWORD [esp+temp], esi  ; backup temp2 in temp
-
-        ; Find the number of bits needed for the magnitude of the coefficient
-        movpic ebp, POINTER [esp+gotptr]   ; load GOT address (ebp)
-        movzx edx, byte [GOTOFF(ebp, jpeg_nbits_table + ecx)]  ; nbits = JPEG_NBITS(temp);
-        mov DWORD [esp+temp2], edx  ; backup nbits in temp2
-
-        ; Emit the Huffman-coded symbol for the number of bits
-        mov    ebp, POINTER [eax+24]  ; After this point, arguments are not accessible anymore
-        mov    eax,  INT [ebp + edx * 4]  ; code = dctbl->ehufco[nbits];
-        movzx  ecx, byte [ebp + edx + 1024]  ; size = dctbl->ehufsi[nbits];
-        EMIT_BITS eax  ; EMIT_BITS(code, size)
-
-        mov ecx, DWORD [esp+temp2]  ; restore nbits
-
-        ; Mask off any extra bits in code
-        mov eax, 1
-        shl eax, cl
-        dec eax
-        and eax, DWORD [esp+temp]  ; temp2 &= (((JLONG) 1)<<nbits) - 1;
-
-        ; Emit that number of bits of the value, if positive,
-        ; or the complement of its magnitude, if negative.
-        EMIT_BITS eax  ; EMIT_BITS(temp2, nbits)
-
-        ; Prepare data
-        xor ecx, ecx
-        mov esi, POINTER [esp+block]
-        kloop_prepare  0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, \
-                       18, 11, 4,  5,  12, 19, 26, 33, 40, 48, 41, 34, \
-                       27, 20, 13, 6,  7,  14, 21, 28, 35, \
-                       xmm0, xmm1, xmm2, xmm3
-        kloop_prepare  32, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, \
-                       30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, \
-                       53, 60, 61, 54, 47, 55, 62, 63, 63, \
-                       xmm0, xmm1, xmm2, xmm3
-
-        pxor xmm7, xmm7
-        movdqa xmm0, XMMWORD [esp + t1 + 0 * SIZEOF_WORD]   ; __m128i tmp0 = _mm_loadu_si128((__m128i *)(t1 + 0));
-        movdqa xmm1, XMMWORD [esp + t1 + 8 * SIZEOF_WORD]   ; __m128i tmp1 = _mm_loadu_si128((__m128i *)(t1 + 8));
-        movdqa xmm2, XMMWORD [esp + t1 + 16 * SIZEOF_WORD]  ; __m128i tmp2 = _mm_loadu_si128((__m128i *)(t1 + 16));
-        movdqa xmm3, XMMWORD [esp + t1 + 24 * SIZEOF_WORD]  ; __m128i tmp3 = _mm_loadu_si128((__m128i *)(t1 + 24));
-        pcmpeqw xmm0, xmm7  ; tmp0 = _mm_cmpeq_epi16(tmp0, zero);
-        pcmpeqw xmm1, xmm7  ; tmp1 = _mm_cmpeq_epi16(tmp1, zero);
-        pcmpeqw xmm2, xmm7  ; tmp2 = _mm_cmpeq_epi16(tmp2, zero);
-        pcmpeqw xmm3, xmm7  ; tmp3 = _mm_cmpeq_epi16(tmp3, zero);
-        packsswb xmm0, xmm1  ; tmp0 = _mm_packs_epi16(tmp0, tmp1);
-        packsswb xmm2, xmm3  ; tmp2 = _mm_packs_epi16(tmp2, tmp3);
-        pmovmskb edx, xmm0  ; index  = ((uint64_t)_mm_movemask_epi8(tmp0)) << 0;
-        pmovmskb ecx, xmm2  ; index  = ((uint64_t)_mm_movemask_epi8(tmp2)) << 16;
-        shl ecx, 16
-        or  edx, ecx
-        not edx  ; index = ~index;
-
-        lea esi, [esp+t1]
-        mov ebp, POINTER [esp+actbl]  ; ebp = actbl
-
-.BLOOP:
-        bsf ecx, edx  ; r = __builtin_ctzl(index);
-        jz .ELOOP
-        lea esi, [esi+ecx*2]  ; k += r;
-        shr edx, cl  ; index >>= r;
-        mov DWORD [esp+temp3], edx
-.BRLOOP:
-        cmp ecx, 16  ; while (r > 15) {
-        jl .ERLOOP
-        sub ecx, 16 ; r -= 16;
-        mov DWORD [esp+temp], ecx
-        mov   eax, INT [ebp + 240 * 4]  ; code_0xf0 = actbl->ehufco[0xf0];
-        movzx ecx, byte [ebp + 1024 + 240]  ; size_0xf0 = actbl->ehufsi[0xf0];
-        EMIT_BITS eax  ; EMIT_BITS(code_0xf0, size_0xf0)
-        mov ecx, DWORD [esp+temp]
-        jmp .BRLOOP
-.ERLOOP:
-        movsx eax, word [esi]  ; temp = t1[k];
-        movpic edx, POINTER [esp+gotptr]   ; load GOT address (edx)
-        movzx eax, byte [GOTOFF(edx, jpeg_nbits_table + eax)]  ; nbits = JPEG_NBITS(temp);
-        mov DWORD [esp+temp2], eax
-        ; Emit Huffman symbol for run length / number of bits
-        shl ecx, 4  ; temp3 = (r << 4) + nbits;
-        add ecx, eax
-        mov   eax,  INT [ebp + ecx * 4]  ; code = actbl->ehufco[temp3];
-        movzx ecx, byte [ebp + ecx + 1024]  ; size = actbl->ehufsi[temp3];
-        EMIT_BITS eax
-
-        movsx edx, word [esi+DCTSIZE2*2]  ; temp2 = t2[k];
-        ; Mask off any extra bits in code
-        mov ecx, DWORD [esp+temp2]
-        mov eax, 1
-        shl eax, cl
-        dec eax
-        and eax, edx  ; temp2 &= (((JLONG) 1)<<nbits) - 1;
-        EMIT_BITS eax  ; PUT_BITS(temp2, nbits)
-        mov edx, DWORD [esp+temp3]
-        add esi, 2  ; ++k;
-        shr edx, 1  ; index >>= 1;
-
-        jmp .BLOOP
-.ELOOP:
-        movdqa xmm0, XMMWORD [esp + t1 + 32 * SIZEOF_WORD]  ; __m128i tmp0 = _mm_loadu_si128((__m128i *)(t1 + 0));
-        movdqa xmm1, XMMWORD [esp + t1 + 40 * SIZEOF_WORD]  ; __m128i tmp1 = _mm_loadu_si128((__m128i *)(t1 + 8));
-        movdqa xmm2, XMMWORD [esp + t1 + 48 * SIZEOF_WORD]  ; __m128i tmp2 = _mm_loadu_si128((__m128i *)(t1 + 16));
-        movdqa xmm3, XMMWORD [esp + t1 + 56 * SIZEOF_WORD]  ; __m128i tmp3 = _mm_loadu_si128((__m128i *)(t1 + 24));
-        pcmpeqw xmm0, xmm7  ; tmp0 = _mm_cmpeq_epi16(tmp0, zero);
-        pcmpeqw xmm1, xmm7  ; tmp1 = _mm_cmpeq_epi16(tmp1, zero);
-        pcmpeqw xmm2, xmm7  ; tmp2 = _mm_cmpeq_epi16(tmp2, zero);
-        pcmpeqw xmm3, xmm7  ; tmp3 = _mm_cmpeq_epi16(tmp3, zero);
-        packsswb xmm0, xmm1  ; tmp0 = _mm_packs_epi16(tmp0, tmp1);
-        packsswb xmm2, xmm3  ; tmp2 = _mm_packs_epi16(tmp2, tmp3);
-        pmovmskb edx, xmm0  ; index  = ((uint64_t)_mm_movemask_epi8(tmp0)) << 0;
-        pmovmskb ecx, xmm2  ; index  = ((uint64_t)_mm_movemask_epi8(tmp2)) << 16;
-        shl ecx, 16
-        or  edx, ecx
-        not edx  ; index = ~index;
-
-        lea eax, [esp + t1 + (DCTSIZE2/2) * 2]
-        sub eax, esi
-        shr eax, 1
-        bsf ecx, edx  ; r = __builtin_ctzl(index);
-        jz .ELOOP2
-        shr edx, cl  ; index >>= r;
-        add ecx, eax
-        lea esi, [esi+ecx*2]  ; k += r;
-        mov DWORD [esp+temp3], edx
-        jmp .BRLOOP2
-.BLOOP2:
-        bsf ecx, edx  ; r = __builtin_ctzl(index);
-        jz .ELOOP2
-        lea esi, [esi+ecx*2]  ; k += r;
-        shr edx, cl  ; index >>= r;
-        mov DWORD [esp+temp3], edx
-.BRLOOP2:
-        cmp ecx, 16  ; while (r > 15) {
-        jl .ERLOOP2
-        sub ecx, 16  ; r -= 16;
-        mov DWORD [esp+temp], ecx
-        mov   eax, INT [ebp + 240 * 4]  ; code_0xf0 = actbl->ehufco[0xf0];
-        movzx ecx, byte [ebp + 1024 + 240]  ; size_0xf0 = actbl->ehufsi[0xf0];
-        EMIT_BITS eax  ; EMIT_BITS(code_0xf0, size_0xf0)
-        mov ecx, DWORD [esp+temp]
-        jmp .BRLOOP2
-.ERLOOP2:
-        movsx eax, word [esi]  ; temp = t1[k];
-        bsr eax, eax  ; nbits = 32 - __builtin_clz(temp);
-        inc eax
-        mov DWORD [esp+temp2], eax
-        ; Emit Huffman symbol for run length / number of bits
-        shl ecx, 4  ; temp3 = (r << 4) + nbits;
-        add ecx, eax
-        mov   eax,  INT [ebp + ecx * 4]  ; code = actbl->ehufco[temp3];
-        movzx ecx, byte [ebp + ecx + 1024]  ; size = actbl->ehufsi[temp3];
-        EMIT_BITS eax
-
-        movsx edx, word [esi+DCTSIZE2*2]  ; temp2 = t2[k];
-        ; Mask off any extra bits in code
-        mov ecx, DWORD [esp+temp2]
-        mov eax, 1
-        shl eax, cl
-        dec eax
-        and eax, edx  ; temp2 &= (((JLONG) 1)<<nbits) - 1;
-        EMIT_BITS eax  ; PUT_BITS(temp2, nbits)
-        mov edx, DWORD [esp+temp3]
-        add esi, 2  ; ++k;
-        shr edx, 1  ; index >>= 1;
-
-        jmp .BLOOP2
-.ELOOP2:
-        ; If the last coef(s) were zero, emit an end-of-block code
-        lea edx, [esp + t1 + (DCTSIZE2-1) * 2]  ; r = DCTSIZE2-1-k;
-        cmp edx, esi  ; if (r > 0) {
-        je .EFN
-        mov   eax,  INT [ebp]  ; code = actbl->ehufco[0];
-        movzx ecx, byte [ebp + 1024]  ; size = actbl->ehufsi[0];
-        EMIT_BITS eax
-.EFN:
-        mov eax, [esp+buffer]
-        pop esi
-        ; Save put_buffer & put_bits
-        mov DWORD [esi+8], put_buffer  ; state->cur.put_buffer = put_buffer;
-        mov DWORD [esi+12], put_bits  ; state->cur.put_bits = put_bits;
-
-        pop     ebp
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-        pop     ecx
-        pop     ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jcsample-sse2-64.asm b/simd/jcsample-sse2-64.asm
deleted file mode 100644
index 40ee15f..0000000
--- a/simd/jcsample-sse2-64.asm
+++ /dev/null
@@ -1,329 +0,0 @@
-;
-; jcsample.asm - downsampling (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Downsample pixel values of a single component.
-; This version handles the common case of 2:1 horizontal and 1:1 vertical,
-; without smoothing.
-;
-; GLOBAL(void)
-; jsimd_h2v1_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
-;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
-;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
-;
-
-; r10 = JDIMENSION image_width
-; r11 = int max_v_samp_factor
-; r12 = JDIMENSION v_samp_factor
-; r13 = JDIMENSION width_blocks
-; r14 = JSAMPARRAY input_data
-; r15 = JSAMPARRAY output_data
-
-        align   16
-        global  EXTN(jsimd_h2v1_downsample_sse2)
-
-EXTN(jsimd_h2v1_downsample_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-
-        mov ecx, r13d
-        shl     rcx,3                   ; imul rcx,DCTSIZE (rcx = output_cols)
-        jz      near .return
-
-        mov edx, r10d
-
-        ; -- expand_right_edge
-
-        push    rcx
-        shl     rcx,1                           ; output_cols * 2
-        sub     rcx,rdx
-        jle     short .expand_end
-
-        mov     rax, r11
-        test    rax,rax
-        jle     short .expand_end
-
-        cld
-        mov     rsi, r14        ; input_data
-.expandloop:
-        push    rax
-        push    rcx
-
-        mov     rdi, JSAMPROW [rsi]
-        add     rdi,rdx
-        mov     al, JSAMPLE [rdi-1]
-
-        rep stosb
-
-        pop     rcx
-        pop     rax
-
-        add     rsi, byte SIZEOF_JSAMPROW
-        dec     rax
-        jg      short .expandloop
-
-.expand_end:
-        pop     rcx                             ; output_cols
-
-        ; -- h2v1_downsample
-
-        mov     eax, r12d        ; rowctr
-        test    eax,eax
-        jle     near .return
-
-        mov     rdx, 0x00010000         ; bias pattern
-        movd    xmm7,edx
-        pcmpeqw xmm6,xmm6
-        pshufd  xmm7,xmm7,0x00          ; xmm7={0, 1, 0, 1, 0, 1, 0, 1}
-        psrlw   xmm6,BYTE_BIT           ; xmm6={0xFF 0x00 0xFF 0x00 ..}
-
-        mov     rsi, r14        ; input_data
-        mov     rdi, r15        ; output_data
-.rowloop:
-        push    rcx
-        push    rdi
-        push    rsi
-
-        mov     rsi, JSAMPROW [rsi]             ; inptr
-        mov rdi, JSAMPROW [rdi]         ; outptr
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     short .columnloop
-
-.columnloop_r8:
-        movdqa  xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        pxor    xmm1,xmm1
-        mov     rcx, SIZEOF_XMMWORD
-        jmp     short .downsample
-
-.columnloop:
-        movdqa  xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqa  xmm1, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-
-.downsample:
-        movdqa  xmm2,xmm0
-        movdqa  xmm3,xmm1
-
-        pand    xmm0,xmm6
-        psrlw   xmm2,BYTE_BIT
-        pand    xmm1,xmm6
-        psrlw   xmm3,BYTE_BIT
-
-        paddw   xmm0,xmm2
-        paddw   xmm1,xmm3
-        paddw   xmm0,xmm7
-        paddw   xmm1,xmm7
-        psrlw   xmm0,1
-        psrlw   xmm1,1
-
-        packuswb xmm0,xmm1
-
-        movdqa  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
-
-        sub     rcx, byte SIZEOF_XMMWORD        ; outcol
-        add     rsi, byte 2*SIZEOF_XMMWORD      ; inptr
-        add     rdi, byte 1*SIZEOF_XMMWORD      ; outptr
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     short .columnloop
-        test    rcx,rcx
-        jnz     short .columnloop_r8
-
-        pop     rsi
-        pop     rdi
-        pop     rcx
-
-        add     rsi, byte SIZEOF_JSAMPROW       ; input_data
-        add     rdi, byte SIZEOF_JSAMPROW       ; output_data
-        dec     rax                             ; rowctr
-        jg      near .rowloop
-
-.return:
-        uncollect_args
-        pop     rbp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Downsample pixel values of a single component.
-; This version handles the standard case of 2:1 horizontal and 2:1 vertical,
-; without smoothing.
-;
-; GLOBAL(void)
-; jsimd_h2v2_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
-;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
-;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
-;
-
-; r10 = JDIMENSION image_width
-; r11 = int max_v_samp_factor
-; r12 = JDIMENSION v_samp_factor
-; r13 = JDIMENSION width_blocks
-; r14 = JSAMPARRAY input_data
-; r15 = JSAMPARRAY output_data
-
-        align   16
-        global  EXTN(jsimd_h2v2_downsample_sse2)
-
-EXTN(jsimd_h2v2_downsample_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-
-        mov     ecx, r13d
-        shl     rcx,3                   ; imul rcx,DCTSIZE (rcx = output_cols)
-        jz      near .return
-
-        mov     edx, r10d
-
-        ; -- expand_right_edge
-
-        push    rcx
-        shl     rcx,1                           ; output_cols * 2
-        sub     rcx,rdx
-        jle     short .expand_end
-
-        mov     rax, r11
-        test    rax,rax
-        jle     short .expand_end
-
-        cld
-        mov     rsi, r14        ; input_data
-.expandloop:
-        push    rax
-        push    rcx
-
-        mov     rdi, JSAMPROW [rsi]
-        add     rdi,rdx
-        mov     al, JSAMPLE [rdi-1]
-
-        rep stosb
-
-        pop     rcx
-        pop     rax
-
-        add     rsi, byte SIZEOF_JSAMPROW
-        dec     rax
-        jg      short .expandloop
-
-.expand_end:
-        pop     rcx                             ; output_cols
-
-        ; -- h2v2_downsample
-
-        mov     eax, r12d        ; rowctr
-        test    rax,rax
-        jle     near .return
-
-        mov     rdx, 0x00020001         ; bias pattern
-        movd    xmm7,edx
-        pcmpeqw xmm6,xmm6
-        pshufd  xmm7,xmm7,0x00          ; xmm7={1, 2, 1, 2, 1, 2, 1, 2}
-        psrlw   xmm6,BYTE_BIT           ; xmm6={0xFF 0x00 0xFF 0x00 ..}
-
-        mov     rsi, r14        ; input_data
-        mov     rdi, r15        ; output_data
-.rowloop:
-        push    rcx
-        push    rdi
-        push    rsi
-
-        mov     rdx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]   ; inptr0
-        mov     rsi, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]   ; inptr1
-        mov     rdi, JSAMPROW [rdi]                     ; outptr
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     short .columnloop
-
-.columnloop_r8:
-        movdqa  xmm0, XMMWORD [rdx+0*SIZEOF_XMMWORD]
-        movdqa  xmm1, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        pxor    xmm2,xmm2
-        pxor    xmm3,xmm3
-        mov     rcx, SIZEOF_XMMWORD
-        jmp     short .downsample
-
-.columnloop:
-        movdqa  xmm0, XMMWORD [rdx+0*SIZEOF_XMMWORD]
-        movdqa  xmm1, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqa  xmm2, XMMWORD [rdx+1*SIZEOF_XMMWORD]
-        movdqa  xmm3, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-
-.downsample:
-        movdqa  xmm4,xmm0
-        movdqa  xmm5,xmm1
-        pand    xmm0,xmm6
-        psrlw   xmm4,BYTE_BIT
-        pand    xmm1,xmm6
-        psrlw   xmm5,BYTE_BIT
-        paddw   xmm0,xmm4
-        paddw   xmm1,xmm5
-
-        movdqa  xmm4,xmm2
-        movdqa  xmm5,xmm3
-        pand    xmm2,xmm6
-        psrlw   xmm4,BYTE_BIT
-        pand    xmm3,xmm6
-        psrlw   xmm5,BYTE_BIT
-        paddw   xmm2,xmm4
-        paddw   xmm3,xmm5
-
-        paddw   xmm0,xmm1
-        paddw   xmm2,xmm3
-        paddw   xmm0,xmm7
-        paddw   xmm2,xmm7
-        psrlw   xmm0,2
-        psrlw   xmm2,2
-
-        packuswb xmm0,xmm2
-
-        movdqa  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
-
-        sub     rcx, byte SIZEOF_XMMWORD        ; outcol
-        add     rdx, byte 2*SIZEOF_XMMWORD      ; inptr0
-        add     rsi, byte 2*SIZEOF_XMMWORD      ; inptr1
-        add     rdi, byte 1*SIZEOF_XMMWORD      ; outptr
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        test    rcx,rcx
-        jnz     near .columnloop_r8
-
-        pop     rsi
-        pop     rdi
-        pop     rcx
-
-        add     rsi, byte 2*SIZEOF_JSAMPROW     ; input_data
-        add     rdi, byte 1*SIZEOF_JSAMPROW     ; output_data
-        dec     rax                             ; rowctr
-        jg      near .rowloop
-
-.return:
-        uncollect_args
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jcsample-sse2.asm b/simd/jcsample-sse2.asm
deleted file mode 100644
index 83c9d15..0000000
--- a/simd/jcsample-sse2.asm
+++ /dev/null
@@ -1,350 +0,0 @@
-;
-; jcsample.asm - downsampling (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Downsample pixel values of a single component.
-; This version handles the common case of 2:1 horizontal and 1:1 vertical,
-; without smoothing.
-;
-; GLOBAL(void)
-; jsimd_h2v1_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
-;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
-;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
-;
-
-%define img_width(b)    (b)+8           ; JDIMENSION image_width
-%define max_v_samp(b)   (b)+12          ; int max_v_samp_factor
-%define v_samp(b)       (b)+16          ; JDIMENSION v_samp_factor
-%define width_blks(b)   (b)+20          ; JDIMENSION width_blocks
-%define input_data(b)   (b)+24          ; JSAMPARRAY input_data
-%define output_data(b)  (b)+28          ; JSAMPARRAY output_data
-
-        align   16
-        global  EXTN(jsimd_h2v1_downsample_sse2)
-
-EXTN(jsimd_h2v1_downsample_sse2):
-        push    ebp
-        mov     ebp,esp
-;       push    ebx             ; unused
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        mov     ecx, JDIMENSION [width_blks(ebp)]
-        shl     ecx,3                   ; imul ecx,DCTSIZE (ecx = output_cols)
-        jz      near .return
-
-        mov     edx, JDIMENSION [img_width(ebp)]
-
-        ; -- expand_right_edge
-
-        push    ecx
-        shl     ecx,1                           ; output_cols * 2
-        sub     ecx,edx
-        jle     short .expand_end
-
-        mov     eax, INT [max_v_samp(ebp)]
-        test    eax,eax
-        jle     short .expand_end
-
-        cld
-        mov     esi, JSAMPARRAY [input_data(ebp)]       ; input_data
-        alignx  16,7
-.expandloop:
-        push    eax
-        push    ecx
-
-        mov     edi, JSAMPROW [esi]
-        add     edi,edx
-        mov     al, JSAMPLE [edi-1]
-
-        rep stosb
-
-        pop     ecx
-        pop     eax
-
-        add     esi, byte SIZEOF_JSAMPROW
-        dec     eax
-        jg      short .expandloop
-
-.expand_end:
-        pop     ecx                             ; output_cols
-
-        ; -- h2v1_downsample
-
-        mov     eax, JDIMENSION [v_samp(ebp)]   ; rowctr
-        test    eax,eax
-        jle     near .return
-
-        mov     edx, 0x00010000         ; bias pattern
-        movd    xmm7,edx
-        pcmpeqw xmm6,xmm6
-        pshufd  xmm7,xmm7,0x00          ; xmm7={0, 1, 0, 1, 0, 1, 0, 1}
-        psrlw   xmm6,BYTE_BIT           ; xmm6={0xFF 0x00 0xFF 0x00 ..}
-
-        mov     esi, JSAMPARRAY [input_data(ebp)]       ; input_data
-        mov     edi, JSAMPARRAY [output_data(ebp)]      ; output_data
-        alignx  16,7
-.rowloop:
-        push    ecx
-        push    edi
-        push    esi
-
-        mov     esi, JSAMPROW [esi]             ; inptr
-        mov     edi, JSAMPROW [edi]             ; outptr
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     short .columnloop
-        alignx  16,7
-
-.columnloop_r8:
-        movdqa  xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        pxor    xmm1,xmm1
-        mov     ecx, SIZEOF_XMMWORD
-        jmp     short .downsample
-        alignx  16,7
-
-.columnloop:
-        movdqa  xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqa  xmm1, XMMWORD [esi+1*SIZEOF_XMMWORD]
-
-.downsample:
-        movdqa  xmm2,xmm0
-        movdqa  xmm3,xmm1
-
-        pand    xmm0,xmm6
-        psrlw   xmm2,BYTE_BIT
-        pand    xmm1,xmm6
-        psrlw   xmm3,BYTE_BIT
-
-        paddw   xmm0,xmm2
-        paddw   xmm1,xmm3
-        paddw   xmm0,xmm7
-        paddw   xmm1,xmm7
-        psrlw   xmm0,1
-        psrlw   xmm1,1
-
-        packuswb xmm0,xmm1
-
-        movdqa  XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
-
-        sub     ecx, byte SIZEOF_XMMWORD        ; outcol
-        add     esi, byte 2*SIZEOF_XMMWORD      ; inptr
-        add     edi, byte 1*SIZEOF_XMMWORD      ; outptr
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     short .columnloop
-        test    ecx,ecx
-        jnz     short .columnloop_r8
-
-        pop     esi
-        pop     edi
-        pop     ecx
-
-        add     esi, byte SIZEOF_JSAMPROW       ; input_data
-        add     edi, byte SIZEOF_JSAMPROW       ; output_data
-        dec     eax                             ; rowctr
-        jg      near .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-;       pop     ebx             ; unused
-        pop     ebp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Downsample pixel values of a single component.
-; This version handles the standard case of 2:1 horizontal and 2:1 vertical,
-; without smoothing.
-;
-; GLOBAL(void)
-; jsimd_h2v2_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
-;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
-;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
-;
-
-%define img_width(b)    (b)+8           ; JDIMENSION image_width
-%define max_v_samp(b)   (b)+12          ; int max_v_samp_factor
-%define v_samp(b)       (b)+16          ; JDIMENSION v_samp_factor
-%define width_blks(b)   (b)+20          ; JDIMENSION width_blocks
-%define input_data(b)   (b)+24          ; JSAMPARRAY input_data
-%define output_data(b)  (b)+28          ; JSAMPARRAY output_data
-
-        align   16
-        global  EXTN(jsimd_h2v2_downsample_sse2)
-
-EXTN(jsimd_h2v2_downsample_sse2):
-        push    ebp
-        mov     ebp,esp
-;       push    ebx             ; unused
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        mov     ecx, JDIMENSION [width_blks(ebp)]
-        shl     ecx,3                   ; imul ecx,DCTSIZE (ecx = output_cols)
-        jz      near .return
-
-        mov     edx, JDIMENSION [img_width(ebp)]
-
-        ; -- expand_right_edge
-
-        push    ecx
-        shl     ecx,1                           ; output_cols * 2
-        sub     ecx,edx
-        jle     short .expand_end
-
-        mov     eax, INT [max_v_samp(ebp)]
-        test    eax,eax
-        jle     short .expand_end
-
-        cld
-        mov     esi, JSAMPARRAY [input_data(ebp)]       ; input_data
-        alignx  16,7
-.expandloop:
-        push    eax
-        push    ecx
-
-        mov     edi, JSAMPROW [esi]
-        add     edi,edx
-        mov     al, JSAMPLE [edi-1]
-
-        rep stosb
-
-        pop     ecx
-        pop     eax
-
-        add     esi, byte SIZEOF_JSAMPROW
-        dec     eax
-        jg      short .expandloop
-
-.expand_end:
-        pop     ecx                             ; output_cols
-
-        ; -- h2v2_downsample
-
-        mov     eax, JDIMENSION [v_samp(ebp)]   ; rowctr
-        test    eax,eax
-        jle     near .return
-
-        mov     edx, 0x00020001         ; bias pattern
-        movd    xmm7,edx
-        pcmpeqw xmm6,xmm6
-        pshufd  xmm7,xmm7,0x00          ; xmm7={1, 2, 1, 2, 1, 2, 1, 2}
-        psrlw   xmm6,BYTE_BIT           ; xmm6={0xFF 0x00 0xFF 0x00 ..}
-
-        mov     esi, JSAMPARRAY [input_data(ebp)]       ; input_data
-        mov     edi, JSAMPARRAY [output_data(ebp)]      ; output_data
-        alignx  16,7
-.rowloop:
-        push    ecx
-        push    edi
-        push    esi
-
-        mov     edx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]   ; inptr0
-        mov     esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]   ; inptr1
-        mov     edi, JSAMPROW [edi]                     ; outptr
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     short .columnloop
-        alignx  16,7
-
-.columnloop_r8:
-        movdqa  xmm0, XMMWORD [edx+0*SIZEOF_XMMWORD]
-        movdqa  xmm1, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        pxor    xmm2,xmm2
-        pxor    xmm3,xmm3
-        mov     ecx, SIZEOF_XMMWORD
-        jmp     short .downsample
-        alignx  16,7
-
-.columnloop:
-        movdqa  xmm0, XMMWORD [edx+0*SIZEOF_XMMWORD]
-        movdqa  xmm1, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqa  xmm2, XMMWORD [edx+1*SIZEOF_XMMWORD]
-        movdqa  xmm3, XMMWORD [esi+1*SIZEOF_XMMWORD]
-
-.downsample:
-        movdqa  xmm4,xmm0
-        movdqa  xmm5,xmm1
-        pand    xmm0,xmm6
-        psrlw   xmm4,BYTE_BIT
-        pand    xmm1,xmm6
-        psrlw   xmm5,BYTE_BIT
-        paddw   xmm0,xmm4
-        paddw   xmm1,xmm5
-
-        movdqa  xmm4,xmm2
-        movdqa  xmm5,xmm3
-        pand    xmm2,xmm6
-        psrlw   xmm4,BYTE_BIT
-        pand    xmm3,xmm6
-        psrlw   xmm5,BYTE_BIT
-        paddw   xmm2,xmm4
-        paddw   xmm3,xmm5
-
-        paddw   xmm0,xmm1
-        paddw   xmm2,xmm3
-        paddw   xmm0,xmm7
-        paddw   xmm2,xmm7
-        psrlw   xmm0,2
-        psrlw   xmm2,2
-
-        packuswb xmm0,xmm2
-
-        movdqa  XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
-
-        sub     ecx, byte SIZEOF_XMMWORD        ; outcol
-        add     edx, byte 2*SIZEOF_XMMWORD      ; inptr0
-        add     esi, byte 2*SIZEOF_XMMWORD      ; inptr1
-        add     edi, byte 1*SIZEOF_XMMWORD      ; outptr
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jae     near .columnloop
-        test    ecx,ecx
-        jnz     near .columnloop_r8
-
-        pop     esi
-        pop     edi
-        pop     ecx
-
-        add     esi, byte 2*SIZEOF_JSAMPROW     ; input_data
-        add     edi, byte 1*SIZEOF_JSAMPROW     ; output_data
-        dec     eax                             ; rowctr
-        jg      near .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-;       pop     ebx             ; unused
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jdcolext-sse2-64.asm b/simd/jdcolext-sse2-64.asm
deleted file mode 100644
index 4634066..0000000
--- a/simd/jdcolext-sse2-64.asm
+++ /dev/null
@@ -1,440 +0,0 @@
-;
-; jdcolext.asm - colorspace conversion (64-bit SSE2)
-;
-; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, 2012, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Convert some rows of samples to the output colorspace.
-;
-; GLOBAL(void)
-; jsimd_ycc_rgb_convert_sse2 (JDIMENSION out_width,
-;                             JSAMPIMAGE input_buf, JDIMENSION input_row,
-;                             JSAMPARRAY output_buf, int num_rows)
-;
-
-; r10 = JDIMENSION out_width
-; r11 = JSAMPIMAGE input_buf
-; r12 = JDIMENSION input_row
-; r13 = JSAMPARRAY output_buf
-; r14 = int num_rows
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_ycc_rgb_convert_sse2)
-
-EXTN(jsimd_ycc_rgb_convert_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-        push    rbx
-
-        mov     ecx, r10d        ; num_cols
-        test    rcx,rcx
-        jz      near .return
-
-        push    rcx
-
-        mov     rdi, r11
-        mov     ecx, r12d
-        mov     rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
-        mov     rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
-        mov     rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
-        lea     rsi, [rsi+rcx*SIZEOF_JSAMPROW]
-        lea     rbx, [rbx+rcx*SIZEOF_JSAMPROW]
-        lea     rdx, [rdx+rcx*SIZEOF_JSAMPROW]
-
-        pop     rcx
-
-        mov     rdi, r13
-        mov     eax, r14d
-        test    rax,rax
-        jle     near .return
-.rowloop:
-        push    rax
-        push    rdi
-        push    rdx
-        push    rbx
-        push    rsi
-        push    rcx                     ; col
-
-        mov     rsi, JSAMPROW [rsi]     ; inptr0
-        mov     rbx, JSAMPROW [rbx]     ; inptr1
-        mov     rdx, JSAMPROW [rdx]     ; inptr2
-        mov     rdi, JSAMPROW [rdi]     ; outptr
-.columnloop:
-
-        movdqa  xmm5, XMMWORD [rbx]     ; xmm5=Cb(0123456789ABCDEF)
-        movdqa  xmm1, XMMWORD [rdx]     ; xmm1=Cr(0123456789ABCDEF)
-
-        pcmpeqw xmm4,xmm4
-        pcmpeqw xmm7,xmm7
-        psrlw   xmm4,BYTE_BIT
-        psllw   xmm7,7                  ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
-        movdqa  xmm0,xmm4               ; xmm0=xmm4={0xFF 0x00 0xFF 0x00 ..}
-
-        pand    xmm4,xmm5               ; xmm4=Cb(02468ACE)=CbE
-        psrlw   xmm5,BYTE_BIT           ; xmm5=Cb(13579BDF)=CbO
-        pand    xmm0,xmm1               ; xmm0=Cr(02468ACE)=CrE
-        psrlw   xmm1,BYTE_BIT           ; xmm1=Cr(13579BDF)=CrO
-
-        paddw   xmm4,xmm7
-        paddw   xmm5,xmm7
-        paddw   xmm0,xmm7
-        paddw   xmm1,xmm7
-
-        ; (Original)
-        ; R = Y                + 1.40200 * Cr
-        ; G = Y - 0.34414 * Cb - 0.71414 * Cr
-        ; B = Y + 1.77200 * Cb
-        ;
-        ; (This implementation)
-        ; R = Y                + 0.40200 * Cr + Cr
-        ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
-        ; B = Y - 0.22800 * Cb + Cb + Cb
-
-        movdqa  xmm2,xmm4               ; xmm2=CbE
-        movdqa  xmm3,xmm5               ; xmm3=CbO
-        paddw   xmm4,xmm4               ; xmm4=2*CbE
-        paddw   xmm5,xmm5               ; xmm5=2*CbO
-        movdqa  xmm6,xmm0               ; xmm6=CrE
-        movdqa  xmm7,xmm1               ; xmm7=CrO
-        paddw   xmm0,xmm0               ; xmm0=2*CrE
-        paddw   xmm1,xmm1               ; xmm1=2*CrO
-
-        pmulhw  xmm4,[rel PW_MF0228]    ; xmm4=(2*CbE * -FIX(0.22800))
-        pmulhw  xmm5,[rel PW_MF0228]    ; xmm5=(2*CbO * -FIX(0.22800))
-        pmulhw  xmm0,[rel PW_F0402]     ; xmm0=(2*CrE * FIX(0.40200))
-        pmulhw  xmm1,[rel PW_F0402]     ; xmm1=(2*CrO * FIX(0.40200))
-
-        paddw   xmm4,[rel PW_ONE]
-        paddw   xmm5,[rel PW_ONE]
-        psraw   xmm4,1                  ; xmm4=(CbE * -FIX(0.22800))
-        psraw   xmm5,1                  ; xmm5=(CbO * -FIX(0.22800))
-        paddw   xmm0,[rel PW_ONE]
-        paddw   xmm1,[rel PW_ONE]
-        psraw   xmm0,1                  ; xmm0=(CrE * FIX(0.40200))
-        psraw   xmm1,1                  ; xmm1=(CrO * FIX(0.40200))
-
-        paddw   xmm4,xmm2
-        paddw   xmm5,xmm3
-        paddw   xmm4,xmm2               ; xmm4=(CbE * FIX(1.77200))=(B-Y)E
-        paddw   xmm5,xmm3               ; xmm5=(CbO * FIX(1.77200))=(B-Y)O
-        paddw   xmm0,xmm6               ; xmm0=(CrE * FIX(1.40200))=(R-Y)E
-        paddw   xmm1,xmm7               ; xmm1=(CrO * FIX(1.40200))=(R-Y)O
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=(B-Y)E
-        movdqa  XMMWORD [wk(1)], xmm5   ; wk(1)=(B-Y)O
-
-        movdqa    xmm4,xmm2
-        movdqa    xmm5,xmm3
-        punpcklwd xmm2,xmm6
-        punpckhwd xmm4,xmm6
-        pmaddwd   xmm2,[rel PW_MF0344_F0285]
-        pmaddwd   xmm4,[rel PW_MF0344_F0285]
-        punpcklwd xmm3,xmm7
-        punpckhwd xmm5,xmm7
-        pmaddwd   xmm3,[rel PW_MF0344_F0285]
-        pmaddwd   xmm5,[rel PW_MF0344_F0285]
-
-        paddd     xmm2,[rel PD_ONEHALF]
-        paddd     xmm4,[rel PD_ONEHALF]
-        psrad     xmm2,SCALEBITS
-        psrad     xmm4,SCALEBITS
-        paddd     xmm3,[rel PD_ONEHALF]
-        paddd     xmm5,[rel PD_ONEHALF]
-        psrad     xmm3,SCALEBITS
-        psrad     xmm5,SCALEBITS
-
-        packssdw  xmm2,xmm4     ; xmm2=CbE*-FIX(0.344)+CrE*FIX(0.285)
-        packssdw  xmm3,xmm5     ; xmm3=CbO*-FIX(0.344)+CrO*FIX(0.285)
-        psubw     xmm2,xmm6     ; xmm2=CbE*-FIX(0.344)+CrE*-FIX(0.714)=(G-Y)E
-        psubw     xmm3,xmm7     ; xmm3=CbO*-FIX(0.344)+CrO*-FIX(0.714)=(G-Y)O
-
-        movdqa    xmm5, XMMWORD [rsi]   ; xmm5=Y(0123456789ABCDEF)
-
-        pcmpeqw   xmm4,xmm4
-        psrlw     xmm4,BYTE_BIT         ; xmm4={0xFF 0x00 0xFF 0x00 ..}
-        pand      xmm4,xmm5             ; xmm4=Y(02468ACE)=YE
-        psrlw     xmm5,BYTE_BIT         ; xmm5=Y(13579BDF)=YO
-
-        paddw     xmm0,xmm4             ; xmm0=((R-Y)E+YE)=RE=R(02468ACE)
-        paddw     xmm1,xmm5             ; xmm1=((R-Y)O+YO)=RO=R(13579BDF)
-        packuswb  xmm0,xmm0             ; xmm0=R(02468ACE********)
-        packuswb  xmm1,xmm1             ; xmm1=R(13579BDF********)
-
-        paddw     xmm2,xmm4             ; xmm2=((G-Y)E+YE)=GE=G(02468ACE)
-        paddw     xmm3,xmm5             ; xmm3=((G-Y)O+YO)=GO=G(13579BDF)
-        packuswb  xmm2,xmm2             ; xmm2=G(02468ACE********)
-        packuswb  xmm3,xmm3             ; xmm3=G(13579BDF********)
-
-        paddw     xmm4, XMMWORD [wk(0)] ; xmm4=(YE+(B-Y)E)=BE=B(02468ACE)
-        paddw     xmm5, XMMWORD [wk(1)] ; xmm5=(YO+(B-Y)O)=BO=B(13579BDF)
-        packuswb  xmm4,xmm4             ; xmm4=B(02468ACE********)
-        packuswb  xmm5,xmm5             ; xmm5=B(13579BDF********)
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmB     ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
-        punpcklbw xmmD,xmmF     ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
-
-        movdqa    xmmG,xmmA
-        movdqa    xmmH,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
-        punpckhwd xmmG,xmmE     ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
-
-        psrldq    xmmH,2        ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
-        psrldq    xmmE,2        ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
-
-        movdqa    xmmC,xmmD
-        movdqa    xmmB,xmmD
-        punpcklwd xmmD,xmmH     ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
-        punpckhwd xmmC,xmmH     ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
-
-        psrldq    xmmB,2        ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
-
-        movdqa    xmmF,xmmE
-        punpcklwd xmmE,xmmB     ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
-        punpckhwd xmmF,xmmB     ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
-
-        pshufd    xmmH,xmmA,0x4E; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
-        movdqa    xmmB,xmmE
-        punpckldq xmmA,xmmD     ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
-        punpckldq xmmE,xmmH     ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
-        punpckhdq xmmD,xmmB     ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
-
-        pshufd    xmmH,xmmG,0x4E; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
-        movdqa    xmmB,xmmF
-        punpckldq xmmG,xmmC     ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
-        punpckldq xmmF,xmmH     ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
-        punpckhdq xmmC,xmmB     ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
-
-        punpcklqdq xmmA,xmmE    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        punpcklqdq xmmD,xmmG    ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        punpcklqdq xmmF,xmmC    ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    rdi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
-.out0:
-        add     rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     rcx, byte SIZEOF_XMMWORD
-        jz      near .nextrow
-
-        add     rsi, byte SIZEOF_XMMWORD        ; inptr0
-        add     rbx, byte SIZEOF_XMMWORD        ; inptr1
-        add     rdx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-
-.column_st32:
-        lea     rcx, [rcx+rcx*2]                ; imul ecx, RGB_PIXELSIZE
-        cmp     rcx, byte 2*SIZEOF_XMMWORD
-        jb      short .column_st16
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        add     rdi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmF
-        sub     rcx, byte 2*SIZEOF_XMMWORD
-        jmp     short .column_st15
-.column_st16:
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jb      short .column_st15
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        add     rdi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     rcx, byte SIZEOF_XMMWORD
-.column_st15:
-        ; Store the lower 8 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     rcx, byte SIZEOF_MMWORD
-        jb      short .column_st7
-        movq    XMM_MMWORD [rdi], xmmA
-        add     rdi, byte SIZEOF_MMWORD
-        sub     rcx, byte SIZEOF_MMWORD
-        psrldq  xmmA, SIZEOF_MMWORD
-.column_st7:
-        ; Store the lower 4 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     rcx, byte SIZEOF_DWORD
-        jb      short .column_st3
-        movd    XMM_DWORD [rdi], xmmA
-        add     rdi, byte SIZEOF_DWORD
-        sub     rcx, byte SIZEOF_DWORD
-        psrldq  xmmA, SIZEOF_DWORD
-.column_st3:
-        ; Store the lower 2 bytes of rax to the output when it has enough
-        ; space.
-        movd    eax, xmmA
-        cmp     rcx, byte SIZEOF_WORD
-        jb      short .column_st1
-        mov     WORD [rdi], ax
-        add     rdi, byte SIZEOF_WORD
-        sub     rcx, byte SIZEOF_WORD
-        shr     rax, 16
-.column_st1:
-        ; Store the lower 1 byte of rax to the output when it has enough
-        ; space.
-        test    rcx, rcx
-        jz      short .nextrow
-        mov     BYTE [rdi], al
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-%ifdef RGBX_FILLER_0XFF
-        pcmpeqb   xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pcmpeqb   xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%else
-        pxor      xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pxor      xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%endif
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmG     ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
-        punpcklbw xmmB,xmmD     ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
-        punpcklbw xmmF,xmmH     ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
-
-        movdqa    xmmC,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
-        punpckhwd xmmC,xmmE     ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
-        movdqa    xmmG,xmmB
-        punpcklwd xmmB,xmmF     ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
-        punpckhwd xmmG,xmmF     ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpckldq xmmA,xmmB     ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        punpckhdq xmmD,xmmB     ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        movdqa    xmmH,xmmC
-        punpckldq xmmC,xmmG     ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        punpckhdq xmmH,xmmG     ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    rdi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
-        movntdq XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
-        movdqu  XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
-.out0:
-        add     rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     rcx, byte SIZEOF_XMMWORD
-        jz      near .nextrow
-
-        add     rsi, byte SIZEOF_XMMWORD        ; inptr0
-        add     rbx, byte SIZEOF_XMMWORD        ; inptr1
-        add     rdx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-
-.column_st32:
-        cmp     rcx, byte SIZEOF_XMMWORD/2
-        jb      short .column_st16
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        add     rdi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmC
-        movdqa  xmmD,xmmH
-        sub     rcx, byte SIZEOF_XMMWORD/2
-.column_st16:
-        cmp     rcx, byte SIZEOF_XMMWORD/4
-        jb      short .column_st15
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        add     rdi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     rcx, byte SIZEOF_XMMWORD/4
-.column_st15:
-        ; Store two pixels (8 bytes) of xmmA to the output when it has enough
-        ; space.
-        cmp     rcx, byte SIZEOF_XMMWORD/8
-        jb      short .column_st7
-        movq    MMWORD [rdi], xmmA
-        add     rdi, byte SIZEOF_XMMWORD/8*4
-        sub     rcx, byte SIZEOF_XMMWORD/8
-        psrldq  xmmA, SIZEOF_XMMWORD/8*4
-.column_st7:
-        ; Store one pixel (4 bytes) of xmmA to the output when it has enough
-        ; space.
-        test    rcx, rcx
-        jz      short .nextrow
-        movd    XMM_DWORD [rdi], xmmA
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-.nextrow:
-        pop     rcx
-        pop     rsi
-        pop     rbx
-        pop     rdx
-        pop     rdi
-        pop     rax
-
-        add     rsi, byte SIZEOF_JSAMPROW
-        add     rbx, byte SIZEOF_JSAMPROW
-        add     rdx, byte SIZEOF_JSAMPROW
-        add     rdi, byte SIZEOF_JSAMPROW       ; output_buf
-        dec     rax                             ; num_rows
-        jg      near .rowloop
-
-        sfence          ; flush the write buffer
-
-.return:
-        pop     rbx
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jdcolext-sse2.asm b/simd/jdcolext-sse2.asm
deleted file mode 100644
index 682aef3..0000000
--- a/simd/jdcolext-sse2.asm
+++ /dev/null
@@ -1,459 +0,0 @@
-;
-; jdcolext.asm - colorspace conversion (SSE2)
-;
-; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2012, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Convert some rows of samples to the output colorspace.
-;
-; GLOBAL(void)
-; jsimd_ycc_rgb_convert_sse2 (JDIMENSION out_width,
-;                             JSAMPIMAGE input_buf, JDIMENSION input_row,
-;                             JSAMPARRAY output_buf, int num_rows)
-;
-
-%define out_width(b)    (b)+8           ; JDIMENSION out_width
-%define input_buf(b)    (b)+12          ; JSAMPIMAGE input_buf
-%define input_row(b)    (b)+16          ; JDIMENSION input_row
-%define output_buf(b)   (b)+20          ; JSAMPARRAY output_buf
-%define num_rows(b)     (b)+24          ; int num_rows
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-%define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
-
-        align   16
-        global  EXTN(jsimd_ycc_rgb_convert_sse2)
-
-EXTN(jsimd_ycc_rgb_convert_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic eax             ; make a room for GOT address
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx                     ; get GOT address
-        movpic  POINTER [gotptr], ebx   ; save GOT address
-
-        mov     ecx, JDIMENSION [out_width(eax)]        ; num_cols
-        test    ecx,ecx
-        jz      near .return
-
-        push    ecx
-
-        mov     edi, JSAMPIMAGE [input_buf(eax)]
-        mov     ecx, JDIMENSION [input_row(eax)]
-        mov     esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
-        mov     ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
-        mov     edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
-        lea     esi, [esi+ecx*SIZEOF_JSAMPROW]
-        lea     ebx, [ebx+ecx*SIZEOF_JSAMPROW]
-        lea     edx, [edx+ecx*SIZEOF_JSAMPROW]
-
-        pop     ecx
-
-        mov     edi, JSAMPARRAY [output_buf(eax)]
-        mov     eax, INT [num_rows(eax)]
-        test    eax,eax
-        jle     near .return
-        alignx  16,7
-.rowloop:
-        push    eax
-        push    edi
-        push    edx
-        push    ebx
-        push    esi
-        push    ecx                     ; col
-
-        mov     esi, JSAMPROW [esi]     ; inptr0
-        mov     ebx, JSAMPROW [ebx]     ; inptr1
-        mov     edx, JSAMPROW [edx]     ; inptr2
-        mov     edi, JSAMPROW [edi]     ; outptr
-        movpic  eax, POINTER [gotptr]   ; load GOT address (eax)
-        alignx  16,7
-.columnloop:
-
-        movdqa  xmm5, XMMWORD [ebx]     ; xmm5=Cb(0123456789ABCDEF)
-        movdqa  xmm1, XMMWORD [edx]     ; xmm1=Cr(0123456789ABCDEF)
-
-        pcmpeqw xmm4,xmm4
-        pcmpeqw xmm7,xmm7
-        psrlw   xmm4,BYTE_BIT
-        psllw   xmm7,7                  ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
-        movdqa  xmm0,xmm4               ; xmm0=xmm4={0xFF 0x00 0xFF 0x00 ..}
-
-        pand    xmm4,xmm5               ; xmm4=Cb(02468ACE)=CbE
-        psrlw   xmm5,BYTE_BIT           ; xmm5=Cb(13579BDF)=CbO
-        pand    xmm0,xmm1               ; xmm0=Cr(02468ACE)=CrE
-        psrlw   xmm1,BYTE_BIT           ; xmm1=Cr(13579BDF)=CrO
-
-        paddw   xmm4,xmm7
-        paddw   xmm5,xmm7
-        paddw   xmm0,xmm7
-        paddw   xmm1,xmm7
-
-        ; (Original)
-        ; R = Y                + 1.40200 * Cr
-        ; G = Y - 0.34414 * Cb - 0.71414 * Cr
-        ; B = Y + 1.77200 * Cb
-        ;
-        ; (This implementation)
-        ; R = Y                + 0.40200 * Cr + Cr
-        ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
-        ; B = Y - 0.22800 * Cb + Cb + Cb
-
-        movdqa  xmm2,xmm4               ; xmm2=CbE
-        movdqa  xmm3,xmm5               ; xmm3=CbO
-        paddw   xmm4,xmm4               ; xmm4=2*CbE
-        paddw   xmm5,xmm5               ; xmm5=2*CbO
-        movdqa  xmm6,xmm0               ; xmm6=CrE
-        movdqa  xmm7,xmm1               ; xmm7=CrO
-        paddw   xmm0,xmm0               ; xmm0=2*CrE
-        paddw   xmm1,xmm1               ; xmm1=2*CrO
-
-        pmulhw  xmm4,[GOTOFF(eax,PW_MF0228)]    ; xmm4=(2*CbE * -FIX(0.22800))
-        pmulhw  xmm5,[GOTOFF(eax,PW_MF0228)]    ; xmm5=(2*CbO * -FIX(0.22800))
-        pmulhw  xmm0,[GOTOFF(eax,PW_F0402)]     ; xmm0=(2*CrE * FIX(0.40200))
-        pmulhw  xmm1,[GOTOFF(eax,PW_F0402)]     ; xmm1=(2*CrO * FIX(0.40200))
-
-        paddw   xmm4,[GOTOFF(eax,PW_ONE)]
-        paddw   xmm5,[GOTOFF(eax,PW_ONE)]
-        psraw   xmm4,1                  ; xmm4=(CbE * -FIX(0.22800))
-        psraw   xmm5,1                  ; xmm5=(CbO * -FIX(0.22800))
-        paddw   xmm0,[GOTOFF(eax,PW_ONE)]
-        paddw   xmm1,[GOTOFF(eax,PW_ONE)]
-        psraw   xmm0,1                  ; xmm0=(CrE * FIX(0.40200))
-        psraw   xmm1,1                  ; xmm1=(CrO * FIX(0.40200))
-
-        paddw   xmm4,xmm2
-        paddw   xmm5,xmm3
-        paddw   xmm4,xmm2               ; xmm4=(CbE * FIX(1.77200))=(B-Y)E
-        paddw   xmm5,xmm3               ; xmm5=(CbO * FIX(1.77200))=(B-Y)O
-        paddw   xmm0,xmm6               ; xmm0=(CrE * FIX(1.40200))=(R-Y)E
-        paddw   xmm1,xmm7               ; xmm1=(CrO * FIX(1.40200))=(R-Y)O
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=(B-Y)E
-        movdqa  XMMWORD [wk(1)], xmm5   ; wk(1)=(B-Y)O
-
-        movdqa    xmm4,xmm2
-        movdqa    xmm5,xmm3
-        punpcklwd xmm2,xmm6
-        punpckhwd xmm4,xmm6
-        pmaddwd   xmm2,[GOTOFF(eax,PW_MF0344_F0285)]
-        pmaddwd   xmm4,[GOTOFF(eax,PW_MF0344_F0285)]
-        punpcklwd xmm3,xmm7
-        punpckhwd xmm5,xmm7
-        pmaddwd   xmm3,[GOTOFF(eax,PW_MF0344_F0285)]
-        pmaddwd   xmm5,[GOTOFF(eax,PW_MF0344_F0285)]
-
-        paddd     xmm2,[GOTOFF(eax,PD_ONEHALF)]
-        paddd     xmm4,[GOTOFF(eax,PD_ONEHALF)]
-        psrad     xmm2,SCALEBITS
-        psrad     xmm4,SCALEBITS
-        paddd     xmm3,[GOTOFF(eax,PD_ONEHALF)]
-        paddd     xmm5,[GOTOFF(eax,PD_ONEHALF)]
-        psrad     xmm3,SCALEBITS
-        psrad     xmm5,SCALEBITS
-
-        packssdw  xmm2,xmm4     ; xmm2=CbE*-FIX(0.344)+CrE*FIX(0.285)
-        packssdw  xmm3,xmm5     ; xmm3=CbO*-FIX(0.344)+CrO*FIX(0.285)
-        psubw     xmm2,xmm6     ; xmm2=CbE*-FIX(0.344)+CrE*-FIX(0.714)=(G-Y)E
-        psubw     xmm3,xmm7     ; xmm3=CbO*-FIX(0.344)+CrO*-FIX(0.714)=(G-Y)O
-
-        movdqa    xmm5, XMMWORD [esi]   ; xmm5=Y(0123456789ABCDEF)
-
-        pcmpeqw   xmm4,xmm4
-        psrlw     xmm4,BYTE_BIT         ; xmm4={0xFF 0x00 0xFF 0x00 ..}
-        pand      xmm4,xmm5             ; xmm4=Y(02468ACE)=YE
-        psrlw     xmm5,BYTE_BIT         ; xmm5=Y(13579BDF)=YO
-
-        paddw     xmm0,xmm4             ; xmm0=((R-Y)E+YE)=RE=R(02468ACE)
-        paddw     xmm1,xmm5             ; xmm1=((R-Y)O+YO)=RO=R(13579BDF)
-        packuswb  xmm0,xmm0             ; xmm0=R(02468ACE********)
-        packuswb  xmm1,xmm1             ; xmm1=R(13579BDF********)
-
-        paddw     xmm2,xmm4             ; xmm2=((G-Y)E+YE)=GE=G(02468ACE)
-        paddw     xmm3,xmm5             ; xmm3=((G-Y)O+YO)=GO=G(13579BDF)
-        packuswb  xmm2,xmm2             ; xmm2=G(02468ACE********)
-        packuswb  xmm3,xmm3             ; xmm3=G(13579BDF********)
-
-        paddw     xmm4, XMMWORD [wk(0)] ; xmm4=(YE+(B-Y)E)=BE=B(02468ACE)
-        paddw     xmm5, XMMWORD [wk(1)] ; xmm5=(YO+(B-Y)O)=BO=B(13579BDF)
-        packuswb  xmm4,xmm4             ; xmm4=B(02468ACE********)
-        packuswb  xmm5,xmm5             ; xmm5=B(13579BDF********)
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmB     ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
-        punpcklbw xmmD,xmmF     ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
-
-        movdqa    xmmG,xmmA
-        movdqa    xmmH,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
-        punpckhwd xmmG,xmmE     ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
-
-        psrldq    xmmH,2        ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
-        psrldq    xmmE,2        ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
-
-        movdqa    xmmC,xmmD
-        movdqa    xmmB,xmmD
-        punpcklwd xmmD,xmmH     ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
-        punpckhwd xmmC,xmmH     ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
-
-        psrldq    xmmB,2        ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
-
-        movdqa    xmmF,xmmE
-        punpcklwd xmmE,xmmB     ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
-        punpckhwd xmmF,xmmB     ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
-
-        pshufd    xmmH,xmmA,0x4E; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
-        movdqa    xmmB,xmmE
-        punpckldq xmmA,xmmD     ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
-        punpckldq xmmE,xmmH     ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
-        punpckhdq xmmD,xmmB     ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
-
-        pshufd    xmmH,xmmG,0x4E; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
-        movdqa    xmmB,xmmF
-        punpckldq xmmG,xmmC     ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
-        punpckldq xmmF,xmmH     ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
-        punpckhdq xmmC,xmmB     ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
-
-        punpcklqdq xmmA,xmmE    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        punpcklqdq xmmD,xmmG    ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        punpcklqdq xmmF,xmmC    ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    edi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
-.out0:
-        add     edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     ecx, byte SIZEOF_XMMWORD
-        jz      near .nextrow
-
-        add     esi, byte SIZEOF_XMMWORD        ; inptr0
-        add     ebx, byte SIZEOF_XMMWORD        ; inptr1
-        add     edx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-        alignx  16,7
-
-.column_st32:
-        lea     ecx, [ecx+ecx*2]                ; imul ecx, RGB_PIXELSIZE
-        cmp     ecx, byte 2*SIZEOF_XMMWORD
-        jb      short .column_st16
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        add     edi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmF
-        sub     ecx, byte 2*SIZEOF_XMMWORD
-        jmp     short .column_st15
-.column_st16:
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jb      short .column_st15
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        add     edi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     ecx, byte SIZEOF_XMMWORD
-.column_st15:
-        ; Store the lower 8 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     ecx, byte SIZEOF_MMWORD
-        jb      short .column_st7
-        movq    XMM_MMWORD [edi], xmmA
-        add     edi, byte SIZEOF_MMWORD
-        sub     ecx, byte SIZEOF_MMWORD
-        psrldq  xmmA, SIZEOF_MMWORD
-.column_st7:
-        ; Store the lower 4 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     ecx, byte SIZEOF_DWORD
-        jb      short .column_st3
-        movd    XMM_DWORD [edi], xmmA
-        add     edi, byte SIZEOF_DWORD
-        sub     ecx, byte SIZEOF_DWORD
-        psrldq  xmmA, SIZEOF_DWORD
-.column_st3:
-        ; Store the lower 2 bytes of eax to the output when it has enough
-        ; space.
-        movd    eax, xmmA
-        cmp     ecx, byte SIZEOF_WORD
-        jb      short .column_st1
-        mov     WORD [edi], ax
-        add     edi, byte SIZEOF_WORD
-        sub     ecx, byte SIZEOF_WORD
-        shr     eax, 16
-.column_st1:
-        ; Store the lower 1 byte of eax to the output when it has enough
-        ; space.
-        test    ecx, ecx
-        jz      short .nextrow
-        mov     BYTE [edi], al
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-%ifdef RGBX_FILLER_0XFF
-        pcmpeqb   xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pcmpeqb   xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%else
-        pxor      xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pxor      xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%endif
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmG     ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
-        punpcklbw xmmB,xmmD     ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
-        punpcklbw xmmF,xmmH     ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
-
-        movdqa    xmmC,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
-        punpckhwd xmmC,xmmE     ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
-        movdqa    xmmG,xmmB
-        punpcklwd xmmB,xmmF     ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
-        punpckhwd xmmG,xmmF     ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpckldq xmmA,xmmB     ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        punpckhdq xmmD,xmmB     ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        movdqa    xmmH,xmmC
-        punpckldq xmmC,xmmG     ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        punpckhdq xmmH,xmmG     ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    edi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
-        movntdq XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
-        movdqu  XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
-.out0:
-        add     edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     ecx, byte SIZEOF_XMMWORD
-        jz      near .nextrow
-
-        add     esi, byte SIZEOF_XMMWORD        ; inptr0
-        add     ebx, byte SIZEOF_XMMWORD        ; inptr1
-        add     edx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-        alignx  16,7
-
-.column_st32:
-        cmp     ecx, byte SIZEOF_XMMWORD/2
-        jb      short .column_st16
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        add     edi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmC
-        movdqa  xmmD,xmmH
-        sub     ecx, byte SIZEOF_XMMWORD/2
-.column_st16:
-        cmp     ecx, byte SIZEOF_XMMWORD/4
-        jb      short .column_st15
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        add     edi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     ecx, byte SIZEOF_XMMWORD/4
-.column_st15:
-        ; Store two pixels (8 bytes) of xmmA to the output when it has enough
-        ; space.
-        cmp     ecx, byte SIZEOF_XMMWORD/8
-        jb      short .column_st7
-        movq    XMM_MMWORD [edi], xmmA
-        add     edi, byte SIZEOF_XMMWORD/8*4
-        sub     ecx, byte SIZEOF_XMMWORD/8
-        psrldq  xmmA, SIZEOF_XMMWORD/8*4
-.column_st7:
-        ; Store one pixel (4 bytes) of xmmA to the output when it has enough
-        ; space.
-        test    ecx, ecx
-        jz      short .nextrow
-        movd    XMM_DWORD [edi], xmmA
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-        alignx  16,7
-
-.nextrow:
-        pop     ecx
-        pop     esi
-        pop     ebx
-        pop     edx
-        pop     edi
-        pop     eax
-
-        add     esi, byte SIZEOF_JSAMPROW
-        add     ebx, byte SIZEOF_JSAMPROW
-        add     edx, byte SIZEOF_JSAMPROW
-        add     edi, byte SIZEOF_JSAMPROW       ; output_buf
-        dec     eax                             ; num_rows
-        jg      near .rowloop
-
-        sfence          ; flush the write buffer
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jdmrgext-sse2-64.asm b/simd/jdmrgext-sse2-64.asm
deleted file mode 100644
index ad74c5f..0000000
--- a/simd/jdmrgext-sse2-64.asm
+++ /dev/null
@@ -1,537 +0,0 @@
-;
-; jdmrgext.asm - merged upsampling/color conversion (64-bit SSE2)
-;
-; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, 2012, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
-;
-; GLOBAL(void)
-; jsimd_h2v1_merged_upsample_sse2 (JDIMENSION output_width,
-;                                  JSAMPIMAGE input_buf,
-;                                  JDIMENSION in_row_group_ctr,
-;                                  JSAMPARRAY output_buf);
-;
-
-; r10 = JDIMENSION output_width
-; r11 = JSAMPIMAGE input_buf
-; r12 = JDIMENSION in_row_group_ctr
-; r13 = JSAMPARRAY output_buf
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          3
-
-        align   16
-        global  EXTN(jsimd_h2v1_merged_upsample_sse2)
-
-EXTN(jsimd_h2v1_merged_upsample_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-        push    rbx
-
-        mov     ecx, r10d        ; col
-        test    rcx,rcx
-        jz      near .return
-
-        push    rcx
-
-        mov     rdi, r11
-        mov     ecx, r12d
-        mov     rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
-        mov     rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
-        mov     rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
-        mov     rdi, r13
-        mov     rsi, JSAMPROW [rsi+rcx*SIZEOF_JSAMPROW]         ; inptr0
-        mov     rbx, JSAMPROW [rbx+rcx*SIZEOF_JSAMPROW]         ; inptr1
-        mov     rdx, JSAMPROW [rdx+rcx*SIZEOF_JSAMPROW]         ; inptr2
-        mov     rdi, JSAMPROW [rdi]                             ; outptr
-
-        pop     rcx                     ; col
-
-.columnloop:
-
-        movdqa    xmm6, XMMWORD [rbx]   ; xmm6=Cb(0123456789ABCDEF)
-        movdqa    xmm7, XMMWORD [rdx]   ; xmm7=Cr(0123456789ABCDEF)
-
-        pxor      xmm1,xmm1             ; xmm1=(all 0's)
-        pcmpeqw   xmm3,xmm3
-        psllw     xmm3,7                ; xmm3={0xFF80 0xFF80 0xFF80 0xFF80 ..}
-
-        movdqa    xmm4,xmm6
-        punpckhbw xmm6,xmm1             ; xmm6=Cb(89ABCDEF)=CbH
-        punpcklbw xmm4,xmm1             ; xmm4=Cb(01234567)=CbL
-        movdqa    xmm0,xmm7
-        punpckhbw xmm7,xmm1             ; xmm7=Cr(89ABCDEF)=CrH
-        punpcklbw xmm0,xmm1             ; xmm0=Cr(01234567)=CrL
-
-        paddw     xmm6,xmm3
-        paddw     xmm4,xmm3
-        paddw     xmm7,xmm3
-        paddw     xmm0,xmm3
-
-        ; (Original)
-        ; R = Y                + 1.40200 * Cr
-        ; G = Y - 0.34414 * Cb - 0.71414 * Cr
-        ; B = Y + 1.77200 * Cb
-        ;
-        ; (This implementation)
-        ; R = Y                + 0.40200 * Cr + Cr
-        ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
-        ; B = Y - 0.22800 * Cb + Cb + Cb
-
-        movdqa  xmm5,xmm6               ; xmm5=CbH
-        movdqa  xmm2,xmm4               ; xmm2=CbL
-        paddw   xmm6,xmm6               ; xmm6=2*CbH
-        paddw   xmm4,xmm4               ; xmm4=2*CbL
-        movdqa  xmm1,xmm7               ; xmm1=CrH
-        movdqa  xmm3,xmm0               ; xmm3=CrL
-        paddw   xmm7,xmm7               ; xmm7=2*CrH
-        paddw   xmm0,xmm0               ; xmm0=2*CrL
-
-        pmulhw  xmm6,[rel PW_MF0228]    ; xmm6=(2*CbH * -FIX(0.22800))
-        pmulhw  xmm4,[rel PW_MF0228]    ; xmm4=(2*CbL * -FIX(0.22800))
-        pmulhw  xmm7,[rel PW_F0402]     ; xmm7=(2*CrH * FIX(0.40200))
-        pmulhw  xmm0,[rel PW_F0402]     ; xmm0=(2*CrL * FIX(0.40200))
-
-        paddw   xmm6,[rel PW_ONE]
-        paddw   xmm4,[rel PW_ONE]
-        psraw   xmm6,1                  ; xmm6=(CbH * -FIX(0.22800))
-        psraw   xmm4,1                  ; xmm4=(CbL * -FIX(0.22800))
-        paddw   xmm7,[rel PW_ONE]
-        paddw   xmm0,[rel PW_ONE]
-        psraw   xmm7,1                  ; xmm7=(CrH * FIX(0.40200))
-        psraw   xmm0,1                  ; xmm0=(CrL * FIX(0.40200))
-
-        paddw   xmm6,xmm5
-        paddw   xmm4,xmm2
-        paddw   xmm6,xmm5               ; xmm6=(CbH * FIX(1.77200))=(B-Y)H
-        paddw   xmm4,xmm2               ; xmm4=(CbL * FIX(1.77200))=(B-Y)L
-        paddw   xmm7,xmm1               ; xmm7=(CrH * FIX(1.40200))=(R-Y)H
-        paddw   xmm0,xmm3               ; xmm0=(CrL * FIX(1.40200))=(R-Y)L
-
-        movdqa  XMMWORD [wk(0)], xmm6   ; wk(0)=(B-Y)H
-        movdqa  XMMWORD [wk(1)], xmm7   ; wk(1)=(R-Y)H
-
-        movdqa    xmm6,xmm5
-        movdqa    xmm7,xmm2
-        punpcklwd xmm5,xmm1
-        punpckhwd xmm6,xmm1
-        pmaddwd   xmm5,[rel PW_MF0344_F0285]
-        pmaddwd   xmm6,[rel PW_MF0344_F0285]
-        punpcklwd xmm2,xmm3
-        punpckhwd xmm7,xmm3
-        pmaddwd   xmm2,[rel PW_MF0344_F0285]
-        pmaddwd   xmm7,[rel PW_MF0344_F0285]
-
-        paddd     xmm5,[rel PD_ONEHALF]
-        paddd     xmm6,[rel PD_ONEHALF]
-        psrad     xmm5,SCALEBITS
-        psrad     xmm6,SCALEBITS
-        paddd     xmm2,[rel PD_ONEHALF]
-        paddd     xmm7,[rel PD_ONEHALF]
-        psrad     xmm2,SCALEBITS
-        psrad     xmm7,SCALEBITS
-
-        packssdw  xmm5,xmm6     ; xmm5=CbH*-FIX(0.344)+CrH*FIX(0.285)
-        packssdw  xmm2,xmm7     ; xmm2=CbL*-FIX(0.344)+CrL*FIX(0.285)
-        psubw     xmm5,xmm1     ; xmm5=CbH*-FIX(0.344)+CrH*-FIX(0.714)=(G-Y)H
-        psubw     xmm2,xmm3     ; xmm2=CbL*-FIX(0.344)+CrL*-FIX(0.714)=(G-Y)L
-
-        movdqa  XMMWORD [wk(2)], xmm5   ; wk(2)=(G-Y)H
-
-        mov     al,2                    ; Yctr
-        jmp     short .Yloop_1st
-
-.Yloop_2nd:
-        movdqa  xmm0, XMMWORD [wk(1)]   ; xmm0=(R-Y)H
-        movdqa  xmm2, XMMWORD [wk(2)]   ; xmm2=(G-Y)H
-        movdqa  xmm4, XMMWORD [wk(0)]   ; xmm4=(B-Y)H
-
-.Yloop_1st:
-        movdqa  xmm7, XMMWORD [rsi]     ; xmm7=Y(0123456789ABCDEF)
-
-        pcmpeqw xmm6,xmm6
-        psrlw   xmm6,BYTE_BIT           ; xmm6={0xFF 0x00 0xFF 0x00 ..}
-        pand    xmm6,xmm7               ; xmm6=Y(02468ACE)=YE
-        psrlw   xmm7,BYTE_BIT           ; xmm7=Y(13579BDF)=YO
-
-        movdqa  xmm1,xmm0               ; xmm1=xmm0=(R-Y)(L/H)
-        movdqa  xmm3,xmm2               ; xmm3=xmm2=(G-Y)(L/H)
-        movdqa  xmm5,xmm4               ; xmm5=xmm4=(B-Y)(L/H)
-
-        paddw     xmm0,xmm6             ; xmm0=((R-Y)+YE)=RE=R(02468ACE)
-        paddw     xmm1,xmm7             ; xmm1=((R-Y)+YO)=RO=R(13579BDF)
-        packuswb  xmm0,xmm0             ; xmm0=R(02468ACE********)
-        packuswb  xmm1,xmm1             ; xmm1=R(13579BDF********)
-
-        paddw     xmm2,xmm6             ; xmm2=((G-Y)+YE)=GE=G(02468ACE)
-        paddw     xmm3,xmm7             ; xmm3=((G-Y)+YO)=GO=G(13579BDF)
-        packuswb  xmm2,xmm2             ; xmm2=G(02468ACE********)
-        packuswb  xmm3,xmm3             ; xmm3=G(13579BDF********)
-
-        paddw     xmm4,xmm6             ; xmm4=((B-Y)+YE)=BE=B(02468ACE)
-        paddw     xmm5,xmm7             ; xmm5=((B-Y)+YO)=BO=B(13579BDF)
-        packuswb  xmm4,xmm4             ; xmm4=B(02468ACE********)
-        packuswb  xmm5,xmm5             ; xmm5=B(13579BDF********)
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmB     ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
-        punpcklbw xmmD,xmmF     ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
-
-        movdqa    xmmG,xmmA
-        movdqa    xmmH,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
-        punpckhwd xmmG,xmmE     ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
-
-        psrldq    xmmH,2        ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
-        psrldq    xmmE,2        ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
-
-        movdqa    xmmC,xmmD
-        movdqa    xmmB,xmmD
-        punpcklwd xmmD,xmmH     ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
-        punpckhwd xmmC,xmmH     ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
-
-        psrldq    xmmB,2        ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
-
-        movdqa    xmmF,xmmE
-        punpcklwd xmmE,xmmB     ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
-        punpckhwd xmmF,xmmB     ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
-
-        pshufd    xmmH,xmmA,0x4E; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
-        movdqa    xmmB,xmmE
-        punpckldq xmmA,xmmD     ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
-        punpckldq xmmE,xmmH     ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
-        punpckhdq xmmD,xmmB     ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
-
-        pshufd    xmmH,xmmG,0x4E; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
-        movdqa    xmmB,xmmF
-        punpckldq xmmG,xmmC     ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
-        punpckldq xmmF,xmmH     ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
-        punpckhdq xmmC,xmmB     ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
-
-        punpcklqdq xmmA,xmmE    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        punpcklqdq xmmD,xmmG    ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        punpcklqdq xmmF,xmmC    ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    rdi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
-.out0:
-        add     rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     rcx, byte SIZEOF_XMMWORD
-        jz      near .endcolumn
-
-        add     rsi, byte SIZEOF_XMMWORD        ; inptr0
-        dec     al                      ; Yctr
-        jnz     near .Yloop_2nd
-
-        add     rbx, byte SIZEOF_XMMWORD        ; inptr1
-        add     rdx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-
-.column_st32:
-        lea     rcx, [rcx+rcx*2]                ; imul ecx, RGB_PIXELSIZE
-        cmp     rcx, byte 2*SIZEOF_XMMWORD
-        jb      short .column_st16
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        add     rdi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmF
-        sub     rcx, byte 2*SIZEOF_XMMWORD
-        jmp     short .column_st15
-.column_st16:
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jb      short .column_st15
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        add     rdi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     rcx, byte SIZEOF_XMMWORD
-.column_st15:
-        ; Store the lower 8 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     rcx, byte SIZEOF_MMWORD
-        jb      short .column_st7
-        movq    XMM_MMWORD [rdi], xmmA
-        add     rdi, byte SIZEOF_MMWORD
-        sub     rcx, byte SIZEOF_MMWORD
-        psrldq  xmmA, SIZEOF_MMWORD
-.column_st7:
-        ; Store the lower 4 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     rcx, byte SIZEOF_DWORD
-        jb      short .column_st3
-        movd    XMM_DWORD [rdi], xmmA
-        add     rdi, byte SIZEOF_DWORD
-        sub     rcx, byte SIZEOF_DWORD
-        psrldq  xmmA, SIZEOF_DWORD
-.column_st3:
-        ; Store the lower 2 bytes of rax to the output when it has enough
-        ; space.
-        movd    eax, xmmA
-        cmp     rcx, byte SIZEOF_WORD
-        jb      short .column_st1
-        mov     WORD [rdi], ax
-        add     rdi, byte SIZEOF_WORD
-        sub     rcx, byte SIZEOF_WORD
-        shr     rax, 16
-.column_st1:
-        ; Store the lower 1 byte of rax to the output when it has enough
-        ; space.
-        test    rcx, rcx
-        jz      short .endcolumn
-        mov     BYTE [rdi], al
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-%ifdef RGBX_FILLER_0XFF
-        pcmpeqb   xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pcmpeqb   xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%else
-        pxor      xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pxor      xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%endif
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmG     ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
-        punpcklbw xmmB,xmmD     ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
-        punpcklbw xmmF,xmmH     ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
-
-        movdqa    xmmC,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
-        punpckhwd xmmC,xmmE     ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
-        movdqa    xmmG,xmmB
-        punpcklwd xmmB,xmmF     ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
-        punpckhwd xmmG,xmmF     ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpckldq xmmA,xmmB     ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        punpckhdq xmmD,xmmB     ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        movdqa    xmmH,xmmC
-        punpckldq xmmC,xmmG     ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        punpckhdq xmmH,xmmG     ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        cmp     rcx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    rdi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
-        movntdq XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
-        movdqu  XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
-.out0:
-        add     rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     rcx, byte SIZEOF_XMMWORD
-        jz      near .endcolumn
-
-        add     rsi, byte SIZEOF_XMMWORD        ; inptr0
-        dec     al                      ; Yctr
-        jnz     near .Yloop_2nd
-
-        add     rbx, byte SIZEOF_XMMWORD        ; inptr1
-        add     rdx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-
-.column_st32:
-        cmp     rcx, byte SIZEOF_XMMWORD/2
-        jb      short .column_st16
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
-        add     rdi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmC
-        movdqa  xmmD,xmmH
-        sub     rcx, byte SIZEOF_XMMWORD/2
-.column_st16:
-        cmp     rcx, byte SIZEOF_XMMWORD/4
-        jb      short .column_st15
-        movdqu  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
-        add     rdi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     rcx, byte SIZEOF_XMMWORD/4
-.column_st15:
-        ; Store two pixels (8 bytes) of xmmA to the output when it has enough
-        ; space.
-        cmp     rcx, byte SIZEOF_XMMWORD/8
-        jb      short .column_st7
-        movq    XMM_MMWORD [rdi], xmmA
-        add     rdi, byte SIZEOF_XMMWORD/8*4
-        sub     rcx, byte SIZEOF_XMMWORD/8
-        psrldq  xmmA, SIZEOF_XMMWORD/8*4
-.column_st7:
-        ; Store one pixel (4 bytes) of xmmA to the output when it has enough
-        ; space.
-        test    rcx, rcx
-        jz      short .endcolumn
-        movd    XMM_DWORD [rdi], xmmA
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-.endcolumn:
-        sfence          ; flush the write buffer
-
-.return:
-        pop     rbx
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
-;
-; GLOBAL(void)
-; jsimd_h2v2_merged_upsample_sse2 (JDIMENSION output_width,
-;                                  JSAMPIMAGE input_buf,
-;                                  JDIMENSION in_row_group_ctr,
-;                                  JSAMPARRAY output_buf);
-;
-
-; r10 = JDIMENSION output_width
-; r11 = JSAMPIMAGE input_buf
-; r12 = JDIMENSION in_row_group_ctr
-; r13 = JSAMPARRAY output_buf
-
-        align   16
-        global  EXTN(jsimd_h2v2_merged_upsample_sse2)
-
-EXTN(jsimd_h2v2_merged_upsample_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-        push    rbx
-
-        mov     eax, r10d
-
-        mov     rdi, r11
-        mov     ecx, r12d
-        mov     rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
-        mov     rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
-        mov     rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
-        mov     rdi, r13
-        lea     rsi, [rsi+rcx*SIZEOF_JSAMPROW]
-
-        push    rdx                     ; inptr2
-        push    rbx                     ; inptr1
-        push    rsi                     ; inptr00
-        mov     rbx,rsp
-
-        push    rdi
-        push    rcx
-        push    rax
-
-        %ifdef WIN64
-        mov r8, rcx
-        mov r9, rdi
-        mov rcx, rax
-        mov rdx, rbx
-        %else
-        mov rdx, rcx
-        mov rcx, rdi
-        mov     rdi, rax
-        mov rsi, rbx
-        %endif
-
-        call    EXTN(jsimd_h2v1_merged_upsample_sse2)
-
-        pop rax
-        pop rcx
-        pop rdi
-        pop rsi
-        pop rbx
-        pop rdx
-
-        add     rdi, byte SIZEOF_JSAMPROW       ; outptr1
-        add     rsi, byte SIZEOF_JSAMPROW       ; inptr01
-
-        push    rdx                     ; inptr2
-        push    rbx                     ; inptr1
-        push    rsi                     ; inptr00
-        mov     rbx,rsp
-
-        push    rdi
-        push    rcx
-        push    rax
-
-        %ifdef WIN64
-        mov r8, rcx
-        mov r9, rdi
-        mov rcx, rax
-        mov rdx, rbx
-        %else
-        mov rdx, rcx
-        mov rcx, rdi
-        mov     rdi, rax
-        mov rsi, rbx
-        %endif
-
-        call    EXTN(jsimd_h2v1_merged_upsample_sse2)
-
-        pop rax
-        pop rcx
-        pop rdi
-        pop rsi
-        pop rbx
-        pop rdx
-
-        pop     rbx
-        uncollect_args
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jdmrgext-sse2.asm b/simd/jdmrgext-sse2.asm
deleted file mode 100644
index b50f698..0000000
--- a/simd/jdmrgext-sse2.asm
+++ /dev/null
@@ -1,518 +0,0 @@
-;
-; jdmrgext.asm - merged upsampling/color conversion (SSE2)
-;
-; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2012, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jcolsamp.inc"
-
-; --------------------------------------------------------------------------
-;
-; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
-;
-; GLOBAL(void)
-; jsimd_h2v1_merged_upsample_sse2 (JDIMENSION output_width,
-;                                  JSAMPIMAGE input_buf,
-;                                  JDIMENSION in_row_group_ctr,
-;                                  JSAMPARRAY output_buf);
-;
-
-%define output_width(b) (b)+8                   ; JDIMENSION output_width
-%define input_buf(b)            (b)+12          ; JSAMPIMAGE input_buf
-%define in_row_group_ctr(b)     (b)+16          ; JDIMENSION in_row_group_ctr
-%define output_buf(b)           (b)+20          ; JSAMPARRAY output_buf
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          3
-%define gotptr          wk(0)-SIZEOF_POINTER    ; void * gotptr
-
-        align   16
-        global  EXTN(jsimd_h2v1_merged_upsample_sse2)
-
-EXTN(jsimd_h2v1_merged_upsample_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic eax             ; make a room for GOT address
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx                     ; get GOT address
-        movpic  POINTER [gotptr], ebx   ; save GOT address
-
-        mov     ecx, JDIMENSION [output_width(eax)]     ; col
-        test    ecx,ecx
-        jz      near .return
-
-        push    ecx
-
-        mov     edi, JSAMPIMAGE [input_buf(eax)]
-        mov     ecx, JDIMENSION [in_row_group_ctr(eax)]
-        mov     esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
-        mov     ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
-        mov     edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
-        mov     edi, JSAMPARRAY [output_buf(eax)]
-        mov     esi, JSAMPROW [esi+ecx*SIZEOF_JSAMPROW]         ; inptr0
-        mov     ebx, JSAMPROW [ebx+ecx*SIZEOF_JSAMPROW]         ; inptr1
-        mov     edx, JSAMPROW [edx+ecx*SIZEOF_JSAMPROW]         ; inptr2
-        mov     edi, JSAMPROW [edi]                             ; outptr
-
-        pop     ecx                     ; col
-
-        alignx  16,7
-.columnloop:
-        movpic  eax, POINTER [gotptr]   ; load GOT address (eax)
-
-        movdqa    xmm6, XMMWORD [ebx]   ; xmm6=Cb(0123456789ABCDEF)
-        movdqa    xmm7, XMMWORD [edx]   ; xmm7=Cr(0123456789ABCDEF)
-
-        pxor      xmm1,xmm1             ; xmm1=(all 0's)
-        pcmpeqw   xmm3,xmm3
-        psllw     xmm3,7                ; xmm3={0xFF80 0xFF80 0xFF80 0xFF80 ..}
-
-        movdqa    xmm4,xmm6
-        punpckhbw xmm6,xmm1             ; xmm6=Cb(89ABCDEF)=CbH
-        punpcklbw xmm4,xmm1             ; xmm4=Cb(01234567)=CbL
-        movdqa    xmm0,xmm7
-        punpckhbw xmm7,xmm1             ; xmm7=Cr(89ABCDEF)=CrH
-        punpcklbw xmm0,xmm1             ; xmm0=Cr(01234567)=CrL
-
-        paddw     xmm6,xmm3
-        paddw     xmm4,xmm3
-        paddw     xmm7,xmm3
-        paddw     xmm0,xmm3
-
-        ; (Original)
-        ; R = Y                + 1.40200 * Cr
-        ; G = Y - 0.34414 * Cb - 0.71414 * Cr
-        ; B = Y + 1.77200 * Cb
-        ;
-        ; (This implementation)
-        ; R = Y                + 0.40200 * Cr + Cr
-        ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
-        ; B = Y - 0.22800 * Cb + Cb + Cb
-
-        movdqa  xmm5,xmm6               ; xmm5=CbH
-        movdqa  xmm2,xmm4               ; xmm2=CbL
-        paddw   xmm6,xmm6               ; xmm6=2*CbH
-        paddw   xmm4,xmm4               ; xmm4=2*CbL
-        movdqa  xmm1,xmm7               ; xmm1=CrH
-        movdqa  xmm3,xmm0               ; xmm3=CrL
-        paddw   xmm7,xmm7               ; xmm7=2*CrH
-        paddw   xmm0,xmm0               ; xmm0=2*CrL
-
-        pmulhw  xmm6,[GOTOFF(eax,PW_MF0228)]    ; xmm6=(2*CbH * -FIX(0.22800))
-        pmulhw  xmm4,[GOTOFF(eax,PW_MF0228)]    ; xmm4=(2*CbL * -FIX(0.22800))
-        pmulhw  xmm7,[GOTOFF(eax,PW_F0402)]     ; xmm7=(2*CrH * FIX(0.40200))
-        pmulhw  xmm0,[GOTOFF(eax,PW_F0402)]     ; xmm0=(2*CrL * FIX(0.40200))
-
-        paddw   xmm6,[GOTOFF(eax,PW_ONE)]
-        paddw   xmm4,[GOTOFF(eax,PW_ONE)]
-        psraw   xmm6,1                  ; xmm6=(CbH * -FIX(0.22800))
-        psraw   xmm4,1                  ; xmm4=(CbL * -FIX(0.22800))
-        paddw   xmm7,[GOTOFF(eax,PW_ONE)]
-        paddw   xmm0,[GOTOFF(eax,PW_ONE)]
-        psraw   xmm7,1                  ; xmm7=(CrH * FIX(0.40200))
-        psraw   xmm0,1                  ; xmm0=(CrL * FIX(0.40200))
-
-        paddw   xmm6,xmm5
-        paddw   xmm4,xmm2
-        paddw   xmm6,xmm5               ; xmm6=(CbH * FIX(1.77200))=(B-Y)H
-        paddw   xmm4,xmm2               ; xmm4=(CbL * FIX(1.77200))=(B-Y)L
-        paddw   xmm7,xmm1               ; xmm7=(CrH * FIX(1.40200))=(R-Y)H
-        paddw   xmm0,xmm3               ; xmm0=(CrL * FIX(1.40200))=(R-Y)L
-
-        movdqa  XMMWORD [wk(0)], xmm6   ; wk(0)=(B-Y)H
-        movdqa  XMMWORD [wk(1)], xmm7   ; wk(1)=(R-Y)H
-
-        movdqa    xmm6,xmm5
-        movdqa    xmm7,xmm2
-        punpcklwd xmm5,xmm1
-        punpckhwd xmm6,xmm1
-        pmaddwd   xmm5,[GOTOFF(eax,PW_MF0344_F0285)]
-        pmaddwd   xmm6,[GOTOFF(eax,PW_MF0344_F0285)]
-        punpcklwd xmm2,xmm3
-        punpckhwd xmm7,xmm3
-        pmaddwd   xmm2,[GOTOFF(eax,PW_MF0344_F0285)]
-        pmaddwd   xmm7,[GOTOFF(eax,PW_MF0344_F0285)]
-
-        paddd     xmm5,[GOTOFF(eax,PD_ONEHALF)]
-        paddd     xmm6,[GOTOFF(eax,PD_ONEHALF)]
-        psrad     xmm5,SCALEBITS
-        psrad     xmm6,SCALEBITS
-        paddd     xmm2,[GOTOFF(eax,PD_ONEHALF)]
-        paddd     xmm7,[GOTOFF(eax,PD_ONEHALF)]
-        psrad     xmm2,SCALEBITS
-        psrad     xmm7,SCALEBITS
-
-        packssdw  xmm5,xmm6     ; xmm5=CbH*-FIX(0.344)+CrH*FIX(0.285)
-        packssdw  xmm2,xmm7     ; xmm2=CbL*-FIX(0.344)+CrL*FIX(0.285)
-        psubw     xmm5,xmm1     ; xmm5=CbH*-FIX(0.344)+CrH*-FIX(0.714)=(G-Y)H
-        psubw     xmm2,xmm3     ; xmm2=CbL*-FIX(0.344)+CrL*-FIX(0.714)=(G-Y)L
-
-        movdqa  XMMWORD [wk(2)], xmm5   ; wk(2)=(G-Y)H
-
-        mov     al,2                    ; Yctr
-        jmp     short .Yloop_1st
-        alignx  16,7
-
-.Yloop_2nd:
-        movdqa  xmm0, XMMWORD [wk(1)]   ; xmm0=(R-Y)H
-        movdqa  xmm2, XMMWORD [wk(2)]   ; xmm2=(G-Y)H
-        movdqa  xmm4, XMMWORD [wk(0)]   ; xmm4=(B-Y)H
-        alignx  16,7
-
-.Yloop_1st:
-        movdqa  xmm7, XMMWORD [esi]     ; xmm7=Y(0123456789ABCDEF)
-
-        pcmpeqw xmm6,xmm6
-        psrlw   xmm6,BYTE_BIT           ; xmm6={0xFF 0x00 0xFF 0x00 ..}
-        pand    xmm6,xmm7               ; xmm6=Y(02468ACE)=YE
-        psrlw   xmm7,BYTE_BIT           ; xmm7=Y(13579BDF)=YO
-
-        movdqa  xmm1,xmm0               ; xmm1=xmm0=(R-Y)(L/H)
-        movdqa  xmm3,xmm2               ; xmm3=xmm2=(G-Y)(L/H)
-        movdqa  xmm5,xmm4               ; xmm5=xmm4=(B-Y)(L/H)
-
-        paddw     xmm0,xmm6             ; xmm0=((R-Y)+YE)=RE=R(02468ACE)
-        paddw     xmm1,xmm7             ; xmm1=((R-Y)+YO)=RO=R(13579BDF)
-        packuswb  xmm0,xmm0             ; xmm0=R(02468ACE********)
-        packuswb  xmm1,xmm1             ; xmm1=R(13579BDF********)
-
-        paddw     xmm2,xmm6             ; xmm2=((G-Y)+YE)=GE=G(02468ACE)
-        paddw     xmm3,xmm7             ; xmm3=((G-Y)+YO)=GO=G(13579BDF)
-        packuswb  xmm2,xmm2             ; xmm2=G(02468ACE********)
-        packuswb  xmm3,xmm3             ; xmm3=G(13579BDF********)
-
-        paddw     xmm4,xmm6             ; xmm4=((B-Y)+YE)=BE=B(02468ACE)
-        paddw     xmm5,xmm7             ; xmm5=((B-Y)+YO)=BO=B(13579BDF)
-        packuswb  xmm4,xmm4             ; xmm4=B(02468ACE********)
-        packuswb  xmm5,xmm5             ; xmm5=B(13579BDF********)
-
-%if RGB_PIXELSIZE == 3 ; ---------------
-
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmB     ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
-        punpcklbw xmmD,xmmF     ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
-
-        movdqa    xmmG,xmmA
-        movdqa    xmmH,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
-        punpckhwd xmmG,xmmE     ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
-
-        psrldq    xmmH,2        ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
-        psrldq    xmmE,2        ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
-
-        movdqa    xmmC,xmmD
-        movdqa    xmmB,xmmD
-        punpcklwd xmmD,xmmH     ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
-        punpckhwd xmmC,xmmH     ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
-
-        psrldq    xmmB,2        ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
-
-        movdqa    xmmF,xmmE
-        punpcklwd xmmE,xmmB     ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
-        punpckhwd xmmF,xmmB     ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
-
-        pshufd    xmmH,xmmA,0x4E; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
-        movdqa    xmmB,xmmE
-        punpckldq xmmA,xmmD     ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
-        punpckldq xmmE,xmmH     ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
-        punpckhdq xmmD,xmmB     ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
-
-        pshufd    xmmH,xmmG,0x4E; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
-        movdqa    xmmB,xmmF
-        punpckldq xmmG,xmmC     ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
-        punpckldq xmmF,xmmH     ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
-        punpckhdq xmmC,xmmB     ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
-
-        punpcklqdq xmmA,xmmE    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
-        punpcklqdq xmmD,xmmG    ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
-        punpcklqdq xmmF,xmmC    ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    edi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [edi+2*SIZEOF_XMMWORD], xmmF
-.out0:
-        add     edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     ecx, byte SIZEOF_XMMWORD
-        jz      near .endcolumn
-
-        add     esi, byte SIZEOF_XMMWORD        ; inptr0
-        dec     al                      ; Yctr
-        jnz     near .Yloop_2nd
-
-        add     ebx, byte SIZEOF_XMMWORD        ; inptr1
-        add     edx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-        alignx  16,7
-
-.column_st32:
-        lea     ecx, [ecx+ecx*2]                ; imul ecx, RGB_PIXELSIZE
-        cmp     ecx, byte 2*SIZEOF_XMMWORD
-        jb      short .column_st16
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        add     edi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmF
-        sub     ecx, byte 2*SIZEOF_XMMWORD
-        jmp     short .column_st15
-.column_st16:
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jb      short .column_st15
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        add     edi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     ecx, byte SIZEOF_XMMWORD
-.column_st15:
-        ; Store the lower 8 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     ecx, byte SIZEOF_MMWORD
-        jb      short .column_st7
-        movq    XMM_MMWORD [edi], xmmA
-        add     edi, byte SIZEOF_MMWORD
-        sub     ecx, byte SIZEOF_MMWORD
-        psrldq  xmmA, SIZEOF_MMWORD
-.column_st7:
-        ; Store the lower 4 bytes of xmmA to the output when it has enough
-        ; space.
-        cmp     ecx, byte SIZEOF_DWORD
-        jb      short .column_st3
-        movd    XMM_DWORD [edi], xmmA
-        add     edi, byte SIZEOF_DWORD
-        sub     ecx, byte SIZEOF_DWORD
-        psrldq  xmmA, SIZEOF_DWORD
-.column_st3:
-        ; Store the lower 2 bytes of eax to the output when it has enough
-        ; space.
-        movd    eax, xmmA
-        cmp     ecx, byte SIZEOF_WORD
-        jb      short .column_st1
-        mov     WORD [edi], ax
-        add     edi, byte SIZEOF_WORD
-        sub     ecx, byte SIZEOF_WORD
-        shr     eax, 16
-.column_st1:
-        ; Store the lower 1 byte of eax to the output when it has enough
-        ; space.
-        test    ecx, ecx
-        jz      short .endcolumn
-        mov     BYTE [edi], al
-
-%else ; RGB_PIXELSIZE == 4 ; -----------
-
-%ifdef RGBX_FILLER_0XFF
-        pcmpeqb   xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pcmpeqb   xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%else
-        pxor      xmm6,xmm6             ; xmm6=XE=X(02468ACE********)
-        pxor      xmm7,xmm7             ; xmm7=XO=X(13579BDF********)
-%endif
-        ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
-        ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
-        ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
-        ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
-
-        punpcklbw xmmA,xmmC     ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
-        punpcklbw xmmE,xmmG     ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
-        punpcklbw xmmB,xmmD     ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
-        punpcklbw xmmF,xmmH     ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
-
-        movdqa    xmmC,xmmA
-        punpcklwd xmmA,xmmE     ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
-        punpckhwd xmmC,xmmE     ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
-        movdqa    xmmG,xmmB
-        punpcklwd xmmB,xmmF     ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
-        punpckhwd xmmG,xmmF     ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
-
-        movdqa    xmmD,xmmA
-        punpckldq xmmA,xmmB     ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
-        punpckhdq xmmD,xmmB     ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
-        movdqa    xmmH,xmmC
-        punpckldq xmmC,xmmG     ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
-        punpckhdq xmmH,xmmG     ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
-
-        cmp     ecx, byte SIZEOF_XMMWORD
-        jb      short .column_st32
-
-        test    edi, SIZEOF_XMMWORD-1
-        jnz     short .out1
-        ; --(aligned)-------------------
-        movntdq XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movntdq XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movntdq XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
-        movntdq XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
-        jmp     short .out0
-.out1:  ; --(unaligned)-----------------
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        movdqu  XMMWORD [edi+2*SIZEOF_XMMWORD], xmmC
-        movdqu  XMMWORD [edi+3*SIZEOF_XMMWORD], xmmH
-.out0:
-        add     edi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
-        sub     ecx, byte SIZEOF_XMMWORD
-        jz      near .endcolumn
-
-        add     esi, byte SIZEOF_XMMWORD        ; inptr0
-        dec     al                      ; Yctr
-        jnz     near .Yloop_2nd
-
-        add     ebx, byte SIZEOF_XMMWORD        ; inptr1
-        add     edx, byte SIZEOF_XMMWORD        ; inptr2
-        jmp     near .columnloop
-        alignx  16,7
-
-.column_st32:
-        cmp     ecx, byte SIZEOF_XMMWORD/2
-        jb      short .column_st16
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        movdqu  XMMWORD [edi+1*SIZEOF_XMMWORD], xmmD
-        add     edi, byte 2*SIZEOF_XMMWORD      ; outptr
-        movdqa  xmmA,xmmC
-        movdqa  xmmD,xmmH
-        sub     ecx, byte SIZEOF_XMMWORD/2
-.column_st16:
-        cmp     ecx, byte SIZEOF_XMMWORD/4
-        jb      short .column_st15
-        movdqu  XMMWORD [edi+0*SIZEOF_XMMWORD], xmmA
-        add     edi, byte SIZEOF_XMMWORD        ; outptr
-        movdqa  xmmA,xmmD
-        sub     ecx, byte SIZEOF_XMMWORD/4
-.column_st15:
-        ; Store two pixels (8 bytes) of xmmA to the output when it has enough
-        ; space.
-        cmp     ecx, byte SIZEOF_XMMWORD/8
-        jb      short .column_st7
-        movq    XMM_MMWORD [edi], xmmA
-        add     edi, byte SIZEOF_XMMWORD/8*4
-        sub     ecx, byte SIZEOF_XMMWORD/8
-        psrldq  xmmA, SIZEOF_XMMWORD/8*4
-.column_st7:
-        ; Store one pixel (4 bytes) of xmmA to the output when it has enough
-        ; space.
-        test    ecx, ecx
-        jz      short .endcolumn
-        movd    XMM_DWORD [edi], xmmA
-
-%endif ; RGB_PIXELSIZE ; ---------------
-
-.endcolumn:
-        sfence          ; flush the write buffer
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
-;
-; GLOBAL(void)
-; jsimd_h2v2_merged_upsample_sse2 (JDIMENSION output_width,
-;                                  JSAMPIMAGE input_buf,
-;                                  JDIMENSION in_row_group_ctr,
-;                                  JSAMPARRAY output_buf);
-;
-
-%define output_width(b) (b)+8                   ; JDIMENSION output_width
-%define input_buf(b)            (b)+12          ; JSAMPIMAGE input_buf
-%define in_row_group_ctr(b)     (b)+16          ; JDIMENSION in_row_group_ctr
-%define output_buf(b)           (b)+20          ; JSAMPARRAY output_buf
-
-        align   16
-        global  EXTN(jsimd_h2v2_merged_upsample_sse2)
-
-EXTN(jsimd_h2v2_merged_upsample_sse2):
-        push    ebp
-        mov     ebp,esp
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        mov     eax, POINTER [output_width(ebp)]
-
-        mov     edi, JSAMPIMAGE [input_buf(ebp)]
-        mov     ecx, JDIMENSION [in_row_group_ctr(ebp)]
-        mov     esi, JSAMPARRAY [edi+0*SIZEOF_JSAMPARRAY]
-        mov     ebx, JSAMPARRAY [edi+1*SIZEOF_JSAMPARRAY]
-        mov     edx, JSAMPARRAY [edi+2*SIZEOF_JSAMPARRAY]
-        mov     edi, JSAMPARRAY [output_buf(ebp)]
-        lea     esi, [esi+ecx*SIZEOF_JSAMPROW]
-
-        push    edx                     ; inptr2
-        push    ebx                     ; inptr1
-        push    esi                     ; inptr00
-        mov     ebx,esp
-
-        push    edi                     ; output_buf (outptr0)
-        push    ecx                     ; in_row_group_ctr
-        push    ebx                     ; input_buf
-        push    eax                     ; output_width
-
-        call    near EXTN(jsimd_h2v1_merged_upsample_sse2)
-
-        add     esi, byte SIZEOF_JSAMPROW       ; inptr01
-        add     edi, byte SIZEOF_JSAMPROW       ; outptr1
-        mov     POINTER [ebx+0*SIZEOF_POINTER], esi
-        mov     POINTER [ebx-1*SIZEOF_POINTER], edi
-
-        call    near EXTN(jsimd_h2v1_merged_upsample_sse2)
-
-        add     esp, byte 7*SIZEOF_DWORD
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jdsample-sse2-64.asm b/simd/jdsample-sse2-64.asm
deleted file mode 100644
index 1faaed6..0000000
--- a/simd/jdsample-sse2-64.asm
+++ /dev/null
@@ -1,670 +0,0 @@
-;
-; jdsample.asm - upsampling (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_fancy_upsample_sse2)
-
-EXTN(jconst_fancy_upsample_sse2):
-
-PW_ONE          times 8 dw  1
-PW_TWO          times 8 dw  2
-PW_THREE        times 8 dw  3
-PW_SEVEN        times 8 dw  7
-PW_EIGHT        times 8 dw  8
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
-;
-; The upsampling algorithm is linear interpolation between pixel centers,
-; also known as a "triangle filter".  This is a good compromise between
-; speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
-; of the way between input pixel centers.
-;
-; GLOBAL(void)
-; jsimd_h2v1_fancy_upsample_sse2 (int max_v_samp_factor,
-;                                 JDIMENSION downsampled_width,
-;                                 JSAMPARRAY input_data,
-;                                 JSAMPARRAY *output_data_ptr);
-;
-
-; r10 = int max_v_samp_factor
-; r11 = JDIMENSION downsampled_width
-; r12 = JSAMPARRAY input_data
-; r13 = JSAMPARRAY *output_data_ptr
-
-        align   16
-        global  EXTN(jsimd_h2v1_fancy_upsample_sse2)
-
-EXTN(jsimd_h2v1_fancy_upsample_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-
-        mov     eax, r11d  ; colctr
-        test    rax,rax
-        jz      near .return
-
-        mov     rcx, r10        ; rowctr
-        test    rcx,rcx
-        jz      near .return
-
-        mov     rsi, r12        ; input_data
-        mov     rdi, r13
-        mov     rdi, JSAMPARRAY [rdi]                   ; output_data
-.rowloop:
-        push    rax                     ; colctr
-        push    rdi
-        push    rsi
-
-        mov     rsi, JSAMPROW [rsi]     ; inptr
-        mov     rdi, JSAMPROW [rdi]     ; outptr
-
-        test    rax, SIZEOF_XMMWORD-1
-        jz      short .skip
-        mov     dl, JSAMPLE [rsi+(rax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [rsi+rax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
-.skip:
-        pxor    xmm0,xmm0               ; xmm0=(all 0's)
-        pcmpeqb xmm7,xmm7
-        psrldq  xmm7,(SIZEOF_XMMWORD-1)
-        pand    xmm7, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-
-        add     rax, byte SIZEOF_XMMWORD-1
-        and     rax, byte -SIZEOF_XMMWORD
-        cmp     rax, byte SIZEOF_XMMWORD
-        ja      short .columnloop
-
-.columnloop_last:
-        pcmpeqb xmm6,xmm6
-        pslldq  xmm6,(SIZEOF_XMMWORD-1)
-        pand    xmm6, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        jmp     short .upsample
-
-.columnloop:
-        movdqa  xmm6, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-        pslldq  xmm6,(SIZEOF_XMMWORD-1)
-
-.upsample:
-        movdqa  xmm1, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-        movdqa  xmm2,xmm1
-        movdqa  xmm3,xmm1               ; xmm1=( 0  1  2 ... 13 14 15)
-        pslldq  xmm2,1                  ; xmm2=(--  0  1 ... 12 13 14)
-        psrldq  xmm3,1                  ; xmm3=( 1  2  3 ... 14 15 --)
-
-        por     xmm2,xmm7               ; xmm2=(-1  0  1 ... 12 13 14)
-        por     xmm3,xmm6               ; xmm3=( 1  2  3 ... 14 15 16)
-
-        movdqa  xmm7,xmm1
-        psrldq  xmm7,(SIZEOF_XMMWORD-1) ; xmm7=(15 -- -- ... -- -- --)
-
-        movdqa    xmm4,xmm1
-        punpcklbw xmm1,xmm0             ; xmm1=( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm4,xmm0             ; xmm4=( 8  9 10 11 12 13 14 15)
-        movdqa    xmm5,xmm2
-        punpcklbw xmm2,xmm0             ; xmm2=(-1  0  1  2  3  4  5  6)
-        punpckhbw xmm5,xmm0             ; xmm5=( 7  8  9 10 11 12 13 14)
-        movdqa    xmm6,xmm3
-        punpcklbw xmm3,xmm0             ; xmm3=( 1  2  3  4  5  6  7  8)
-        punpckhbw xmm6,xmm0             ; xmm6=( 9 10 11 12 13 14 15 16)
-
-        pmullw  xmm1,[rel PW_THREE]
-        pmullw  xmm4,[rel PW_THREE]
-        paddw   xmm2,[rel PW_ONE]
-        paddw   xmm5,[rel PW_ONE]
-        paddw   xmm3,[rel PW_TWO]
-        paddw   xmm6,[rel PW_TWO]
-
-        paddw   xmm2,xmm1
-        paddw   xmm5,xmm4
-        psrlw   xmm2,2                  ; xmm2=OutLE=( 0  2  4  6  8 10 12 14)
-        psrlw   xmm5,2                  ; xmm5=OutHE=(16 18 20 22 24 26 28 30)
-        paddw   xmm3,xmm1
-        paddw   xmm6,xmm4
-        psrlw   xmm3,2                  ; xmm3=OutLO=( 1  3  5  7  9 11 13 15)
-        psrlw   xmm6,2                  ; xmm6=OutHO=(17 19 21 23 25 27 29 31)
-
-        psllw   xmm3,BYTE_BIT
-        psllw   xmm6,BYTE_BIT
-        por     xmm2,xmm3               ; xmm2=OutL=( 0  1  2 ... 13 14 15)
-        por     xmm5,xmm6               ; xmm5=OutH=(16 17 18 ... 29 30 31)
-
-        movdqa  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm5
-
-        sub     rax, byte SIZEOF_XMMWORD
-        add     rsi, byte 1*SIZEOF_XMMWORD      ; inptr
-        add     rdi, byte 2*SIZEOF_XMMWORD      ; outptr
-        cmp     rax, byte SIZEOF_XMMWORD
-        ja      near .columnloop
-        test    eax,eax
-        jnz     near .columnloop_last
-
-        pop     rsi
-        pop     rdi
-        pop     rax
-
-        add     rsi, byte SIZEOF_JSAMPROW       ; input_data
-        add     rdi, byte SIZEOF_JSAMPROW       ; output_data
-        dec     rcx                             ; rowctr
-        jg      near .rowloop
-
-.return:
-        uncollect_args
-        pop     rbp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
-; Again a triangle filter; see comments for h2v1 case, above.
-;
-; GLOBAL(void)
-; jsimd_h2v2_fancy_upsample_sse2 (int max_v_samp_factor,
-;                                 JDIMENSION downsampled_width,
-;                                 JSAMPARRAY input_data,
-;                                 JSAMPARRAY *output_data_ptr);
-;
-
-; r10 = int max_v_samp_factor
-; r11 = JDIMENSION downsampled_width
-; r12 = JSAMPARRAY input_data
-; r13 = JSAMPARRAY *output_data_ptr
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          4
-
-        align   16
-        global  EXTN(jsimd_h2v2_fancy_upsample_sse2)
-
-EXTN(jsimd_h2v2_fancy_upsample_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-        push    rbx
-
-        mov     eax, r11d  ; colctr
-        test    rax,rax
-        jz      near .return
-
-        mov     rcx, r10        ; rowctr
-        test    rcx,rcx
-        jz      near .return
-
-        mov     rsi, r12        ; input_data
-        mov     rdi, r13
-        mov     rdi, JSAMPARRAY [rdi]                   ; output_data
-.rowloop:
-        push    rax                                     ; colctr
-        push    rcx
-        push    rdi
-        push    rsi
-
-        mov     rcx, JSAMPROW [rsi-1*SIZEOF_JSAMPROW]   ; inptr1(above)
-        mov     rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]   ; inptr0
-        mov     rsi, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]   ; inptr1(below)
-        mov     rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]   ; outptr0
-        mov     rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]   ; outptr1
-
-        test    rax, SIZEOF_XMMWORD-1
-        jz      short .skip
-        push    rdx
-        mov     dl, JSAMPLE [rcx+(rax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [rcx+rax*SIZEOF_JSAMPLE], dl
-        mov     dl, JSAMPLE [rbx+(rax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [rbx+rax*SIZEOF_JSAMPLE], dl
-        mov     dl, JSAMPLE [rsi+(rax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [rsi+rax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
-        pop     rdx
-.skip:
-        ; -- process the first column block
-
-        movdqa  xmm0, XMMWORD [rbx+0*SIZEOF_XMMWORD]    ; xmm0=row[ 0][0]
-        movdqa  xmm1, XMMWORD [rcx+0*SIZEOF_XMMWORD]    ; xmm1=row[-1][0]
-        movdqa  xmm2, XMMWORD [rsi+0*SIZEOF_XMMWORD]    ; xmm2=row[+1][0]
-
-        pxor      xmm3,xmm3             ; xmm3=(all 0's)
-        movdqa    xmm4,xmm0
-        punpcklbw xmm0,xmm3             ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm4,xmm3             ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm5,xmm1
-        punpcklbw xmm1,xmm3             ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm5,xmm3             ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm6,xmm2
-        punpcklbw xmm2,xmm3             ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm6,xmm3             ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
-
-        pmullw  xmm0,[rel PW_THREE]
-        pmullw  xmm4,[rel PW_THREE]
-
-        pcmpeqb xmm7,xmm7
-        psrldq  xmm7,(SIZEOF_XMMWORD-2)
-
-        paddw   xmm1,xmm0               ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm5,xmm4               ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
-        paddw   xmm2,xmm0               ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm6,xmm4               ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
-
-        movdqa  XMMWORD [rdx+0*SIZEOF_XMMWORD], xmm1    ; temporarily save
-        movdqa  XMMWORD [rdx+1*SIZEOF_XMMWORD], xmm5    ; the intermediate data
-        movdqa  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm6
-
-        pand    xmm1,xmm7               ; xmm1=( 0 -- -- -- -- -- -- --)
-        pand    xmm2,xmm7               ; xmm2=( 0 -- -- -- -- -- -- --)
-
-        movdqa  XMMWORD [wk(0)], xmm1
-        movdqa  XMMWORD [wk(1)], xmm2
-
-        add     rax, byte SIZEOF_XMMWORD-1
-        and     rax, byte -SIZEOF_XMMWORD
-        cmp     rax, byte SIZEOF_XMMWORD
-        ja      short .columnloop
-
-.columnloop_last:
-        ; -- process the last column block
-
-        pcmpeqb xmm1,xmm1
-        pslldq  xmm1,(SIZEOF_XMMWORD-2)
-        movdqa  xmm2,xmm1
-
-        pand    xmm1, XMMWORD [rdx+1*SIZEOF_XMMWORD]
-        pand    xmm2, XMMWORD [rdi+1*SIZEOF_XMMWORD]
-
-        movdqa  XMMWORD [wk(2)], xmm1   ; xmm1=(-- -- -- -- -- -- -- 15)
-        movdqa  XMMWORD [wk(3)], xmm2   ; xmm2=(-- -- -- -- -- -- -- 15)
-
-        jmp     near .upsample
-
-.columnloop:
-        ; -- process the next column block
-
-        movdqa  xmm0, XMMWORD [rbx+1*SIZEOF_XMMWORD]    ; xmm0=row[ 0][1]
-        movdqa  xmm1, XMMWORD [rcx+1*SIZEOF_XMMWORD]    ; xmm1=row[-1][1]
-        movdqa  xmm2, XMMWORD [rsi+1*SIZEOF_XMMWORD]    ; xmm2=row[+1][1]
-
-        pxor      xmm3,xmm3             ; xmm3=(all 0's)
-        movdqa    xmm4,xmm0
-        punpcklbw xmm0,xmm3             ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm4,xmm3             ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm5,xmm1
-        punpcklbw xmm1,xmm3             ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm5,xmm3             ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm6,xmm2
-        punpcklbw xmm2,xmm3             ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm6,xmm3             ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
-
-        pmullw  xmm0,[rel PW_THREE]
-        pmullw  xmm4,[rel PW_THREE]
-
-        paddw   xmm1,xmm0               ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm5,xmm4               ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
-        paddw   xmm2,xmm0               ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm6,xmm4               ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
-
-        movdqa  XMMWORD [rdx+2*SIZEOF_XMMWORD], xmm1    ; temporarily save
-        movdqa  XMMWORD [rdx+3*SIZEOF_XMMWORD], xmm5    ; the intermediate data
-        movdqa  XMMWORD [rdi+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [rdi+3*SIZEOF_XMMWORD], xmm6
-
-        pslldq  xmm1,(SIZEOF_XMMWORD-2) ; xmm1=(-- -- -- -- -- -- --  0)
-        pslldq  xmm2,(SIZEOF_XMMWORD-2) ; xmm2=(-- -- -- -- -- -- --  0)
-
-        movdqa  XMMWORD [wk(2)], xmm1
-        movdqa  XMMWORD [wk(3)], xmm2
-
-.upsample:
-        ; -- process the upper row
-
-        movdqa  xmm7, XMMWORD [rdx+0*SIZEOF_XMMWORD]
-        movdqa  xmm3, XMMWORD [rdx+1*SIZEOF_XMMWORD]
-
-        movdqa  xmm0,xmm7               ; xmm7=Int0L=( 0  1  2  3  4  5  6  7)
-        movdqa  xmm4,xmm3               ; xmm3=Int0H=( 8  9 10 11 12 13 14 15)
-        psrldq  xmm0,2                  ; xmm0=( 1  2  3  4  5  6  7 --)
-        pslldq  xmm4,(SIZEOF_XMMWORD-2) ; xmm4=(-- -- -- -- -- -- --  8)
-        movdqa  xmm5,xmm7
-        movdqa  xmm6,xmm3
-        psrldq  xmm5,(SIZEOF_XMMWORD-2) ; xmm5=( 7 -- -- -- -- -- -- --)
-        pslldq  xmm6,2                  ; xmm6=(--  8  9 10 11 12 13 14)
-
-        por     xmm0,xmm4               ; xmm0=( 1  2  3  4  5  6  7  8)
-        por     xmm5,xmm6               ; xmm5=( 7  8  9 10 11 12 13 14)
-
-        movdqa  xmm1,xmm7
-        movdqa  xmm2,xmm3
-        pslldq  xmm1,2                  ; xmm1=(--  0  1  2  3  4  5  6)
-        psrldq  xmm2,2                  ; xmm2=( 9 10 11 12 13 14 15 --)
-        movdqa  xmm4,xmm3
-        psrldq  xmm4,(SIZEOF_XMMWORD-2) ; xmm4=(15 -- -- -- -- -- -- --)
-
-        por     xmm1, XMMWORD [wk(0)]   ; xmm1=(-1  0  1  2  3  4  5  6)
-        por     xmm2, XMMWORD [wk(2)]   ; xmm2=( 9 10 11 12 13 14 15 16)
-
-        movdqa  XMMWORD [wk(0)], xmm4
-
-        pmullw  xmm7,[rel PW_THREE]
-        pmullw  xmm3,[rel PW_THREE]
-        paddw   xmm1,[rel PW_EIGHT]
-        paddw   xmm5,[rel PW_EIGHT]
-        paddw   xmm0,[rel PW_SEVEN]
-        paddw   xmm2,[rel PW_SEVEN]
-
-        paddw   xmm1,xmm7
-        paddw   xmm5,xmm3
-        psrlw   xmm1,4                  ; xmm1=Out0LE=( 0  2  4  6  8 10 12 14)
-        psrlw   xmm5,4                  ; xmm5=Out0HE=(16 18 20 22 24 26 28 30)
-        paddw   xmm0,xmm7
-        paddw   xmm2,xmm3
-        psrlw   xmm0,4                  ; xmm0=Out0LO=( 1  3  5  7  9 11 13 15)
-        psrlw   xmm2,4                  ; xmm2=Out0HO=(17 19 21 23 25 27 29 31)
-
-        psllw   xmm0,BYTE_BIT
-        psllw   xmm2,BYTE_BIT
-        por     xmm1,xmm0               ; xmm1=Out0L=( 0  1  2 ... 13 14 15)
-        por     xmm5,xmm2               ; xmm5=Out0H=(16 17 18 ... 29 30 31)
-
-        movdqa  XMMWORD [rdx+0*SIZEOF_XMMWORD], xmm1
-        movdqa  XMMWORD [rdx+1*SIZEOF_XMMWORD], xmm5
-
-        ; -- process the lower row
-
-        movdqa  xmm6, XMMWORD [rdi+0*SIZEOF_XMMWORD]
-        movdqa  xmm4, XMMWORD [rdi+1*SIZEOF_XMMWORD]
-
-        movdqa  xmm7,xmm6               ; xmm6=Int1L=( 0  1  2  3  4  5  6  7)
-        movdqa  xmm3,xmm4               ; xmm4=Int1H=( 8  9 10 11 12 13 14 15)
-        psrldq  xmm7,2                  ; xmm7=( 1  2  3  4  5  6  7 --)
-        pslldq  xmm3,(SIZEOF_XMMWORD-2) ; xmm3=(-- -- -- -- -- -- --  8)
-        movdqa  xmm0,xmm6
-        movdqa  xmm2,xmm4
-        psrldq  xmm0,(SIZEOF_XMMWORD-2) ; xmm0=( 7 -- -- -- -- -- -- --)
-        pslldq  xmm2,2                  ; xmm2=(--  8  9 10 11 12 13 14)
-
-        por     xmm7,xmm3               ; xmm7=( 1  2  3  4  5  6  7  8)
-        por     xmm0,xmm2               ; xmm0=( 7  8  9 10 11 12 13 14)
-
-        movdqa  xmm1,xmm6
-        movdqa  xmm5,xmm4
-        pslldq  xmm1,2                  ; xmm1=(--  0  1  2  3  4  5  6)
-        psrldq  xmm5,2                  ; xmm5=( 9 10 11 12 13 14 15 --)
-        movdqa  xmm3,xmm4
-        psrldq  xmm3,(SIZEOF_XMMWORD-2) ; xmm3=(15 -- -- -- -- -- -- --)
-
-        por     xmm1, XMMWORD [wk(1)]   ; xmm1=(-1  0  1  2  3  4  5  6)
-        por     xmm5, XMMWORD [wk(3)]   ; xmm5=( 9 10 11 12 13 14 15 16)
-
-        movdqa  XMMWORD [wk(1)], xmm3
-
-        pmullw  xmm6,[rel PW_THREE]
-        pmullw  xmm4,[rel PW_THREE]
-        paddw   xmm1,[rel PW_EIGHT]
-        paddw   xmm0,[rel PW_EIGHT]
-        paddw   xmm7,[rel PW_SEVEN]
-        paddw   xmm5,[rel PW_SEVEN]
-
-        paddw   xmm1,xmm6
-        paddw   xmm0,xmm4
-        psrlw   xmm1,4                  ; xmm1=Out1LE=( 0  2  4  6  8 10 12 14)
-        psrlw   xmm0,4                  ; xmm0=Out1HE=(16 18 20 22 24 26 28 30)
-        paddw   xmm7,xmm6
-        paddw   xmm5,xmm4
-        psrlw   xmm7,4                  ; xmm7=Out1LO=( 1  3  5  7  9 11 13 15)
-        psrlw   xmm5,4                  ; xmm5=Out1HO=(17 19 21 23 25 27 29 31)
-
-        psllw   xmm7,BYTE_BIT
-        psllw   xmm5,BYTE_BIT
-        por     xmm1,xmm7               ; xmm1=Out1L=( 0  1  2 ... 13 14 15)
-        por     xmm0,xmm5               ; xmm0=Out1H=(16 17 18 ... 29 30 31)
-
-        movdqa  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm1
-        movdqa  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm0
-
-        sub     rax, byte SIZEOF_XMMWORD
-        add     rcx, byte 1*SIZEOF_XMMWORD      ; inptr1(above)
-        add     rbx, byte 1*SIZEOF_XMMWORD      ; inptr0
-        add     rsi, byte 1*SIZEOF_XMMWORD      ; inptr1(below)
-        add     rdx, byte 2*SIZEOF_XMMWORD      ; outptr0
-        add     rdi, byte 2*SIZEOF_XMMWORD      ; outptr1
-        cmp     rax, byte SIZEOF_XMMWORD
-        ja      near .columnloop
-        test    rax,rax
-        jnz     near .columnloop_last
-
-        pop     rsi
-        pop     rdi
-        pop     rcx
-        pop     rax
-
-        add     rsi, byte 1*SIZEOF_JSAMPROW     ; input_data
-        add     rdi, byte 2*SIZEOF_JSAMPROW     ; output_data
-        sub     rcx, byte 2                     ; rowctr
-        jg      near .rowloop
-
-.return:
-        pop     rbx
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
-; It's still a box filter.
-;
-; GLOBAL(void)
-; jsimd_h2v1_upsample_sse2 (int max_v_samp_factor,
-;                           JDIMENSION output_width,
-;                           JSAMPARRAY input_data,
-;                           JSAMPARRAY *output_data_ptr);
-;
-
-; r10 = int max_v_samp_factor
-; r11 = JDIMENSION output_width
-; r12 = JSAMPARRAY input_data
-; r13 = JSAMPARRAY *output_data_ptr
-
-        align   16
-        global  EXTN(jsimd_h2v1_upsample_sse2)
-
-EXTN(jsimd_h2v1_upsample_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-
-        mov     edx, r11d
-        add     rdx, byte (2*SIZEOF_XMMWORD)-1
-        and     rdx, byte -(2*SIZEOF_XMMWORD)
-        jz      near .return
-
-        mov     rcx, r10        ; rowctr
-        test    rcx,rcx
-        jz      short .return
-
-        mov     rsi, r12 ; input_data
-        mov     rdi, r13
-        mov     rdi, JSAMPARRAY [rdi]                   ; output_data
-.rowloop:
-        push    rdi
-        push    rsi
-
-        mov     rsi, JSAMPROW [rsi]             ; inptr
-        mov     rdi, JSAMPROW [rdi]             ; outptr
-        mov     rax,rdx                         ; colctr
-.columnloop:
-
-        movdqa  xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-
-        movdqa    xmm1,xmm0
-        punpcklbw xmm0,xmm0
-        punpckhbw xmm1,xmm1
-
-        movdqa  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
-        movdqa  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm1
-
-        sub     rax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        movdqa  xmm2, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-
-        movdqa    xmm3,xmm2
-        punpcklbw xmm2,xmm2
-        punpckhbw xmm3,xmm3
-
-        movdqa  XMMWORD [rdi+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [rdi+3*SIZEOF_XMMWORD], xmm3
-
-        sub     rax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        add     rsi, byte 2*SIZEOF_XMMWORD      ; inptr
-        add     rdi, byte 4*SIZEOF_XMMWORD      ; outptr
-        jmp     short .columnloop
-
-.nextrow:
-        pop     rsi
-        pop     rdi
-
-        add     rsi, byte SIZEOF_JSAMPROW       ; input_data
-        add     rdi, byte SIZEOF_JSAMPROW       ; output_data
-        dec     rcx                             ; rowctr
-        jg      short .rowloop
-
-.return:
-        uncollect_args
-        pop     rbp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
-; It's still a box filter.
-;
-; GLOBAL(void)
-; jsimd_h2v2_upsample_sse2 (nt max_v_samp_factor,
-;                           JDIMENSION output_width,
-;                           JSAMPARRAY input_data,
-;                           JSAMPARRAY *output_data_ptr);
-;
-
-; r10 = int max_v_samp_factor
-; r11 = JDIMENSION output_width
-; r12 = JSAMPARRAY input_data
-; r13 = JSAMPARRAY *output_data_ptr
-
-        align   16
-        global  EXTN(jsimd_h2v2_upsample_sse2)
-
-EXTN(jsimd_h2v2_upsample_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-        push    rbx
-
-        mov     edx, r11d
-        add     rdx, byte (2*SIZEOF_XMMWORD)-1
-        and     rdx, byte -(2*SIZEOF_XMMWORD)
-        jz      near .return
-
-        mov     rcx, r10        ; rowctr
-        test    rcx,rcx
-        jz      near .return
-
-        mov     rsi, r12        ; input_data
-        mov     rdi, r13
-        mov     rdi, JSAMPARRAY [rdi]                   ; output_data
-.rowloop:
-        push    rdi
-        push    rsi
-
-        mov     rsi, JSAMPROW [rsi]                     ; inptr
-        mov     rbx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]   ; outptr0
-        mov     rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]   ; outptr1
-        mov     rax,rdx                                 ; colctr
-.columnloop:
-
-        movdqa  xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
-
-        movdqa    xmm1,xmm0
-        punpcklbw xmm0,xmm0
-        punpckhbw xmm1,xmm1
-
-        movdqa  XMMWORD [rbx+0*SIZEOF_XMMWORD], xmm0
-        movdqa  XMMWORD [rbx+1*SIZEOF_XMMWORD], xmm1
-        movdqa  XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
-        movdqa  XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm1
-
-        sub     rax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        movdqa  xmm2, XMMWORD [rsi+1*SIZEOF_XMMWORD]
-
-        movdqa    xmm3,xmm2
-        punpcklbw xmm2,xmm2
-        punpckhbw xmm3,xmm3
-
-        movdqa  XMMWORD [rbx+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [rbx+3*SIZEOF_XMMWORD], xmm3
-        movdqa  XMMWORD [rdi+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [rdi+3*SIZEOF_XMMWORD], xmm3
-
-        sub     rax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        add     rsi, byte 2*SIZEOF_XMMWORD      ; inptr
-        add     rbx, byte 4*SIZEOF_XMMWORD      ; outptr0
-        add     rdi, byte 4*SIZEOF_XMMWORD      ; outptr1
-        jmp     short .columnloop
-
-.nextrow:
-        pop     rsi
-        pop     rdi
-
-        add     rsi, byte 1*SIZEOF_JSAMPROW     ; input_data
-        add     rdi, byte 2*SIZEOF_JSAMPROW     ; output_data
-        sub     rcx, byte 2                     ; rowctr
-        jg      near .rowloop
-
-.return:
-        pop     rbx
-        uncollect_args
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jdsample-sse2.asm b/simd/jdsample-sse2.asm
deleted file mode 100644
index 1d0059e..0000000
--- a/simd/jdsample-sse2.asm
+++ /dev/null
@@ -1,728 +0,0 @@
-;
-; jdsample.asm - upsampling (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_fancy_upsample_sse2)
-
-EXTN(jconst_fancy_upsample_sse2):
-
-PW_ONE          times 8 dw  1
-PW_TWO          times 8 dw  2
-PW_THREE        times 8 dw  3
-PW_SEVEN        times 8 dw  7
-PW_EIGHT        times 8 dw  8
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
-;
-; The upsampling algorithm is linear interpolation between pixel centers,
-; also known as a "triangle filter".  This is a good compromise between
-; speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
-; of the way between input pixel centers.
-;
-; GLOBAL(void)
-; jsimd_h2v1_fancy_upsample_sse2 (int max_v_samp_factor,
-;                                 JDIMENSION downsampled_width,
-;                                 JSAMPARRAY input_data,
-;                                 JSAMPARRAY *output_data_ptr);
-;
-
-%define max_v_samp(b)           (b)+8           ; int max_v_samp_factor
-%define downsamp_width(b)       (b)+12          ; JDIMENSION downsampled_width
-%define input_data(b)           (b)+16          ; JSAMPARRAY input_data
-%define output_data_ptr(b)      (b)+20          ; JSAMPARRAY *output_data_ptr
-
-        align   16
-        global  EXTN(jsimd_h2v1_fancy_upsample_sse2)
-
-EXTN(jsimd_h2v1_fancy_upsample_sse2):
-        push    ebp
-        mov     ebp,esp
-        pushpic ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx             ; get GOT address
-
-        mov     eax, JDIMENSION [downsamp_width(ebp)]  ; colctr
-        test    eax,eax
-        jz      near .return
-
-        mov     ecx, INT [max_v_samp(ebp)]      ; rowctr
-        test    ecx,ecx
-        jz      near .return
-
-        mov     esi, JSAMPARRAY [input_data(ebp)]       ; input_data
-        mov     edi, POINTER [output_data_ptr(ebp)]
-        mov     edi, JSAMPARRAY [edi]                   ; output_data
-        alignx  16,7
-.rowloop:
-        push    eax                     ; colctr
-        push    edi
-        push    esi
-
-        mov     esi, JSAMPROW [esi]     ; inptr
-        mov     edi, JSAMPROW [edi]     ; outptr
-
-        test    eax, SIZEOF_XMMWORD-1
-        jz      short .skip
-        mov     dl, JSAMPLE [esi+(eax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [esi+eax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
-.skip:
-        pxor    xmm0,xmm0               ; xmm0=(all 0's)
-        pcmpeqb xmm7,xmm7
-        psrldq  xmm7,(SIZEOF_XMMWORD-1)
-        pand    xmm7, XMMWORD [esi+0*SIZEOF_XMMWORD]
-
-        add     eax, byte SIZEOF_XMMWORD-1
-        and     eax, byte -SIZEOF_XMMWORD
-        cmp     eax, byte SIZEOF_XMMWORD
-        ja      short .columnloop
-        alignx  16,7
-
-.columnloop_last:
-        pcmpeqb xmm6,xmm6
-        pslldq  xmm6,(SIZEOF_XMMWORD-1)
-        pand    xmm6, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        jmp     short .upsample
-        alignx  16,7
-
-.columnloop:
-        movdqa  xmm6, XMMWORD [esi+1*SIZEOF_XMMWORD]
-        pslldq  xmm6,(SIZEOF_XMMWORD-1)
-
-.upsample:
-        movdqa  xmm1, XMMWORD [esi+0*SIZEOF_XMMWORD]
-        movdqa  xmm2,xmm1
-        movdqa  xmm3,xmm1               ; xmm1=( 0  1  2 ... 13 14 15)
-        pslldq  xmm2,1                  ; xmm2=(--  0  1 ... 12 13 14)
-        psrldq  xmm3,1                  ; xmm3=( 1  2  3 ... 14 15 --)
-
-        por     xmm2,xmm7               ; xmm2=(-1  0  1 ... 12 13 14)
-        por     xmm3,xmm6               ; xmm3=( 1  2  3 ... 14 15 16)
-
-        movdqa  xmm7,xmm1
-        psrldq  xmm7,(SIZEOF_XMMWORD-1) ; xmm7=(15 -- -- ... -- -- --)
-
-        movdqa    xmm4,xmm1
-        punpcklbw xmm1,xmm0             ; xmm1=( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm4,xmm0             ; xmm4=( 8  9 10 11 12 13 14 15)
-        movdqa    xmm5,xmm2
-        punpcklbw xmm2,xmm0             ; xmm2=(-1  0  1  2  3  4  5  6)
-        punpckhbw xmm5,xmm0             ; xmm5=( 7  8  9 10 11 12 13 14)
-        movdqa    xmm6,xmm3
-        punpcklbw xmm3,xmm0             ; xmm3=( 1  2  3  4  5  6  7  8)
-        punpckhbw xmm6,xmm0             ; xmm6=( 9 10 11 12 13 14 15 16)
-
-        pmullw  xmm1,[GOTOFF(ebx,PW_THREE)]
-        pmullw  xmm4,[GOTOFF(ebx,PW_THREE)]
-        paddw   xmm2,[GOTOFF(ebx,PW_ONE)]
-        paddw   xmm5,[GOTOFF(ebx,PW_ONE)]
-        paddw   xmm3,[GOTOFF(ebx,PW_TWO)]
-        paddw   xmm6,[GOTOFF(ebx,PW_TWO)]
-
-        paddw   xmm2,xmm1
-        paddw   xmm5,xmm4
-        psrlw   xmm2,2                  ; xmm2=OutLE=( 0  2  4  6  8 10 12 14)
-        psrlw   xmm5,2                  ; xmm5=OutHE=(16 18 20 22 24 26 28 30)
-        paddw   xmm3,xmm1
-        paddw   xmm6,xmm4
-        psrlw   xmm3,2                  ; xmm3=OutLO=( 1  3  5  7  9 11 13 15)
-        psrlw   xmm6,2                  ; xmm6=OutHO=(17 19 21 23 25 27 29 31)
-
-        psllw   xmm3,BYTE_BIT
-        psllw   xmm6,BYTE_BIT
-        por     xmm2,xmm3               ; xmm2=OutL=( 0  1  2 ... 13 14 15)
-        por     xmm5,xmm6               ; xmm5=OutH=(16 17 18 ... 29 30 31)
-
-        movdqa  XMMWORD [edi+0*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [edi+1*SIZEOF_XMMWORD], xmm5
-
-        sub     eax, byte SIZEOF_XMMWORD
-        add     esi, byte 1*SIZEOF_XMMWORD      ; inptr
-        add     edi, byte 2*SIZEOF_XMMWORD      ; outptr
-        cmp     eax, byte SIZEOF_XMMWORD
-        ja      near .columnloop
-        test    eax,eax
-        jnz     near .columnloop_last
-
-        pop     esi
-        pop     edi
-        pop     eax
-
-        add     esi, byte SIZEOF_JSAMPROW       ; input_data
-        add     edi, byte SIZEOF_JSAMPROW       ; output_data
-        dec     ecx                             ; rowctr
-        jg      near .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        poppic  ebx
-        pop     ebp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
-; Again a triangle filter; see comments for h2v1 case, above.
-;
-; GLOBAL(void)
-; jsimd_h2v2_fancy_upsample_sse2 (int max_v_samp_factor,
-;                                 JDIMENSION downsampled_width,
-;                                 JSAMPARRAY input_data,
-;                                 JSAMPARRAY *output_data_ptr);
-;
-
-%define max_v_samp(b)           (b)+8           ; int max_v_samp_factor
-%define downsamp_width(b)       (b)+12          ; JDIMENSION downsampled_width
-%define input_data(b)           (b)+16          ; JSAMPARRAY input_data
-%define output_data_ptr(b)      (b)+20          ; JSAMPARRAY *output_data_ptr
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          4
-%define gotptr          wk(0)-SIZEOF_POINTER    ; void *gotptr
-
-        align   16
-        global  EXTN(jsimd_h2v2_fancy_upsample_sse2)
-
-EXTN(jsimd_h2v2_fancy_upsample_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic eax             ; make a room for GOT address
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx                     ; get GOT address
-        movpic  POINTER [gotptr], ebx   ; save GOT address
-
-        mov     edx,eax                         ; edx = original ebp
-        mov     eax, JDIMENSION [downsamp_width(edx)]  ; colctr
-        test    eax,eax
-        jz      near .return
-
-        mov     ecx, INT [max_v_samp(edx)]      ; rowctr
-        test    ecx,ecx
-        jz      near .return
-
-        mov     esi, JSAMPARRAY [input_data(edx)]       ; input_data
-        mov     edi, POINTER [output_data_ptr(edx)]
-        mov     edi, JSAMPARRAY [edi]                   ; output_data
-        alignx  16,7
-.rowloop:
-        push    eax                                     ; colctr
-        push    ecx
-        push    edi
-        push    esi
-
-        mov     ecx, JSAMPROW [esi-1*SIZEOF_JSAMPROW]   ; inptr1(above)
-        mov     ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]   ; inptr0
-        mov     esi, JSAMPROW [esi+1*SIZEOF_JSAMPROW]   ; inptr1(below)
-        mov     edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]   ; outptr0
-        mov     edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]   ; outptr1
-
-        test    eax, SIZEOF_XMMWORD-1
-        jz      short .skip
-        push    edx
-        mov     dl, JSAMPLE [ecx+(eax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [ecx+eax*SIZEOF_JSAMPLE], dl
-        mov     dl, JSAMPLE [ebx+(eax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [ebx+eax*SIZEOF_JSAMPLE], dl
-        mov     dl, JSAMPLE [esi+(eax-1)*SIZEOF_JSAMPLE]
-        mov     JSAMPLE [esi+eax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
-        pop     edx
-.skip:
-        ; -- process the first column block
-
-        movdqa  xmm0, XMMWORD [ebx+0*SIZEOF_XMMWORD]    ; xmm0=row[ 0][0]
-        movdqa  xmm1, XMMWORD [ecx+0*SIZEOF_XMMWORD]    ; xmm1=row[-1][0]
-        movdqa  xmm2, XMMWORD [esi+0*SIZEOF_XMMWORD]    ; xmm2=row[+1][0]
-
-        pushpic ebx
-        movpic  ebx, POINTER [gotptr]   ; load GOT address
-
-        pxor      xmm3,xmm3             ; xmm3=(all 0's)
-        movdqa    xmm4,xmm0
-        punpcklbw xmm0,xmm3             ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm4,xmm3             ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm5,xmm1
-        punpcklbw xmm1,xmm3             ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm5,xmm3             ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm6,xmm2
-        punpcklbw xmm2,xmm3             ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm6,xmm3             ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
-
-        pmullw  xmm0,[GOTOFF(ebx,PW_THREE)]
-        pmullw  xmm4,[GOTOFF(ebx,PW_THREE)]
-
-        pcmpeqb xmm7,xmm7
-        psrldq  xmm7,(SIZEOF_XMMWORD-2)
-
-        paddw   xmm1,xmm0               ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm5,xmm4               ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
-        paddw   xmm2,xmm0               ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm6,xmm4               ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
-
-        movdqa  XMMWORD [edx+0*SIZEOF_XMMWORD], xmm1    ; temporarily save
-        movdqa  XMMWORD [edx+1*SIZEOF_XMMWORD], xmm5    ; the intermediate data
-        movdqa  XMMWORD [edi+0*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [edi+1*SIZEOF_XMMWORD], xmm6
-
-        pand    xmm1,xmm7               ; xmm1=( 0 -- -- -- -- -- -- --)
-        pand    xmm2,xmm7               ; xmm2=( 0 -- -- -- -- -- -- --)
-
-        movdqa  XMMWORD [wk(0)], xmm1
-        movdqa  XMMWORD [wk(1)], xmm2
-
-        poppic  ebx
-
-        add     eax, byte SIZEOF_XMMWORD-1
-        and     eax, byte -SIZEOF_XMMWORD
-        cmp     eax, byte SIZEOF_XMMWORD
-        ja      short .columnloop
-        alignx  16,7
-
-.columnloop_last:
-        ; -- process the last column block
-
-        pushpic ebx
-        movpic  ebx, POINTER [gotptr]   ; load GOT address
-
-        pcmpeqb xmm1,xmm1
-        pslldq  xmm1,(SIZEOF_XMMWORD-2)
-        movdqa  xmm2,xmm1
-
-        pand    xmm1, XMMWORD [edx+1*SIZEOF_XMMWORD]
-        pand    xmm2, XMMWORD [edi+1*SIZEOF_XMMWORD]
-
-        movdqa  XMMWORD [wk(2)], xmm1   ; xmm1=(-- -- -- -- -- -- -- 15)
-        movdqa  XMMWORD [wk(3)], xmm2   ; xmm2=(-- -- -- -- -- -- -- 15)
-
-        jmp     near .upsample
-        alignx  16,7
-
-.columnloop:
-        ; -- process the next column block
-
-        movdqa  xmm0, XMMWORD [ebx+1*SIZEOF_XMMWORD]    ; xmm0=row[ 0][1]
-        movdqa  xmm1, XMMWORD [ecx+1*SIZEOF_XMMWORD]    ; xmm1=row[-1][1]
-        movdqa  xmm2, XMMWORD [esi+1*SIZEOF_XMMWORD]    ; xmm2=row[+1][1]
-
-        pushpic ebx
-        movpic  ebx, POINTER [gotptr]   ; load GOT address
-
-        pxor      xmm3,xmm3             ; xmm3=(all 0's)
-        movdqa    xmm4,xmm0
-        punpcklbw xmm0,xmm3             ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm4,xmm3             ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm5,xmm1
-        punpcklbw xmm1,xmm3             ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm5,xmm3             ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
-        movdqa    xmm6,xmm2
-        punpcklbw xmm2,xmm3             ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
-        punpckhbw xmm6,xmm3             ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
-
-        pmullw  xmm0,[GOTOFF(ebx,PW_THREE)]
-        pmullw  xmm4,[GOTOFF(ebx,PW_THREE)]
-
-        paddw   xmm1,xmm0               ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm5,xmm4               ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
-        paddw   xmm2,xmm0               ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
-        paddw   xmm6,xmm4               ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
-
-        movdqa  XMMWORD [edx+2*SIZEOF_XMMWORD], xmm1    ; temporarily save
-        movdqa  XMMWORD [edx+3*SIZEOF_XMMWORD], xmm5    ; the intermediate data
-        movdqa  XMMWORD [edi+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [edi+3*SIZEOF_XMMWORD], xmm6
-
-        pslldq  xmm1,(SIZEOF_XMMWORD-2) ; xmm1=(-- -- -- -- -- -- --  0)
-        pslldq  xmm2,(SIZEOF_XMMWORD-2) ; xmm2=(-- -- -- -- -- -- --  0)
-
-        movdqa  XMMWORD [wk(2)], xmm1
-        movdqa  XMMWORD [wk(3)], xmm2
-
-.upsample:
-        ; -- process the upper row
-
-        movdqa  xmm7, XMMWORD [edx+0*SIZEOF_XMMWORD]
-        movdqa  xmm3, XMMWORD [edx+1*SIZEOF_XMMWORD]
-
-        movdqa  xmm0,xmm7               ; xmm7=Int0L=( 0  1  2  3  4  5  6  7)
-        movdqa  xmm4,xmm3               ; xmm3=Int0H=( 8  9 10 11 12 13 14 15)
-        psrldq  xmm0,2                  ; xmm0=( 1  2  3  4  5  6  7 --)
-        pslldq  xmm4,(SIZEOF_XMMWORD-2) ; xmm4=(-- -- -- -- -- -- --  8)
-        movdqa  xmm5,xmm7
-        movdqa  xmm6,xmm3
-        psrldq  xmm5,(SIZEOF_XMMWORD-2) ; xmm5=( 7 -- -- -- -- -- -- --)
-        pslldq  xmm6,2                  ; xmm6=(--  8  9 10 11 12 13 14)
-
-        por     xmm0,xmm4               ; xmm0=( 1  2  3  4  5  6  7  8)
-        por     xmm5,xmm6               ; xmm5=( 7  8  9 10 11 12 13 14)
-
-        movdqa  xmm1,xmm7
-        movdqa  xmm2,xmm3
-        pslldq  xmm1,2                  ; xmm1=(--  0  1  2  3  4  5  6)
-        psrldq  xmm2,2                  ; xmm2=( 9 10 11 12 13 14 15 --)
-        movdqa  xmm4,xmm3
-        psrldq  xmm4,(SIZEOF_XMMWORD-2) ; xmm4=(15 -- -- -- -- -- -- --)
-
-        por     xmm1, XMMWORD [wk(0)]   ; xmm1=(-1  0  1  2  3  4  5  6)
-        por     xmm2, XMMWORD [wk(2)]   ; xmm2=( 9 10 11 12 13 14 15 16)
-
-        movdqa  XMMWORD [wk(0)], xmm4
-
-        pmullw  xmm7,[GOTOFF(ebx,PW_THREE)]
-        pmullw  xmm3,[GOTOFF(ebx,PW_THREE)]
-        paddw   xmm1,[GOTOFF(ebx,PW_EIGHT)]
-        paddw   xmm5,[GOTOFF(ebx,PW_EIGHT)]
-        paddw   xmm0,[GOTOFF(ebx,PW_SEVEN)]
-        paddw   xmm2,[GOTOFF(ebx,PW_SEVEN)]
-
-        paddw   xmm1,xmm7
-        paddw   xmm5,xmm3
-        psrlw   xmm1,4                  ; xmm1=Out0LE=( 0  2  4  6  8 10 12 14)
-        psrlw   xmm5,4                  ; xmm5=Out0HE=(16 18 20 22 24 26 28 30)
-        paddw   xmm0,xmm7
-        paddw   xmm2,xmm3
-        psrlw   xmm0,4                  ; xmm0=Out0LO=( 1  3  5  7  9 11 13 15)
-        psrlw   xmm2,4                  ; xmm2=Out0HO=(17 19 21 23 25 27 29 31)
-
-        psllw   xmm0,BYTE_BIT
-        psllw   xmm2,BYTE_BIT
-        por     xmm1,xmm0               ; xmm1=Out0L=( 0  1  2 ... 13 14 15)
-        por     xmm5,xmm2               ; xmm5=Out0H=(16 17 18 ... 29 30 31)
-
-        movdqa  XMMWORD [edx+0*SIZEOF_XMMWORD], xmm1
-        movdqa  XMMWORD [edx+1*SIZEOF_XMMWORD], xmm5
-
-        ; -- process the lower row
-
-        movdqa  xmm6, XMMWORD [edi+0*SIZEOF_XMMWORD]
-        movdqa  xmm4, XMMWORD [edi+1*SIZEOF_XMMWORD]
-
-        movdqa  xmm7,xmm6               ; xmm6=Int1L=( 0  1  2  3  4  5  6  7)
-        movdqa  xmm3,xmm4               ; xmm4=Int1H=( 8  9 10 11 12 13 14 15)
-        psrldq  xmm7,2                  ; xmm7=( 1  2  3  4  5  6  7 --)
-        pslldq  xmm3,(SIZEOF_XMMWORD-2) ; xmm3=(-- -- -- -- -- -- --  8)
-        movdqa  xmm0,xmm6
-        movdqa  xmm2,xmm4
-        psrldq  xmm0,(SIZEOF_XMMWORD-2) ; xmm0=( 7 -- -- -- -- -- -- --)
-        pslldq  xmm2,2                  ; xmm2=(--  8  9 10 11 12 13 14)
-
-        por     xmm7,xmm3               ; xmm7=( 1  2  3  4  5  6  7  8)
-        por     xmm0,xmm2               ; xmm0=( 7  8  9 10 11 12 13 14)
-
-        movdqa  xmm1,xmm6
-        movdqa  xmm5,xmm4
-        pslldq  xmm1,2                  ; xmm1=(--  0  1  2  3  4  5  6)
-        psrldq  xmm5,2                  ; xmm5=( 9 10 11 12 13 14 15 --)
-        movdqa  xmm3,xmm4
-        psrldq  xmm3,(SIZEOF_XMMWORD-2) ; xmm3=(15 -- -- -- -- -- -- --)
-
-        por     xmm1, XMMWORD [wk(1)]   ; xmm1=(-1  0  1  2  3  4  5  6)
-        por     xmm5, XMMWORD [wk(3)]   ; xmm5=( 9 10 11 12 13 14 15 16)
-
-        movdqa  XMMWORD [wk(1)], xmm3
-
-        pmullw  xmm6,[GOTOFF(ebx,PW_THREE)]
-        pmullw  xmm4,[GOTOFF(ebx,PW_THREE)]
-        paddw   xmm1,[GOTOFF(ebx,PW_EIGHT)]
-        paddw   xmm0,[GOTOFF(ebx,PW_EIGHT)]
-        paddw   xmm7,[GOTOFF(ebx,PW_SEVEN)]
-        paddw   xmm5,[GOTOFF(ebx,PW_SEVEN)]
-
-        paddw   xmm1,xmm6
-        paddw   xmm0,xmm4
-        psrlw   xmm1,4                  ; xmm1=Out1LE=( 0  2  4  6  8 10 12 14)
-        psrlw   xmm0,4                  ; xmm0=Out1HE=(16 18 20 22 24 26 28 30)
-        paddw   xmm7,xmm6
-        paddw   xmm5,xmm4
-        psrlw   xmm7,4                  ; xmm7=Out1LO=( 1  3  5  7  9 11 13 15)
-        psrlw   xmm5,4                  ; xmm5=Out1HO=(17 19 21 23 25 27 29 31)
-
-        psllw   xmm7,BYTE_BIT
-        psllw   xmm5,BYTE_BIT
-        por     xmm1,xmm7               ; xmm1=Out1L=( 0  1  2 ... 13 14 15)
-        por     xmm0,xmm5               ; xmm0=Out1H=(16 17 18 ... 29 30 31)
-
-        movdqa  XMMWORD [edi+0*SIZEOF_XMMWORD], xmm1
-        movdqa  XMMWORD [edi+1*SIZEOF_XMMWORD], xmm0
-
-        poppic  ebx
-
-        sub     eax, byte SIZEOF_XMMWORD
-        add     ecx, byte 1*SIZEOF_XMMWORD      ; inptr1(above)
-        add     ebx, byte 1*SIZEOF_XMMWORD      ; inptr0
-        add     esi, byte 1*SIZEOF_XMMWORD      ; inptr1(below)
-        add     edx, byte 2*SIZEOF_XMMWORD      ; outptr0
-        add     edi, byte 2*SIZEOF_XMMWORD      ; outptr1
-        cmp     eax, byte SIZEOF_XMMWORD
-        ja      near .columnloop
-        test    eax,eax
-        jnz     near .columnloop_last
-
-        pop     esi
-        pop     edi
-        pop     ecx
-        pop     eax
-
-        add     esi, byte 1*SIZEOF_JSAMPROW     ; input_data
-        add     edi, byte 2*SIZEOF_JSAMPROW     ; output_data
-        sub     ecx, byte 2                     ; rowctr
-        jg      near .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
-; It's still a box filter.
-;
-; GLOBAL(void)
-; jsimd_h2v1_upsample_sse2 (int max_v_samp_factor,
-;                           JDIMENSION output_width,
-;                           JSAMPARRAY input_data,
-;                           JSAMPARRAY *output_data_ptr);
-;
-
-%define max_v_samp(b)           (b)+8           ; int max_v_samp_factor
-%define output_width(b)         (b)+12          ; JDIMENSION output_width
-%define input_data(b)           (b)+16          ; JSAMPARRAY input_data
-%define output_data_ptr(b)      (b)+20          ; JSAMPARRAY *output_data_ptr
-
-        align   16
-        global  EXTN(jsimd_h2v1_upsample_sse2)
-
-EXTN(jsimd_h2v1_upsample_sse2):
-        push    ebp
-        mov     ebp,esp
-;       push    ebx             ; unused
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        mov     edx, JDIMENSION [output_width(ebp)]
-        add     edx, byte (2*SIZEOF_XMMWORD)-1
-        and     edx, byte -(2*SIZEOF_XMMWORD)
-        jz      short .return
-
-        mov     ecx, INT [max_v_samp(ebp)]      ; rowctr
-        test    ecx,ecx
-        jz      short .return
-
-        mov     esi, JSAMPARRAY [input_data(ebp)]       ; input_data
-        mov     edi, POINTER [output_data_ptr(ebp)]
-        mov     edi, JSAMPARRAY [edi]                   ; output_data
-        alignx  16,7
-.rowloop:
-        push    edi
-        push    esi
-
-        mov     esi, JSAMPROW [esi]             ; inptr
-        mov     edi, JSAMPROW [edi]             ; outptr
-        mov     eax,edx                         ; colctr
-        alignx  16,7
-.columnloop:
-
-        movdqa  xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
-
-        movdqa    xmm1,xmm0
-        punpcklbw xmm0,xmm0
-        punpckhbw xmm1,xmm1
-
-        movdqa  XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
-        movdqa  XMMWORD [edi+1*SIZEOF_XMMWORD], xmm1
-
-        sub     eax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        movdqa  xmm2, XMMWORD [esi+1*SIZEOF_XMMWORD]
-
-        movdqa    xmm3,xmm2
-        punpcklbw xmm2,xmm2
-        punpckhbw xmm3,xmm3
-
-        movdqa  XMMWORD [edi+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [edi+3*SIZEOF_XMMWORD], xmm3
-
-        sub     eax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        add     esi, byte 2*SIZEOF_XMMWORD      ; inptr
-        add     edi, byte 4*SIZEOF_XMMWORD      ; outptr
-        jmp     short .columnloop
-        alignx  16,7
-
-.nextrow:
-        pop     esi
-        pop     edi
-
-        add     esi, byte SIZEOF_JSAMPROW       ; input_data
-        add     edi, byte SIZEOF_JSAMPROW       ; output_data
-        dec     ecx                             ; rowctr
-        jg      short .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-;       pop     ebx             ; unused
-        pop     ebp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
-; It's still a box filter.
-;
-; GLOBAL(void)
-; jsimd_h2v2_upsample_sse2 (nt max_v_samp_factor,
-;                           JDIMENSION output_width,
-;                           JSAMPARRAY input_data,
-;                           JSAMPARRAY *output_data_ptr);
-;
-
-%define max_v_samp(b)           (b)+8           ; int max_v_samp_factor
-%define output_width(b)         (b)+12          ; JDIMENSION output_width
-%define input_data(b)           (b)+16          ; JSAMPARRAY input_data
-%define output_data_ptr(b)      (b)+20          ; JSAMPARRAY *output_data_ptr
-
-        align   16
-        global  EXTN(jsimd_h2v2_upsample_sse2)
-
-EXTN(jsimd_h2v2_upsample_sse2):
-        push    ebp
-        mov     ebp,esp
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        mov     edx, JDIMENSION [output_width(ebp)]
-        add     edx, byte (2*SIZEOF_XMMWORD)-1
-        and     edx, byte -(2*SIZEOF_XMMWORD)
-        jz      near .return
-
-        mov     ecx, INT [max_v_samp(ebp)]      ; rowctr
-        test    ecx,ecx
-        jz      near .return
-
-        mov     esi, JSAMPARRAY [input_data(ebp)]       ; input_data
-        mov     edi, POINTER [output_data_ptr(ebp)]
-        mov     edi, JSAMPARRAY [edi]                   ; output_data
-        alignx  16,7
-.rowloop:
-        push    edi
-        push    esi
-
-        mov     esi, JSAMPROW [esi]                     ; inptr
-        mov     ebx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]   ; outptr0
-        mov     edi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]   ; outptr1
-        mov     eax,edx                                 ; colctr
-        alignx  16,7
-.columnloop:
-
-        movdqa  xmm0, XMMWORD [esi+0*SIZEOF_XMMWORD]
-
-        movdqa    xmm1,xmm0
-        punpcklbw xmm0,xmm0
-        punpckhbw xmm1,xmm1
-
-        movdqa  XMMWORD [ebx+0*SIZEOF_XMMWORD], xmm0
-        movdqa  XMMWORD [ebx+1*SIZEOF_XMMWORD], xmm1
-        movdqa  XMMWORD [edi+0*SIZEOF_XMMWORD], xmm0
-        movdqa  XMMWORD [edi+1*SIZEOF_XMMWORD], xmm1
-
-        sub     eax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        movdqa  xmm2, XMMWORD [esi+1*SIZEOF_XMMWORD]
-
-        movdqa    xmm3,xmm2
-        punpcklbw xmm2,xmm2
-        punpckhbw xmm3,xmm3
-
-        movdqa  XMMWORD [ebx+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [ebx+3*SIZEOF_XMMWORD], xmm3
-        movdqa  XMMWORD [edi+2*SIZEOF_XMMWORD], xmm2
-        movdqa  XMMWORD [edi+3*SIZEOF_XMMWORD], xmm3
-
-        sub     eax, byte 2*SIZEOF_XMMWORD
-        jz      short .nextrow
-
-        add     esi, byte 2*SIZEOF_XMMWORD      ; inptr
-        add     ebx, byte 4*SIZEOF_XMMWORD      ; outptr0
-        add     edi, byte 4*SIZEOF_XMMWORD      ; outptr1
-        jmp     short .columnloop
-        alignx  16,7
-
-.nextrow:
-        pop     esi
-        pop     edi
-
-        add     esi, byte 1*SIZEOF_JSAMPROW     ; input_data
-        add     edi, byte 2*SIZEOF_JSAMPROW     ; output_data
-        sub     ecx, byte 2                     ; rowctr
-        jg      short .rowloop
-
-.return:
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jfdctflt-sse-64.asm b/simd/jfdctflt-sse-64.asm
deleted file mode 100644
index 4b64ea4..0000000
--- a/simd/jfdctflt-sse-64.asm
+++ /dev/null
@@ -1,357 +0,0 @@
-;
-; jfdctflt.asm - floating-point FDCT (64-bit SSE)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a floating-point implementation of the forward DCT
-; (Discrete Cosine Transform). The following code is based directly on
-; the IJG's original jfdctflt.c; see the jfdctflt.c for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%macro  unpcklps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
-        shufps  %1,%2,0x44
-%endmacro
-
-%macro  unpckhps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
-        shufps  %1,%2,0xEE
-%endmacro
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_fdct_float_sse)
-
-EXTN(jconst_fdct_float_sse):
-
-PD_0_382        times 4 dd  0.382683432365089771728460
-PD_0_707        times 4 dd  0.707106781186547524400844
-PD_0_541        times 4 dd  0.541196100146196984399723
-PD_1_306        times 4 dd  1.306562964876376527856643
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Perform the forward DCT on one block of samples.
-;
-; GLOBAL(void)
-; jsimd_fdct_float_sse (FAST_FLOAT *data)
-;
-
-; r10 = FAST_FLOAT *data
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_fdct_float_sse)
-
-EXTN(jsimd_fdct_float_sse):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-
-        ; ---- Pass 1: process rows.
-
-        mov     rdx, r10        ; (FAST_FLOAT *)
-        mov     rcx, DCTSIZE/4
-.rowloop:
-
-        movaps  xmm0, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(2,1,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(3,1,rdx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm0=(20 21 22 23), xmm2=(24 25 26 27)
-        ; xmm1=(30 31 32 33), xmm3=(34 35 36 37)
-
-        movaps   xmm4,xmm0              ; transpose coefficients(phase 1)
-        unpcklps xmm0,xmm1              ; xmm0=(20 30 21 31)
-        unpckhps xmm4,xmm1              ; xmm4=(22 32 23 33)
-        movaps   xmm5,xmm2              ; transpose coefficients(phase 1)
-        unpcklps xmm2,xmm3              ; xmm2=(24 34 25 35)
-        unpckhps xmm5,xmm3              ; xmm5=(26 36 27 37)
-
-        movaps  xmm6, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm7, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(0,1,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(1,1,rdx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm6=(00 01 02 03), xmm1=(04 05 06 07)
-        ; xmm7=(10 11 12 13), xmm3=(14 15 16 17)
-
-        movaps  XMMWORD [wk(0)], xmm4   ; wk(0)=(22 32 23 33)
-        movaps  XMMWORD [wk(1)], xmm2   ; wk(1)=(24 34 25 35)
-
-        movaps   xmm4,xmm6              ; transpose coefficients(phase 1)
-        unpcklps xmm6,xmm7              ; xmm6=(00 10 01 11)
-        unpckhps xmm4,xmm7              ; xmm4=(02 12 03 13)
-        movaps   xmm2,xmm1              ; transpose coefficients(phase 1)
-        unpcklps xmm1,xmm3              ; xmm1=(04 14 05 15)
-        unpckhps xmm2,xmm3              ; xmm2=(06 16 07 17)
-
-        movaps    xmm7,xmm6             ; transpose coefficients(phase 2)
-        unpcklps2 xmm6,xmm0             ; xmm6=(00 10 20 30)=data0
-        unpckhps2 xmm7,xmm0             ; xmm7=(01 11 21 31)=data1
-        movaps    xmm3,xmm2             ; transpose coefficients(phase 2)
-        unpcklps2 xmm2,xmm5             ; xmm2=(06 16 26 36)=data6
-        unpckhps2 xmm3,xmm5             ; xmm3=(07 17 27 37)=data7
-
-        movaps  xmm0,xmm7
-        movaps  xmm5,xmm6
-        subps   xmm7,xmm2               ; xmm7=data1-data6=tmp6
-        subps   xmm6,xmm3               ; xmm6=data0-data7=tmp7
-        addps   xmm0,xmm2               ; xmm0=data1+data6=tmp1
-        addps   xmm5,xmm3               ; xmm5=data0+data7=tmp0
-
-        movaps  xmm2, XMMWORD [wk(0)]   ; xmm2=(22 32 23 33)
-        movaps  xmm3, XMMWORD [wk(1)]   ; xmm3=(24 34 25 35)
-        movaps  XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
-        movaps  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
-
-        movaps    xmm7,xmm4             ; transpose coefficients(phase 2)
-        unpcklps2 xmm4,xmm2             ; xmm4=(02 12 22 32)=data2
-        unpckhps2 xmm7,xmm2             ; xmm7=(03 13 23 33)=data3
-        movaps    xmm6,xmm1             ; transpose coefficients(phase 2)
-        unpcklps2 xmm1,xmm3             ; xmm1=(04 14 24 34)=data4
-        unpckhps2 xmm6,xmm3             ; xmm6=(05 15 25 35)=data5
-
-        movaps  xmm2,xmm7
-        movaps  xmm3,xmm4
-        addps   xmm7,xmm1               ; xmm7=data3+data4=tmp3
-        addps   xmm4,xmm6               ; xmm4=data2+data5=tmp2
-        subps   xmm2,xmm1               ; xmm2=data3-data4=tmp4
-        subps   xmm3,xmm6               ; xmm3=data2-data5=tmp5
-
-        ; -- Even part
-
-        movaps  xmm1,xmm5
-        movaps  xmm6,xmm0
-        subps   xmm5,xmm7               ; xmm5=tmp13
-        subps   xmm0,xmm4               ; xmm0=tmp12
-        addps   xmm1,xmm7               ; xmm1=tmp10
-        addps   xmm6,xmm4               ; xmm6=tmp11
-
-        addps   xmm0,xmm5
-        mulps   xmm0,[rel PD_0_707] ; xmm0=z1
-
-        movaps  xmm7,xmm1
-        movaps  xmm4,xmm5
-        subps   xmm1,xmm6               ; xmm1=data4
-        subps   xmm5,xmm0               ; xmm5=data6
-        addps   xmm7,xmm6               ; xmm7=data0
-        addps   xmm4,xmm0               ; xmm4=data2
-
-        movaps  XMMWORD [XMMBLOCK(0,1,rdx,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(2,1,rdx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
-
-        ; -- Odd part
-
-        movaps  xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
-        movaps  xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
-
-        addps   xmm2,xmm3               ; xmm2=tmp10
-        addps   xmm3,xmm6               ; xmm3=tmp11
-        addps   xmm6,xmm0               ; xmm6=tmp12, xmm0=tmp7
-
-        mulps   xmm3,[rel PD_0_707] ; xmm3=z3
-
-        movaps  xmm1,xmm2               ; xmm1=tmp10
-        subps   xmm2,xmm6
-        mulps   xmm2,[rel PD_0_382] ; xmm2=z5
-        mulps   xmm1,[rel PD_0_541] ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
-        mulps   xmm6,[rel PD_1_306] ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
-        addps   xmm1,xmm2               ; xmm1=z2
-        addps   xmm6,xmm2               ; xmm6=z4
-
-        movaps  xmm5,xmm0
-        subps   xmm0,xmm3               ; xmm0=z13
-        addps   xmm5,xmm3               ; xmm5=z11
-
-        movaps  xmm7,xmm0
-        movaps  xmm4,xmm5
-        subps   xmm0,xmm1               ; xmm0=data3
-        subps   xmm5,xmm6               ; xmm5=data7
-        addps   xmm7,xmm1               ; xmm7=data5
-        addps   xmm4,xmm6               ; xmm4=data1
-
-        movaps  XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(3,1,rdx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(1,1,rdx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
-
-        add     rdx, 4*DCTSIZE*SIZEOF_FAST_FLOAT
-        dec     rcx
-        jnz     near .rowloop
-
-        ; ---- Pass 2: process columns.
-
-        mov     rdx, r10        ; (FAST_FLOAT *)
-        mov     rcx, DCTSIZE/4
-.columnloop:
-
-        movaps  xmm0, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm0=(02 12 22 32), xmm2=(42 52 62 72)
-        ; xmm1=(03 13 23 33), xmm3=(43 53 63 73)
-
-        movaps   xmm4,xmm0              ; transpose coefficients(phase 1)
-        unpcklps xmm0,xmm1              ; xmm0=(02 03 12 13)
-        unpckhps xmm4,xmm1              ; xmm4=(22 23 32 33)
-        movaps   xmm5,xmm2              ; transpose coefficients(phase 1)
-        unpcklps xmm2,xmm3              ; xmm2=(42 43 52 53)
-        unpckhps xmm5,xmm3              ; xmm5=(62 63 72 73)
-
-        movaps  xmm6, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm7, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm6=(00 10 20 30), xmm1=(40 50 60 70)
-        ; xmm7=(01 11 21 31), xmm3=(41 51 61 71)
-
-        movaps  XMMWORD [wk(0)], xmm4   ; wk(0)=(22 23 32 33)
-        movaps  XMMWORD [wk(1)], xmm2   ; wk(1)=(42 43 52 53)
-
-        movaps   xmm4,xmm6              ; transpose coefficients(phase 1)
-        unpcklps xmm6,xmm7              ; xmm6=(00 01 10 11)
-        unpckhps xmm4,xmm7              ; xmm4=(20 21 30 31)
-        movaps   xmm2,xmm1              ; transpose coefficients(phase 1)
-        unpcklps xmm1,xmm3              ; xmm1=(40 41 50 51)
-        unpckhps xmm2,xmm3              ; xmm2=(60 61 70 71)
-
-        movaps    xmm7,xmm6             ; transpose coefficients(phase 2)
-        unpcklps2 xmm6,xmm0             ; xmm6=(00 01 02 03)=data0
-        unpckhps2 xmm7,xmm0             ; xmm7=(10 11 12 13)=data1
-        movaps    xmm3,xmm2             ; transpose coefficients(phase 2)
-        unpcklps2 xmm2,xmm5             ; xmm2=(60 61 62 63)=data6
-        unpckhps2 xmm3,xmm5             ; xmm3=(70 71 72 73)=data7
-
-        movaps  xmm0,xmm7
-        movaps  xmm5,xmm6
-        subps   xmm7,xmm2               ; xmm7=data1-data6=tmp6
-        subps   xmm6,xmm3               ; xmm6=data0-data7=tmp7
-        addps   xmm0,xmm2               ; xmm0=data1+data6=tmp1
-        addps   xmm5,xmm3               ; xmm5=data0+data7=tmp0
-
-        movaps  xmm2, XMMWORD [wk(0)]   ; xmm2=(22 23 32 33)
-        movaps  xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53)
-        movaps  XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
-        movaps  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
-
-        movaps    xmm7,xmm4             ; transpose coefficients(phase 2)
-        unpcklps2 xmm4,xmm2             ; xmm4=(20 21 22 23)=data2
-        unpckhps2 xmm7,xmm2             ; xmm7=(30 31 32 33)=data3
-        movaps    xmm6,xmm1             ; transpose coefficients(phase 2)
-        unpcklps2 xmm1,xmm3             ; xmm1=(40 41 42 43)=data4
-        unpckhps2 xmm6,xmm3             ; xmm6=(50 51 52 53)=data5
-
-        movaps  xmm2,xmm7
-        movaps  xmm3,xmm4
-        addps   xmm7,xmm1               ; xmm7=data3+data4=tmp3
-        addps   xmm4,xmm6               ; xmm4=data2+data5=tmp2
-        subps   xmm2,xmm1               ; xmm2=data3-data4=tmp4
-        subps   xmm3,xmm6               ; xmm3=data2-data5=tmp5
-
-        ; -- Even part
-
-        movaps  xmm1,xmm5
-        movaps  xmm6,xmm0
-        subps   xmm5,xmm7               ; xmm5=tmp13
-        subps   xmm0,xmm4               ; xmm0=tmp12
-        addps   xmm1,xmm7               ; xmm1=tmp10
-        addps   xmm6,xmm4               ; xmm6=tmp11
-
-        addps   xmm0,xmm5
-        mulps   xmm0,[rel PD_0_707] ; xmm0=z1
-
-        movaps  xmm7,xmm1
-        movaps  xmm4,xmm5
-        subps   xmm1,xmm6               ; xmm1=data4
-        subps   xmm5,xmm0               ; xmm5=data6
-        addps   xmm7,xmm6               ; xmm7=data0
-        addps   xmm4,xmm0               ; xmm4=data2
-
-        movaps  XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
-
-        ; -- Odd part
-
-        movaps  xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
-        movaps  xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
-
-        addps   xmm2,xmm3               ; xmm2=tmp10
-        addps   xmm3,xmm6               ; xmm3=tmp11
-        addps   xmm6,xmm0               ; xmm6=tmp12, xmm0=tmp7
-
-        mulps   xmm3,[rel PD_0_707] ; xmm3=z3
-
-        movaps  xmm1,xmm2               ; xmm1=tmp10
-        subps   xmm2,xmm6
-        mulps   xmm2,[rel PD_0_382] ; xmm2=z5
-        mulps   xmm1,[rel PD_0_541] ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
-        mulps   xmm6,[rel PD_1_306] ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
-        addps   xmm1,xmm2               ; xmm1=z2
-        addps   xmm6,xmm2               ; xmm6=z4
-
-        movaps  xmm5,xmm0
-        subps   xmm0,xmm3               ; xmm0=z13
-        addps   xmm5,xmm3               ; xmm5=z11
-
-        movaps  xmm7,xmm0
-        movaps  xmm4,xmm5
-        subps   xmm0,xmm1               ; xmm0=data3
-        subps   xmm5,xmm6               ; xmm5=data7
-        addps   xmm7,xmm1               ; xmm7=data5
-        addps   xmm4,xmm6               ; xmm4=data1
-
-        movaps  XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
-
-        add     rdx, byte 4*SIZEOF_FAST_FLOAT
-        dec     rcx
-        jnz     near .columnloop
-
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jfdctflt-sse.asm b/simd/jfdctflt-sse.asm
deleted file mode 100644
index e7ede26..0000000
--- a/simd/jfdctflt-sse.asm
+++ /dev/null
@@ -1,369 +0,0 @@
-;
-; jfdctflt.asm - floating-point FDCT (SSE)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a floating-point implementation of the forward DCT
-; (Discrete Cosine Transform). The following code is based directly on
-; the IJG's original jfdctflt.c; see the jfdctflt.c for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%macro  unpcklps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
-        shufps  %1,%2,0x44
-%endmacro
-
-%macro  unpckhps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
-        shufps  %1,%2,0xEE
-%endmacro
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_fdct_float_sse)
-
-EXTN(jconst_fdct_float_sse):
-
-PD_0_382        times 4 dd  0.382683432365089771728460
-PD_0_707        times 4 dd  0.707106781186547524400844
-PD_0_541        times 4 dd  0.541196100146196984399723
-PD_1_306        times 4 dd  1.306562964876376527856643
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Perform the forward DCT on one block of samples.
-;
-; GLOBAL(void)
-; jsimd_fdct_float_sse (FAST_FLOAT *data)
-;
-
-%define data(b)         (b)+8           ; FAST_FLOAT *data
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_fdct_float_sse)
-
-EXTN(jsimd_fdct_float_sse):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-;       push    esi             ; unused
-;       push    edi             ; unused
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process rows.
-
-        mov     edx, POINTER [data(eax)]        ; (FAST_FLOAT *)
-        mov     ecx, DCTSIZE/4
-        alignx  16,7
-.rowloop:
-
-        movaps  xmm0, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(2,1,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(3,1,edx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm0=(20 21 22 23), xmm2=(24 25 26 27)
-        ; xmm1=(30 31 32 33), xmm3=(34 35 36 37)
-
-        movaps   xmm4,xmm0              ; transpose coefficients(phase 1)
-        unpcklps xmm0,xmm1              ; xmm0=(20 30 21 31)
-        unpckhps xmm4,xmm1              ; xmm4=(22 32 23 33)
-        movaps   xmm5,xmm2              ; transpose coefficients(phase 1)
-        unpcklps xmm2,xmm3              ; xmm2=(24 34 25 35)
-        unpckhps xmm5,xmm3              ; xmm5=(26 36 27 37)
-
-        movaps  xmm6, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm7, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(0,1,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(1,1,edx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm6=(00 01 02 03), xmm1=(04 05 06 07)
-        ; xmm7=(10 11 12 13), xmm3=(14 15 16 17)
-
-        movaps  XMMWORD [wk(0)], xmm4   ; wk(0)=(22 32 23 33)
-        movaps  XMMWORD [wk(1)], xmm2   ; wk(1)=(24 34 25 35)
-
-        movaps   xmm4,xmm6              ; transpose coefficients(phase 1)
-        unpcklps xmm6,xmm7              ; xmm6=(00 10 01 11)
-        unpckhps xmm4,xmm7              ; xmm4=(02 12 03 13)
-        movaps   xmm2,xmm1              ; transpose coefficients(phase 1)
-        unpcklps xmm1,xmm3              ; xmm1=(04 14 05 15)
-        unpckhps xmm2,xmm3              ; xmm2=(06 16 07 17)
-
-        movaps    xmm7,xmm6             ; transpose coefficients(phase 2)
-        unpcklps2 xmm6,xmm0             ; xmm6=(00 10 20 30)=data0
-        unpckhps2 xmm7,xmm0             ; xmm7=(01 11 21 31)=data1
-        movaps    xmm3,xmm2             ; transpose coefficients(phase 2)
-        unpcklps2 xmm2,xmm5             ; xmm2=(06 16 26 36)=data6
-        unpckhps2 xmm3,xmm5             ; xmm3=(07 17 27 37)=data7
-
-        movaps  xmm0,xmm7
-        movaps  xmm5,xmm6
-        subps   xmm7,xmm2               ; xmm7=data1-data6=tmp6
-        subps   xmm6,xmm3               ; xmm6=data0-data7=tmp7
-        addps   xmm0,xmm2               ; xmm0=data1+data6=tmp1
-        addps   xmm5,xmm3               ; xmm5=data0+data7=tmp0
-
-        movaps  xmm2, XMMWORD [wk(0)]   ; xmm2=(22 32 23 33)
-        movaps  xmm3, XMMWORD [wk(1)]   ; xmm3=(24 34 25 35)
-        movaps  XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
-        movaps  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
-
-        movaps    xmm7,xmm4             ; transpose coefficients(phase 2)
-        unpcklps2 xmm4,xmm2             ; xmm4=(02 12 22 32)=data2
-        unpckhps2 xmm7,xmm2             ; xmm7=(03 13 23 33)=data3
-        movaps    xmm6,xmm1             ; transpose coefficients(phase 2)
-        unpcklps2 xmm1,xmm3             ; xmm1=(04 14 24 34)=data4
-        unpckhps2 xmm6,xmm3             ; xmm6=(05 15 25 35)=data5
-
-        movaps  xmm2,xmm7
-        movaps  xmm3,xmm4
-        addps   xmm7,xmm1               ; xmm7=data3+data4=tmp3
-        addps   xmm4,xmm6               ; xmm4=data2+data5=tmp2
-        subps   xmm2,xmm1               ; xmm2=data3-data4=tmp4
-        subps   xmm3,xmm6               ; xmm3=data2-data5=tmp5
-
-        ; -- Even part
-
-        movaps  xmm1,xmm5
-        movaps  xmm6,xmm0
-        subps   xmm5,xmm7               ; xmm5=tmp13
-        subps   xmm0,xmm4               ; xmm0=tmp12
-        addps   xmm1,xmm7               ; xmm1=tmp10
-        addps   xmm6,xmm4               ; xmm6=tmp11
-
-        addps   xmm0,xmm5
-        mulps   xmm0,[GOTOFF(ebx,PD_0_707)] ; xmm0=z1
-
-        movaps  xmm7,xmm1
-        movaps  xmm4,xmm5
-        subps   xmm1,xmm6               ; xmm1=data4
-        subps   xmm5,xmm0               ; xmm5=data6
-        addps   xmm7,xmm6               ; xmm7=data0
-        addps   xmm4,xmm0               ; xmm4=data2
-
-        movaps  XMMWORD [XMMBLOCK(0,1,edx,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(2,1,edx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)], xmm4
-
-        ; -- Odd part
-
-        movaps  xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
-        movaps  xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
-
-        addps   xmm2,xmm3               ; xmm2=tmp10
-        addps   xmm3,xmm6               ; xmm3=tmp11
-        addps   xmm6,xmm0               ; xmm6=tmp12, xmm0=tmp7
-
-        mulps   xmm3,[GOTOFF(ebx,PD_0_707)] ; xmm3=z3
-
-        movaps  xmm1,xmm2               ; xmm1=tmp10
-        subps   xmm2,xmm6
-        mulps   xmm2,[GOTOFF(ebx,PD_0_382)] ; xmm2=z5
-        mulps   xmm1,[GOTOFF(ebx,PD_0_541)] ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
-        mulps   xmm6,[GOTOFF(ebx,PD_1_306)] ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
-        addps   xmm1,xmm2               ; xmm1=z2
-        addps   xmm6,xmm2               ; xmm6=z4
-
-        movaps  xmm5,xmm0
-        subps   xmm0,xmm3               ; xmm0=z13
-        addps   xmm5,xmm3               ; xmm5=z11
-
-        movaps  xmm7,xmm0
-        movaps  xmm4,xmm5
-        subps   xmm0,xmm1               ; xmm0=data3
-        subps   xmm5,xmm6               ; xmm5=data7
-        addps   xmm7,xmm1               ; xmm7=data5
-        addps   xmm4,xmm6               ; xmm4=data1
-
-        movaps  XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(3,1,edx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(1,1,edx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)], xmm4
-
-        add     edx, 4*DCTSIZE*SIZEOF_FAST_FLOAT
-        dec     ecx
-        jnz     near .rowloop
-
-        ; ---- Pass 2: process columns.
-
-        mov     edx, POINTER [data(eax)]        ; (FAST_FLOAT *)
-        mov     ecx, DCTSIZE/4
-        alignx  16,7
-.columnloop:
-
-        movaps  xmm0, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm0=(02 12 22 32), xmm2=(42 52 62 72)
-        ; xmm1=(03 13 23 33), xmm3=(43 53 63 73)
-
-        movaps   xmm4,xmm0              ; transpose coefficients(phase 1)
-        unpcklps xmm0,xmm1              ; xmm0=(02 03 12 13)
-        unpckhps xmm4,xmm1              ; xmm4=(22 23 32 33)
-        movaps   xmm5,xmm2              ; transpose coefficients(phase 1)
-        unpcklps xmm2,xmm3              ; xmm2=(42 43 52 53)
-        unpckhps xmm5,xmm3              ; xmm5=(62 63 72 73)
-
-        movaps  xmm6, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm7, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_FAST_FLOAT)]
-
-        ; xmm6=(00 10 20 30), xmm1=(40 50 60 70)
-        ; xmm7=(01 11 21 31), xmm3=(41 51 61 71)
-
-        movaps  XMMWORD [wk(0)], xmm4   ; wk(0)=(22 23 32 33)
-        movaps  XMMWORD [wk(1)], xmm2   ; wk(1)=(42 43 52 53)
-
-        movaps   xmm4,xmm6              ; transpose coefficients(phase 1)
-        unpcklps xmm6,xmm7              ; xmm6=(00 01 10 11)
-        unpckhps xmm4,xmm7              ; xmm4=(20 21 30 31)
-        movaps   xmm2,xmm1              ; transpose coefficients(phase 1)
-        unpcklps xmm1,xmm3              ; xmm1=(40 41 50 51)
-        unpckhps xmm2,xmm3              ; xmm2=(60 61 70 71)
-
-        movaps    xmm7,xmm6             ; transpose coefficients(phase 2)
-        unpcklps2 xmm6,xmm0             ; xmm6=(00 01 02 03)=data0
-        unpckhps2 xmm7,xmm0             ; xmm7=(10 11 12 13)=data1
-        movaps    xmm3,xmm2             ; transpose coefficients(phase 2)
-        unpcklps2 xmm2,xmm5             ; xmm2=(60 61 62 63)=data6
-        unpckhps2 xmm3,xmm5             ; xmm3=(70 71 72 73)=data7
-
-        movaps  xmm0,xmm7
-        movaps  xmm5,xmm6
-        subps   xmm7,xmm2               ; xmm7=data1-data6=tmp6
-        subps   xmm6,xmm3               ; xmm6=data0-data7=tmp7
-        addps   xmm0,xmm2               ; xmm0=data1+data6=tmp1
-        addps   xmm5,xmm3               ; xmm5=data0+data7=tmp0
-
-        movaps  xmm2, XMMWORD [wk(0)]   ; xmm2=(22 23 32 33)
-        movaps  xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53)
-        movaps  XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
-        movaps  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
-
-        movaps    xmm7,xmm4             ; transpose coefficients(phase 2)
-        unpcklps2 xmm4,xmm2             ; xmm4=(20 21 22 23)=data2
-        unpckhps2 xmm7,xmm2             ; xmm7=(30 31 32 33)=data3
-        movaps    xmm6,xmm1             ; transpose coefficients(phase 2)
-        unpcklps2 xmm1,xmm3             ; xmm1=(40 41 42 43)=data4
-        unpckhps2 xmm6,xmm3             ; xmm6=(50 51 52 53)=data5
-
-        movaps  xmm2,xmm7
-        movaps  xmm3,xmm4
-        addps   xmm7,xmm1               ; xmm7=data3+data4=tmp3
-        addps   xmm4,xmm6               ; xmm4=data2+data5=tmp2
-        subps   xmm2,xmm1               ; xmm2=data3-data4=tmp4
-        subps   xmm3,xmm6               ; xmm3=data2-data5=tmp5
-
-        ; -- Even part
-
-        movaps  xmm1,xmm5
-        movaps  xmm6,xmm0
-        subps   xmm5,xmm7               ; xmm5=tmp13
-        subps   xmm0,xmm4               ; xmm0=tmp12
-        addps   xmm1,xmm7               ; xmm1=tmp10
-        addps   xmm6,xmm4               ; xmm6=tmp11
-
-        addps   xmm0,xmm5
-        mulps   xmm0,[GOTOFF(ebx,PD_0_707)] ; xmm0=z1
-
-        movaps  xmm7,xmm1
-        movaps  xmm4,xmm5
-        subps   xmm1,xmm6               ; xmm1=data4
-        subps   xmm5,xmm0               ; xmm5=data6
-        addps   xmm7,xmm6               ; xmm7=data0
-        addps   xmm4,xmm0               ; xmm4=data2
-
-        movaps  XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FAST_FLOAT)], xmm4
-
-        ; -- Odd part
-
-        movaps  xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
-        movaps  xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
-
-        addps   xmm2,xmm3               ; xmm2=tmp10
-        addps   xmm3,xmm6               ; xmm3=tmp11
-        addps   xmm6,xmm0               ; xmm6=tmp12, xmm0=tmp7
-
-        mulps   xmm3,[GOTOFF(ebx,PD_0_707)] ; xmm3=z3
-
-        movaps  xmm1,xmm2               ; xmm1=tmp10
-        subps   xmm2,xmm6
-        mulps   xmm2,[GOTOFF(ebx,PD_0_382)] ; xmm2=z5
-        mulps   xmm1,[GOTOFF(ebx,PD_0_541)] ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
-        mulps   xmm6,[GOTOFF(ebx,PD_1_306)] ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
-        addps   xmm1,xmm2               ; xmm1=z2
-        addps   xmm6,xmm2               ; xmm6=z4
-
-        movaps  xmm5,xmm0
-        subps   xmm0,xmm3               ; xmm0=z13
-        addps   xmm5,xmm3               ; xmm5=z11
-
-        movaps  xmm7,xmm0
-        movaps  xmm4,xmm5
-        subps   xmm0,xmm1               ; xmm0=data3
-        subps   xmm5,xmm6               ; xmm5=data7
-        addps   xmm7,xmm1               ; xmm7=data5
-        addps   xmm4,xmm6               ; xmm4=data1
-
-        movaps  XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_FAST_FLOAT)], xmm7
-        movaps  XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)], xmm4
-
-        add     edx, byte 4*SIZEOF_FAST_FLOAT
-        dec     ecx
-        jnz     near .columnloop
-
-;       pop     edi             ; unused
-;       pop     esi             ; unused
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        poppic  ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jfdctfst-sse2-64.asm b/simd/jfdctfst-sse2-64.asm
deleted file mode 100644
index 4c96685..0000000
--- a/simd/jfdctfst-sse2-64.asm
+++ /dev/null
@@ -1,391 +0,0 @@
-;
-; jfdctfst.asm - fast integer FDCT (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a fast, not so accurate integer implementation of
-; the forward DCT (Discrete Cosine Transform). The following code is
-; based directly on the IJG's original jfdctfst.c; see the jfdctfst.c
-; for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      8       ; 14 is also OK.
-
-%if CONST_BITS == 8
-F_0_382 equ      98             ; FIX(0.382683433)
-F_0_541 equ     139             ; FIX(0.541196100)
-F_0_707 equ     181             ; FIX(0.707106781)
-F_1_306 equ     334             ; FIX(1.306562965)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_382 equ     DESCALE( 410903207,30-CONST_BITS)       ; FIX(0.382683433)
-F_0_541 equ     DESCALE( 581104887,30-CONST_BITS)       ; FIX(0.541196100)
-F_0_707 equ     DESCALE( 759250124,30-CONST_BITS)       ; FIX(0.707106781)
-F_1_306 equ     DESCALE(1402911301,30-CONST_BITS)       ; FIX(1.306562965)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
-; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
-
-%define PRE_MULTIPLY_SCALE_BITS   2
-%define CONST_SHIFT     (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
-
-        alignz  16
-        global  EXTN(jconst_fdct_ifast_sse2)
-
-EXTN(jconst_fdct_ifast_sse2):
-
-PW_F0707        times 8 dw  F_0_707 << CONST_SHIFT
-PW_F0382        times 8 dw  F_0_382 << CONST_SHIFT
-PW_F0541        times 8 dw  F_0_541 << CONST_SHIFT
-PW_F1306        times 8 dw  F_1_306 << CONST_SHIFT
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Perform the forward DCT on one block of samples.
-;
-; GLOBAL(void)
-; jsimd_fdct_ifast_sse2 (DCTELEM *data)
-;
-
-; r10 = DCTELEM *data
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_fdct_ifast_sse2)
-
-EXTN(jsimd_fdct_ifast_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-
-        ; ---- Pass 1: process rows.
-
-        mov     rdx, r10        ; (DCTELEM *)
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)]
-
-        ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
-        ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
-
-        movdqa    xmm4,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm1             ; xmm0=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm4,xmm1             ; xmm4=(04 14 05 15 06 16 07 17)
-        movdqa    xmm5,xmm2             ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm3             ; xmm2=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm5,xmm3             ; xmm5=(24 34 25 35 26 36 27 37)
-
-        movdqa  xmm6, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm7, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)]
-
-        ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
-        ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
-        movdqa  XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
-
-        movdqa    xmm2,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm7             ; xmm6=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm2,xmm7             ; xmm2=(44 54 45 55 46 56 47 57)
-        movdqa    xmm5,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm3             ; xmm1=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm5,xmm3             ; xmm5=(64 74 65 75 66 76 67 77)
-
-        movdqa    xmm7,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm1             ; xmm6=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm7,xmm1             ; xmm7=(42 52 62 72 43 53 63 73)
-        movdqa    xmm3,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm5             ; xmm2=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm3,xmm5             ; xmm3=(46 56 66 76 47 57 67 77)
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=(42 52 62 72 43 53 63 73)
-        movdqa  XMMWORD [wk(1)], xmm2   ; wk(1)=(44 54 64 74 45 55 65 75)
-
-        movdqa    xmm7,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm1             ; xmm0=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm7,xmm1             ; xmm7=(02 12 22 32 03 13 23 33)
-        movdqa    xmm2,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm5             ; xmm4=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm2,xmm5             ; xmm2=(06 16 26 36 07 17 27 37)
-
-        movdqa     xmm1,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm6            ; xmm0=(00 10 20 30 40 50 60 70)=data0
-        punpckhqdq xmm1,xmm6            ; xmm1=(01 11 21 31 41 51 61 71)=data1
-        movdqa     xmm5,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm3            ; xmm2=(06 16 26 36 46 56 66 76)=data6
-        punpckhqdq xmm5,xmm3            ; xmm5=(07 17 27 37 47 57 67 77)=data7
-
-        movdqa  xmm6,xmm1
-        movdqa  xmm3,xmm0
-        psubw   xmm1,xmm2               ; xmm1=data1-data6=tmp6
-        psubw   xmm0,xmm5               ; xmm0=data0-data7=tmp7
-        paddw   xmm6,xmm2               ; xmm6=data1+data6=tmp1
-        paddw   xmm3,xmm5               ; xmm3=data0+data7=tmp0
-
-        movdqa  xmm2, XMMWORD [wk(0)]   ; xmm2=(42 52 62 72 43 53 63 73)
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=(44 54 64 74 45 55 65 75)
-        movdqa  XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
-
-        movdqa     xmm1,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm2            ; xmm7=(02 12 22 32 42 52 62 72)=data2
-        punpckhqdq xmm1,xmm2            ; xmm1=(03 13 23 33 43 53 63 73)=data3
-        movdqa     xmm0,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm5            ; xmm4=(04 14 24 34 44 54 64 74)=data4
-        punpckhqdq xmm0,xmm5            ; xmm0=(05 15 25 35 45 55 65 75)=data5
-
-        movdqa  xmm2,xmm1
-        movdqa  xmm5,xmm7
-        paddw   xmm1,xmm4               ; xmm1=data3+data4=tmp3
-        paddw   xmm7,xmm0               ; xmm7=data2+data5=tmp2
-        psubw   xmm2,xmm4               ; xmm2=data3-data4=tmp4
-        psubw   xmm5,xmm0               ; xmm5=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm0,xmm6
-        psubw   xmm3,xmm1               ; xmm3=tmp13
-        psubw   xmm6,xmm7               ; xmm6=tmp12
-        paddw   xmm4,xmm1               ; xmm4=tmp10
-        paddw   xmm0,xmm7               ; xmm0=tmp11
-
-        paddw   xmm6,xmm3
-        psllw   xmm6,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm6,[rel PW_F0707] ; xmm6=z1
-
-        movdqa  xmm1,xmm4
-        movdqa  xmm7,xmm3
-        psubw   xmm4,xmm0               ; xmm4=data4
-        psubw   xmm3,xmm6               ; xmm3=data6
-        paddw   xmm1,xmm0               ; xmm1=data0
-        paddw   xmm7,xmm6               ; xmm7=data2
-
-        movdqa  xmm0, XMMWORD [wk(0)]   ; xmm0=tmp6
-        movdqa  xmm6, XMMWORD [wk(1)]   ; xmm6=tmp7
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=data4
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=data6
-
-        ; -- Odd part
-
-        paddw   xmm2,xmm5               ; xmm2=tmp10
-        paddw   xmm5,xmm0               ; xmm5=tmp11
-        paddw   xmm0,xmm6               ; xmm0=tmp12, xmm6=tmp7
-
-        psllw   xmm2,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm0,PRE_MULTIPLY_SCALE_BITS
-
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm5,[rel PW_F0707] ; xmm5=z3
-
-        movdqa  xmm4,xmm2               ; xmm4=tmp10
-        psubw   xmm2,xmm0
-        pmulhw  xmm2,[rel PW_F0382] ; xmm2=z5
-        pmulhw  xmm4,[rel PW_F0541] ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
-        pmulhw  xmm0,[rel PW_F1306] ; xmm0=MULTIPLY(tmp12,FIX_1_306562)
-        paddw   xmm4,xmm2               ; xmm4=z2
-        paddw   xmm0,xmm2               ; xmm0=z4
-
-        movdqa  xmm3,xmm6
-        psubw   xmm6,xmm5               ; xmm6=z13
-        paddw   xmm3,xmm5               ; xmm3=z11
-
-        movdqa  xmm2,xmm6
-        movdqa  xmm5,xmm3
-        psubw   xmm6,xmm4               ; xmm6=data3
-        psubw   xmm3,xmm0               ; xmm3=data7
-        paddw   xmm2,xmm4               ; xmm2=data5
-        paddw   xmm5,xmm0               ; xmm5=data1
-
-        ; ---- Pass 2: process columns.
-
-        ; xmm1=(00 10 20 30 40 50 60 70), xmm7=(02 12 22 32 42 52 62 72)
-        ; xmm5=(01 11 21 31 41 51 61 71), xmm6=(03 13 23 33 43 53 63 73)
-
-        movdqa    xmm4,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm5             ; xmm1=(00 01 10 11 20 21 30 31)
-        punpckhwd xmm4,xmm5             ; xmm4=(40 41 50 51 60 61 70 71)
-        movdqa    xmm0,xmm7             ; transpose coefficients(phase 1)
-        punpcklwd xmm7,xmm6             ; xmm7=(02 03 12 13 22 23 32 33)
-        punpckhwd xmm0,xmm6             ; xmm0=(42 43 52 53 62 63 72 73)
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=col4
-        movdqa  xmm6, XMMWORD [wk(1)]   ; xmm6=col6
-
-        ; xmm5=(04 14 24 34 44 54 64 74), xmm6=(06 16 26 36 46 56 66 76)
-        ; xmm2=(05 15 25 35 45 55 65 75), xmm3=(07 17 27 37 47 57 67 77)
-
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=(02 03 12 13 22 23 32 33)
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=(42 43 52 53 62 63 72 73)
-
-        movdqa    xmm7,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm2             ; xmm5=(04 05 14 15 24 25 34 35)
-        punpckhwd xmm7,xmm2             ; xmm7=(44 45 54 55 64 65 74 75)
-        movdqa    xmm0,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm3             ; xmm6=(06 07 16 17 26 27 36 37)
-        punpckhwd xmm0,xmm3             ; xmm0=(46 47 56 57 66 67 76 77)
-
-        movdqa    xmm2,xmm5             ; transpose coefficients(phase 2)
-        punpckldq xmm5,xmm6             ; xmm5=(04 05 06 07 14 15 16 17)
-        punpckhdq xmm2,xmm6             ; xmm2=(24 25 26 27 34 35 36 37)
-        movdqa    xmm3,xmm7             ; transpose coefficients(phase 2)
-        punpckldq xmm7,xmm0             ; xmm7=(44 45 46 47 54 55 56 57)
-        punpckhdq xmm3,xmm0             ; xmm3=(64 65 66 67 74 75 76 77)
-
-        movdqa  xmm6, XMMWORD [wk(0)]   ; xmm6=(02 03 12 13 22 23 32 33)
-        movdqa  xmm0, XMMWORD [wk(1)]   ; xmm0=(42 43 52 53 62 63 72 73)
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=(24 25 26 27 34 35 36 37)
-        movdqa  XMMWORD [wk(1)], xmm7   ; wk(1)=(44 45 46 47 54 55 56 57)
-
-        movdqa    xmm2,xmm1             ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm6             ; xmm1=(00 01 02 03 10 11 12 13)
-        punpckhdq xmm2,xmm6             ; xmm2=(20 21 22 23 30 31 32 33)
-        movdqa    xmm7,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm0             ; xmm4=(40 41 42 43 50 51 52 53)
-        punpckhdq xmm7,xmm0             ; xmm7=(60 61 62 63 70 71 72 73)
-
-        movdqa     xmm6,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm5            ; xmm1=(00 01 02 03 04 05 06 07)=data0
-        punpckhqdq xmm6,xmm5            ; xmm6=(10 11 12 13 14 15 16 17)=data1
-        movdqa     xmm0,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm3            ; xmm7=(60 61 62 63 64 65 66 67)=data6
-        punpckhqdq xmm0,xmm3            ; xmm0=(70 71 72 73 74 75 76 77)=data7
-
-        movdqa  xmm5,xmm6
-        movdqa  xmm3,xmm1
-        psubw   xmm6,xmm7               ; xmm6=data1-data6=tmp6
-        psubw   xmm1,xmm0               ; xmm1=data0-data7=tmp7
-        paddw   xmm5,xmm7               ; xmm5=data1+data6=tmp1
-        paddw   xmm3,xmm0               ; xmm3=data0+data7=tmp0
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=(24 25 26 27 34 35 36 37)
-        movdqa  xmm0, XMMWORD [wk(1)]   ; xmm0=(44 45 46 47 54 55 56 57)
-        movdqa  XMMWORD [wk(0)], xmm6   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm1   ; wk(1)=tmp7
-
-        movdqa     xmm6,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm7            ; xmm2=(20 21 22 23 24 25 26 27)=data2
-        punpckhqdq xmm6,xmm7            ; xmm6=(30 31 32 33 34 35 36 37)=data3
-        movdqa     xmm1,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm0            ; xmm4=(40 41 42 43 44 45 46 47)=data4
-        punpckhqdq xmm1,xmm0            ; xmm1=(50 51 52 53 54 55 56 57)=data5
-
-        movdqa  xmm7,xmm6
-        movdqa  xmm0,xmm2
-        paddw   xmm6,xmm4               ; xmm6=data3+data4=tmp3
-        paddw   xmm2,xmm1               ; xmm2=data2+data5=tmp2
-        psubw   xmm7,xmm4               ; xmm7=data3-data4=tmp4
-        psubw   xmm0,xmm1               ; xmm0=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm1,xmm5
-        psubw   xmm3,xmm6               ; xmm3=tmp13
-        psubw   xmm5,xmm2               ; xmm5=tmp12
-        paddw   xmm4,xmm6               ; xmm4=tmp10
-        paddw   xmm1,xmm2               ; xmm1=tmp11
-
-        paddw   xmm5,xmm3
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm5,[rel PW_F0707] ; xmm5=z1
-
-        movdqa  xmm6,xmm4
-        movdqa  xmm2,xmm3
-        psubw   xmm4,xmm1               ; xmm4=data4
-        psubw   xmm3,xmm5               ; xmm3=data6
-        paddw   xmm6,xmm1               ; xmm6=data0
-        paddw   xmm2,xmm5               ; xmm2=data2
-
-        movdqa  XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)], xmm4
-        movdqa  XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)], xmm3
-        movdqa  XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)], xmm6
-        movdqa  XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)], xmm2
-
-        ; -- Odd part
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=tmp6
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
-
-        paddw   xmm7,xmm0               ; xmm7=tmp10
-        paddw   xmm0,xmm1               ; xmm0=tmp11
-        paddw   xmm1,xmm5               ; xmm1=tmp12, xmm5=tmp7
-
-        psllw   xmm7,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm1,PRE_MULTIPLY_SCALE_BITS
-
-        psllw   xmm0,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm0,[rel PW_F0707] ; xmm0=z3
-
-        movdqa  xmm4,xmm7               ; xmm4=tmp10
-        psubw   xmm7,xmm1
-        pmulhw  xmm7,[rel PW_F0382] ; xmm7=z5
-        pmulhw  xmm4,[rel PW_F0541] ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
-        pmulhw  xmm1,[rel PW_F1306] ; xmm1=MULTIPLY(tmp12,FIX_1_306562)
-        paddw   xmm4,xmm7               ; xmm4=z2
-        paddw   xmm1,xmm7               ; xmm1=z4
-
-        movdqa  xmm3,xmm5
-        psubw   xmm5,xmm0               ; xmm5=z13
-        paddw   xmm3,xmm0               ; xmm3=z11
-
-        movdqa  xmm6,xmm5
-        movdqa  xmm2,xmm3
-        psubw   xmm5,xmm4               ; xmm5=data3
-        psubw   xmm3,xmm1               ; xmm3=data7
-        paddw   xmm6,xmm4               ; xmm6=data5
-        paddw   xmm2,xmm1               ; xmm2=data1
-
-        movdqa  XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)], xmm5
-        movdqa  XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)], xmm3
-        movdqa  XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)], xmm6
-        movdqa  XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)], xmm2
-
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jfdctfst-sse2.asm b/simd/jfdctfst-sse2.asm
deleted file mode 100644
index 54856a2..0000000
--- a/simd/jfdctfst-sse2.asm
+++ /dev/null
@@ -1,403 +0,0 @@
-;
-; jfdctfst.asm - fast integer FDCT (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a fast, not so accurate integer implementation of
-; the forward DCT (Discrete Cosine Transform). The following code is
-; based directly on the IJG's original jfdctfst.c; see the jfdctfst.c
-; for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      8       ; 14 is also OK.
-
-%if CONST_BITS == 8
-F_0_382 equ      98             ; FIX(0.382683433)
-F_0_541 equ     139             ; FIX(0.541196100)
-F_0_707 equ     181             ; FIX(0.707106781)
-F_1_306 equ     334             ; FIX(1.306562965)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_382 equ     DESCALE( 410903207,30-CONST_BITS)       ; FIX(0.382683433)
-F_0_541 equ     DESCALE( 581104887,30-CONST_BITS)       ; FIX(0.541196100)
-F_0_707 equ     DESCALE( 759250124,30-CONST_BITS)       ; FIX(0.707106781)
-F_1_306 equ     DESCALE(1402911301,30-CONST_BITS)       ; FIX(1.306562965)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
-; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
-
-%define PRE_MULTIPLY_SCALE_BITS   2
-%define CONST_SHIFT     (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
-
-        alignz  16
-        global  EXTN(jconst_fdct_ifast_sse2)
-
-EXTN(jconst_fdct_ifast_sse2):
-
-PW_F0707        times 8 dw  F_0_707 << CONST_SHIFT
-PW_F0382        times 8 dw  F_0_382 << CONST_SHIFT
-PW_F0541        times 8 dw  F_0_541 << CONST_SHIFT
-PW_F1306        times 8 dw  F_1_306 << CONST_SHIFT
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Perform the forward DCT on one block of samples.
-;
-; GLOBAL(void)
-; jsimd_fdct_ifast_sse2 (DCTELEM *data)
-;
-
-%define data(b)         (b)+8           ; DCTELEM *data
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_fdct_ifast_sse2)
-
-EXTN(jsimd_fdct_ifast_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic ebx
-;       push    ecx             ; unused
-;       push    edx             ; need not be preserved
-;       push    esi             ; unused
-;       push    edi             ; unused
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process rows.
-
-        mov     edx, POINTER [data(eax)]        ; (DCTELEM *)
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)]
-
-        ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
-        ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
-
-        movdqa    xmm4,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm1             ; xmm0=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm4,xmm1             ; xmm4=(04 14 05 15 06 16 07 17)
-        movdqa    xmm5,xmm2             ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm3             ; xmm2=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm5,xmm3             ; xmm5=(24 34 25 35 26 36 27 37)
-
-        movdqa  xmm6, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm7, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)]
-
-        ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
-        ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
-        movdqa  XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
-
-        movdqa    xmm2,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm7             ; xmm6=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm2,xmm7             ; xmm2=(44 54 45 55 46 56 47 57)
-        movdqa    xmm5,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm3             ; xmm1=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm5,xmm3             ; xmm5=(64 74 65 75 66 76 67 77)
-
-        movdqa    xmm7,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm1             ; xmm6=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm7,xmm1             ; xmm7=(42 52 62 72 43 53 63 73)
-        movdqa    xmm3,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm5             ; xmm2=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm3,xmm5             ; xmm3=(46 56 66 76 47 57 67 77)
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=(42 52 62 72 43 53 63 73)
-        movdqa  XMMWORD [wk(1)], xmm2   ; wk(1)=(44 54 64 74 45 55 65 75)
-
-        movdqa    xmm7,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm1             ; xmm0=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm7,xmm1             ; xmm7=(02 12 22 32 03 13 23 33)
-        movdqa    xmm2,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm5             ; xmm4=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm2,xmm5             ; xmm2=(06 16 26 36 07 17 27 37)
-
-        movdqa     xmm1,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm6            ; xmm0=(00 10 20 30 40 50 60 70)=data0
-        punpckhqdq xmm1,xmm6            ; xmm1=(01 11 21 31 41 51 61 71)=data1
-        movdqa     xmm5,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm3            ; xmm2=(06 16 26 36 46 56 66 76)=data6
-        punpckhqdq xmm5,xmm3            ; xmm5=(07 17 27 37 47 57 67 77)=data7
-
-        movdqa  xmm6,xmm1
-        movdqa  xmm3,xmm0
-        psubw   xmm1,xmm2               ; xmm1=data1-data6=tmp6
-        psubw   xmm0,xmm5               ; xmm0=data0-data7=tmp7
-        paddw   xmm6,xmm2               ; xmm6=data1+data6=tmp1
-        paddw   xmm3,xmm5               ; xmm3=data0+data7=tmp0
-
-        movdqa  xmm2, XMMWORD [wk(0)]   ; xmm2=(42 52 62 72 43 53 63 73)
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=(44 54 64 74 45 55 65 75)
-        movdqa  XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
-
-        movdqa     xmm1,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm2            ; xmm7=(02 12 22 32 42 52 62 72)=data2
-        punpckhqdq xmm1,xmm2            ; xmm1=(03 13 23 33 43 53 63 73)=data3
-        movdqa     xmm0,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm5            ; xmm4=(04 14 24 34 44 54 64 74)=data4
-        punpckhqdq xmm0,xmm5            ; xmm0=(05 15 25 35 45 55 65 75)=data5
-
-        movdqa  xmm2,xmm1
-        movdqa  xmm5,xmm7
-        paddw   xmm1,xmm4               ; xmm1=data3+data4=tmp3
-        paddw   xmm7,xmm0               ; xmm7=data2+data5=tmp2
-        psubw   xmm2,xmm4               ; xmm2=data3-data4=tmp4
-        psubw   xmm5,xmm0               ; xmm5=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm0,xmm6
-        psubw   xmm3,xmm1               ; xmm3=tmp13
-        psubw   xmm6,xmm7               ; xmm6=tmp12
-        paddw   xmm4,xmm1               ; xmm4=tmp10
-        paddw   xmm0,xmm7               ; xmm0=tmp11
-
-        paddw   xmm6,xmm3
-        psllw   xmm6,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm6,[GOTOFF(ebx,PW_F0707)] ; xmm6=z1
-
-        movdqa  xmm1,xmm4
-        movdqa  xmm7,xmm3
-        psubw   xmm4,xmm0               ; xmm4=data4
-        psubw   xmm3,xmm6               ; xmm3=data6
-        paddw   xmm1,xmm0               ; xmm1=data0
-        paddw   xmm7,xmm6               ; xmm7=data2
-
-        movdqa  xmm0, XMMWORD [wk(0)]   ; xmm0=tmp6
-        movdqa  xmm6, XMMWORD [wk(1)]   ; xmm6=tmp7
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=data4
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=data6
-
-        ; -- Odd part
-
-        paddw   xmm2,xmm5               ; xmm2=tmp10
-        paddw   xmm5,xmm0               ; xmm5=tmp11
-        paddw   xmm0,xmm6               ; xmm0=tmp12, xmm6=tmp7
-
-        psllw   xmm2,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm0,PRE_MULTIPLY_SCALE_BITS
-
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm5,[GOTOFF(ebx,PW_F0707)] ; xmm5=z3
-
-        movdqa  xmm4,xmm2               ; xmm4=tmp10
-        psubw   xmm2,xmm0
-        pmulhw  xmm2,[GOTOFF(ebx,PW_F0382)] ; xmm2=z5
-        pmulhw  xmm4,[GOTOFF(ebx,PW_F0541)] ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
-        pmulhw  xmm0,[GOTOFF(ebx,PW_F1306)] ; xmm0=MULTIPLY(tmp12,FIX_1_306562)
-        paddw   xmm4,xmm2               ; xmm4=z2
-        paddw   xmm0,xmm2               ; xmm0=z4
-
-        movdqa  xmm3,xmm6
-        psubw   xmm6,xmm5               ; xmm6=z13
-        paddw   xmm3,xmm5               ; xmm3=z11
-
-        movdqa  xmm2,xmm6
-        movdqa  xmm5,xmm3
-        psubw   xmm6,xmm4               ; xmm6=data3
-        psubw   xmm3,xmm0               ; xmm3=data7
-        paddw   xmm2,xmm4               ; xmm2=data5
-        paddw   xmm5,xmm0               ; xmm5=data1
-
-        ; ---- Pass 2: process columns.
-
-;       mov     edx, POINTER [data(eax)]        ; (DCTELEM *)
-
-        ; xmm1=(00 10 20 30 40 50 60 70), xmm7=(02 12 22 32 42 52 62 72)
-        ; xmm5=(01 11 21 31 41 51 61 71), xmm6=(03 13 23 33 43 53 63 73)
-
-        movdqa    xmm4,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm5             ; xmm1=(00 01 10 11 20 21 30 31)
-        punpckhwd xmm4,xmm5             ; xmm4=(40 41 50 51 60 61 70 71)
-        movdqa    xmm0,xmm7             ; transpose coefficients(phase 1)
-        punpcklwd xmm7,xmm6             ; xmm7=(02 03 12 13 22 23 32 33)
-        punpckhwd xmm0,xmm6             ; xmm0=(42 43 52 53 62 63 72 73)
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=col4
-        movdqa  xmm6, XMMWORD [wk(1)]   ; xmm6=col6
-
-        ; xmm5=(04 14 24 34 44 54 64 74), xmm6=(06 16 26 36 46 56 66 76)
-        ; xmm2=(05 15 25 35 45 55 65 75), xmm3=(07 17 27 37 47 57 67 77)
-
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=(02 03 12 13 22 23 32 33)
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=(42 43 52 53 62 63 72 73)
-
-        movdqa    xmm7,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm2             ; xmm5=(04 05 14 15 24 25 34 35)
-        punpckhwd xmm7,xmm2             ; xmm7=(44 45 54 55 64 65 74 75)
-        movdqa    xmm0,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm3             ; xmm6=(06 07 16 17 26 27 36 37)
-        punpckhwd xmm0,xmm3             ; xmm0=(46 47 56 57 66 67 76 77)
-
-        movdqa    xmm2,xmm5             ; transpose coefficients(phase 2)
-        punpckldq xmm5,xmm6             ; xmm5=(04 05 06 07 14 15 16 17)
-        punpckhdq xmm2,xmm6             ; xmm2=(24 25 26 27 34 35 36 37)
-        movdqa    xmm3,xmm7             ; transpose coefficients(phase 2)
-        punpckldq xmm7,xmm0             ; xmm7=(44 45 46 47 54 55 56 57)
-        punpckhdq xmm3,xmm0             ; xmm3=(64 65 66 67 74 75 76 77)
-
-        movdqa  xmm6, XMMWORD [wk(0)]   ; xmm6=(02 03 12 13 22 23 32 33)
-        movdqa  xmm0, XMMWORD [wk(1)]   ; xmm0=(42 43 52 53 62 63 72 73)
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=(24 25 26 27 34 35 36 37)
-        movdqa  XMMWORD [wk(1)], xmm7   ; wk(1)=(44 45 46 47 54 55 56 57)
-
-        movdqa    xmm2,xmm1             ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm6             ; xmm1=(00 01 02 03 10 11 12 13)
-        punpckhdq xmm2,xmm6             ; xmm2=(20 21 22 23 30 31 32 33)
-        movdqa    xmm7,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm0             ; xmm4=(40 41 42 43 50 51 52 53)
-        punpckhdq xmm7,xmm0             ; xmm7=(60 61 62 63 70 71 72 73)
-
-        movdqa     xmm6,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm5            ; xmm1=(00 01 02 03 04 05 06 07)=data0
-        punpckhqdq xmm6,xmm5            ; xmm6=(10 11 12 13 14 15 16 17)=data1
-        movdqa     xmm0,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm3            ; xmm7=(60 61 62 63 64 65 66 67)=data6
-        punpckhqdq xmm0,xmm3            ; xmm0=(70 71 72 73 74 75 76 77)=data7
-
-        movdqa  xmm5,xmm6
-        movdqa  xmm3,xmm1
-        psubw   xmm6,xmm7               ; xmm6=data1-data6=tmp6
-        psubw   xmm1,xmm0               ; xmm1=data0-data7=tmp7
-        paddw   xmm5,xmm7               ; xmm5=data1+data6=tmp1
-        paddw   xmm3,xmm0               ; xmm3=data0+data7=tmp0
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=(24 25 26 27 34 35 36 37)
-        movdqa  xmm0, XMMWORD [wk(1)]   ; xmm0=(44 45 46 47 54 55 56 57)
-        movdqa  XMMWORD [wk(0)], xmm6   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm1   ; wk(1)=tmp7
-
-        movdqa     xmm6,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm7            ; xmm2=(20 21 22 23 24 25 26 27)=data2
-        punpckhqdq xmm6,xmm7            ; xmm6=(30 31 32 33 34 35 36 37)=data3
-        movdqa     xmm1,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm0            ; xmm4=(40 41 42 43 44 45 46 47)=data4
-        punpckhqdq xmm1,xmm0            ; xmm1=(50 51 52 53 54 55 56 57)=data5
-
-        movdqa  xmm7,xmm6
-        movdqa  xmm0,xmm2
-        paddw   xmm6,xmm4               ; xmm6=data3+data4=tmp3
-        paddw   xmm2,xmm1               ; xmm2=data2+data5=tmp2
-        psubw   xmm7,xmm4               ; xmm7=data3-data4=tmp4
-        psubw   xmm0,xmm1               ; xmm0=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm1,xmm5
-        psubw   xmm3,xmm6               ; xmm3=tmp13
-        psubw   xmm5,xmm2               ; xmm5=tmp12
-        paddw   xmm4,xmm6               ; xmm4=tmp10
-        paddw   xmm1,xmm2               ; xmm1=tmp11
-
-        paddw   xmm5,xmm3
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm5,[GOTOFF(ebx,PW_F0707)] ; xmm5=z1
-
-        movdqa  xmm6,xmm4
-        movdqa  xmm2,xmm3
-        psubw   xmm4,xmm1               ; xmm4=data4
-        psubw   xmm3,xmm5               ; xmm3=data6
-        paddw   xmm6,xmm1               ; xmm6=data0
-        paddw   xmm2,xmm5               ; xmm2=data2
-
-        movdqa  XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)], xmm4
-        movdqa  XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)], xmm3
-        movdqa  XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)], xmm6
-        movdqa  XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)], xmm2
-
-        ; -- Odd part
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=tmp6
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
-
-        paddw   xmm7,xmm0               ; xmm7=tmp10
-        paddw   xmm0,xmm1               ; xmm0=tmp11
-        paddw   xmm1,xmm5               ; xmm1=tmp12, xmm5=tmp7
-
-        psllw   xmm7,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm1,PRE_MULTIPLY_SCALE_BITS
-
-        psllw   xmm0,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm0,[GOTOFF(ebx,PW_F0707)] ; xmm0=z3
-
-        movdqa  xmm4,xmm7               ; xmm4=tmp10
-        psubw   xmm7,xmm1
-        pmulhw  xmm7,[GOTOFF(ebx,PW_F0382)] ; xmm7=z5
-        pmulhw  xmm4,[GOTOFF(ebx,PW_F0541)] ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
-        pmulhw  xmm1,[GOTOFF(ebx,PW_F1306)] ; xmm1=MULTIPLY(tmp12,FIX_1_306562)
-        paddw   xmm4,xmm7               ; xmm4=z2
-        paddw   xmm1,xmm7               ; xmm1=z4
-
-        movdqa  xmm3,xmm5
-        psubw   xmm5,xmm0               ; xmm5=z13
-        paddw   xmm3,xmm0               ; xmm3=z11
-
-        movdqa  xmm6,xmm5
-        movdqa  xmm2,xmm3
-        psubw   xmm5,xmm4               ; xmm5=data3
-        psubw   xmm3,xmm1               ; xmm3=data7
-        paddw   xmm6,xmm4               ; xmm6=data5
-        paddw   xmm2,xmm1               ; xmm2=data1
-
-        movdqa  XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)], xmm5
-        movdqa  XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)], xmm3
-        movdqa  XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)], xmm6
-        movdqa  XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)], xmm2
-
-;       pop     edi             ; unused
-;       pop     esi             ; unused
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; unused
-        poppic  ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jfdctint-sse2-64.asm b/simd/jfdctint-sse2-64.asm
deleted file mode 100644
index 9a0ca0f..0000000
--- a/simd/jfdctint-sse2-64.asm
+++ /dev/null
@@ -1,621 +0,0 @@
-;
-; jfdctint.asm - accurate integer FDCT (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a slow-but-accurate integer implementation of the
-; forward DCT (Discrete Cosine Transform). The following code is based
-; directly on the IJG's original jfdctint.c; see the jfdctint.c for
-; more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      13
-%define PASS1_BITS      2
-
-%define DESCALE_P1      (CONST_BITS-PASS1_BITS)
-%define DESCALE_P2      (CONST_BITS+PASS1_BITS)
-
-%if CONST_BITS == 13
-F_0_298 equ      2446           ; FIX(0.298631336)
-F_0_390 equ      3196           ; FIX(0.390180644)
-F_0_541 equ      4433           ; FIX(0.541196100)
-F_0_765 equ      6270           ; FIX(0.765366865)
-F_0_899 equ      7373           ; FIX(0.899976223)
-F_1_175 equ      9633           ; FIX(1.175875602)
-F_1_501 equ     12299           ; FIX(1.501321110)
-F_1_847 equ     15137           ; FIX(1.847759065)
-F_1_961 equ     16069           ; FIX(1.961570560)
-F_2_053 equ     16819           ; FIX(2.053119869)
-F_2_562 equ     20995           ; FIX(2.562915447)
-F_3_072 equ     25172           ; FIX(3.072711026)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_298 equ     DESCALE( 320652955,30-CONST_BITS)       ; FIX(0.298631336)
-F_0_390 equ     DESCALE( 418953276,30-CONST_BITS)       ; FIX(0.390180644)
-F_0_541 equ     DESCALE( 581104887,30-CONST_BITS)       ; FIX(0.541196100)
-F_0_765 equ     DESCALE( 821806413,30-CONST_BITS)       ; FIX(0.765366865)
-F_0_899 equ     DESCALE( 966342111,30-CONST_BITS)       ; FIX(0.899976223)
-F_1_175 equ     DESCALE(1262586813,30-CONST_BITS)       ; FIX(1.175875602)
-F_1_501 equ     DESCALE(1612031267,30-CONST_BITS)       ; FIX(1.501321110)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_1_961 equ     DESCALE(2106220350,30-CONST_BITS)       ; FIX(1.961570560)
-F_2_053 equ     DESCALE(2204520673,30-CONST_BITS)       ; FIX(2.053119869)
-F_2_562 equ     DESCALE(2751909506,30-CONST_BITS)       ; FIX(2.562915447)
-F_3_072 equ     DESCALE(3299298341,30-CONST_BITS)       ; FIX(3.072711026)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_fdct_islow_sse2)
-
-EXTN(jconst_fdct_islow_sse2):
-
-PW_F130_F054    times 4 dw  (F_0_541+F_0_765), F_0_541
-PW_F054_MF130   times 4 dw  F_0_541, (F_0_541-F_1_847)
-PW_MF078_F117   times 4 dw  (F_1_175-F_1_961), F_1_175
-PW_F117_F078    times 4 dw  F_1_175, (F_1_175-F_0_390)
-PW_MF060_MF089  times 4 dw  (F_0_298-F_0_899),-F_0_899
-PW_MF089_F060   times 4 dw -F_0_899, (F_1_501-F_0_899)
-PW_MF050_MF256  times 4 dw  (F_2_053-F_2_562),-F_2_562
-PW_MF256_F050   times 4 dw -F_2_562, (F_3_072-F_2_562)
-PD_DESCALE_P1   times 4 dd  1 << (DESCALE_P1-1)
-PD_DESCALE_P2   times 4 dd  1 << (DESCALE_P2-1)
-PW_DESCALE_P2X  times 8 dw  1 << (PASS1_BITS-1)
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Perform the forward DCT on one block of samples.
-;
-; GLOBAL(void)
-; jsimd_fdct_islow_sse2 (DCTELEM *data)
-;
-
-; r10 = DCTELEM *data
-
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          6
-
-        align   16
-        global  EXTN(jsimd_fdct_islow_sse2)
-
-EXTN(jsimd_fdct_islow_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-
-        ; ---- Pass 1: process rows.
-
-        mov     rdx, r10        ; (DCTELEM *)
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)]
-
-        ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
-        ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
-
-        movdqa    xmm4,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm1             ; xmm0=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm4,xmm1             ; xmm4=(04 14 05 15 06 16 07 17)
-        movdqa    xmm5,xmm2             ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm3             ; xmm2=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm5,xmm3             ; xmm5=(24 34 25 35 26 36 27 37)
-
-        movdqa  xmm6, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm7, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)]
-
-        ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
-        ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
-        movdqa  XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
-
-        movdqa    xmm2,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm7             ; xmm6=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm2,xmm7             ; xmm2=(44 54 45 55 46 56 47 57)
-        movdqa    xmm5,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm3             ; xmm1=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm5,xmm3             ; xmm5=(64 74 65 75 66 76 67 77)
-
-        movdqa    xmm7,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm1             ; xmm6=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm7,xmm1             ; xmm7=(42 52 62 72 43 53 63 73)
-        movdqa    xmm3,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm5             ; xmm2=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm3,xmm5             ; xmm3=(46 56 66 76 47 57 67 77)
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
-        movdqa  XMMWORD [wk(2)], xmm7   ; wk(2)=(42 52 62 72 43 53 63 73)
-        movdqa  XMMWORD [wk(3)], xmm2   ; wk(3)=(44 54 64 74 45 55 65 75)
-
-        movdqa    xmm7,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm1             ; xmm0=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm7,xmm1             ; xmm7=(02 12 22 32 03 13 23 33)
-        movdqa    xmm2,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm5             ; xmm4=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm2,xmm5             ; xmm2=(06 16 26 36 07 17 27 37)
-
-        movdqa     xmm1,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm6            ; xmm0=(00 10 20 30 40 50 60 70)=data0
-        punpckhqdq xmm1,xmm6            ; xmm1=(01 11 21 31 41 51 61 71)=data1
-        movdqa     xmm5,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm3            ; xmm2=(06 16 26 36 46 56 66 76)=data6
-        punpckhqdq xmm5,xmm3            ; xmm5=(07 17 27 37 47 57 67 77)=data7
-
-        movdqa  xmm6,xmm1
-        movdqa  xmm3,xmm0
-        psubw   xmm1,xmm2               ; xmm1=data1-data6=tmp6
-        psubw   xmm0,xmm5               ; xmm0=data0-data7=tmp7
-        paddw   xmm6,xmm2               ; xmm6=data1+data6=tmp1
-        paddw   xmm3,xmm5               ; xmm3=data0+data7=tmp0
-
-        movdqa  xmm2, XMMWORD [wk(2)]   ; xmm2=(42 52 62 72 43 53 63 73)
-        movdqa  xmm5, XMMWORD [wk(3)]   ; xmm5=(44 54 64 74 45 55 65 75)
-        movdqa  XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
-
-        movdqa     xmm1,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm2            ; xmm7=(02 12 22 32 42 52 62 72)=data2
-        punpckhqdq xmm1,xmm2            ; xmm1=(03 13 23 33 43 53 63 73)=data3
-        movdqa     xmm0,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm5            ; xmm4=(04 14 24 34 44 54 64 74)=data4
-        punpckhqdq xmm0,xmm5            ; xmm0=(05 15 25 35 45 55 65 75)=data5
-
-        movdqa  xmm2,xmm1
-        movdqa  xmm5,xmm7
-        paddw   xmm1,xmm4               ; xmm1=data3+data4=tmp3
-        paddw   xmm7,xmm0               ; xmm7=data2+data5=tmp2
-        psubw   xmm2,xmm4               ; xmm2=data3-data4=tmp4
-        psubw   xmm5,xmm0               ; xmm5=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm0,xmm6
-        paddw   xmm3,xmm1               ; xmm3=tmp10
-        paddw   xmm6,xmm7               ; xmm6=tmp11
-        psubw   xmm4,xmm1               ; xmm4=tmp13
-        psubw   xmm0,xmm7               ; xmm0=tmp12
-
-        movdqa  xmm1,xmm3
-        paddw   xmm3,xmm6               ; xmm3=tmp10+tmp11
-        psubw   xmm1,xmm6               ; xmm1=tmp10-tmp11
-
-        psllw   xmm3,PASS1_BITS         ; xmm3=data0
-        psllw   xmm1,PASS1_BITS         ; xmm1=data4
-
-        movdqa  XMMWORD [wk(2)], xmm3   ; wk(2)=data0
-        movdqa  XMMWORD [wk(3)], xmm1   ; wk(3)=data4
-
-        ; (Original)
-        ; z1 = (tmp12 + tmp13) * 0.541196100;
-        ; data2 = z1 + tmp13 * 0.765366865;
-        ; data6 = z1 + tmp12 * -1.847759065;
-        ;
-        ; (This implementation)
-        ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
-        ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
-
-        movdqa    xmm7,xmm4             ; xmm4=tmp13
-        movdqa    xmm6,xmm4
-        punpcklwd xmm7,xmm0             ; xmm0=tmp12
-        punpckhwd xmm6,xmm0
-        movdqa    xmm4,xmm7
-        movdqa    xmm0,xmm6
-        pmaddwd   xmm7,[rel PW_F130_F054]       ; xmm7=data2L
-        pmaddwd   xmm6,[rel PW_F130_F054]       ; xmm6=data2H
-        pmaddwd   xmm4,[rel PW_F054_MF130]      ; xmm4=data6L
-        pmaddwd   xmm0,[rel PW_F054_MF130]      ; xmm0=data6H
-
-        paddd   xmm7,[rel PD_DESCALE_P1]
-        paddd   xmm6,[rel PD_DESCALE_P1]
-        psrad   xmm7,DESCALE_P1
-        psrad   xmm6,DESCALE_P1
-        paddd   xmm4,[rel PD_DESCALE_P1]
-        paddd   xmm0,[rel PD_DESCALE_P1]
-        psrad   xmm4,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-
-        packssdw  xmm7,xmm6             ; xmm7=data2
-        packssdw  xmm4,xmm0             ; xmm4=data6
-
-        movdqa  XMMWORD [wk(4)], xmm7   ; wk(4)=data2
-        movdqa  XMMWORD [wk(5)], xmm4   ; wk(5)=data6
-
-        ; -- Odd part
-
-        movdqa  xmm3, XMMWORD [wk(0)]   ; xmm3=tmp6
-        movdqa  xmm1, XMMWORD [wk(1)]   ; xmm1=tmp7
-
-        movdqa  xmm6,xmm2               ; xmm2=tmp4
-        movdqa  xmm0,xmm5               ; xmm5=tmp5
-        paddw   xmm6,xmm3               ; xmm6=z3
-        paddw   xmm0,xmm1               ; xmm0=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm7,xmm6
-        movdqa    xmm4,xmm6
-        punpcklwd xmm7,xmm0
-        punpckhwd xmm4,xmm0
-        movdqa    xmm6,xmm7
-        movdqa    xmm0,xmm4
-        pmaddwd   xmm7,[rel PW_MF078_F117]      ; xmm7=z3L
-        pmaddwd   xmm4,[rel PW_MF078_F117]      ; xmm4=z3H
-        pmaddwd   xmm6,[rel PW_F117_F078]       ; xmm6=z4L
-        pmaddwd   xmm0,[rel PW_F117_F078]       ; xmm0=z4H
-
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=z3L
-        movdqa  XMMWORD [wk(1)], xmm4   ; wk(1)=z3H
-
-        ; (Original)
-        ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
-        ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
-        ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
-        ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
-        ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
-        ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
-        ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
-        ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
-        ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
-
-        movdqa    xmm7,xmm2
-        movdqa    xmm4,xmm2
-        punpcklwd xmm7,xmm1
-        punpckhwd xmm4,xmm1
-        movdqa    xmm2,xmm7
-        movdqa    xmm1,xmm4
-        pmaddwd   xmm7,[rel PW_MF060_MF089]     ; xmm7=tmp4L
-        pmaddwd   xmm4,[rel PW_MF060_MF089]     ; xmm4=tmp4H
-        pmaddwd   xmm2,[rel PW_MF089_F060]      ; xmm2=tmp7L
-        pmaddwd   xmm1,[rel PW_MF089_F060]      ; xmm1=tmp7H
-
-        paddd   xmm7, XMMWORD [wk(0)]   ; xmm7=data7L
-        paddd   xmm4, XMMWORD [wk(1)]   ; xmm4=data7H
-        paddd   xmm2,xmm6               ; xmm2=data1L
-        paddd   xmm1,xmm0               ; xmm1=data1H
-
-        paddd   xmm7,[rel PD_DESCALE_P1]
-        paddd   xmm4,[rel PD_DESCALE_P1]
-        psrad   xmm7,DESCALE_P1
-        psrad   xmm4,DESCALE_P1
-        paddd   xmm2,[rel PD_DESCALE_P1]
-        paddd   xmm1,[rel PD_DESCALE_P1]
-        psrad   xmm2,DESCALE_P1
-        psrad   xmm1,DESCALE_P1
-
-        packssdw  xmm7,xmm4             ; xmm7=data7
-        packssdw  xmm2,xmm1             ; xmm2=data1
-
-        movdqa    xmm4,xmm5
-        movdqa    xmm1,xmm5
-        punpcklwd xmm4,xmm3
-        punpckhwd xmm1,xmm3
-        movdqa    xmm5,xmm4
-        movdqa    xmm3,xmm1
-        pmaddwd   xmm4,[rel PW_MF050_MF256]     ; xmm4=tmp5L
-        pmaddwd   xmm1,[rel PW_MF050_MF256]     ; xmm1=tmp5H
-        pmaddwd   xmm5,[rel PW_MF256_F050]      ; xmm5=tmp6L
-        pmaddwd   xmm3,[rel PW_MF256_F050]      ; xmm3=tmp6H
-
-        paddd   xmm4,xmm6               ; xmm4=data5L
-        paddd   xmm1,xmm0               ; xmm1=data5H
-        paddd   xmm5, XMMWORD [wk(0)]   ; xmm5=data3L
-        paddd   xmm3, XMMWORD [wk(1)]   ; xmm3=data3H
-
-        paddd   xmm4,[rel PD_DESCALE_P1]
-        paddd   xmm1,[rel PD_DESCALE_P1]
-        psrad   xmm4,DESCALE_P1
-        psrad   xmm1,DESCALE_P1
-        paddd   xmm5,[rel PD_DESCALE_P1]
-        paddd   xmm3,[rel PD_DESCALE_P1]
-        psrad   xmm5,DESCALE_P1
-        psrad   xmm3,DESCALE_P1
-
-        packssdw  xmm4,xmm1             ; xmm4=data5
-        packssdw  xmm5,xmm3             ; xmm5=data3
-
-        ; ---- Pass 2: process columns.
-
-        movdqa  xmm6, XMMWORD [wk(2)]   ; xmm6=col0
-        movdqa  xmm0, XMMWORD [wk(4)]   ; xmm0=col2
-
-        ; xmm6=(00 10 20 30 40 50 60 70), xmm0=(02 12 22 32 42 52 62 72)
-        ; xmm2=(01 11 21 31 41 51 61 71), xmm5=(03 13 23 33 43 53 63 73)
-
-        movdqa    xmm1,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm2             ; xmm6=(00 01 10 11 20 21 30 31)
-        punpckhwd xmm1,xmm2             ; xmm1=(40 41 50 51 60 61 70 71)
-        movdqa    xmm3,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm5             ; xmm0=(02 03 12 13 22 23 32 33)
-        punpckhwd xmm3,xmm5             ; xmm3=(42 43 52 53 62 63 72 73)
-
-        movdqa  xmm2, XMMWORD [wk(3)]   ; xmm2=col4
-        movdqa  xmm5, XMMWORD [wk(5)]   ; xmm5=col6
-
-        ; xmm2=(04 14 24 34 44 54 64 74), xmm5=(06 16 26 36 46 56 66 76)
-        ; xmm4=(05 15 25 35 45 55 65 75), xmm7=(07 17 27 37 47 57 67 77)
-
-        movdqa  XMMWORD [wk(0)], xmm0   ; wk(0)=(02 03 12 13 22 23 32 33)
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=(42 43 52 53 62 63 72 73)
-
-        movdqa    xmm0,xmm2             ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm4             ; xmm2=(04 05 14 15 24 25 34 35)
-        punpckhwd xmm0,xmm4             ; xmm0=(44 45 54 55 64 65 74 75)
-        movdqa    xmm3,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm7             ; xmm5=(06 07 16 17 26 27 36 37)
-        punpckhwd xmm3,xmm7             ; xmm3=(46 47 56 57 66 67 76 77)
-
-        movdqa    xmm4,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm5             ; xmm2=(04 05 06 07 14 15 16 17)
-        punpckhdq xmm4,xmm5             ; xmm4=(24 25 26 27 34 35 36 37)
-        movdqa    xmm7,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm3             ; xmm0=(44 45 46 47 54 55 56 57)
-        punpckhdq xmm7,xmm3             ; xmm7=(64 65 66 67 74 75 76 77)
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=(02 03 12 13 22 23 32 33)
-        movdqa  xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53 62 63 72 73)
-        movdqa  XMMWORD [wk(2)], xmm4   ; wk(2)=(24 25 26 27 34 35 36 37)
-        movdqa  XMMWORD [wk(3)], xmm0   ; wk(3)=(44 45 46 47 54 55 56 57)
-
-        movdqa    xmm4,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm5             ; xmm6=(00 01 02 03 10 11 12 13)
-        punpckhdq xmm4,xmm5             ; xmm4=(20 21 22 23 30 31 32 33)
-        movdqa    xmm0,xmm1             ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm3             ; xmm1=(40 41 42 43 50 51 52 53)
-        punpckhdq xmm0,xmm3             ; xmm0=(60 61 62 63 70 71 72 73)
-
-        movdqa     xmm5,xmm6            ; transpose coefficients(phase 3)
-        punpcklqdq xmm6,xmm2            ; xmm6=(00 01 02 03 04 05 06 07)=data0
-        punpckhqdq xmm5,xmm2            ; xmm5=(10 11 12 13 14 15 16 17)=data1
-        movdqa     xmm3,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm7            ; xmm0=(60 61 62 63 64 65 66 67)=data6
-        punpckhqdq xmm3,xmm7            ; xmm3=(70 71 72 73 74 75 76 77)=data7
-
-        movdqa  xmm2,xmm5
-        movdqa  xmm7,xmm6
-        psubw   xmm5,xmm0               ; xmm5=data1-data6=tmp6
-        psubw   xmm6,xmm3               ; xmm6=data0-data7=tmp7
-        paddw   xmm2,xmm0               ; xmm2=data1+data6=tmp1
-        paddw   xmm7,xmm3               ; xmm7=data0+data7=tmp0
-
-        movdqa  xmm0, XMMWORD [wk(2)]   ; xmm0=(24 25 26 27 34 35 36 37)
-        movdqa  xmm3, XMMWORD [wk(3)]   ; xmm3=(44 45 46 47 54 55 56 57)
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
-
-        movdqa     xmm5,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm0            ; xmm4=(20 21 22 23 24 25 26 27)=data2
-        punpckhqdq xmm5,xmm0            ; xmm5=(30 31 32 33 34 35 36 37)=data3
-        movdqa     xmm6,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm3            ; xmm1=(40 41 42 43 44 45 46 47)=data4
-        punpckhqdq xmm6,xmm3            ; xmm6=(50 51 52 53 54 55 56 57)=data5
-
-        movdqa  xmm0,xmm5
-        movdqa  xmm3,xmm4
-        paddw   xmm5,xmm1               ; xmm5=data3+data4=tmp3
-        paddw   xmm4,xmm6               ; xmm4=data2+data5=tmp2
-        psubw   xmm0,xmm1               ; xmm0=data3-data4=tmp4
-        psubw   xmm3,xmm6               ; xmm3=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm1,xmm7
-        movdqa  xmm6,xmm2
-        paddw   xmm7,xmm5               ; xmm7=tmp10
-        paddw   xmm2,xmm4               ; xmm2=tmp11
-        psubw   xmm1,xmm5               ; xmm1=tmp13
-        psubw   xmm6,xmm4               ; xmm6=tmp12
-
-        movdqa  xmm5,xmm7
-        paddw   xmm7,xmm2               ; xmm7=tmp10+tmp11
-        psubw   xmm5,xmm2               ; xmm5=tmp10-tmp11
-
-        paddw   xmm7,[rel PW_DESCALE_P2X]
-        paddw   xmm5,[rel PW_DESCALE_P2X]
-        psraw   xmm7,PASS1_BITS         ; xmm7=data0
-        psraw   xmm5,PASS1_BITS         ; xmm5=data4
-
-        movdqa  XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)], xmm7
-        movdqa  XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)], xmm5
-
-        ; (Original)
-        ; z1 = (tmp12 + tmp13) * 0.541196100;
-        ; data2 = z1 + tmp13 * 0.765366865;
-        ; data6 = z1 + tmp12 * -1.847759065;
-        ;
-        ; (This implementation)
-        ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
-        ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
-
-        movdqa    xmm4,xmm1             ; xmm1=tmp13
-        movdqa    xmm2,xmm1
-        punpcklwd xmm4,xmm6             ; xmm6=tmp12
-        punpckhwd xmm2,xmm6
-        movdqa    xmm1,xmm4
-        movdqa    xmm6,xmm2
-        pmaddwd   xmm4,[rel PW_F130_F054]       ; xmm4=data2L
-        pmaddwd   xmm2,[rel PW_F130_F054]       ; xmm2=data2H
-        pmaddwd   xmm1,[rel PW_F054_MF130]      ; xmm1=data6L
-        pmaddwd   xmm6,[rel PW_F054_MF130]      ; xmm6=data6H
-
-        paddd   xmm4,[rel PD_DESCALE_P2]
-        paddd   xmm2,[rel PD_DESCALE_P2]
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm2,DESCALE_P2
-        paddd   xmm1,[rel PD_DESCALE_P2]
-        paddd   xmm6,[rel PD_DESCALE_P2]
-        psrad   xmm1,DESCALE_P2
-        psrad   xmm6,DESCALE_P2
-
-        packssdw  xmm4,xmm2             ; xmm4=data2
-        packssdw  xmm1,xmm6             ; xmm1=data6
-
-        movdqa  XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)], xmm4
-        movdqa  XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)], xmm1
-
-        ; -- Odd part
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp6
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
-
-        movdqa  xmm2,xmm0               ; xmm0=tmp4
-        movdqa  xmm6,xmm3               ; xmm3=tmp5
-        paddw   xmm2,xmm7               ; xmm2=z3
-        paddw   xmm6,xmm5               ; xmm6=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm4,xmm2
-        movdqa    xmm1,xmm2
-        punpcklwd xmm4,xmm6
-        punpckhwd xmm1,xmm6
-        movdqa    xmm2,xmm4
-        movdqa    xmm6,xmm1
-        pmaddwd   xmm4,[rel PW_MF078_F117]      ; xmm4=z3L
-        pmaddwd   xmm1,[rel PW_MF078_F117]      ; xmm1=z3H
-        pmaddwd   xmm2,[rel PW_F117_F078]       ; xmm2=z4L
-        pmaddwd   xmm6,[rel PW_F117_F078]       ; xmm6=z4H
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=z3L
-        movdqa  XMMWORD [wk(1)], xmm1   ; wk(1)=z3H
-
-        ; (Original)
-        ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
-        ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
-        ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
-        ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
-        ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
-        ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
-        ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
-        ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
-        ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
-
-        movdqa    xmm4,xmm0
-        movdqa    xmm1,xmm0
-        punpcklwd xmm4,xmm5
-        punpckhwd xmm1,xmm5
-        movdqa    xmm0,xmm4
-        movdqa    xmm5,xmm1
-        pmaddwd   xmm4,[rel PW_MF060_MF089]     ; xmm4=tmp4L
-        pmaddwd   xmm1,[rel PW_MF060_MF089]     ; xmm1=tmp4H
-        pmaddwd   xmm0,[rel PW_MF089_F060]      ; xmm0=tmp7L
-        pmaddwd   xmm5,[rel PW_MF089_F060]      ; xmm5=tmp7H
-
-        paddd   xmm4, XMMWORD [wk(0)]   ; xmm4=data7L
-        paddd   xmm1, XMMWORD [wk(1)]   ; xmm1=data7H
-        paddd   xmm0,xmm2               ; xmm0=data1L
-        paddd   xmm5,xmm6               ; xmm5=data1H
-
-        paddd   xmm4,[rel PD_DESCALE_P2]
-        paddd   xmm1,[rel PD_DESCALE_P2]
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm1,DESCALE_P2
-        paddd   xmm0,[rel PD_DESCALE_P2]
-        paddd   xmm5,[rel PD_DESCALE_P2]
-        psrad   xmm0,DESCALE_P2
-        psrad   xmm5,DESCALE_P2
-
-        packssdw  xmm4,xmm1             ; xmm4=data7
-        packssdw  xmm0,xmm5             ; xmm0=data1
-
-        movdqa  XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)], xmm4
-        movdqa  XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)], xmm0
-
-        movdqa    xmm1,xmm3
-        movdqa    xmm5,xmm3
-        punpcklwd xmm1,xmm7
-        punpckhwd xmm5,xmm7
-        movdqa    xmm3,xmm1
-        movdqa    xmm7,xmm5
-        pmaddwd   xmm1,[rel PW_MF050_MF256]     ; xmm1=tmp5L
-        pmaddwd   xmm5,[rel PW_MF050_MF256]     ; xmm5=tmp5H
-        pmaddwd   xmm3,[rel PW_MF256_F050]      ; xmm3=tmp6L
-        pmaddwd   xmm7,[rel PW_MF256_F050]      ; xmm7=tmp6H
-
-        paddd   xmm1,xmm2               ; xmm1=data5L
-        paddd   xmm5,xmm6               ; xmm5=data5H
-        paddd   xmm3, XMMWORD [wk(0)]   ; xmm3=data3L
-        paddd   xmm7, XMMWORD [wk(1)]   ; xmm7=data3H
-
-        paddd   xmm1,[rel PD_DESCALE_P2]
-        paddd   xmm5,[rel PD_DESCALE_P2]
-        psrad   xmm1,DESCALE_P2
-        psrad   xmm5,DESCALE_P2
-        paddd   xmm3,[rel PD_DESCALE_P2]
-        paddd   xmm7,[rel PD_DESCALE_P2]
-        psrad   xmm3,DESCALE_P2
-        psrad   xmm7,DESCALE_P2
-
-        packssdw  xmm1,xmm5             ; xmm1=data5
-        packssdw  xmm3,xmm7             ; xmm3=data3
-
-        movdqa  XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)], xmm1
-        movdqa  XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)], xmm3
-
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jfdctint-sse2.asm b/simd/jfdctint-sse2.asm
deleted file mode 100644
index db9d0bb..0000000
--- a/simd/jfdctint-sse2.asm
+++ /dev/null
@@ -1,633 +0,0 @@
-;
-; jfdctint.asm - accurate integer FDCT (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a slow-but-accurate integer implementation of the
-; forward DCT (Discrete Cosine Transform). The following code is based
-; directly on the IJG's original jfdctint.c; see the jfdctint.c for
-; more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      13
-%define PASS1_BITS      2
-
-%define DESCALE_P1      (CONST_BITS-PASS1_BITS)
-%define DESCALE_P2      (CONST_BITS+PASS1_BITS)
-
-%if CONST_BITS == 13
-F_0_298 equ      2446           ; FIX(0.298631336)
-F_0_390 equ      3196           ; FIX(0.390180644)
-F_0_541 equ      4433           ; FIX(0.541196100)
-F_0_765 equ      6270           ; FIX(0.765366865)
-F_0_899 equ      7373           ; FIX(0.899976223)
-F_1_175 equ      9633           ; FIX(1.175875602)
-F_1_501 equ     12299           ; FIX(1.501321110)
-F_1_847 equ     15137           ; FIX(1.847759065)
-F_1_961 equ     16069           ; FIX(1.961570560)
-F_2_053 equ     16819           ; FIX(2.053119869)
-F_2_562 equ     20995           ; FIX(2.562915447)
-F_3_072 equ     25172           ; FIX(3.072711026)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_298 equ     DESCALE( 320652955,30-CONST_BITS)       ; FIX(0.298631336)
-F_0_390 equ     DESCALE( 418953276,30-CONST_BITS)       ; FIX(0.390180644)
-F_0_541 equ     DESCALE( 581104887,30-CONST_BITS)       ; FIX(0.541196100)
-F_0_765 equ     DESCALE( 821806413,30-CONST_BITS)       ; FIX(0.765366865)
-F_0_899 equ     DESCALE( 966342111,30-CONST_BITS)       ; FIX(0.899976223)
-F_1_175 equ     DESCALE(1262586813,30-CONST_BITS)       ; FIX(1.175875602)
-F_1_501 equ     DESCALE(1612031267,30-CONST_BITS)       ; FIX(1.501321110)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_1_961 equ     DESCALE(2106220350,30-CONST_BITS)       ; FIX(1.961570560)
-F_2_053 equ     DESCALE(2204520673,30-CONST_BITS)       ; FIX(2.053119869)
-F_2_562 equ     DESCALE(2751909506,30-CONST_BITS)       ; FIX(2.562915447)
-F_3_072 equ     DESCALE(3299298341,30-CONST_BITS)       ; FIX(3.072711026)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_fdct_islow_sse2)
-
-EXTN(jconst_fdct_islow_sse2):
-
-PW_F130_F054    times 4 dw  (F_0_541+F_0_765), F_0_541
-PW_F054_MF130   times 4 dw  F_0_541, (F_0_541-F_1_847)
-PW_MF078_F117   times 4 dw  (F_1_175-F_1_961), F_1_175
-PW_F117_F078    times 4 dw  F_1_175, (F_1_175-F_0_390)
-PW_MF060_MF089  times 4 dw  (F_0_298-F_0_899),-F_0_899
-PW_MF089_F060   times 4 dw -F_0_899, (F_1_501-F_0_899)
-PW_MF050_MF256  times 4 dw  (F_2_053-F_2_562),-F_2_562
-PW_MF256_F050   times 4 dw -F_2_562, (F_3_072-F_2_562)
-PD_DESCALE_P1   times 4 dd  1 << (DESCALE_P1-1)
-PD_DESCALE_P2   times 4 dd  1 << (DESCALE_P2-1)
-PW_DESCALE_P2X  times 8 dw  1 << (PASS1_BITS-1)
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Perform the forward DCT on one block of samples.
-;
-; GLOBAL(void)
-; jsimd_fdct_islow_sse2 (DCTELEM *data)
-;
-
-%define data(b)         (b)+8           ; DCTELEM *data
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          6
-
-        align   16
-        global  EXTN(jsimd_fdct_islow_sse2)
-
-EXTN(jsimd_fdct_islow_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic ebx
-;       push    ecx             ; unused
-;       push    edx             ; need not be preserved
-;       push    esi             ; unused
-;       push    edi             ; unused
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process rows.
-
-        mov     edx, POINTER [data(eax)]        ; (DCTELEM *)
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)]
-
-        ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
-        ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
-
-        movdqa    xmm4,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm1             ; xmm0=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm4,xmm1             ; xmm4=(04 14 05 15 06 16 07 17)
-        movdqa    xmm5,xmm2             ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm3             ; xmm2=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm5,xmm3             ; xmm5=(24 34 25 35 26 36 27 37)
-
-        movdqa  xmm6, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm7, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)]
-
-        ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
-        ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
-        movdqa  XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
-
-        movdqa    xmm2,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm7             ; xmm6=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm2,xmm7             ; xmm2=(44 54 45 55 46 56 47 57)
-        movdqa    xmm5,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm3             ; xmm1=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm5,xmm3             ; xmm5=(64 74 65 75 66 76 67 77)
-
-        movdqa    xmm7,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm1             ; xmm6=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm7,xmm1             ; xmm7=(42 52 62 72 43 53 63 73)
-        movdqa    xmm3,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm5             ; xmm2=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm3,xmm5             ; xmm3=(46 56 66 76 47 57 67 77)
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
-        movdqa  XMMWORD [wk(2)], xmm7   ; wk(2)=(42 52 62 72 43 53 63 73)
-        movdqa  XMMWORD [wk(3)], xmm2   ; wk(3)=(44 54 64 74 45 55 65 75)
-
-        movdqa    xmm7,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm1             ; xmm0=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm7,xmm1             ; xmm7=(02 12 22 32 03 13 23 33)
-        movdqa    xmm2,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm5             ; xmm4=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm2,xmm5             ; xmm2=(06 16 26 36 07 17 27 37)
-
-        movdqa     xmm1,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm6            ; xmm0=(00 10 20 30 40 50 60 70)=data0
-        punpckhqdq xmm1,xmm6            ; xmm1=(01 11 21 31 41 51 61 71)=data1
-        movdqa     xmm5,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm3            ; xmm2=(06 16 26 36 46 56 66 76)=data6
-        punpckhqdq xmm5,xmm3            ; xmm5=(07 17 27 37 47 57 67 77)=data7
-
-        movdqa  xmm6,xmm1
-        movdqa  xmm3,xmm0
-        psubw   xmm1,xmm2               ; xmm1=data1-data6=tmp6
-        psubw   xmm0,xmm5               ; xmm0=data0-data7=tmp7
-        paddw   xmm6,xmm2               ; xmm6=data1+data6=tmp1
-        paddw   xmm3,xmm5               ; xmm3=data0+data7=tmp0
-
-        movdqa  xmm2, XMMWORD [wk(2)]   ; xmm2=(42 52 62 72 43 53 63 73)
-        movdqa  xmm5, XMMWORD [wk(3)]   ; xmm5=(44 54 64 74 45 55 65 75)
-        movdqa  XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
-
-        movdqa     xmm1,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm2            ; xmm7=(02 12 22 32 42 52 62 72)=data2
-        punpckhqdq xmm1,xmm2            ; xmm1=(03 13 23 33 43 53 63 73)=data3
-        movdqa     xmm0,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm5            ; xmm4=(04 14 24 34 44 54 64 74)=data4
-        punpckhqdq xmm0,xmm5            ; xmm0=(05 15 25 35 45 55 65 75)=data5
-
-        movdqa  xmm2,xmm1
-        movdqa  xmm5,xmm7
-        paddw   xmm1,xmm4               ; xmm1=data3+data4=tmp3
-        paddw   xmm7,xmm0               ; xmm7=data2+data5=tmp2
-        psubw   xmm2,xmm4               ; xmm2=data3-data4=tmp4
-        psubw   xmm5,xmm0               ; xmm5=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm0,xmm6
-        paddw   xmm3,xmm1               ; xmm3=tmp10
-        paddw   xmm6,xmm7               ; xmm6=tmp11
-        psubw   xmm4,xmm1               ; xmm4=tmp13
-        psubw   xmm0,xmm7               ; xmm0=tmp12
-
-        movdqa  xmm1,xmm3
-        paddw   xmm3,xmm6               ; xmm3=tmp10+tmp11
-        psubw   xmm1,xmm6               ; xmm1=tmp10-tmp11
-
-        psllw   xmm3,PASS1_BITS         ; xmm3=data0
-        psllw   xmm1,PASS1_BITS         ; xmm1=data4
-
-        movdqa  XMMWORD [wk(2)], xmm3   ; wk(2)=data0
-        movdqa  XMMWORD [wk(3)], xmm1   ; wk(3)=data4
-
-        ; (Original)
-        ; z1 = (tmp12 + tmp13) * 0.541196100;
-        ; data2 = z1 + tmp13 * 0.765366865;
-        ; data6 = z1 + tmp12 * -1.847759065;
-        ;
-        ; (This implementation)
-        ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
-        ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
-
-        movdqa    xmm7,xmm4             ; xmm4=tmp13
-        movdqa    xmm6,xmm4
-        punpcklwd xmm7,xmm0             ; xmm0=tmp12
-        punpckhwd xmm6,xmm0
-        movdqa    xmm4,xmm7
-        movdqa    xmm0,xmm6
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_F130_F054)]       ; xmm7=data2L
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_F130_F054)]       ; xmm6=data2H
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm4=data6L
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm0=data6H
-
-        paddd   xmm7,[GOTOFF(ebx,PD_DESCALE_P1)]
-        paddd   xmm6,[GOTOFF(ebx,PD_DESCALE_P1)]
-        psrad   xmm7,DESCALE_P1
-        psrad   xmm6,DESCALE_P1
-        paddd   xmm4,[GOTOFF(ebx,PD_DESCALE_P1)]
-        paddd   xmm0,[GOTOFF(ebx,PD_DESCALE_P1)]
-        psrad   xmm4,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-
-        packssdw  xmm7,xmm6             ; xmm7=data2
-        packssdw  xmm4,xmm0             ; xmm4=data6
-
-        movdqa  XMMWORD [wk(4)], xmm7   ; wk(4)=data2
-        movdqa  XMMWORD [wk(5)], xmm4   ; wk(5)=data6
-
-        ; -- Odd part
-
-        movdqa  xmm3, XMMWORD [wk(0)]   ; xmm3=tmp6
-        movdqa  xmm1, XMMWORD [wk(1)]   ; xmm1=tmp7
-
-        movdqa  xmm6,xmm2               ; xmm2=tmp4
-        movdqa  xmm0,xmm5               ; xmm5=tmp5
-        paddw   xmm6,xmm3               ; xmm6=z3
-        paddw   xmm0,xmm1               ; xmm0=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm7,xmm6
-        movdqa    xmm4,xmm6
-        punpcklwd xmm7,xmm0
-        punpckhwd xmm4,xmm0
-        movdqa    xmm6,xmm7
-        movdqa    xmm0,xmm4
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm7=z3L
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm4=z3H
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_F117_F078)]       ; xmm6=z4L
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_F117_F078)]       ; xmm0=z4H
-
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=z3L
-        movdqa  XMMWORD [wk(1)], xmm4   ; wk(1)=z3H
-
-        ; (Original)
-        ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
-        ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
-        ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
-        ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
-        ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
-        ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
-        ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
-        ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
-        ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
-
-        movdqa    xmm7,xmm2
-        movdqa    xmm4,xmm2
-        punpcklwd xmm7,xmm1
-        punpckhwd xmm4,xmm1
-        movdqa    xmm2,xmm7
-        movdqa    xmm1,xmm4
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm7=tmp4L
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm4=tmp4H
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm2=tmp7L
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm1=tmp7H
-
-        paddd   xmm7, XMMWORD [wk(0)]   ; xmm7=data7L
-        paddd   xmm4, XMMWORD [wk(1)]   ; xmm4=data7H
-        paddd   xmm2,xmm6               ; xmm2=data1L
-        paddd   xmm1,xmm0               ; xmm1=data1H
-
-        paddd   xmm7,[GOTOFF(ebx,PD_DESCALE_P1)]
-        paddd   xmm4,[GOTOFF(ebx,PD_DESCALE_P1)]
-        psrad   xmm7,DESCALE_P1
-        psrad   xmm4,DESCALE_P1
-        paddd   xmm2,[GOTOFF(ebx,PD_DESCALE_P1)]
-        paddd   xmm1,[GOTOFF(ebx,PD_DESCALE_P1)]
-        psrad   xmm2,DESCALE_P1
-        psrad   xmm1,DESCALE_P1
-
-        packssdw  xmm7,xmm4             ; xmm7=data7
-        packssdw  xmm2,xmm1             ; xmm2=data1
-
-        movdqa    xmm4,xmm5
-        movdqa    xmm1,xmm5
-        punpcklwd xmm4,xmm3
-        punpckhwd xmm1,xmm3
-        movdqa    xmm5,xmm4
-        movdqa    xmm3,xmm1
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm4=tmp5L
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm1=tmp5H
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm5=tmp6L
-        pmaddwd   xmm3,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm3=tmp6H
-
-        paddd   xmm4,xmm6               ; xmm4=data5L
-        paddd   xmm1,xmm0               ; xmm1=data5H
-        paddd   xmm5, XMMWORD [wk(0)]   ; xmm5=data3L
-        paddd   xmm3, XMMWORD [wk(1)]   ; xmm3=data3H
-
-        paddd   xmm4,[GOTOFF(ebx,PD_DESCALE_P1)]
-        paddd   xmm1,[GOTOFF(ebx,PD_DESCALE_P1)]
-        psrad   xmm4,DESCALE_P1
-        psrad   xmm1,DESCALE_P1
-        paddd   xmm5,[GOTOFF(ebx,PD_DESCALE_P1)]
-        paddd   xmm3,[GOTOFF(ebx,PD_DESCALE_P1)]
-        psrad   xmm5,DESCALE_P1
-        psrad   xmm3,DESCALE_P1
-
-        packssdw  xmm4,xmm1             ; xmm4=data5
-        packssdw  xmm5,xmm3             ; xmm5=data3
-
-        ; ---- Pass 2: process columns.
-
-;       mov     edx, POINTER [data(eax)]        ; (DCTELEM *)
-
-        movdqa  xmm6, XMMWORD [wk(2)]   ; xmm6=col0
-        movdqa  xmm0, XMMWORD [wk(4)]   ; xmm0=col2
-
-        ; xmm6=(00 10 20 30 40 50 60 70), xmm0=(02 12 22 32 42 52 62 72)
-        ; xmm2=(01 11 21 31 41 51 61 71), xmm5=(03 13 23 33 43 53 63 73)
-
-        movdqa    xmm1,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm2             ; xmm6=(00 01 10 11 20 21 30 31)
-        punpckhwd xmm1,xmm2             ; xmm1=(40 41 50 51 60 61 70 71)
-        movdqa    xmm3,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm5             ; xmm0=(02 03 12 13 22 23 32 33)
-        punpckhwd xmm3,xmm5             ; xmm3=(42 43 52 53 62 63 72 73)
-
-        movdqa  xmm2, XMMWORD [wk(3)]   ; xmm2=col4
-        movdqa  xmm5, XMMWORD [wk(5)]   ; xmm5=col6
-
-        ; xmm2=(04 14 24 34 44 54 64 74), xmm5=(06 16 26 36 46 56 66 76)
-        ; xmm4=(05 15 25 35 45 55 65 75), xmm7=(07 17 27 37 47 57 67 77)
-
-        movdqa  XMMWORD [wk(0)], xmm0   ; wk(0)=(02 03 12 13 22 23 32 33)
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=(42 43 52 53 62 63 72 73)
-
-        movdqa    xmm0,xmm2             ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm4             ; xmm2=(04 05 14 15 24 25 34 35)
-        punpckhwd xmm0,xmm4             ; xmm0=(44 45 54 55 64 65 74 75)
-        movdqa    xmm3,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm7             ; xmm5=(06 07 16 17 26 27 36 37)
-        punpckhwd xmm3,xmm7             ; xmm3=(46 47 56 57 66 67 76 77)
-
-        movdqa    xmm4,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm5             ; xmm2=(04 05 06 07 14 15 16 17)
-        punpckhdq xmm4,xmm5             ; xmm4=(24 25 26 27 34 35 36 37)
-        movdqa    xmm7,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm3             ; xmm0=(44 45 46 47 54 55 56 57)
-        punpckhdq xmm7,xmm3             ; xmm7=(64 65 66 67 74 75 76 77)
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=(02 03 12 13 22 23 32 33)
-        movdqa  xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53 62 63 72 73)
-        movdqa  XMMWORD [wk(2)], xmm4   ; wk(2)=(24 25 26 27 34 35 36 37)
-        movdqa  XMMWORD [wk(3)], xmm0   ; wk(3)=(44 45 46 47 54 55 56 57)
-
-        movdqa    xmm4,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm5             ; xmm6=(00 01 02 03 10 11 12 13)
-        punpckhdq xmm4,xmm5             ; xmm4=(20 21 22 23 30 31 32 33)
-        movdqa    xmm0,xmm1             ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm3             ; xmm1=(40 41 42 43 50 51 52 53)
-        punpckhdq xmm0,xmm3             ; xmm0=(60 61 62 63 70 71 72 73)
-
-        movdqa     xmm5,xmm6            ; transpose coefficients(phase 3)
-        punpcklqdq xmm6,xmm2            ; xmm6=(00 01 02 03 04 05 06 07)=data0
-        punpckhqdq xmm5,xmm2            ; xmm5=(10 11 12 13 14 15 16 17)=data1
-        movdqa     xmm3,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm7            ; xmm0=(60 61 62 63 64 65 66 67)=data6
-        punpckhqdq xmm3,xmm7            ; xmm3=(70 71 72 73 74 75 76 77)=data7
-
-        movdqa  xmm2,xmm5
-        movdqa  xmm7,xmm6
-        psubw   xmm5,xmm0               ; xmm5=data1-data6=tmp6
-        psubw   xmm6,xmm3               ; xmm6=data0-data7=tmp7
-        paddw   xmm2,xmm0               ; xmm2=data1+data6=tmp1
-        paddw   xmm7,xmm3               ; xmm7=data0+data7=tmp0
-
-        movdqa  xmm0, XMMWORD [wk(2)]   ; xmm0=(24 25 26 27 34 35 36 37)
-        movdqa  xmm3, XMMWORD [wk(3)]   ; xmm3=(44 45 46 47 54 55 56 57)
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=tmp6
-        movdqa  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
-
-        movdqa     xmm5,xmm4            ; transpose coefficients(phase 3)
-        punpcklqdq xmm4,xmm0            ; xmm4=(20 21 22 23 24 25 26 27)=data2
-        punpckhqdq xmm5,xmm0            ; xmm5=(30 31 32 33 34 35 36 37)=data3
-        movdqa     xmm6,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm3            ; xmm1=(40 41 42 43 44 45 46 47)=data4
-        punpckhqdq xmm6,xmm3            ; xmm6=(50 51 52 53 54 55 56 57)=data5
-
-        movdqa  xmm0,xmm5
-        movdqa  xmm3,xmm4
-        paddw   xmm5,xmm1               ; xmm5=data3+data4=tmp3
-        paddw   xmm4,xmm6               ; xmm4=data2+data5=tmp2
-        psubw   xmm0,xmm1               ; xmm0=data3-data4=tmp4
-        psubw   xmm3,xmm6               ; xmm3=data2-data5=tmp5
-
-        ; -- Even part
-
-        movdqa  xmm1,xmm7
-        movdqa  xmm6,xmm2
-        paddw   xmm7,xmm5               ; xmm7=tmp10
-        paddw   xmm2,xmm4               ; xmm2=tmp11
-        psubw   xmm1,xmm5               ; xmm1=tmp13
-        psubw   xmm6,xmm4               ; xmm6=tmp12
-
-        movdqa  xmm5,xmm7
-        paddw   xmm7,xmm2               ; xmm7=tmp10+tmp11
-        psubw   xmm5,xmm2               ; xmm5=tmp10-tmp11
-
-        paddw   xmm7,[GOTOFF(ebx,PW_DESCALE_P2X)]
-        paddw   xmm5,[GOTOFF(ebx,PW_DESCALE_P2X)]
-        psraw   xmm7,PASS1_BITS         ; xmm7=data0
-        psraw   xmm5,PASS1_BITS         ; xmm5=data4
-
-        movdqa  XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_DCTELEM)], xmm7
-        movdqa  XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_DCTELEM)], xmm5
-
-        ; (Original)
-        ; z1 = (tmp12 + tmp13) * 0.541196100;
-        ; data2 = z1 + tmp13 * 0.765366865;
-        ; data6 = z1 + tmp12 * -1.847759065;
-        ;
-        ; (This implementation)
-        ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
-        ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
-
-        movdqa    xmm4,xmm1             ; xmm1=tmp13
-        movdqa    xmm2,xmm1
-        punpcklwd xmm4,xmm6             ; xmm6=tmp12
-        punpckhwd xmm2,xmm6
-        movdqa    xmm1,xmm4
-        movdqa    xmm6,xmm2
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_F130_F054)]       ; xmm4=data2L
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_F130_F054)]       ; xmm2=data2H
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm1=data6L
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm6=data6H
-
-        paddd   xmm4,[GOTOFF(ebx,PD_DESCALE_P2)]
-        paddd   xmm2,[GOTOFF(ebx,PD_DESCALE_P2)]
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm2,DESCALE_P2
-        paddd   xmm1,[GOTOFF(ebx,PD_DESCALE_P2)]
-        paddd   xmm6,[GOTOFF(ebx,PD_DESCALE_P2)]
-        psrad   xmm1,DESCALE_P2
-        psrad   xmm6,DESCALE_P2
-
-        packssdw  xmm4,xmm2             ; xmm4=data2
-        packssdw  xmm1,xmm6             ; xmm1=data6
-
-        movdqa  XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_DCTELEM)], xmm4
-        movdqa  XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_DCTELEM)], xmm1
-
-        ; -- Odd part
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp6
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
-
-        movdqa  xmm2,xmm0               ; xmm0=tmp4
-        movdqa  xmm6,xmm3               ; xmm3=tmp5
-        paddw   xmm2,xmm7               ; xmm2=z3
-        paddw   xmm6,xmm5               ; xmm6=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm4,xmm2
-        movdqa    xmm1,xmm2
-        punpcklwd xmm4,xmm6
-        punpckhwd xmm1,xmm6
-        movdqa    xmm2,xmm4
-        movdqa    xmm6,xmm1
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm4=z3L
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm1=z3H
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_F117_F078)]       ; xmm2=z4L
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_F117_F078)]       ; xmm6=z4H
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=z3L
-        movdqa  XMMWORD [wk(1)], xmm1   ; wk(1)=z3H
-
-        ; (Original)
-        ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
-        ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
-        ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
-        ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
-        ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
-        ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
-        ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
-        ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
-        ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
-
-        movdqa    xmm4,xmm0
-        movdqa    xmm1,xmm0
-        punpcklwd xmm4,xmm5
-        punpckhwd xmm1,xmm5
-        movdqa    xmm0,xmm4
-        movdqa    xmm5,xmm1
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm4=tmp4L
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm1=tmp4H
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm0=tmp7L
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm5=tmp7H
-
-        paddd   xmm4, XMMWORD [wk(0)]   ; xmm4=data7L
-        paddd   xmm1, XMMWORD [wk(1)]   ; xmm1=data7H
-        paddd   xmm0,xmm2               ; xmm0=data1L
-        paddd   xmm5,xmm6               ; xmm5=data1H
-
-        paddd   xmm4,[GOTOFF(ebx,PD_DESCALE_P2)]
-        paddd   xmm1,[GOTOFF(ebx,PD_DESCALE_P2)]
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm1,DESCALE_P2
-        paddd   xmm0,[GOTOFF(ebx,PD_DESCALE_P2)]
-        paddd   xmm5,[GOTOFF(ebx,PD_DESCALE_P2)]
-        psrad   xmm0,DESCALE_P2
-        psrad   xmm5,DESCALE_P2
-
-        packssdw  xmm4,xmm1             ; xmm4=data7
-        packssdw  xmm0,xmm5             ; xmm0=data1
-
-        movdqa  XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_DCTELEM)], xmm4
-        movdqa  XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_DCTELEM)], xmm0
-
-        movdqa    xmm1,xmm3
-        movdqa    xmm5,xmm3
-        punpcklwd xmm1,xmm7
-        punpckhwd xmm5,xmm7
-        movdqa    xmm3,xmm1
-        movdqa    xmm7,xmm5
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm1=tmp5L
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm5=tmp5H
-        pmaddwd   xmm3,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm3=tmp6L
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm7=tmp6H
-
-        paddd   xmm1,xmm2               ; xmm1=data5L
-        paddd   xmm5,xmm6               ; xmm5=data5H
-        paddd   xmm3, XMMWORD [wk(0)]   ; xmm3=data3L
-        paddd   xmm7, XMMWORD [wk(1)]   ; xmm7=data3H
-
-        paddd   xmm1,[GOTOFF(ebx,PD_DESCALE_P2)]
-        paddd   xmm5,[GOTOFF(ebx,PD_DESCALE_P2)]
-        psrad   xmm1,DESCALE_P2
-        psrad   xmm5,DESCALE_P2
-        paddd   xmm3,[GOTOFF(ebx,PD_DESCALE_P2)]
-        paddd   xmm7,[GOTOFF(ebx,PD_DESCALE_P2)]
-        psrad   xmm3,DESCALE_P2
-        psrad   xmm7,DESCALE_P2
-
-        packssdw  xmm1,xmm5             ; xmm1=data5
-        packssdw  xmm3,xmm7             ; xmm3=data3
-
-        movdqa  XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_DCTELEM)], xmm1
-        movdqa  XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_DCTELEM)], xmm3
-
-;       pop     edi             ; unused
-;       pop     esi             ; unused
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; unused
-        poppic  ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctflt-sse2-64.asm b/simd/jidctflt-sse2-64.asm
deleted file mode 100644
index bdda05d..0000000
--- a/simd/jidctflt-sse2-64.asm
+++ /dev/null
@@ -1,482 +0,0 @@
-;
-; jidctflt.asm - floating-point IDCT (64-bit SSE & SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a floating-point implementation of the inverse DCT
-; (Discrete Cosine Transform). The following code is based directly on
-; the IJG's original jidctflt.c; see the jidctflt.c for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%macro  unpcklps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
-        shufps  %1,%2,0x44
-%endmacro
-
-%macro  unpckhps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
-        shufps  %1,%2,0xEE
-%endmacro
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_idct_float_sse2)
-
-EXTN(jconst_idct_float_sse2):
-
-PD_1_414        times 4 dd  1.414213562373095048801689
-PD_1_847        times 4 dd  1.847759065022573512256366
-PD_1_082        times 4 dd  1.082392200292393968799446
-PD_M2_613       times 4 dd -2.613125929752753055713286
-PD_RNDINT_MAGIC times 4 dd  100663296.0 ; (float)(0x00C00000 << 3)
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Perform dequantization and inverse DCT on one block of coefficients.
-;
-; GLOBAL(void)
-; jsimd_idct_float_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                        JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-; r10 = void *dct_table
-; r11 = JCOEFPTR coef_block
-; r12 = JSAMPARRAY output_buf
-; r13 = JDIMENSION output_col
-
-%define original_rbp    rbp+0
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-%define workspace       wk(0)-DCTSIZE2*SIZEOF_FAST_FLOAT
-                                        ; FAST_FLOAT workspace[DCTSIZE2]
-
-        align   16
-        global  EXTN(jsimd_idct_float_sse2)
-
-EXTN(jsimd_idct_float_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [workspace]
-        collect_args
-        push    rbx
-
-        ; ---- Pass 1: process columns from input, store into work array.
-
-        mov     rdx, r10                ; quantptr
-        mov     rsi, r11                ; inptr
-        lea     rdi, [workspace]                        ; FAST_FLOAT *wsptr
-        mov     rcx, DCTSIZE/4                          ; ctr
-.columnloop:
-%ifndef NO_ZERO_COLUMN_TEST_FLOAT_SSE
-        mov     eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        jnz     near .columnDCT
-
-        movq    xmm1, XMM_MMWORD [MMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movq    xmm2, XMM_MMWORD [MMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        movq    xmm3, XMM_MMWORD [MMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        movq    xmm4, XMM_MMWORD [MMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
-        movq    xmm5, XMM_MMWORD [MMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        movq    xmm6, XMM_MMWORD [MMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-        movq    xmm7, XMM_MMWORD [MMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1,xmm2
-        por     xmm3,xmm4
-        por     xmm5,xmm6
-        por     xmm1,xmm3
-        por     xmm5,xmm7
-        por     xmm1,xmm5
-        packsswb xmm1,xmm1
-        movd    eax,xmm1
-        test    rax,rax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movq      xmm0, XMM_MMWORD [MMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-
-        punpcklwd xmm0,xmm0             ; xmm0=(00 00 01 01 02 02 03 03)
-        psrad     xmm0,(DWORD_BIT-WORD_BIT)     ; xmm0=in0=(00 01 02 03)
-        cvtdq2ps  xmm0,xmm0                     ; xmm0=in0=(00 01 02 03)
-
-        mulps   xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-
-        movaps  xmm1,xmm0
-        movaps  xmm2,xmm0
-        movaps  xmm3,xmm0
-
-        shufps  xmm0,xmm0,0x00                  ; xmm0=(00 00 00 00)
-        shufps  xmm1,xmm1,0x55                  ; xmm1=(01 01 01 01)
-        shufps  xmm2,xmm2,0xAA                  ; xmm2=(02 02 02 02)
-        shufps  xmm3,xmm3,0xFF                  ; xmm3=(03 03 03 03)
-
-        movaps  XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(0,1,rdi,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(1,1,rdi,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_FAST_FLOAT)], xmm2
-        movaps  XMMWORD [XMMBLOCK(2,1,rdi,SIZEOF_FAST_FLOAT)], xmm2
-        movaps  XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_FAST_FLOAT)], xmm3
-        movaps  XMMWORD [XMMBLOCK(3,1,rdi,SIZEOF_FAST_FLOAT)], xmm3
-        jmp     near .nextcolumn
-%endif
-.columnDCT:
-
-        ; -- Even part
-
-        movq      xmm0, XMM_MMWORD [MMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        movq      xmm1, XMM_MMWORD [MMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        movq      xmm2, XMM_MMWORD [MMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
-        movq      xmm3, XMM_MMWORD [MMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-
-        punpcklwd xmm0,xmm0             ; xmm0=(00 00 01 01 02 02 03 03)
-        punpcklwd xmm1,xmm1             ; xmm1=(20 20 21 21 22 22 23 23)
-        psrad     xmm0,(DWORD_BIT-WORD_BIT)     ; xmm0=in0=(00 01 02 03)
-        psrad     xmm1,(DWORD_BIT-WORD_BIT)     ; xmm1=in2=(20 21 22 23)
-        cvtdq2ps  xmm0,xmm0                     ; xmm0=in0=(00 01 02 03)
-        cvtdq2ps  xmm1,xmm1                     ; xmm1=in2=(20 21 22 23)
-
-        punpcklwd xmm2,xmm2             ; xmm2=(40 40 41 41 42 42 43 43)
-        punpcklwd xmm3,xmm3             ; xmm3=(60 60 61 61 62 62 63 63)
-        psrad     xmm2,(DWORD_BIT-WORD_BIT)     ; xmm2=in4=(40 41 42 43)
-        psrad     xmm3,(DWORD_BIT-WORD_BIT)     ; xmm3=in6=(60 61 62 63)
-        cvtdq2ps  xmm2,xmm2                     ; xmm2=in4=(40 41 42 43)
-        cvtdq2ps  xmm3,xmm3                     ; xmm3=in6=(60 61 62 63)
-
-        mulps     xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm1, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm2, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm3, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-
-        movaps  xmm4,xmm0
-        movaps  xmm5,xmm1
-        subps   xmm0,xmm2               ; xmm0=tmp11
-        subps   xmm1,xmm3
-        addps   xmm4,xmm2               ; xmm4=tmp10
-        addps   xmm5,xmm3               ; xmm5=tmp13
-
-        mulps   xmm1,[rel PD_1_414]
-        subps   xmm1,xmm5               ; xmm1=tmp12
-
-        movaps  xmm6,xmm4
-        movaps  xmm7,xmm0
-        subps   xmm4,xmm5               ; xmm4=tmp3
-        subps   xmm0,xmm1               ; xmm0=tmp2
-        addps   xmm6,xmm5               ; xmm6=tmp0
-        addps   xmm7,xmm1               ; xmm7=tmp1
-
-        movaps  XMMWORD [wk(1)], xmm4   ; tmp3
-        movaps  XMMWORD [wk(0)], xmm0   ; tmp2
-
-        ; -- Odd part
-
-        movq      xmm2, XMM_MMWORD [MMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movq      xmm3, XMM_MMWORD [MMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        movq      xmm5, XMM_MMWORD [MMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        movq      xmm1, XMM_MMWORD [MMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-
-        punpcklwd xmm2,xmm2             ; xmm2=(10 10 11 11 12 12 13 13)
-        punpcklwd xmm3,xmm3             ; xmm3=(30 30 31 31 32 32 33 33)
-        psrad     xmm2,(DWORD_BIT-WORD_BIT)     ; xmm2=in1=(10 11 12 13)
-        psrad     xmm3,(DWORD_BIT-WORD_BIT)     ; xmm3=in3=(30 31 32 33)
-        cvtdq2ps  xmm2,xmm2                     ; xmm2=in1=(10 11 12 13)
-        cvtdq2ps  xmm3,xmm3                     ; xmm3=in3=(30 31 32 33)
-
-        punpcklwd xmm5,xmm5             ; xmm5=(50 50 51 51 52 52 53 53)
-        punpcklwd xmm1,xmm1             ; xmm1=(70 70 71 71 72 72 73 73)
-        psrad     xmm5,(DWORD_BIT-WORD_BIT)     ; xmm5=in5=(50 51 52 53)
-        psrad     xmm1,(DWORD_BIT-WORD_BIT)     ; xmm1=in7=(70 71 72 73)
-        cvtdq2ps  xmm5,xmm5                     ; xmm5=in5=(50 51 52 53)
-        cvtdq2ps  xmm1,xmm1                     ; xmm1=in7=(70 71 72 73)
-
-        mulps     xmm2, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm5, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm1, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
-
-        movaps  xmm4,xmm2
-        movaps  xmm0,xmm5
-        addps   xmm2,xmm1               ; xmm2=z11
-        addps   xmm5,xmm3               ; xmm5=z13
-        subps   xmm4,xmm1               ; xmm4=z12
-        subps   xmm0,xmm3               ; xmm0=z10
-
-        movaps  xmm1,xmm2
-        subps   xmm2,xmm5
-        addps   xmm1,xmm5               ; xmm1=tmp7
-
-        mulps   xmm2,[rel PD_1_414]     ; xmm2=tmp11
-
-        movaps  xmm3,xmm0
-        addps   xmm0,xmm4
-        mulps   xmm0,[rel PD_1_847]     ; xmm0=z5
-        mulps   xmm3,[rel PD_M2_613]    ; xmm3=(z10 * -2.613125930)
-        mulps   xmm4,[rel PD_1_082]     ; xmm4=(z12 * 1.082392200)
-        addps   xmm3,xmm0               ; xmm3=tmp12
-        subps   xmm4,xmm0               ; xmm4=tmp10
-
-        ; -- Final output stage
-
-        subps   xmm3,xmm1               ; xmm3=tmp6
-        movaps  xmm5,xmm6
-        movaps  xmm0,xmm7
-        addps   xmm6,xmm1               ; xmm6=data0=(00 01 02 03)
-        addps   xmm7,xmm3               ; xmm7=data1=(10 11 12 13)
-        subps   xmm5,xmm1               ; xmm5=data7=(70 71 72 73)
-        subps   xmm0,xmm3               ; xmm0=data6=(60 61 62 63)
-        subps   xmm2,xmm3               ; xmm2=tmp5
-
-        movaps    xmm1,xmm6             ; transpose coefficients(phase 1)
-        unpcklps  xmm6,xmm7             ; xmm6=(00 10 01 11)
-        unpckhps  xmm1,xmm7             ; xmm1=(02 12 03 13)
-        movaps    xmm3,xmm0             ; transpose coefficients(phase 1)
-        unpcklps  xmm0,xmm5             ; xmm0=(60 70 61 71)
-        unpckhps  xmm3,xmm5             ; xmm3=(62 72 63 73)
-
-        movaps  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
-        movaps  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp3
-
-        movaps  XMMWORD [wk(0)], xmm0   ; wk(0)=(60 70 61 71)
-        movaps  XMMWORD [wk(1)], xmm3   ; wk(1)=(62 72 63 73)
-
-        addps   xmm4,xmm2               ; xmm4=tmp4
-        movaps  xmm0,xmm7
-        movaps  xmm3,xmm5
-        addps   xmm7,xmm2               ; xmm7=data2=(20 21 22 23)
-        addps   xmm5,xmm4               ; xmm5=data4=(40 41 42 43)
-        subps   xmm0,xmm2               ; xmm0=data5=(50 51 52 53)
-        subps   xmm3,xmm4               ; xmm3=data3=(30 31 32 33)
-
-        movaps    xmm2,xmm7             ; transpose coefficients(phase 1)
-        unpcklps  xmm7,xmm3             ; xmm7=(20 30 21 31)
-        unpckhps  xmm2,xmm3             ; xmm2=(22 32 23 33)
-        movaps    xmm4,xmm5             ; transpose coefficients(phase 1)
-        unpcklps  xmm5,xmm0             ; xmm5=(40 50 41 51)
-        unpckhps  xmm4,xmm0             ; xmm4=(42 52 43 53)
-
-        movaps    xmm3,xmm6             ; transpose coefficients(phase 2)
-        unpcklps2 xmm6,xmm7             ; xmm6=(00 10 20 30)
-        unpckhps2 xmm3,xmm7             ; xmm3=(01 11 21 31)
-        movaps    xmm0,xmm1             ; transpose coefficients(phase 2)
-        unpcklps2 xmm1,xmm2             ; xmm1=(02 12 22 32)
-        unpckhps2 xmm0,xmm2             ; xmm0=(03 13 23 33)
-
-        movaps  xmm7, XMMWORD [wk(0)]   ; xmm7=(60 70 61 71)
-        movaps  xmm2, XMMWORD [wk(1)]   ; xmm2=(62 72 63 73)
-
-        movaps  XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_FAST_FLOAT)], xmm6
-        movaps  XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_FAST_FLOAT)], xmm3
-        movaps  XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_FAST_FLOAT)], xmm0
-
-        movaps    xmm6,xmm5             ; transpose coefficients(phase 2)
-        unpcklps2 xmm5,xmm7             ; xmm5=(40 50 60 70)
-        unpckhps2 xmm6,xmm7             ; xmm6=(41 51 61 71)
-        movaps    xmm3,xmm4             ; transpose coefficients(phase 2)
-        unpcklps2 xmm4,xmm2             ; xmm4=(42 52 62 72)
-        unpckhps2 xmm3,xmm2             ; xmm3=(43 53 63 73)
-
-        movaps  XMMWORD [XMMBLOCK(0,1,rdi,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(1,1,rdi,SIZEOF_FAST_FLOAT)], xmm6
-        movaps  XMMWORD [XMMBLOCK(2,1,rdi,SIZEOF_FAST_FLOAT)], xmm4
-        movaps  XMMWORD [XMMBLOCK(3,1,rdi,SIZEOF_FAST_FLOAT)], xmm3
-
-.nextcolumn:
-        add     rsi, byte 4*SIZEOF_JCOEF                ; coef_block
-        add     rdx, byte 4*SIZEOF_FLOAT_MULT_TYPE      ; quantptr
-        add     rdi,      4*DCTSIZE*SIZEOF_FAST_FLOAT   ; wsptr
-        dec     rcx                                     ; ctr
-        jnz     near .columnloop
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 0*32]
-        prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 1*32]
-        prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 2*32]
-        prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows from work array, store into output array.
-
-        mov     rax, [original_rbp]
-        lea     rsi, [workspace]                        ; FAST_FLOAT *wsptr
-        mov     rdi, r12        ; (JSAMPROW *)
-        mov     eax, r13d
-        mov     rcx, DCTSIZE/4                          ; ctr
-.rowloop:
-
-        ; -- Even part
-
-        movaps  xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_FAST_FLOAT)]
-
-        movaps  xmm4,xmm0
-        movaps  xmm5,xmm1
-        subps   xmm0,xmm2               ; xmm0=tmp11
-        subps   xmm1,xmm3
-        addps   xmm4,xmm2               ; xmm4=tmp10
-        addps   xmm5,xmm3               ; xmm5=tmp13
-
-        mulps   xmm1,[rel PD_1_414]
-        subps   xmm1,xmm5               ; xmm1=tmp12
-
-        movaps  xmm6,xmm4
-        movaps  xmm7,xmm0
-        subps   xmm4,xmm5               ; xmm4=tmp3
-        subps   xmm0,xmm1               ; xmm0=tmp2
-        addps   xmm6,xmm5               ; xmm6=tmp0
-        addps   xmm7,xmm1               ; xmm7=tmp1
-
-        movaps  XMMWORD [wk(1)], xmm4   ; tmp3
-        movaps  XMMWORD [wk(0)], xmm0   ; tmp2
-
-        ; -- Odd part
-
-        movaps  xmm2, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm5, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_FAST_FLOAT)]
-
-        movaps  xmm4,xmm2
-        movaps  xmm0,xmm5
-        addps   xmm2,xmm1               ; xmm2=z11
-        addps   xmm5,xmm3               ; xmm5=z13
-        subps   xmm4,xmm1               ; xmm4=z12
-        subps   xmm0,xmm3               ; xmm0=z10
-
-        movaps  xmm1,xmm2
-        subps   xmm2,xmm5
-        addps   xmm1,xmm5               ; xmm1=tmp7
-
-        mulps   xmm2,[rel PD_1_414]     ; xmm2=tmp11
-
-        movaps  xmm3,xmm0
-        addps   xmm0,xmm4
-        mulps   xmm0,[rel PD_1_847]     ; xmm0=z5
-        mulps   xmm3,[rel PD_M2_613]    ; xmm3=(z10 * -2.613125930)
-        mulps   xmm4,[rel PD_1_082]     ; xmm4=(z12 * 1.082392200)
-        addps   xmm3,xmm0               ; xmm3=tmp12
-        subps   xmm4,xmm0               ; xmm4=tmp10
-
-        ; -- Final output stage
-
-        subps   xmm3,xmm1               ; xmm3=tmp6
-        movaps  xmm5,xmm6
-        movaps  xmm0,xmm7
-        addps   xmm6,xmm1               ; xmm6=data0=(00 10 20 30)
-        addps   xmm7,xmm3               ; xmm7=data1=(01 11 21 31)
-        subps   xmm5,xmm1               ; xmm5=data7=(07 17 27 37)
-        subps   xmm0,xmm3               ; xmm0=data6=(06 16 26 36)
-        subps   xmm2,xmm3               ; xmm2=tmp5
-
-        movaps  xmm1,[rel PD_RNDINT_MAGIC]      ; xmm1=[rel PD_RNDINT_MAGIC]
-        pcmpeqd xmm3,xmm3
-        psrld   xmm3,WORD_BIT           ; xmm3={0xFFFF 0x0000 0xFFFF 0x0000 ..}
-
-        addps   xmm6,xmm1       ; xmm6=roundint(data0/8)=(00 ** 10 ** 20 ** 30 **)
-        addps   xmm7,xmm1       ; xmm7=roundint(data1/8)=(01 ** 11 ** 21 ** 31 **)
-        addps   xmm0,xmm1       ; xmm0=roundint(data6/8)=(06 ** 16 ** 26 ** 36 **)
-        addps   xmm5,xmm1       ; xmm5=roundint(data7/8)=(07 ** 17 ** 27 ** 37 **)
-
-        pand    xmm6,xmm3               ; xmm6=(00 -- 10 -- 20 -- 30 --)
-        pslld   xmm7,WORD_BIT           ; xmm7=(-- 01 -- 11 -- 21 -- 31)
-        pand    xmm0,xmm3               ; xmm0=(06 -- 16 -- 26 -- 36 --)
-        pslld   xmm5,WORD_BIT           ; xmm5=(-- 07 -- 17 -- 27 -- 37)
-        por     xmm6,xmm7               ; xmm6=(00 01 10 11 20 21 30 31)
-        por     xmm0,xmm5               ; xmm0=(06 07 16 17 26 27 36 37)
-
-        movaps  xmm1, XMMWORD [wk(0)]   ; xmm1=tmp2
-        movaps  xmm3, XMMWORD [wk(1)]   ; xmm3=tmp3
-
-        addps   xmm4,xmm2               ; xmm4=tmp4
-        movaps  xmm7,xmm1
-        movaps  xmm5,xmm3
-        addps   xmm1,xmm2               ; xmm1=data2=(02 12 22 32)
-        addps   xmm3,xmm4               ; xmm3=data4=(04 14 24 34)
-        subps   xmm7,xmm2               ; xmm7=data5=(05 15 25 35)
-        subps   xmm5,xmm4               ; xmm5=data3=(03 13 23 33)
-
-        movaps  xmm2,[rel PD_RNDINT_MAGIC]      ; xmm2=[rel PD_RNDINT_MAGIC]
-        pcmpeqd xmm4,xmm4
-        psrld   xmm4,WORD_BIT           ; xmm4={0xFFFF 0x0000 0xFFFF 0x0000 ..}
-
-        addps   xmm3,xmm2       ; xmm3=roundint(data4/8)=(04 ** 14 ** 24 ** 34 **)
-        addps   xmm7,xmm2       ; xmm7=roundint(data5/8)=(05 ** 15 ** 25 ** 35 **)
-        addps   xmm1,xmm2       ; xmm1=roundint(data2/8)=(02 ** 12 ** 22 ** 32 **)
-        addps   xmm5,xmm2       ; xmm5=roundint(data3/8)=(03 ** 13 ** 23 ** 33 **)
-
-        pand    xmm3,xmm4               ; xmm3=(04 -- 14 -- 24 -- 34 --)
-        pslld   xmm7,WORD_BIT           ; xmm7=(-- 05 -- 15 -- 25 -- 35)
-        pand    xmm1,xmm4               ; xmm1=(02 -- 12 -- 22 -- 32 --)
-        pslld   xmm5,WORD_BIT           ; xmm5=(-- 03 -- 13 -- 23 -- 33)
-        por     xmm3,xmm7               ; xmm3=(04 05 14 15 24 25 34 35)
-        por     xmm1,xmm5               ; xmm1=(02 03 12 13 22 23 32 33)
-
-        movdqa    xmm2,[rel PB_CENTERJSAMP]     ; xmm2=[rel PB_CENTERJSAMP]
-
-        packsswb  xmm6,xmm3     ; xmm6=(00 01 10 11 20 21 30 31 04 05 14 15 24 25 34 35)
-        packsswb  xmm1,xmm0     ; xmm1=(02 03 12 13 22 23 32 33 06 07 16 17 26 27 36 37)
-        paddb     xmm6,xmm2
-        paddb     xmm1,xmm2
-
-        movdqa    xmm4,xmm6     ; transpose coefficients(phase 2)
-        punpcklwd xmm6,xmm1     ; xmm6=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
-        punpckhwd xmm4,xmm1     ; xmm4=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
-
-        movdqa    xmm7,xmm6     ; transpose coefficients(phase 3)
-        punpckldq xmm6,xmm4     ; xmm6=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
-        punpckhdq xmm7,xmm4     ; xmm7=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
-
-        pshufd  xmm5,xmm6,0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
-        pshufd  xmm3,xmm7,0x4E  ; xmm3=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
-
-        mov     rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
-        mov     rbx, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm6
-        movq    XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE], xmm7
-        mov     rdx, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
-        mov     rbx, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm5
-        movq    XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE], xmm3
-
-        add     rsi, byte 4*SIZEOF_FAST_FLOAT   ; wsptr
-        add     rdi, byte 4*SIZEOF_JSAMPROW
-        dec     rcx                             ; ctr
-        jnz     near .rowloop
-
-        pop     rbx
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctflt-sse2.asm b/simd/jidctflt-sse2.asm
deleted file mode 100644
index a15a9c1..0000000
--- a/simd/jidctflt-sse2.asm
+++ /dev/null
@@ -1,497 +0,0 @@
-;
-; jidctflt.asm - floating-point IDCT (SSE & SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a floating-point implementation of the inverse DCT
-; (Discrete Cosine Transform). The following code is based directly on
-; the IJG's original jidctflt.c; see the jidctflt.c for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%macro  unpcklps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
-        shufps  %1,%2,0x44
-%endmacro
-
-%macro  unpckhps2 2     ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
-        shufps  %1,%2,0xEE
-%endmacro
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_idct_float_sse2)
-
-EXTN(jconst_idct_float_sse2):
-
-PD_1_414        times 4 dd  1.414213562373095048801689
-PD_1_847        times 4 dd  1.847759065022573512256366
-PD_1_082        times 4 dd  1.082392200292393968799446
-PD_M2_613       times 4 dd -2.613125929752753055713286
-PD_RNDINT_MAGIC times 4 dd  100663296.0 ; (float)(0x00C00000 << 3)
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Perform dequantization and inverse DCT on one block of coefficients.
-;
-; GLOBAL(void)
-; jsimd_idct_float_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                        JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-%define dct_table(b)    (b)+8           ; void *dct_table
-%define coef_block(b)   (b)+12          ; JCOEFPTR coef_block
-%define output_buf(b)   (b)+16          ; JSAMPARRAY output_buf
-%define output_col(b)   (b)+20          ; JDIMENSION output_col
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-%define workspace       wk(0)-DCTSIZE2*SIZEOF_FAST_FLOAT
-                                        ; FAST_FLOAT workspace[DCTSIZE2]
-
-        align   16
-        global  EXTN(jsimd_idct_float_sse2)
-
-EXTN(jsimd_idct_float_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [workspace]
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process columns from input, store into work array.
-
-;       mov     eax, [original_ebp]
-        mov     edx, POINTER [dct_table(eax)]           ; quantptr
-        mov     esi, JCOEFPTR [coef_block(eax)]         ; inptr
-        lea     edi, [workspace]                        ; FAST_FLOAT *wsptr
-        mov     ecx, DCTSIZE/4                          ; ctr
-        alignx  16,7
-.columnloop:
-%ifndef NO_ZERO_COLUMN_TEST_FLOAT_SSE
-        mov     eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        jnz     near .columnDCT
-
-        movq    xmm1, XMM_MMWORD [MMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movq    xmm2, XMM_MMWORD [MMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        movq    xmm3, XMM_MMWORD [MMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        movq    xmm4, XMM_MMWORD [MMBLOCK(4,0,esi,SIZEOF_JCOEF)]
-        movq    xmm5, XMM_MMWORD [MMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        movq    xmm6, XMM_MMWORD [MMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-        movq    xmm7, XMM_MMWORD [MMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        por     xmm1,xmm2
-        por     xmm3,xmm4
-        por     xmm5,xmm6
-        por     xmm1,xmm3
-        por     xmm5,xmm7
-        por     xmm1,xmm5
-        packsswb xmm1,xmm1
-        movd    eax,xmm1
-        test    eax,eax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movq      xmm0, XMM_MMWORD [MMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-
-        punpcklwd xmm0,xmm0             ; xmm0=(00 00 01 01 02 02 03 03)
-        psrad     xmm0,(DWORD_BIT-WORD_BIT)     ; xmm0=in0=(00 01 02 03)
-        cvtdq2ps  xmm0,xmm0                     ; xmm0=in0=(00 01 02 03)
-
-        mulps   xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-
-        movaps  xmm1,xmm0
-        movaps  xmm2,xmm0
-        movaps  xmm3,xmm0
-
-        shufps  xmm0,xmm0,0x00                  ; xmm0=(00 00 00 00)
-        shufps  xmm1,xmm1,0x55                  ; xmm1=(01 01 01 01)
-        shufps  xmm2,xmm2,0xAA                  ; xmm2=(02 02 02 02)
-        shufps  xmm3,xmm3,0xFF                  ; xmm3=(03 03 03 03)
-
-        movaps  XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(0,1,edi,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(1,1,edi,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_FAST_FLOAT)], xmm2
-        movaps  XMMWORD [XMMBLOCK(2,1,edi,SIZEOF_FAST_FLOAT)], xmm2
-        movaps  XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_FAST_FLOAT)], xmm3
-        movaps  XMMWORD [XMMBLOCK(3,1,edi,SIZEOF_FAST_FLOAT)], xmm3
-        jmp     near .nextcolumn
-        alignx  16,7
-%endif
-.columnDCT:
-
-        ; -- Even part
-
-        movq      xmm0, XMM_MMWORD [MMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        movq      xmm1, XMM_MMWORD [MMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        movq      xmm2, XMM_MMWORD [MMBLOCK(4,0,esi,SIZEOF_JCOEF)]
-        movq      xmm3, XMM_MMWORD [MMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-
-        punpcklwd xmm0,xmm0             ; xmm0=(00 00 01 01 02 02 03 03)
-        punpcklwd xmm1,xmm1             ; xmm1=(20 20 21 21 22 22 23 23)
-        psrad     xmm0,(DWORD_BIT-WORD_BIT)     ; xmm0=in0=(00 01 02 03)
-        psrad     xmm1,(DWORD_BIT-WORD_BIT)     ; xmm1=in2=(20 21 22 23)
-        cvtdq2ps  xmm0,xmm0                     ; xmm0=in0=(00 01 02 03)
-        cvtdq2ps  xmm1,xmm1                     ; xmm1=in2=(20 21 22 23)
-
-        punpcklwd xmm2,xmm2             ; xmm2=(40 40 41 41 42 42 43 43)
-        punpcklwd xmm3,xmm3             ; xmm3=(60 60 61 61 62 62 63 63)
-        psrad     xmm2,(DWORD_BIT-WORD_BIT)     ; xmm2=in4=(40 41 42 43)
-        psrad     xmm3,(DWORD_BIT-WORD_BIT)     ; xmm3=in6=(60 61 62 63)
-        cvtdq2ps  xmm2,xmm2                     ; xmm2=in4=(40 41 42 43)
-        cvtdq2ps  xmm3,xmm3                     ; xmm3=in6=(60 61 62 63)
-
-        mulps     xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm1, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm2, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm3, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-
-        movaps  xmm4,xmm0
-        movaps  xmm5,xmm1
-        subps   xmm0,xmm2               ; xmm0=tmp11
-        subps   xmm1,xmm3
-        addps   xmm4,xmm2               ; xmm4=tmp10
-        addps   xmm5,xmm3               ; xmm5=tmp13
-
-        mulps   xmm1,[GOTOFF(ebx,PD_1_414)]
-        subps   xmm1,xmm5               ; xmm1=tmp12
-
-        movaps  xmm6,xmm4
-        movaps  xmm7,xmm0
-        subps   xmm4,xmm5               ; xmm4=tmp3
-        subps   xmm0,xmm1               ; xmm0=tmp2
-        addps   xmm6,xmm5               ; xmm6=tmp0
-        addps   xmm7,xmm1               ; xmm7=tmp1
-
-        movaps  XMMWORD [wk(1)], xmm4   ; tmp3
-        movaps  XMMWORD [wk(0)], xmm0   ; tmp2
-
-        ; -- Odd part
-
-        movq      xmm2, XMM_MMWORD [MMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movq      xmm3, XMM_MMWORD [MMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        movq      xmm5, XMM_MMWORD [MMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        movq      xmm1, XMM_MMWORD [MMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-
-        punpcklwd xmm2,xmm2             ; xmm2=(10 10 11 11 12 12 13 13)
-        punpcklwd xmm3,xmm3             ; xmm3=(30 30 31 31 32 32 33 33)
-        psrad     xmm2,(DWORD_BIT-WORD_BIT)     ; xmm2=in1=(10 11 12 13)
-        psrad     xmm3,(DWORD_BIT-WORD_BIT)     ; xmm3=in3=(30 31 32 33)
-        cvtdq2ps  xmm2,xmm2                     ; xmm2=in1=(10 11 12 13)
-        cvtdq2ps  xmm3,xmm3                     ; xmm3=in3=(30 31 32 33)
-
-        punpcklwd xmm5,xmm5             ; xmm5=(50 50 51 51 52 52 53 53)
-        punpcklwd xmm1,xmm1             ; xmm1=(70 70 71 71 72 72 73 73)
-        psrad     xmm5,(DWORD_BIT-WORD_BIT)     ; xmm5=in5=(50 51 52 53)
-        psrad     xmm1,(DWORD_BIT-WORD_BIT)     ; xmm1=in7=(70 71 72 73)
-        cvtdq2ps  xmm5,xmm5                     ; xmm5=in5=(50 51 52 53)
-        cvtdq2ps  xmm1,xmm1                     ; xmm1=in7=(70 71 72 73)
-
-        mulps     xmm2, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm5, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-        mulps     xmm1, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_FLOAT_MULT_TYPE)]
-
-        movaps  xmm4,xmm2
-        movaps  xmm0,xmm5
-        addps   xmm2,xmm1               ; xmm2=z11
-        addps   xmm5,xmm3               ; xmm5=z13
-        subps   xmm4,xmm1               ; xmm4=z12
-        subps   xmm0,xmm3               ; xmm0=z10
-
-        movaps  xmm1,xmm2
-        subps   xmm2,xmm5
-        addps   xmm1,xmm5               ; xmm1=tmp7
-
-        mulps   xmm2,[GOTOFF(ebx,PD_1_414)]     ; xmm2=tmp11
-
-        movaps  xmm3,xmm0
-        addps   xmm0,xmm4
-        mulps   xmm0,[GOTOFF(ebx,PD_1_847)]     ; xmm0=z5
-        mulps   xmm3,[GOTOFF(ebx,PD_M2_613)]    ; xmm3=(z10 * -2.613125930)
-        mulps   xmm4,[GOTOFF(ebx,PD_1_082)]     ; xmm4=(z12 * 1.082392200)
-        addps   xmm3,xmm0               ; xmm3=tmp12
-        subps   xmm4,xmm0               ; xmm4=tmp10
-
-        ; -- Final output stage
-
-        subps   xmm3,xmm1               ; xmm3=tmp6
-        movaps  xmm5,xmm6
-        movaps  xmm0,xmm7
-        addps   xmm6,xmm1               ; xmm6=data0=(00 01 02 03)
-        addps   xmm7,xmm3               ; xmm7=data1=(10 11 12 13)
-        subps   xmm5,xmm1               ; xmm5=data7=(70 71 72 73)
-        subps   xmm0,xmm3               ; xmm0=data6=(60 61 62 63)
-        subps   xmm2,xmm3               ; xmm2=tmp5
-
-        movaps    xmm1,xmm6             ; transpose coefficients(phase 1)
-        unpcklps  xmm6,xmm7             ; xmm6=(00 10 01 11)
-        unpckhps  xmm1,xmm7             ; xmm1=(02 12 03 13)
-        movaps    xmm3,xmm0             ; transpose coefficients(phase 1)
-        unpcklps  xmm0,xmm5             ; xmm0=(60 70 61 71)
-        unpckhps  xmm3,xmm5             ; xmm3=(62 72 63 73)
-
-        movaps  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
-        movaps  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp3
-
-        movaps  XMMWORD [wk(0)], xmm0   ; wk(0)=(60 70 61 71)
-        movaps  XMMWORD [wk(1)], xmm3   ; wk(1)=(62 72 63 73)
-
-        addps   xmm4,xmm2               ; xmm4=tmp4
-        movaps  xmm0,xmm7
-        movaps  xmm3,xmm5
-        addps   xmm7,xmm2               ; xmm7=data2=(20 21 22 23)
-        addps   xmm5,xmm4               ; xmm5=data4=(40 41 42 43)
-        subps   xmm0,xmm2               ; xmm0=data5=(50 51 52 53)
-        subps   xmm3,xmm4               ; xmm3=data3=(30 31 32 33)
-
-        movaps    xmm2,xmm7             ; transpose coefficients(phase 1)
-        unpcklps  xmm7,xmm3             ; xmm7=(20 30 21 31)
-        unpckhps  xmm2,xmm3             ; xmm2=(22 32 23 33)
-        movaps    xmm4,xmm5             ; transpose coefficients(phase 1)
-        unpcklps  xmm5,xmm0             ; xmm5=(40 50 41 51)
-        unpckhps  xmm4,xmm0             ; xmm4=(42 52 43 53)
-
-        movaps    xmm3,xmm6             ; transpose coefficients(phase 2)
-        unpcklps2 xmm6,xmm7             ; xmm6=(00 10 20 30)
-        unpckhps2 xmm3,xmm7             ; xmm3=(01 11 21 31)
-        movaps    xmm0,xmm1             ; transpose coefficients(phase 2)
-        unpcklps2 xmm1,xmm2             ; xmm1=(02 12 22 32)
-        unpckhps2 xmm0,xmm2             ; xmm0=(03 13 23 33)
-
-        movaps  xmm7, XMMWORD [wk(0)]   ; xmm7=(60 70 61 71)
-        movaps  xmm2, XMMWORD [wk(1)]   ; xmm2=(62 72 63 73)
-
-        movaps  XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_FAST_FLOAT)], xmm6
-        movaps  XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_FAST_FLOAT)], xmm3
-        movaps  XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_FAST_FLOAT)], xmm1
-        movaps  XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_FAST_FLOAT)], xmm0
-
-        movaps    xmm6,xmm5             ; transpose coefficients(phase 2)
-        unpcklps2 xmm5,xmm7             ; xmm5=(40 50 60 70)
-        unpckhps2 xmm6,xmm7             ; xmm6=(41 51 61 71)
-        movaps    xmm3,xmm4             ; transpose coefficients(phase 2)
-        unpcklps2 xmm4,xmm2             ; xmm4=(42 52 62 72)
-        unpckhps2 xmm3,xmm2             ; xmm3=(43 53 63 73)
-
-        movaps  XMMWORD [XMMBLOCK(0,1,edi,SIZEOF_FAST_FLOAT)], xmm5
-        movaps  XMMWORD [XMMBLOCK(1,1,edi,SIZEOF_FAST_FLOAT)], xmm6
-        movaps  XMMWORD [XMMBLOCK(2,1,edi,SIZEOF_FAST_FLOAT)], xmm4
-        movaps  XMMWORD [XMMBLOCK(3,1,edi,SIZEOF_FAST_FLOAT)], xmm3
-
-.nextcolumn:
-        add     esi, byte 4*SIZEOF_JCOEF                ; coef_block
-        add     edx, byte 4*SIZEOF_FLOAT_MULT_TYPE      ; quantptr
-        add     edi,      4*DCTSIZE*SIZEOF_FAST_FLOAT   ; wsptr
-        dec     ecx                                     ; ctr
-        jnz     near .columnloop
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 0*32]
-        prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 1*32]
-        prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 2*32]
-        prefetchnta [esi + (DCTSIZE2-8)*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows from work array, store into output array.
-
-        mov     eax, [original_ebp]
-        lea     esi, [workspace]                        ; FAST_FLOAT *wsptr
-        mov     edi, JSAMPARRAY [output_buf(eax)]       ; (JSAMPROW *)
-        mov     eax, JDIMENSION [output_col(eax)]
-        mov     ecx, DCTSIZE/4                          ; ctr
-        alignx  16,7
-.rowloop:
-
-        ; -- Even part
-
-        movaps  xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_FAST_FLOAT)]
-
-        movaps  xmm4,xmm0
-        movaps  xmm5,xmm1
-        subps   xmm0,xmm2               ; xmm0=tmp11
-        subps   xmm1,xmm3
-        addps   xmm4,xmm2               ; xmm4=tmp10
-        addps   xmm5,xmm3               ; xmm5=tmp13
-
-        mulps   xmm1,[GOTOFF(ebx,PD_1_414)]
-        subps   xmm1,xmm5               ; xmm1=tmp12
-
-        movaps  xmm6,xmm4
-        movaps  xmm7,xmm0
-        subps   xmm4,xmm5               ; xmm4=tmp3
-        subps   xmm0,xmm1               ; xmm0=tmp2
-        addps   xmm6,xmm5               ; xmm6=tmp0
-        addps   xmm7,xmm1               ; xmm7=tmp1
-
-        movaps  XMMWORD [wk(1)], xmm4   ; tmp3
-        movaps  XMMWORD [wk(0)], xmm0   ; tmp2
-
-        ; -- Odd part
-
-        movaps  xmm2, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm5, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_FAST_FLOAT)]
-
-        movaps  xmm4,xmm2
-        movaps  xmm0,xmm5
-        addps   xmm2,xmm1               ; xmm2=z11
-        addps   xmm5,xmm3               ; xmm5=z13
-        subps   xmm4,xmm1               ; xmm4=z12
-        subps   xmm0,xmm3               ; xmm0=z10
-
-        movaps  xmm1,xmm2
-        subps   xmm2,xmm5
-        addps   xmm1,xmm5               ; xmm1=tmp7
-
-        mulps   xmm2,[GOTOFF(ebx,PD_1_414)]     ; xmm2=tmp11
-
-        movaps  xmm3,xmm0
-        addps   xmm0,xmm4
-        mulps   xmm0,[GOTOFF(ebx,PD_1_847)]     ; xmm0=z5
-        mulps   xmm3,[GOTOFF(ebx,PD_M2_613)]    ; xmm3=(z10 * -2.613125930)
-        mulps   xmm4,[GOTOFF(ebx,PD_1_082)]     ; xmm4=(z12 * 1.082392200)
-        addps   xmm3,xmm0               ; xmm3=tmp12
-        subps   xmm4,xmm0               ; xmm4=tmp10
-
-        ; -- Final output stage
-
-        subps   xmm3,xmm1               ; xmm3=tmp6
-        movaps  xmm5,xmm6
-        movaps  xmm0,xmm7
-        addps   xmm6,xmm1               ; xmm6=data0=(00 10 20 30)
-        addps   xmm7,xmm3               ; xmm7=data1=(01 11 21 31)
-        subps   xmm5,xmm1               ; xmm5=data7=(07 17 27 37)
-        subps   xmm0,xmm3               ; xmm0=data6=(06 16 26 36)
-        subps   xmm2,xmm3               ; xmm2=tmp5
-
-        movaps  xmm1,[GOTOFF(ebx,PD_RNDINT_MAGIC)]      ; xmm1=[PD_RNDINT_MAGIC]
-        pcmpeqd xmm3,xmm3
-        psrld   xmm3,WORD_BIT           ; xmm3={0xFFFF 0x0000 0xFFFF 0x0000 ..}
-
-        addps   xmm6,xmm1       ; xmm6=roundint(data0/8)=(00 ** 10 ** 20 ** 30 **)
-        addps   xmm7,xmm1       ; xmm7=roundint(data1/8)=(01 ** 11 ** 21 ** 31 **)
-        addps   xmm0,xmm1       ; xmm0=roundint(data6/8)=(06 ** 16 ** 26 ** 36 **)
-        addps   xmm5,xmm1       ; xmm5=roundint(data7/8)=(07 ** 17 ** 27 ** 37 **)
-
-        pand    xmm6,xmm3               ; xmm6=(00 -- 10 -- 20 -- 30 --)
-        pslld   xmm7,WORD_BIT           ; xmm7=(-- 01 -- 11 -- 21 -- 31)
-        pand    xmm0,xmm3               ; xmm0=(06 -- 16 -- 26 -- 36 --)
-        pslld   xmm5,WORD_BIT           ; xmm5=(-- 07 -- 17 -- 27 -- 37)
-        por     xmm6,xmm7               ; xmm6=(00 01 10 11 20 21 30 31)
-        por     xmm0,xmm5               ; xmm0=(06 07 16 17 26 27 36 37)
-
-        movaps  xmm1, XMMWORD [wk(0)]   ; xmm1=tmp2
-        movaps  xmm3, XMMWORD [wk(1)]   ; xmm3=tmp3
-
-        addps   xmm4,xmm2               ; xmm4=tmp4
-        movaps  xmm7,xmm1
-        movaps  xmm5,xmm3
-        addps   xmm1,xmm2               ; xmm1=data2=(02 12 22 32)
-        addps   xmm3,xmm4               ; xmm3=data4=(04 14 24 34)
-        subps   xmm7,xmm2               ; xmm7=data5=(05 15 25 35)
-        subps   xmm5,xmm4               ; xmm5=data3=(03 13 23 33)
-
-        movaps  xmm2,[GOTOFF(ebx,PD_RNDINT_MAGIC)]      ; xmm2=[PD_RNDINT_MAGIC]
-        pcmpeqd xmm4,xmm4
-        psrld   xmm4,WORD_BIT           ; xmm4={0xFFFF 0x0000 0xFFFF 0x0000 ..}
-
-        addps   xmm3,xmm2       ; xmm3=roundint(data4/8)=(04 ** 14 ** 24 ** 34 **)
-        addps   xmm7,xmm2       ; xmm7=roundint(data5/8)=(05 ** 15 ** 25 ** 35 **)
-        addps   xmm1,xmm2       ; xmm1=roundint(data2/8)=(02 ** 12 ** 22 ** 32 **)
-        addps   xmm5,xmm2       ; xmm5=roundint(data3/8)=(03 ** 13 ** 23 ** 33 **)
-
-        pand    xmm3,xmm4               ; xmm3=(04 -- 14 -- 24 -- 34 --)
-        pslld   xmm7,WORD_BIT           ; xmm7=(-- 05 -- 15 -- 25 -- 35)
-        pand    xmm1,xmm4               ; xmm1=(02 -- 12 -- 22 -- 32 --)
-        pslld   xmm5,WORD_BIT           ; xmm5=(-- 03 -- 13 -- 23 -- 33)
-        por     xmm3,xmm7               ; xmm3=(04 05 14 15 24 25 34 35)
-        por     xmm1,xmm5               ; xmm1=(02 03 12 13 22 23 32 33)
-
-        movdqa    xmm2,[GOTOFF(ebx,PB_CENTERJSAMP)]     ; xmm2=[PB_CENTERJSAMP]
-
-        packsswb  xmm6,xmm3     ; xmm6=(00 01 10 11 20 21 30 31 04 05 14 15 24 25 34 35)
-        packsswb  xmm1,xmm0     ; xmm1=(02 03 12 13 22 23 32 33 06 07 16 17 26 27 36 37)
-        paddb     xmm6,xmm2
-        paddb     xmm1,xmm2
-
-        movdqa    xmm4,xmm6     ; transpose coefficients(phase 2)
-        punpcklwd xmm6,xmm1     ; xmm6=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
-        punpckhwd xmm4,xmm1     ; xmm4=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
-
-        movdqa    xmm7,xmm6     ; transpose coefficients(phase 3)
-        punpckldq xmm6,xmm4     ; xmm6=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
-        punpckhdq xmm7,xmm4     ; xmm7=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
-
-        pshufd  xmm5,xmm6,0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
-        pshufd  xmm3,xmm7,0x4E  ; xmm3=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
-
-        pushpic ebx                     ; save GOT address
-
-        mov     edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
-        mov     ebx, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm6
-        movq    XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE], xmm7
-        mov     edx, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
-        mov     ebx, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm5
-        movq    XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE], xmm3
-
-        poppic  ebx                     ; restore GOT address
-
-        add     esi, byte 4*SIZEOF_FAST_FLOAT   ; wsptr
-        add     edi, byte 4*SIZEOF_JSAMPROW
-        dec     ecx                             ; ctr
-        jnz     near .rowloop
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctfst-sse2-64.asm b/simd/jidctfst-sse2-64.asm
deleted file mode 100644
index 4884642..0000000
--- a/simd/jidctfst-sse2-64.asm
+++ /dev/null
@@ -1,491 +0,0 @@
-;
-; jidctfst.asm - fast integer IDCT (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a fast, not so accurate integer implementation of
-; the inverse DCT (Discrete Cosine Transform). The following code is
-; based directly on the IJG's original jidctfst.c; see the jidctfst.c
-; for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      8       ; 14 is also OK.
-%define PASS1_BITS      2
-
-%if IFAST_SCALE_BITS != PASS1_BITS
-%error "'IFAST_SCALE_BITS' must be equal to 'PASS1_BITS'."
-%endif
-
-%if CONST_BITS == 8
-F_1_082 equ     277             ; FIX(1.082392200)
-F_1_414 equ     362             ; FIX(1.414213562)
-F_1_847 equ     473             ; FIX(1.847759065)
-F_2_613 equ     669             ; FIX(2.613125930)
-F_1_613 equ     (F_2_613 - 256) ; FIX(2.613125930) - FIX(1)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_1_082 equ     DESCALE(1162209775,30-CONST_BITS)       ; FIX(1.082392200)
-F_1_414 equ     DESCALE(1518500249,30-CONST_BITS)       ; FIX(1.414213562)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_2_613 equ     DESCALE(2805822602,30-CONST_BITS)       ; FIX(2.613125930)
-F_1_613 equ     (F_2_613 - (1 << CONST_BITS))   ; FIX(2.613125930) - FIX(1)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
-; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
-
-%define PRE_MULTIPLY_SCALE_BITS   2
-%define CONST_SHIFT     (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
-
-        alignz  16
-        global  EXTN(jconst_idct_ifast_sse2)
-
-EXTN(jconst_idct_ifast_sse2):
-
-PW_F1414        times 8 dw  F_1_414 << CONST_SHIFT
-PW_F1847        times 8 dw  F_1_847 << CONST_SHIFT
-PW_MF1613       times 8 dw -F_1_613 << CONST_SHIFT
-PW_F1082        times 8 dw  F_1_082 << CONST_SHIFT
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Perform dequantization and inverse DCT on one block of coefficients.
-;
-; GLOBAL(void)
-; jsimd_idct_ifast_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                       JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-; r10 = jpeg_component_info *compptr
-; r11 = JCOEFPTR coef_block
-; r12 = JSAMPARRAY output_buf
-; r13 = JDIMENSION output_col
-
-%define original_rbp    rbp+0
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_idct_ifast_sse2)
-
-EXTN(jsimd_idct_ifast_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-
-        ; ---- Pass 1: process columns from input.
-
-        mov     rdx, r10                ; quantptr
-        mov     rsi, r11                ; inptr
-
-%ifndef NO_ZERO_COLUMN_TEST_IFAST_SSE2
-        mov     eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        jnz     near .columnDCT
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1,xmm0
-        packsswb xmm1,xmm1
-        packsswb xmm1,xmm1
-        movd    eax,xmm1
-        test    rax,rax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        movdqa    xmm7,xmm0             ; xmm0=in0=(00 01 02 03 04 05 06 07)
-        punpcklwd xmm0,xmm0             ; xmm0=(00 00 01 01 02 02 03 03)
-        punpckhwd xmm7,xmm7             ; xmm7=(04 04 05 05 06 06 07 07)
-
-        pshufd  xmm6,xmm0,0x00          ; xmm6=col0=(00 00 00 00 00 00 00 00)
-        pshufd  xmm2,xmm0,0x55          ; xmm2=col1=(01 01 01 01 01 01 01 01)
-        pshufd  xmm5,xmm0,0xAA          ; xmm5=col2=(02 02 02 02 02 02 02 02)
-        pshufd  xmm0,xmm0,0xFF          ; xmm0=col3=(03 03 03 03 03 03 03 03)
-        pshufd  xmm1,xmm7,0x00          ; xmm1=col4=(04 04 04 04 04 04 04 04)
-        pshufd  xmm4,xmm7,0x55          ; xmm4=col5=(05 05 05 05 05 05 05 05)
-        pshufd  xmm3,xmm7,0xAA          ; xmm3=col6=(06 06 06 06 06 06 06 06)
-        pshufd  xmm7,xmm7,0xFF          ; xmm7=col7=(07 07 07 07 07 07 07 07)
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=col1
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=col3
-        jmp     near .column_end
-%endif
-.columnDCT:
-
-        ; -- Even part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-
-        movdqa  xmm4,xmm0
-        movdqa  xmm5,xmm1
-        psubw   xmm0,xmm2               ; xmm0=tmp11
-        psubw   xmm1,xmm3
-        paddw   xmm4,xmm2               ; xmm4=tmp10
-        paddw   xmm5,xmm3               ; xmm5=tmp13
-
-        psllw   xmm1,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm1,[rel PW_F1414]
-        psubw   xmm1,xmm5               ; xmm1=tmp12
-
-        movdqa  xmm6,xmm4
-        movdqa  xmm7,xmm0
-        psubw   xmm4,xmm5               ; xmm4=tmp3
-        psubw   xmm0,xmm1               ; xmm0=tmp2
-        paddw   xmm6,xmm5               ; xmm6=tmp0
-        paddw   xmm7,xmm1               ; xmm7=tmp1
-
-        movdqa  XMMWORD [wk(1)], xmm4   ; wk(1)=tmp3
-        movdqa  XMMWORD [wk(0)], xmm0   ; wk(0)=tmp2
-
-        ; -- Odd part
-
-        movdqa  xmm2, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-        movdqa  xmm5, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm5, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
-
-        movdqa  xmm4,xmm2
-        movdqa  xmm0,xmm5
-        psubw   xmm2,xmm1               ; xmm2=z12
-        psubw   xmm5,xmm3               ; xmm5=z10
-        paddw   xmm4,xmm1               ; xmm4=z11
-        paddw   xmm0,xmm3               ; xmm0=z13
-
-        movdqa  xmm1,xmm5               ; xmm1=z10(unscaled)
-        psllw   xmm2,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-
-        movdqa  xmm3,xmm4
-        psubw   xmm4,xmm0
-        paddw   xmm3,xmm0               ; xmm3=tmp7
-
-        psllw   xmm4,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm4,[rel PW_F1414]     ; xmm4=tmp11
-
-        ; To avoid overflow...
-        ;
-        ; (Original)
-        ; tmp12 = -2.613125930 * z10 + z5;
-        ;
-        ; (This implementation)
-        ; tmp12 = (-1.613125930 - 1) * z10 + z5;
-        ;       = -1.613125930 * z10 - z10 + z5;
-
-        movdqa  xmm0,xmm5
-        paddw   xmm5,xmm2
-        pmulhw  xmm5,[rel PW_F1847]     ; xmm5=z5
-        pmulhw  xmm0,[rel PW_MF1613]
-        pmulhw  xmm2,[rel PW_F1082]
-        psubw   xmm0,xmm1
-        psubw   xmm2,xmm5               ; xmm2=tmp10
-        paddw   xmm0,xmm5               ; xmm0=tmp12
-
-        ; -- Final output stage
-
-        psubw   xmm0,xmm3               ; xmm0=tmp6
-        movdqa  xmm1,xmm6
-        movdqa  xmm5,xmm7
-        paddw   xmm6,xmm3               ; xmm6=data0=(00 01 02 03 04 05 06 07)
-        paddw   xmm7,xmm0               ; xmm7=data1=(10 11 12 13 14 15 16 17)
-        psubw   xmm1,xmm3               ; xmm1=data7=(70 71 72 73 74 75 76 77)
-        psubw   xmm5,xmm0               ; xmm5=data6=(60 61 62 63 64 65 66 67)
-        psubw   xmm4,xmm0               ; xmm4=tmp5
-
-        movdqa    xmm3,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm7             ; xmm6=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm3,xmm7             ; xmm3=(04 14 05 15 06 16 07 17)
-        movdqa    xmm0,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm1             ; xmm5=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm0,xmm1             ; xmm0=(64 74 65 75 66 76 67 77)
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
-        movdqa  xmm1, XMMWORD [wk(1)]   ; xmm1=tmp3
-
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=(60 70 61 71 62 72 63 73)
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=(64 74 65 75 66 76 67 77)
-
-        paddw   xmm2,xmm4               ; xmm2=tmp4
-        movdqa  xmm5,xmm7
-        movdqa  xmm0,xmm1
-        paddw   xmm7,xmm4               ; xmm7=data2=(20 21 22 23 24 25 26 27)
-        paddw   xmm1,xmm2               ; xmm1=data4=(40 41 42 43 44 45 46 47)
-        psubw   xmm5,xmm4               ; xmm5=data5=(50 51 52 53 54 55 56 57)
-        psubw   xmm0,xmm2               ; xmm0=data3=(30 31 32 33 34 35 36 37)
-
-        movdqa    xmm4,xmm7             ; transpose coefficients(phase 1)
-        punpcklwd xmm7,xmm0             ; xmm7=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm4,xmm0             ; xmm4=(24 34 25 35 26 36 27 37)
-        movdqa    xmm2,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm5             ; xmm1=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm2,xmm5             ; xmm2=(44 54 45 55 46 56 47 57)
-
-        movdqa    xmm0,xmm3             ; transpose coefficients(phase 2)
-        punpckldq xmm3,xmm4             ; xmm3=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm0,xmm4             ; xmm0=(06 16 26 36 07 17 27 37)
-        movdqa    xmm5,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm7             ; xmm6=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm5,xmm7             ; xmm5=(02 12 22 32 03 13 23 33)
-
-        movdqa  xmm4, XMMWORD [wk(0)]   ; xmm4=(60 70 61 71 62 72 63 73)
-        movdqa  xmm7, XMMWORD [wk(1)]   ; xmm7=(64 74 65 75 66 76 67 77)
-
-        movdqa  XMMWORD [wk(0)], xmm3   ; wk(0)=(04 14 24 34 05 15 25 35)
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=(06 16 26 36 07 17 27 37)
-
-        movdqa    xmm3,xmm1             ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm4             ; xmm1=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm3,xmm4             ; xmm3=(42 52 62 72 43 53 63 73)
-        movdqa    xmm0,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm7             ; xmm2=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm0,xmm7             ; xmm0=(46 56 66 76 47 57 67 77)
-
-        movdqa     xmm4,xmm6            ; transpose coefficients(phase 3)
-        punpcklqdq xmm6,xmm1            ; xmm6=col0=(00 10 20 30 40 50 60 70)
-        punpckhqdq xmm4,xmm1            ; xmm4=col1=(01 11 21 31 41 51 61 71)
-        movdqa     xmm7,xmm5            ; transpose coefficients(phase 3)
-        punpcklqdq xmm5,xmm3            ; xmm5=col2=(02 12 22 32 42 52 62 72)
-        punpckhqdq xmm7,xmm3            ; xmm7=col3=(03 13 23 33 43 53 63 73)
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=(04 14 24 34 05 15 25 35)
-        movdqa  xmm3, XMMWORD [wk(1)]   ; xmm3=(06 16 26 36 07 17 27 37)
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=col1
-        movdqa  XMMWORD [wk(1)], xmm7   ; wk(1)=col3
-
-        movdqa     xmm4,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm2            ; xmm1=col4=(04 14 24 34 44 54 64 74)
-        punpckhqdq xmm4,xmm2            ; xmm4=col5=(05 15 25 35 45 55 65 75)
-        movdqa     xmm7,xmm3            ; transpose coefficients(phase 3)
-        punpcklqdq xmm3,xmm0            ; xmm3=col6=(06 16 26 36 46 56 66 76)
-        punpckhqdq xmm7,xmm0            ; xmm7=col7=(07 17 27 37 47 57 67 77)
-.column_end:
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows from work array, store into output array.
-
-        mov     rax, [original_rbp]
-        mov     rdi, r12        ; (JSAMPROW *)
-        mov     eax, r13d
-
-        ; -- Even part
-
-        ; xmm6=col0, xmm5=col2, xmm1=col4, xmm3=col6
-
-        movdqa  xmm2,xmm6
-        movdqa  xmm0,xmm5
-        psubw   xmm6,xmm1               ; xmm6=tmp11
-        psubw   xmm5,xmm3
-        paddw   xmm2,xmm1               ; xmm2=tmp10
-        paddw   xmm0,xmm3               ; xmm0=tmp13
-
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm5,[rel PW_F1414]
-        psubw   xmm5,xmm0               ; xmm5=tmp12
-
-        movdqa  xmm1,xmm2
-        movdqa  xmm3,xmm6
-        psubw   xmm2,xmm0               ; xmm2=tmp3
-        psubw   xmm6,xmm5               ; xmm6=tmp2
-        paddw   xmm1,xmm0               ; xmm1=tmp0
-        paddw   xmm3,xmm5               ; xmm3=tmp1
-
-        movdqa  xmm0, XMMWORD [wk(0)]   ; xmm0=col1
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=col3
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=tmp3
-        movdqa  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp2
-
-        ; -- Odd part
-
-        ; xmm0=col1, xmm5=col3, xmm4=col5, xmm7=col7
-
-        movdqa  xmm2,xmm0
-        movdqa  xmm6,xmm4
-        psubw   xmm0,xmm7               ; xmm0=z12
-        psubw   xmm4,xmm5               ; xmm4=z10
-        paddw   xmm2,xmm7               ; xmm2=z11
-        paddw   xmm6,xmm5               ; xmm6=z13
-
-        movdqa  xmm7,xmm4               ; xmm7=z10(unscaled)
-        psllw   xmm0,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm4,PRE_MULTIPLY_SCALE_BITS
-
-        movdqa  xmm5,xmm2
-        psubw   xmm2,xmm6
-        paddw   xmm5,xmm6               ; xmm5=tmp7
-
-        psllw   xmm2,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm2,[rel PW_F1414]     ; xmm2=tmp11
-
-        ; To avoid overflow...
-        ;
-        ; (Original)
-        ; tmp12 = -2.613125930 * z10 + z5;
-        ;
-        ; (This implementation)
-        ; tmp12 = (-1.613125930 - 1) * z10 + z5;
-        ;       = -1.613125930 * z10 - z10 + z5;
-
-        movdqa  xmm6,xmm4
-        paddw   xmm4,xmm0
-        pmulhw  xmm4,[rel PW_F1847]     ; xmm4=z5
-        pmulhw  xmm6,[rel PW_MF1613]
-        pmulhw  xmm0,[rel PW_F1082]
-        psubw   xmm6,xmm7
-        psubw   xmm0,xmm4               ; xmm0=tmp10
-        paddw   xmm6,xmm4               ; xmm6=tmp12
-
-        ; -- Final output stage
-
-        psubw   xmm6,xmm5               ; xmm6=tmp6
-        movdqa  xmm7,xmm1
-        movdqa  xmm4,xmm3
-        paddw   xmm1,xmm5               ; xmm1=data0=(00 10 20 30 40 50 60 70)
-        paddw   xmm3,xmm6               ; xmm3=data1=(01 11 21 31 41 51 61 71)
-        psraw   xmm1,(PASS1_BITS+3)     ; descale
-        psraw   xmm3,(PASS1_BITS+3)     ; descale
-        psubw   xmm7,xmm5               ; xmm7=data7=(07 17 27 37 47 57 67 77)
-        psubw   xmm4,xmm6               ; xmm4=data6=(06 16 26 36 46 56 66 76)
-        psraw   xmm7,(PASS1_BITS+3)     ; descale
-        psraw   xmm4,(PASS1_BITS+3)     ; descale
-        psubw   xmm2,xmm6               ; xmm2=tmp5
-
-        packsswb  xmm1,xmm4     ; xmm1=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        packsswb  xmm3,xmm7     ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp2
-        movdqa  xmm6, XMMWORD [wk(0)]   ; xmm6=tmp3
-
-        paddw   xmm0,xmm2               ; xmm0=tmp4
-        movdqa  xmm4,xmm5
-        movdqa  xmm7,xmm6
-        paddw   xmm5,xmm2               ; xmm5=data2=(02 12 22 32 42 52 62 72)
-        paddw   xmm6,xmm0               ; xmm6=data4=(04 14 24 34 44 54 64 74)
-        psraw   xmm5,(PASS1_BITS+3)     ; descale
-        psraw   xmm6,(PASS1_BITS+3)     ; descale
-        psubw   xmm4,xmm2               ; xmm4=data5=(05 15 25 35 45 55 65 75)
-        psubw   xmm7,xmm0               ; xmm7=data3=(03 13 23 33 43 53 63 73)
-        psraw   xmm4,(PASS1_BITS+3)     ; descale
-        psraw   xmm7,(PASS1_BITS+3)     ; descale
-
-        movdqa    xmm2,[rel PB_CENTERJSAMP]     ; xmm2=[rel PB_CENTERJSAMP]
-
-        packsswb  xmm5,xmm6     ; xmm5=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
-        packsswb  xmm7,xmm4     ; xmm7=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
-
-        paddb     xmm1,xmm2
-        paddb     xmm3,xmm2
-        paddb     xmm5,xmm2
-        paddb     xmm7,xmm2
-
-        movdqa    xmm0,xmm1     ; transpose coefficients(phase 1)
-        punpcklbw xmm1,xmm3     ; xmm1=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
-        punpckhbw xmm0,xmm3     ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
-        movdqa    xmm6,xmm5     ; transpose coefficients(phase 1)
-        punpcklbw xmm5,xmm7     ; xmm5=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
-        punpckhbw xmm6,xmm7     ; xmm6=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
-
-        movdqa    xmm4,xmm1     ; transpose coefficients(phase 2)
-        punpcklwd xmm1,xmm5     ; xmm1=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
-        punpckhwd xmm4,xmm5     ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
-        movdqa    xmm2,xmm6     ; transpose coefficients(phase 2)
-        punpcklwd xmm6,xmm0     ; xmm6=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
-        punpckhwd xmm2,xmm0     ; xmm2=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
-
-        movdqa    xmm3,xmm1     ; transpose coefficients(phase 3)
-        punpckldq xmm1,xmm6     ; xmm1=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
-        punpckhdq xmm3,xmm6     ; xmm3=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
-        movdqa    xmm7,xmm4     ; transpose coefficients(phase 3)
-        punpckldq xmm4,xmm2     ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
-        punpckhdq xmm7,xmm2     ; xmm7=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
-
-        pshufd  xmm5,xmm1,0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
-        pshufd  xmm0,xmm3,0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
-        pshufd  xmm6,xmm4,0x4E  ; xmm6=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
-        pshufd  xmm2,xmm7,0x4E  ; xmm2=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
-
-        mov     rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm1
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm3
-        mov     rdx, JSAMPROW [rdi+4*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+6*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm4
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm7
-
-        mov     rdx, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm5
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm0
-        mov     rdx, JSAMPROW [rdi+5*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+7*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm6
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm2
-
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctfst-sse2.asm b/simd/jidctfst-sse2.asm
deleted file mode 100644
index f591e55..0000000
--- a/simd/jidctfst-sse2.asm
+++ /dev/null
@@ -1,501 +0,0 @@
-;
-; jidctfst.asm - fast integer IDCT (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a fast, not so accurate integer implementation of
-; the inverse DCT (Discrete Cosine Transform). The following code is
-; based directly on the IJG's original jidctfst.c; see the jidctfst.c
-; for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      8       ; 14 is also OK.
-%define PASS1_BITS      2
-
-%if IFAST_SCALE_BITS != PASS1_BITS
-%error "'IFAST_SCALE_BITS' must be equal to 'PASS1_BITS'."
-%endif
-
-%if CONST_BITS == 8
-F_1_082 equ     277             ; FIX(1.082392200)
-F_1_414 equ     362             ; FIX(1.414213562)
-F_1_847 equ     473             ; FIX(1.847759065)
-F_2_613 equ     669             ; FIX(2.613125930)
-F_1_613 equ     (F_2_613 - 256) ; FIX(2.613125930) - FIX(1)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_1_082 equ     DESCALE(1162209775,30-CONST_BITS)       ; FIX(1.082392200)
-F_1_414 equ     DESCALE(1518500249,30-CONST_BITS)       ; FIX(1.414213562)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_2_613 equ     DESCALE(2805822602,30-CONST_BITS)       ; FIX(2.613125930)
-F_1_613 equ     (F_2_613 - (1 << CONST_BITS))   ; FIX(2.613125930) - FIX(1)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
-; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
-
-%define PRE_MULTIPLY_SCALE_BITS   2
-%define CONST_SHIFT     (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
-
-        alignz  16
-        global  EXTN(jconst_idct_ifast_sse2)
-
-EXTN(jconst_idct_ifast_sse2):
-
-PW_F1414        times 8 dw  F_1_414 << CONST_SHIFT
-PW_F1847        times 8 dw  F_1_847 << CONST_SHIFT
-PW_MF1613       times 8 dw -F_1_613 << CONST_SHIFT
-PW_F1082        times 8 dw  F_1_082 << CONST_SHIFT
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Perform dequantization and inverse DCT on one block of coefficients.
-;
-; GLOBAL(void)
-; jsimd_idct_ifast_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                       JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-%define dct_table(b)    (b)+8           ; jpeg_component_info *compptr
-%define coef_block(b)   (b)+12          ; JCOEFPTR coef_block
-%define output_buf(b)   (b)+16          ; JSAMPARRAY output_buf
-%define output_col(b)   (b)+20          ; JDIMENSION output_col
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_idct_ifast_sse2)
-
-EXTN(jsimd_idct_ifast_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic ebx
-;       push    ecx             ; unused
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process columns from input.
-
-;       mov     eax, [original_ebp]
-        mov     edx, POINTER [dct_table(eax)]           ; quantptr
-        mov     esi, JCOEFPTR [coef_block(eax)]         ; inptr
-
-%ifndef NO_ZERO_COLUMN_TEST_IFAST_SSE2
-        mov     eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        jnz     near .columnDCT
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        por     xmm1,xmm0
-        packsswb xmm1,xmm1
-        packsswb xmm1,xmm1
-        movd    eax,xmm1
-        test    eax,eax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        movdqa    xmm7,xmm0             ; xmm0=in0=(00 01 02 03 04 05 06 07)
-        punpcklwd xmm0,xmm0             ; xmm0=(00 00 01 01 02 02 03 03)
-        punpckhwd xmm7,xmm7             ; xmm7=(04 04 05 05 06 06 07 07)
-
-        pshufd  xmm6,xmm0,0x00          ; xmm6=col0=(00 00 00 00 00 00 00 00)
-        pshufd  xmm2,xmm0,0x55          ; xmm2=col1=(01 01 01 01 01 01 01 01)
-        pshufd  xmm5,xmm0,0xAA          ; xmm5=col2=(02 02 02 02 02 02 02 02)
-        pshufd  xmm0,xmm0,0xFF          ; xmm0=col3=(03 03 03 03 03 03 03 03)
-        pshufd  xmm1,xmm7,0x00          ; xmm1=col4=(04 04 04 04 04 04 04 04)
-        pshufd  xmm4,xmm7,0x55          ; xmm4=col5=(05 05 05 05 05 05 05 05)
-        pshufd  xmm3,xmm7,0xAA          ; xmm3=col6=(06 06 06 06 06 06 06 06)
-        pshufd  xmm7,xmm7,0xFF          ; xmm7=col7=(07 07 07 07 07 07 07 07)
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=col1
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=col3
-        jmp     near .column_end
-        alignx  16,7
-%endif
-.columnDCT:
-
-        ; -- Even part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-
-        movdqa  xmm4,xmm0
-        movdqa  xmm5,xmm1
-        psubw   xmm0,xmm2               ; xmm0=tmp11
-        psubw   xmm1,xmm3
-        paddw   xmm4,xmm2               ; xmm4=tmp10
-        paddw   xmm5,xmm3               ; xmm5=tmp13
-
-        psllw   xmm1,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm1,[GOTOFF(ebx,PW_F1414)]
-        psubw   xmm1,xmm5               ; xmm1=tmp12
-
-        movdqa  xmm6,xmm4
-        movdqa  xmm7,xmm0
-        psubw   xmm4,xmm5               ; xmm4=tmp3
-        psubw   xmm0,xmm1               ; xmm0=tmp2
-        paddw   xmm6,xmm5               ; xmm6=tmp0
-        paddw   xmm7,xmm1               ; xmm7=tmp1
-
-        movdqa  XMMWORD [wk(1)], xmm4   ; wk(1)=tmp3
-        movdqa  XMMWORD [wk(0)], xmm0   ; wk(0)=tmp2
-
-        ; -- Odd part
-
-        movdqa  xmm2, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-        movdqa  xmm5, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm5, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_IFAST_MULT_TYPE)]
-
-        movdqa  xmm4,xmm2
-        movdqa  xmm0,xmm5
-        psubw   xmm2,xmm1               ; xmm2=z12
-        psubw   xmm5,xmm3               ; xmm5=z10
-        paddw   xmm4,xmm1               ; xmm4=z11
-        paddw   xmm0,xmm3               ; xmm0=z13
-
-        movdqa  xmm1,xmm5               ; xmm1=z10(unscaled)
-        psllw   xmm2,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-
-        movdqa  xmm3,xmm4
-        psubw   xmm4,xmm0
-        paddw   xmm3,xmm0               ; xmm3=tmp7
-
-        psllw   xmm4,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm4,[GOTOFF(ebx,PW_F1414)]     ; xmm4=tmp11
-
-        ; To avoid overflow...
-        ;
-        ; (Original)
-        ; tmp12 = -2.613125930 * z10 + z5;
-        ;
-        ; (This implementation)
-        ; tmp12 = (-1.613125930 - 1) * z10 + z5;
-        ;       = -1.613125930 * z10 - z10 + z5;
-
-        movdqa  xmm0,xmm5
-        paddw   xmm5,xmm2
-        pmulhw  xmm5,[GOTOFF(ebx,PW_F1847)]     ; xmm5=z5
-        pmulhw  xmm0,[GOTOFF(ebx,PW_MF1613)]
-        pmulhw  xmm2,[GOTOFF(ebx,PW_F1082)]
-        psubw   xmm0,xmm1
-        psubw   xmm2,xmm5               ; xmm2=tmp10
-        paddw   xmm0,xmm5               ; xmm0=tmp12
-
-        ; -- Final output stage
-
-        psubw   xmm0,xmm3               ; xmm0=tmp6
-        movdqa  xmm1,xmm6
-        movdqa  xmm5,xmm7
-        paddw   xmm6,xmm3               ; xmm6=data0=(00 01 02 03 04 05 06 07)
-        paddw   xmm7,xmm0               ; xmm7=data1=(10 11 12 13 14 15 16 17)
-        psubw   xmm1,xmm3               ; xmm1=data7=(70 71 72 73 74 75 76 77)
-        psubw   xmm5,xmm0               ; xmm5=data6=(60 61 62 63 64 65 66 67)
-        psubw   xmm4,xmm0               ; xmm4=tmp5
-
-        movdqa    xmm3,xmm6             ; transpose coefficients(phase 1)
-        punpcklwd xmm6,xmm7             ; xmm6=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm3,xmm7             ; xmm3=(04 14 05 15 06 16 07 17)
-        movdqa    xmm0,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm1             ; xmm5=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm0,xmm1             ; xmm0=(64 74 65 75 66 76 67 77)
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
-        movdqa  xmm1, XMMWORD [wk(1)]   ; xmm1=tmp3
-
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=(60 70 61 71 62 72 63 73)
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=(64 74 65 75 66 76 67 77)
-
-        paddw   xmm2,xmm4               ; xmm2=tmp4
-        movdqa  xmm5,xmm7
-        movdqa  xmm0,xmm1
-        paddw   xmm7,xmm4               ; xmm7=data2=(20 21 22 23 24 25 26 27)
-        paddw   xmm1,xmm2               ; xmm1=data4=(40 41 42 43 44 45 46 47)
-        psubw   xmm5,xmm4               ; xmm5=data5=(50 51 52 53 54 55 56 57)
-        psubw   xmm0,xmm2               ; xmm0=data3=(30 31 32 33 34 35 36 37)
-
-        movdqa    xmm4,xmm7             ; transpose coefficients(phase 1)
-        punpcklwd xmm7,xmm0             ; xmm7=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm4,xmm0             ; xmm4=(24 34 25 35 26 36 27 37)
-        movdqa    xmm2,xmm1             ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm5             ; xmm1=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm2,xmm5             ; xmm2=(44 54 45 55 46 56 47 57)
-
-        movdqa    xmm0,xmm3             ; transpose coefficients(phase 2)
-        punpckldq xmm3,xmm4             ; xmm3=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm0,xmm4             ; xmm0=(06 16 26 36 07 17 27 37)
-        movdqa    xmm5,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm7             ; xmm6=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm5,xmm7             ; xmm5=(02 12 22 32 03 13 23 33)
-
-        movdqa  xmm4, XMMWORD [wk(0)]   ; xmm4=(60 70 61 71 62 72 63 73)
-        movdqa  xmm7, XMMWORD [wk(1)]   ; xmm7=(64 74 65 75 66 76 67 77)
-
-        movdqa  XMMWORD [wk(0)], xmm3   ; wk(0)=(04 14 24 34 05 15 25 35)
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=(06 16 26 36 07 17 27 37)
-
-        movdqa    xmm3,xmm1             ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm4             ; xmm1=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm3,xmm4             ; xmm3=(42 52 62 72 43 53 63 73)
-        movdqa    xmm0,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm7             ; xmm2=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm0,xmm7             ; xmm0=(46 56 66 76 47 57 67 77)
-
-        movdqa     xmm4,xmm6            ; transpose coefficients(phase 3)
-        punpcklqdq xmm6,xmm1            ; xmm6=col0=(00 10 20 30 40 50 60 70)
-        punpckhqdq xmm4,xmm1            ; xmm4=col1=(01 11 21 31 41 51 61 71)
-        movdqa     xmm7,xmm5            ; transpose coefficients(phase 3)
-        punpcklqdq xmm5,xmm3            ; xmm5=col2=(02 12 22 32 42 52 62 72)
-        punpckhqdq xmm7,xmm3            ; xmm7=col3=(03 13 23 33 43 53 63 73)
-
-        movdqa  xmm1, XMMWORD [wk(0)]   ; xmm1=(04 14 24 34 05 15 25 35)
-        movdqa  xmm3, XMMWORD [wk(1)]   ; xmm3=(06 16 26 36 07 17 27 37)
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=col1
-        movdqa  XMMWORD [wk(1)], xmm7   ; wk(1)=col3
-
-        movdqa     xmm4,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm2            ; xmm1=col4=(04 14 24 34 44 54 64 74)
-        punpckhqdq xmm4,xmm2            ; xmm4=col5=(05 15 25 35 45 55 65 75)
-        movdqa     xmm7,xmm3            ; transpose coefficients(phase 3)
-        punpcklqdq xmm3,xmm0            ; xmm3=col6=(06 16 26 36 46 56 66 76)
-        punpckhqdq xmm7,xmm0            ; xmm7=col7=(07 17 27 37 47 57 67 77)
-.column_end:
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows from work array, store into output array.
-
-        mov     eax, [original_ebp]
-        mov     edi, JSAMPARRAY [output_buf(eax)]       ; (JSAMPROW *)
-        mov     eax, JDIMENSION [output_col(eax)]
-
-        ; -- Even part
-
-        ; xmm6=col0, xmm5=col2, xmm1=col4, xmm3=col6
-
-        movdqa  xmm2,xmm6
-        movdqa  xmm0,xmm5
-        psubw   xmm6,xmm1               ; xmm6=tmp11
-        psubw   xmm5,xmm3
-        paddw   xmm2,xmm1               ; xmm2=tmp10
-        paddw   xmm0,xmm3               ; xmm0=tmp13
-
-        psllw   xmm5,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm5,[GOTOFF(ebx,PW_F1414)]
-        psubw   xmm5,xmm0               ; xmm5=tmp12
-
-        movdqa  xmm1,xmm2
-        movdqa  xmm3,xmm6
-        psubw   xmm2,xmm0               ; xmm2=tmp3
-        psubw   xmm6,xmm5               ; xmm6=tmp2
-        paddw   xmm1,xmm0               ; xmm1=tmp0
-        paddw   xmm3,xmm5               ; xmm3=tmp1
-
-        movdqa  xmm0, XMMWORD [wk(0)]   ; xmm0=col1
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=col3
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=tmp3
-        movdqa  XMMWORD [wk(1)], xmm6   ; wk(1)=tmp2
-
-        ; -- Odd part
-
-        ; xmm0=col1, xmm5=col3, xmm4=col5, xmm7=col7
-
-        movdqa  xmm2,xmm0
-        movdqa  xmm6,xmm4
-        psubw   xmm0,xmm7               ; xmm0=z12
-        psubw   xmm4,xmm5               ; xmm4=z10
-        paddw   xmm2,xmm7               ; xmm2=z11
-        paddw   xmm6,xmm5               ; xmm6=z13
-
-        movdqa  xmm7,xmm4               ; xmm7=z10(unscaled)
-        psllw   xmm0,PRE_MULTIPLY_SCALE_BITS
-        psllw   xmm4,PRE_MULTIPLY_SCALE_BITS
-
-        movdqa  xmm5,xmm2
-        psubw   xmm2,xmm6
-        paddw   xmm5,xmm6               ; xmm5=tmp7
-
-        psllw   xmm2,PRE_MULTIPLY_SCALE_BITS
-        pmulhw  xmm2,[GOTOFF(ebx,PW_F1414)]     ; xmm2=tmp11
-
-        ; To avoid overflow...
-        ;
-        ; (Original)
-        ; tmp12 = -2.613125930 * z10 + z5;
-        ;
-        ; (This implementation)
-        ; tmp12 = (-1.613125930 - 1) * z10 + z5;
-        ;       = -1.613125930 * z10 - z10 + z5;
-
-        movdqa  xmm6,xmm4
-        paddw   xmm4,xmm0
-        pmulhw  xmm4,[GOTOFF(ebx,PW_F1847)]     ; xmm4=z5
-        pmulhw  xmm6,[GOTOFF(ebx,PW_MF1613)]
-        pmulhw  xmm0,[GOTOFF(ebx,PW_F1082)]
-        psubw   xmm6,xmm7
-        psubw   xmm0,xmm4               ; xmm0=tmp10
-        paddw   xmm6,xmm4               ; xmm6=tmp12
-
-        ; -- Final output stage
-
-        psubw   xmm6,xmm5               ; xmm6=tmp6
-        movdqa  xmm7,xmm1
-        movdqa  xmm4,xmm3
-        paddw   xmm1,xmm5               ; xmm1=data0=(00 10 20 30 40 50 60 70)
-        paddw   xmm3,xmm6               ; xmm3=data1=(01 11 21 31 41 51 61 71)
-        psraw   xmm1,(PASS1_BITS+3)     ; descale
-        psraw   xmm3,(PASS1_BITS+3)     ; descale
-        psubw   xmm7,xmm5               ; xmm7=data7=(07 17 27 37 47 57 67 77)
-        psubw   xmm4,xmm6               ; xmm4=data6=(06 16 26 36 46 56 66 76)
-        psraw   xmm7,(PASS1_BITS+3)     ; descale
-        psraw   xmm4,(PASS1_BITS+3)     ; descale
-        psubw   xmm2,xmm6               ; xmm2=tmp5
-
-        packsswb  xmm1,xmm4     ; xmm1=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        packsswb  xmm3,xmm7     ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        movdqa  xmm5, XMMWORD [wk(1)]   ; xmm5=tmp2
-        movdqa  xmm6, XMMWORD [wk(0)]   ; xmm6=tmp3
-
-        paddw   xmm0,xmm2               ; xmm0=tmp4
-        movdqa  xmm4,xmm5
-        movdqa  xmm7,xmm6
-        paddw   xmm5,xmm2               ; xmm5=data2=(02 12 22 32 42 52 62 72)
-        paddw   xmm6,xmm0               ; xmm6=data4=(04 14 24 34 44 54 64 74)
-        psraw   xmm5,(PASS1_BITS+3)     ; descale
-        psraw   xmm6,(PASS1_BITS+3)     ; descale
-        psubw   xmm4,xmm2               ; xmm4=data5=(05 15 25 35 45 55 65 75)
-        psubw   xmm7,xmm0               ; xmm7=data3=(03 13 23 33 43 53 63 73)
-        psraw   xmm4,(PASS1_BITS+3)     ; descale
-        psraw   xmm7,(PASS1_BITS+3)     ; descale
-
-        movdqa    xmm2,[GOTOFF(ebx,PB_CENTERJSAMP)]     ; xmm2=[PB_CENTERJSAMP]
-
-        packsswb  xmm5,xmm6     ; xmm5=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
-        packsswb  xmm7,xmm4     ; xmm7=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
-
-        paddb     xmm1,xmm2
-        paddb     xmm3,xmm2
-        paddb     xmm5,xmm2
-        paddb     xmm7,xmm2
-
-        movdqa    xmm0,xmm1     ; transpose coefficients(phase 1)
-        punpcklbw xmm1,xmm3     ; xmm1=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
-        punpckhbw xmm0,xmm3     ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
-        movdqa    xmm6,xmm5     ; transpose coefficients(phase 1)
-        punpcklbw xmm5,xmm7     ; xmm5=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
-        punpckhbw xmm6,xmm7     ; xmm6=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
-
-        movdqa    xmm4,xmm1     ; transpose coefficients(phase 2)
-        punpcklwd xmm1,xmm5     ; xmm1=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
-        punpckhwd xmm4,xmm5     ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
-        movdqa    xmm2,xmm6     ; transpose coefficients(phase 2)
-        punpcklwd xmm6,xmm0     ; xmm6=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
-        punpckhwd xmm2,xmm0     ; xmm2=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
-
-        movdqa    xmm3,xmm1     ; transpose coefficients(phase 3)
-        punpckldq xmm1,xmm6     ; xmm1=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
-        punpckhdq xmm3,xmm6     ; xmm3=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
-        movdqa    xmm7,xmm4     ; transpose coefficients(phase 3)
-        punpckldq xmm4,xmm2     ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
-        punpckhdq xmm7,xmm2     ; xmm7=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
-
-        pshufd  xmm5,xmm1,0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
-        pshufd  xmm0,xmm3,0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
-        pshufd  xmm6,xmm4,0x4E  ; xmm6=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
-        pshufd  xmm2,xmm7,0x4E  ; xmm2=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
-
-        mov     edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm1
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm3
-        mov     edx, JSAMPROW [edi+4*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+6*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm4
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm7
-
-        mov     edx, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm5
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm0
-        mov     edx, JSAMPROW [edi+5*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+7*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm6
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm2
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; unused
-        poppic  ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctint-sse2-64.asm b/simd/jidctint-sse2-64.asm
deleted file mode 100644
index afe1d6a..0000000
--- a/simd/jidctint-sse2-64.asm
+++ /dev/null
@@ -1,847 +0,0 @@
-;
-; jidctint.asm - accurate integer IDCT (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a slow-but-accurate integer implementation of the
-; inverse DCT (Discrete Cosine Transform). The following code is based
-; directly on the IJG's original jidctint.c; see the jidctint.c for
-; more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      13
-%define PASS1_BITS      2
-
-%define DESCALE_P1      (CONST_BITS-PASS1_BITS)
-%define DESCALE_P2      (CONST_BITS+PASS1_BITS+3)
-
-%if CONST_BITS == 13
-F_0_298 equ      2446           ; FIX(0.298631336)
-F_0_390 equ      3196           ; FIX(0.390180644)
-F_0_541 equ      4433           ; FIX(0.541196100)
-F_0_765 equ      6270           ; FIX(0.765366865)
-F_0_899 equ      7373           ; FIX(0.899976223)
-F_1_175 equ      9633           ; FIX(1.175875602)
-F_1_501 equ     12299           ; FIX(1.501321110)
-F_1_847 equ     15137           ; FIX(1.847759065)
-F_1_961 equ     16069           ; FIX(1.961570560)
-F_2_053 equ     16819           ; FIX(2.053119869)
-F_2_562 equ     20995           ; FIX(2.562915447)
-F_3_072 equ     25172           ; FIX(3.072711026)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_298 equ     DESCALE( 320652955,30-CONST_BITS)       ; FIX(0.298631336)
-F_0_390 equ     DESCALE( 418953276,30-CONST_BITS)       ; FIX(0.390180644)
-F_0_541 equ     DESCALE( 581104887,30-CONST_BITS)       ; FIX(0.541196100)
-F_0_765 equ     DESCALE( 821806413,30-CONST_BITS)       ; FIX(0.765366865)
-F_0_899 equ     DESCALE( 966342111,30-CONST_BITS)       ; FIX(0.899976223)
-F_1_175 equ     DESCALE(1262586813,30-CONST_BITS)       ; FIX(1.175875602)
-F_1_501 equ     DESCALE(1612031267,30-CONST_BITS)       ; FIX(1.501321110)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_1_961 equ     DESCALE(2106220350,30-CONST_BITS)       ; FIX(1.961570560)
-F_2_053 equ     DESCALE(2204520673,30-CONST_BITS)       ; FIX(2.053119869)
-F_2_562 equ     DESCALE(2751909506,30-CONST_BITS)       ; FIX(2.562915447)
-F_3_072 equ     DESCALE(3299298341,30-CONST_BITS)       ; FIX(3.072711026)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_idct_islow_sse2)
-
-EXTN(jconst_idct_islow_sse2):
-
-PW_F130_F054    times 4 dw  (F_0_541+F_0_765), F_0_541
-PW_F054_MF130   times 4 dw  F_0_541, (F_0_541-F_1_847)
-PW_MF078_F117   times 4 dw  (F_1_175-F_1_961), F_1_175
-PW_F117_F078    times 4 dw  F_1_175, (F_1_175-F_0_390)
-PW_MF060_MF089  times 4 dw  (F_0_298-F_0_899),-F_0_899
-PW_MF089_F060   times 4 dw -F_0_899, (F_1_501-F_0_899)
-PW_MF050_MF256  times 4 dw  (F_2_053-F_2_562),-F_2_562
-PW_MF256_F050   times 4 dw -F_2_562, (F_3_072-F_2_562)
-PD_DESCALE_P1   times 4 dd  1 << (DESCALE_P1-1)
-PD_DESCALE_P2   times 4 dd  1 << (DESCALE_P2-1)
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Perform dequantization and inverse DCT on one block of coefficients.
-;
-; GLOBAL(void)
-; jsimd_idct_islow_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                        JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-; r10 = jpeg_component_info *compptr
-; r11 = JCOEFPTR coef_block
-; r12 = JSAMPARRAY output_buf
-; r13 = JDIMENSION output_col
-
-%define original_rbp    rbp+0
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          12
-
-        align   16
-        global  EXTN(jsimd_idct_islow_sse2)
-
-EXTN(jsimd_idct_islow_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-
-        ; ---- Pass 1: process columns from input.
-
-        mov     rdx, r10                ; quantptr
-        mov     rsi, r11                ; inptr
-
-%ifndef NO_ZERO_COLUMN_TEST_ISLOW_SSE2
-        mov     eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        jnz     near .columnDCT
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1,xmm0
-        packsswb xmm1,xmm1
-        packsswb xmm1,xmm1
-        movd    eax,xmm1
-        test    rax,rax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movdqa  xmm5, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm5, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        psllw   xmm5,PASS1_BITS
-
-        movdqa    xmm4,xmm5             ; xmm5=in0=(00 01 02 03 04 05 06 07)
-        punpcklwd xmm5,xmm5             ; xmm5=(00 00 01 01 02 02 03 03)
-        punpckhwd xmm4,xmm4             ; xmm4=(04 04 05 05 06 06 07 07)
-
-        pshufd  xmm7,xmm5,0x00          ; xmm7=col0=(00 00 00 00 00 00 00 00)
-        pshufd  xmm6,xmm5,0x55          ; xmm6=col1=(01 01 01 01 01 01 01 01)
-        pshufd  xmm1,xmm5,0xAA          ; xmm1=col2=(02 02 02 02 02 02 02 02)
-        pshufd  xmm5,xmm5,0xFF          ; xmm5=col3=(03 03 03 03 03 03 03 03)
-        pshufd  xmm0,xmm4,0x00          ; xmm0=col4=(04 04 04 04 04 04 04 04)
-        pshufd  xmm3,xmm4,0x55          ; xmm3=col5=(05 05 05 05 05 05 05 05)
-        pshufd  xmm2,xmm4,0xAA          ; xmm2=col6=(06 06 06 06 06 06 06 06)
-        pshufd  xmm4,xmm4,0xFF          ; xmm4=col7=(07 07 07 07 07 07 07 07)
-
-        movdqa  XMMWORD [wk(8)], xmm6   ; wk(8)=col1
-        movdqa  XMMWORD [wk(9)], xmm5   ; wk(9)=col3
-        movdqa  XMMWORD [wk(10)], xmm3  ; wk(10)=col5
-        movdqa  XMMWORD [wk(11)], xmm4  ; wk(11)=col7
-        jmp     near .column_end
-%endif
-.columnDCT:
-
-        ; -- Even part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        ; (Original)
-        ; z1 = (z2 + z3) * 0.541196100;
-        ; tmp2 = z1 + z3 * -1.847759065;
-        ; tmp3 = z1 + z2 * 0.765366865;
-        ;
-        ; (This implementation)
-        ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
-        ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
-
-        movdqa    xmm4,xmm1             ; xmm1=in2=z2
-        movdqa    xmm5,xmm1
-        punpcklwd xmm4,xmm3             ; xmm3=in6=z3
-        punpckhwd xmm5,xmm3
-        movdqa    xmm1,xmm4
-        movdqa    xmm3,xmm5
-        pmaddwd   xmm4,[rel PW_F130_F054]       ; xmm4=tmp3L
-        pmaddwd   xmm5,[rel PW_F130_F054]       ; xmm5=tmp3H
-        pmaddwd   xmm1,[rel PW_F054_MF130]      ; xmm1=tmp2L
-        pmaddwd   xmm3,[rel PW_F054_MF130]      ; xmm3=tmp2H
-
-        movdqa    xmm6,xmm0
-        paddw     xmm0,xmm2             ; xmm0=in0+in4
-        psubw     xmm6,xmm2             ; xmm6=in0-in4
-
-        pxor      xmm7,xmm7
-        pxor      xmm2,xmm2
-        punpcklwd xmm7,xmm0             ; xmm7=tmp0L
-        punpckhwd xmm2,xmm0             ; xmm2=tmp0H
-        psrad     xmm7,(16-CONST_BITS)  ; psrad xmm7,16 & pslld xmm7,CONST_BITS
-        psrad     xmm2,(16-CONST_BITS)  ; psrad xmm2,16 & pslld xmm2,CONST_BITS
-
-        movdqa  xmm0,xmm7
-        paddd   xmm7,xmm4               ; xmm7=tmp10L
-        psubd   xmm0,xmm4               ; xmm0=tmp13L
-        movdqa  xmm4,xmm2
-        paddd   xmm2,xmm5               ; xmm2=tmp10H
-        psubd   xmm4,xmm5               ; xmm4=tmp13H
-
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=tmp10L
-        movdqa  XMMWORD [wk(1)], xmm2   ; wk(1)=tmp10H
-        movdqa  XMMWORD [wk(2)], xmm0   ; wk(2)=tmp13L
-        movdqa  XMMWORD [wk(3)], xmm4   ; wk(3)=tmp13H
-
-        pxor      xmm5,xmm5
-        pxor      xmm7,xmm7
-        punpcklwd xmm5,xmm6             ; xmm5=tmp1L
-        punpckhwd xmm7,xmm6             ; xmm7=tmp1H
-        psrad     xmm5,(16-CONST_BITS)  ; psrad xmm5,16 & pslld xmm5,CONST_BITS
-        psrad     xmm7,(16-CONST_BITS)  ; psrad xmm7,16 & pslld xmm7,CONST_BITS
-
-        movdqa  xmm2,xmm5
-        paddd   xmm5,xmm1               ; xmm5=tmp11L
-        psubd   xmm2,xmm1               ; xmm2=tmp12L
-        movdqa  xmm0,xmm7
-        paddd   xmm7,xmm3               ; xmm7=tmp11H
-        psubd   xmm0,xmm3               ; xmm0=tmp12H
-
-        movdqa  XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
-        movdqa  XMMWORD [wk(5)], xmm7   ; wk(5)=tmp11H
-        movdqa  XMMWORD [wk(6)], xmm2   ; wk(6)=tmp12L
-        movdqa  XMMWORD [wk(7)], xmm0   ; wk(7)=tmp12H
-
-        ; -- Odd part
-
-        movdqa  xmm4, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm6, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm4, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm6, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        movdqa  xmm5,xmm6
-        movdqa  xmm7,xmm4
-        paddw   xmm5,xmm3               ; xmm5=z3
-        paddw   xmm7,xmm1               ; xmm7=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm2,xmm5
-        movdqa    xmm0,xmm5
-        punpcklwd xmm2,xmm7
-        punpckhwd xmm0,xmm7
-        movdqa    xmm5,xmm2
-        movdqa    xmm7,xmm0
-        pmaddwd   xmm2,[rel PW_MF078_F117]      ; xmm2=z3L
-        pmaddwd   xmm0,[rel PW_MF078_F117]      ; xmm0=z3H
-        pmaddwd   xmm5,[rel PW_F117_F078]       ; xmm5=z4L
-        pmaddwd   xmm7,[rel PW_F117_F078]       ; xmm7=z4H
-
-        movdqa  XMMWORD [wk(10)], xmm2  ; wk(10)=z3L
-        movdqa  XMMWORD [wk(11)], xmm0  ; wk(11)=z3H
-
-        ; (Original)
-        ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
-        ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
-        ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
-        ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
-        ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
-        ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
-        ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
-        ; tmp0 += z3;  tmp1 += z4;
-        ; tmp2 += z3;  tmp3 += z4;
-
-        movdqa    xmm2,xmm3
-        movdqa    xmm0,xmm3
-        punpcklwd xmm2,xmm4
-        punpckhwd xmm0,xmm4
-        movdqa    xmm3,xmm2
-        movdqa    xmm4,xmm0
-        pmaddwd   xmm2,[rel PW_MF060_MF089]     ; xmm2=tmp0L
-        pmaddwd   xmm0,[rel PW_MF060_MF089]     ; xmm0=tmp0H
-        pmaddwd   xmm3,[rel PW_MF089_F060]      ; xmm3=tmp3L
-        pmaddwd   xmm4,[rel PW_MF089_F060]      ; xmm4=tmp3H
-
-        paddd   xmm2, XMMWORD [wk(10)]  ; xmm2=tmp0L
-        paddd   xmm0, XMMWORD [wk(11)]  ; xmm0=tmp0H
-        paddd   xmm3,xmm5               ; xmm3=tmp3L
-        paddd   xmm4,xmm7               ; xmm4=tmp3H
-
-        movdqa  XMMWORD [wk(8)], xmm2   ; wk(8)=tmp0L
-        movdqa  XMMWORD [wk(9)], xmm0   ; wk(9)=tmp0H
-
-        movdqa    xmm2,xmm1
-        movdqa    xmm0,xmm1
-        punpcklwd xmm2,xmm6
-        punpckhwd xmm0,xmm6
-        movdqa    xmm1,xmm2
-        movdqa    xmm6,xmm0
-        pmaddwd   xmm2,[rel PW_MF050_MF256]     ; xmm2=tmp1L
-        pmaddwd   xmm0,[rel PW_MF050_MF256]     ; xmm0=tmp1H
-        pmaddwd   xmm1,[rel PW_MF256_F050]      ; xmm1=tmp2L
-        pmaddwd   xmm6,[rel PW_MF256_F050]      ; xmm6=tmp2H
-
-        paddd   xmm2,xmm5               ; xmm2=tmp1L
-        paddd   xmm0,xmm7               ; xmm0=tmp1H
-        paddd   xmm1, XMMWORD [wk(10)]  ; xmm1=tmp2L
-        paddd   xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
-
-        movdqa  XMMWORD [wk(10)], xmm2  ; wk(10)=tmp1L
-        movdqa  XMMWORD [wk(11)], xmm0  ; wk(11)=tmp1H
-
-        ; -- Final output stage
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
-        movdqa  xmm7, XMMWORD [wk(1)]   ; xmm7=tmp10H
-
-        movdqa  xmm2,xmm5
-        movdqa  xmm0,xmm7
-        paddd   xmm5,xmm3               ; xmm5=data0L
-        paddd   xmm7,xmm4               ; xmm7=data0H
-        psubd   xmm2,xmm3               ; xmm2=data7L
-        psubd   xmm0,xmm4               ; xmm0=data7H
-
-        movdqa  xmm3,[rel PD_DESCALE_P1]        ; xmm3=[rel PD_DESCALE_P1]
-
-        paddd   xmm5,xmm3
-        paddd   xmm7,xmm3
-        psrad   xmm5,DESCALE_P1
-        psrad   xmm7,DESCALE_P1
-        paddd   xmm2,xmm3
-        paddd   xmm0,xmm3
-        psrad   xmm2,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-
-        packssdw  xmm5,xmm7             ; xmm5=data0=(00 01 02 03 04 05 06 07)
-        packssdw  xmm2,xmm0             ; xmm2=data7=(70 71 72 73 74 75 76 77)
-
-        movdqa  xmm4, XMMWORD [wk(4)]   ; xmm4=tmp11L
-        movdqa  xmm3, XMMWORD [wk(5)]   ; xmm3=tmp11H
-
-        movdqa  xmm7,xmm4
-        movdqa  xmm0,xmm3
-        paddd   xmm4,xmm1               ; xmm4=data1L
-        paddd   xmm3,xmm6               ; xmm3=data1H
-        psubd   xmm7,xmm1               ; xmm7=data6L
-        psubd   xmm0,xmm6               ; xmm0=data6H
-
-        movdqa  xmm1,[rel PD_DESCALE_P1]        ; xmm1=[rel PD_DESCALE_P1]
-
-        paddd   xmm4,xmm1
-        paddd   xmm3,xmm1
-        psrad   xmm4,DESCALE_P1
-        psrad   xmm3,DESCALE_P1
-        paddd   xmm7,xmm1
-        paddd   xmm0,xmm1
-        psrad   xmm7,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-
-        packssdw  xmm4,xmm3             ; xmm4=data1=(10 11 12 13 14 15 16 17)
-        packssdw  xmm7,xmm0             ; xmm7=data6=(60 61 62 63 64 65 66 67)
-
-        movdqa    xmm6,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm4             ; xmm5=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm6,xmm4             ; xmm6=(04 14 05 15 06 16 07 17)
-        movdqa    xmm1,xmm7             ; transpose coefficients(phase 1)
-        punpcklwd xmm7,xmm2             ; xmm7=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm1,xmm2             ; xmm1=(64 74 65 75 66 76 67 77)
-
-        movdqa  xmm3, XMMWORD [wk(6)]   ; xmm3=tmp12L
-        movdqa  xmm0, XMMWORD [wk(7)]   ; xmm0=tmp12H
-        movdqa  xmm4, XMMWORD [wk(10)]  ; xmm4=tmp1L
-        movdqa  xmm2, XMMWORD [wk(11)]  ; xmm2=tmp1H
-
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 01 11 02 12 03 13)
-        movdqa  XMMWORD [wk(1)], xmm6   ; wk(1)=(04 14 05 15 06 16 07 17)
-        movdqa  XMMWORD [wk(4)], xmm7   ; wk(4)=(60 70 61 71 62 72 63 73)
-        movdqa  XMMWORD [wk(5)], xmm1   ; wk(5)=(64 74 65 75 66 76 67 77)
-
-        movdqa  xmm5,xmm3
-        movdqa  xmm6,xmm0
-        paddd   xmm3,xmm4               ; xmm3=data2L
-        paddd   xmm0,xmm2               ; xmm0=data2H
-        psubd   xmm5,xmm4               ; xmm5=data5L
-        psubd   xmm6,xmm2               ; xmm6=data5H
-
-        movdqa  xmm7,[rel PD_DESCALE_P1]        ; xmm7=[rel PD_DESCALE_P1]
-
-        paddd   xmm3,xmm7
-        paddd   xmm0,xmm7
-        psrad   xmm3,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-        paddd   xmm5,xmm7
-        paddd   xmm6,xmm7
-        psrad   xmm5,DESCALE_P1
-        psrad   xmm6,DESCALE_P1
-
-        packssdw  xmm3,xmm0             ; xmm3=data2=(20 21 22 23 24 25 26 27)
-        packssdw  xmm5,xmm6             ; xmm5=data5=(50 51 52 53 54 55 56 57)
-
-        movdqa  xmm1, XMMWORD [wk(2)]   ; xmm1=tmp13L
-        movdqa  xmm4, XMMWORD [wk(3)]   ; xmm4=tmp13H
-        movdqa  xmm2, XMMWORD [wk(8)]   ; xmm2=tmp0L
-        movdqa  xmm7, XMMWORD [wk(9)]   ; xmm7=tmp0H
-
-        movdqa  xmm0,xmm1
-        movdqa  xmm6,xmm4
-        paddd   xmm1,xmm2               ; xmm1=data3L
-        paddd   xmm4,xmm7               ; xmm4=data3H
-        psubd   xmm0,xmm2               ; xmm0=data4L
-        psubd   xmm6,xmm7               ; xmm6=data4H
-
-        movdqa  xmm2,[rel PD_DESCALE_P1]        ; xmm2=[rel PD_DESCALE_P1]
-
-        paddd   xmm1,xmm2
-        paddd   xmm4,xmm2
-        psrad   xmm1,DESCALE_P1
-        psrad   xmm4,DESCALE_P1
-        paddd   xmm0,xmm2
-        paddd   xmm6,xmm2
-        psrad   xmm0,DESCALE_P1
-        psrad   xmm6,DESCALE_P1
-
-        packssdw  xmm1,xmm4             ; xmm1=data3=(30 31 32 33 34 35 36 37)
-        packssdw  xmm0,xmm6             ; xmm0=data4=(40 41 42 43 44 45 46 47)
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=(00 10 01 11 02 12 03 13)
-        movdqa  xmm2, XMMWORD [wk(1)]   ; xmm2=(04 14 05 15 06 16 07 17)
-
-        movdqa    xmm4,xmm3             ; transpose coefficients(phase 1)
-        punpcklwd xmm3,xmm1             ; xmm3=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm4,xmm1             ; xmm4=(24 34 25 35 26 36 27 37)
-        movdqa    xmm6,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm5             ; xmm0=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm6,xmm5             ; xmm6=(44 54 45 55 46 56 47 57)
-
-        movdqa    xmm1,xmm7             ; transpose coefficients(phase 2)
-        punpckldq xmm7,xmm3             ; xmm7=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm1,xmm3             ; xmm1=(02 12 22 32 03 13 23 33)
-        movdqa    xmm5,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm4             ; xmm2=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm5,xmm4             ; xmm5=(06 16 26 36 07 17 27 37)
-
-        movdqa  xmm3, XMMWORD [wk(4)]   ; xmm3=(60 70 61 71 62 72 63 73)
-        movdqa  xmm4, XMMWORD [wk(5)]   ; xmm4=(64 74 65 75 66 76 67 77)
-
-        movdqa  XMMWORD [wk(6)], xmm2   ; wk(6)=(04 14 24 34 05 15 25 35)
-        movdqa  XMMWORD [wk(7)], xmm5   ; wk(7)=(06 16 26 36 07 17 27 37)
-
-        movdqa    xmm2,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm3             ; xmm0=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm2,xmm3             ; xmm2=(42 52 62 72 43 53 63 73)
-        movdqa    xmm5,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm4             ; xmm6=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm5,xmm4             ; xmm5=(46 56 66 76 47 57 67 77)
-
-        movdqa     xmm3,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm0            ; xmm7=col0=(00 10 20 30 40 50 60 70)
-        punpckhqdq xmm3,xmm0            ; xmm3=col1=(01 11 21 31 41 51 61 71)
-        movdqa     xmm4,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm2            ; xmm1=col2=(02 12 22 32 42 52 62 72)
-        punpckhqdq xmm4,xmm2            ; xmm4=col3=(03 13 23 33 43 53 63 73)
-
-        movdqa  xmm0, XMMWORD [wk(6)]   ; xmm0=(04 14 24 34 05 15 25 35)
-        movdqa  xmm2, XMMWORD [wk(7)]   ; xmm2=(06 16 26 36 07 17 27 37)
-
-        movdqa  XMMWORD [wk(8)], xmm3   ; wk(8)=col1
-        movdqa  XMMWORD [wk(9)], xmm4   ; wk(9)=col3
-
-        movdqa     xmm3,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm6            ; xmm0=col4=(04 14 24 34 44 54 64 74)
-        punpckhqdq xmm3,xmm6            ; xmm3=col5=(05 15 25 35 45 55 65 75)
-        movdqa     xmm4,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm5            ; xmm2=col6=(06 16 26 36 46 56 66 76)
-        punpckhqdq xmm4,xmm5            ; xmm4=col7=(07 17 27 37 47 57 67 77)
-
-        movdqa  XMMWORD [wk(10)], xmm3  ; wk(10)=col5
-        movdqa  XMMWORD [wk(11)], xmm4  ; wk(11)=col7
-.column_end:
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows from work array, store into output array.
-
-        mov     rax, [original_rbp]
-        mov     rdi, r12        ; (JSAMPROW *)
-        mov     eax, r13d
-
-        ; -- Even part
-
-        ; xmm7=col0, xmm1=col2, xmm0=col4, xmm2=col6
-
-        ; (Original)
-        ; z1 = (z2 + z3) * 0.541196100;
-        ; tmp2 = z1 + z3 * -1.847759065;
-        ; tmp3 = z1 + z2 * 0.765366865;
-        ;
-        ; (This implementation)
-        ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
-        ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
-
-        movdqa    xmm6,xmm1             ; xmm1=in2=z2
-        movdqa    xmm5,xmm1
-        punpcklwd xmm6,xmm2             ; xmm2=in6=z3
-        punpckhwd xmm5,xmm2
-        movdqa    xmm1,xmm6
-        movdqa    xmm2,xmm5
-        pmaddwd   xmm6,[rel PW_F130_F054]       ; xmm6=tmp3L
-        pmaddwd   xmm5,[rel PW_F130_F054]       ; xmm5=tmp3H
-        pmaddwd   xmm1,[rel PW_F054_MF130]      ; xmm1=tmp2L
-        pmaddwd   xmm2,[rel PW_F054_MF130]      ; xmm2=tmp2H
-
-        movdqa    xmm3,xmm7
-        paddw     xmm7,xmm0             ; xmm7=in0+in4
-        psubw     xmm3,xmm0             ; xmm3=in0-in4
-
-        pxor      xmm4,xmm4
-        pxor      xmm0,xmm0
-        punpcklwd xmm4,xmm7             ; xmm4=tmp0L
-        punpckhwd xmm0,xmm7             ; xmm0=tmp0H
-        psrad     xmm4,(16-CONST_BITS)  ; psrad xmm4,16 & pslld xmm4,CONST_BITS
-        psrad     xmm0,(16-CONST_BITS)  ; psrad xmm0,16 & pslld xmm0,CONST_BITS
-
-        movdqa  xmm7,xmm4
-        paddd   xmm4,xmm6               ; xmm4=tmp10L
-        psubd   xmm7,xmm6               ; xmm7=tmp13L
-        movdqa  xmm6,xmm0
-        paddd   xmm0,xmm5               ; xmm0=tmp10H
-        psubd   xmm6,xmm5               ; xmm6=tmp13H
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=tmp10L
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=tmp10H
-        movdqa  XMMWORD [wk(2)], xmm7   ; wk(2)=tmp13L
-        movdqa  XMMWORD [wk(3)], xmm6   ; wk(3)=tmp13H
-
-        pxor      xmm5,xmm5
-        pxor      xmm4,xmm4
-        punpcklwd xmm5,xmm3             ; xmm5=tmp1L
-        punpckhwd xmm4,xmm3             ; xmm4=tmp1H
-        psrad     xmm5,(16-CONST_BITS)  ; psrad xmm5,16 & pslld xmm5,CONST_BITS
-        psrad     xmm4,(16-CONST_BITS)  ; psrad xmm4,16 & pslld xmm4,CONST_BITS
-
-        movdqa  xmm0,xmm5
-        paddd   xmm5,xmm1               ; xmm5=tmp11L
-        psubd   xmm0,xmm1               ; xmm0=tmp12L
-        movdqa  xmm7,xmm4
-        paddd   xmm4,xmm2               ; xmm4=tmp11H
-        psubd   xmm7,xmm2               ; xmm7=tmp12H
-
-        movdqa  XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
-        movdqa  XMMWORD [wk(5)], xmm4   ; wk(5)=tmp11H
-        movdqa  XMMWORD [wk(6)], xmm0   ; wk(6)=tmp12L
-        movdqa  XMMWORD [wk(7)], xmm7   ; wk(7)=tmp12H
-
-        ; -- Odd part
-
-        movdqa  xmm6, XMMWORD [wk(9)]   ; xmm6=col3
-        movdqa  xmm3, XMMWORD [wk(8)]   ; xmm3=col1
-        movdqa  xmm1, XMMWORD [wk(11)]  ; xmm1=col7
-        movdqa  xmm2, XMMWORD [wk(10)]  ; xmm2=col5
-
-        movdqa  xmm5,xmm6
-        movdqa  xmm4,xmm3
-        paddw   xmm5,xmm1               ; xmm5=z3
-        paddw   xmm4,xmm2               ; xmm4=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm0,xmm5
-        movdqa    xmm7,xmm5
-        punpcklwd xmm0,xmm4
-        punpckhwd xmm7,xmm4
-        movdqa    xmm5,xmm0
-        movdqa    xmm4,xmm7
-        pmaddwd   xmm0,[rel PW_MF078_F117]      ; xmm0=z3L
-        pmaddwd   xmm7,[rel PW_MF078_F117]      ; xmm7=z3H
-        pmaddwd   xmm5,[rel PW_F117_F078]       ; xmm5=z4L
-        pmaddwd   xmm4,[rel PW_F117_F078]       ; xmm4=z4H
-
-        movdqa  XMMWORD [wk(10)], xmm0  ; wk(10)=z3L
-        movdqa  XMMWORD [wk(11)], xmm7  ; wk(11)=z3H
-
-        ; (Original)
-        ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
-        ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
-        ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
-        ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
-        ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
-        ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
-        ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
-        ; tmp0 += z3;  tmp1 += z4;
-        ; tmp2 += z3;  tmp3 += z4;
-
-        movdqa    xmm0,xmm1
-        movdqa    xmm7,xmm1
-        punpcklwd xmm0,xmm3
-        punpckhwd xmm7,xmm3
-        movdqa    xmm1,xmm0
-        movdqa    xmm3,xmm7
-        pmaddwd   xmm0,[rel PW_MF060_MF089]     ; xmm0=tmp0L
-        pmaddwd   xmm7,[rel PW_MF060_MF089]     ; xmm7=tmp0H
-        pmaddwd   xmm1,[rel PW_MF089_F060]      ; xmm1=tmp3L
-        pmaddwd   xmm3,[rel PW_MF089_F060]      ; xmm3=tmp3H
-
-        paddd   xmm0, XMMWORD [wk(10)]  ; xmm0=tmp0L
-        paddd   xmm7, XMMWORD [wk(11)]  ; xmm7=tmp0H
-        paddd   xmm1,xmm5               ; xmm1=tmp3L
-        paddd   xmm3,xmm4               ; xmm3=tmp3H
-
-        movdqa  XMMWORD [wk(8)], xmm0   ; wk(8)=tmp0L
-        movdqa  XMMWORD [wk(9)], xmm7   ; wk(9)=tmp0H
-
-        movdqa    xmm0,xmm2
-        movdqa    xmm7,xmm2
-        punpcklwd xmm0,xmm6
-        punpckhwd xmm7,xmm6
-        movdqa    xmm2,xmm0
-        movdqa    xmm6,xmm7
-        pmaddwd   xmm0,[rel PW_MF050_MF256]     ; xmm0=tmp1L
-        pmaddwd   xmm7,[rel PW_MF050_MF256]     ; xmm7=tmp1H
-        pmaddwd   xmm2,[rel PW_MF256_F050]      ; xmm2=tmp2L
-        pmaddwd   xmm6,[rel PW_MF256_F050]      ; xmm6=tmp2H
-
-        paddd   xmm0,xmm5               ; xmm0=tmp1L
-        paddd   xmm7,xmm4               ; xmm7=tmp1H
-        paddd   xmm2, XMMWORD [wk(10)]  ; xmm2=tmp2L
-        paddd   xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
-
-        movdqa  XMMWORD [wk(10)], xmm0  ; wk(10)=tmp1L
-        movdqa  XMMWORD [wk(11)], xmm7  ; wk(11)=tmp1H
-
-        ; -- Final output stage
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
-        movdqa  xmm4, XMMWORD [wk(1)]   ; xmm4=tmp10H
-
-        movdqa  xmm0,xmm5
-        movdqa  xmm7,xmm4
-        paddd   xmm5,xmm1               ; xmm5=data0L
-        paddd   xmm4,xmm3               ; xmm4=data0H
-        psubd   xmm0,xmm1               ; xmm0=data7L
-        psubd   xmm7,xmm3               ; xmm7=data7H
-
-        movdqa  xmm1,[rel PD_DESCALE_P2]        ; xmm1=[rel PD_DESCALE_P2]
-
-        paddd   xmm5,xmm1
-        paddd   xmm4,xmm1
-        psrad   xmm5,DESCALE_P2
-        psrad   xmm4,DESCALE_P2
-        paddd   xmm0,xmm1
-        paddd   xmm7,xmm1
-        psrad   xmm0,DESCALE_P2
-        psrad   xmm7,DESCALE_P2
-
-        packssdw  xmm5,xmm4             ; xmm5=data0=(00 10 20 30 40 50 60 70)
-        packssdw  xmm0,xmm7             ; xmm0=data7=(07 17 27 37 47 57 67 77)
-
-        movdqa  xmm3, XMMWORD [wk(4)]   ; xmm3=tmp11L
-        movdqa  xmm1, XMMWORD [wk(5)]   ; xmm1=tmp11H
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm7,xmm1
-        paddd   xmm3,xmm2               ; xmm3=data1L
-        paddd   xmm1,xmm6               ; xmm1=data1H
-        psubd   xmm4,xmm2               ; xmm4=data6L
-        psubd   xmm7,xmm6               ; xmm7=data6H
-
-        movdqa  xmm2,[rel PD_DESCALE_P2]        ; xmm2=[rel PD_DESCALE_P2]
-
-        paddd   xmm3,xmm2
-        paddd   xmm1,xmm2
-        psrad   xmm3,DESCALE_P2
-        psrad   xmm1,DESCALE_P2
-        paddd   xmm4,xmm2
-        paddd   xmm7,xmm2
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm7,DESCALE_P2
-
-        packssdw  xmm3,xmm1             ; xmm3=data1=(01 11 21 31 41 51 61 71)
-        packssdw  xmm4,xmm7             ; xmm4=data6=(06 16 26 36 46 56 66 76)
-
-        packsswb  xmm5,xmm4             ; xmm5=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        packsswb  xmm3,xmm0             ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        movdqa  xmm6, XMMWORD [wk(6)]   ; xmm6=tmp12L
-        movdqa  xmm2, XMMWORD [wk(7)]   ; xmm2=tmp12H
-        movdqa  xmm1, XMMWORD [wk(10)]  ; xmm1=tmp1L
-        movdqa  xmm7, XMMWORD [wk(11)]  ; xmm7=tmp1H
-
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        movdqa  xmm4,xmm6
-        movdqa  xmm0,xmm2
-        paddd   xmm6,xmm1               ; xmm6=data2L
-        paddd   xmm2,xmm7               ; xmm2=data2H
-        psubd   xmm4,xmm1               ; xmm4=data5L
-        psubd   xmm0,xmm7               ; xmm0=data5H
-
-        movdqa  xmm5,[rel PD_DESCALE_P2]        ; xmm5=[rel PD_DESCALE_P2]
-
-        paddd   xmm6,xmm5
-        paddd   xmm2,xmm5
-        psrad   xmm6,DESCALE_P2
-        psrad   xmm2,DESCALE_P2
-        paddd   xmm4,xmm5
-        paddd   xmm0,xmm5
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm0,DESCALE_P2
-
-        packssdw  xmm6,xmm2             ; xmm6=data2=(02 12 22 32 42 52 62 72)
-        packssdw  xmm4,xmm0             ; xmm4=data5=(05 15 25 35 45 55 65 75)
-
-        movdqa  xmm3, XMMWORD [wk(2)]   ; xmm3=tmp13L
-        movdqa  xmm1, XMMWORD [wk(3)]   ; xmm1=tmp13H
-        movdqa  xmm7, XMMWORD [wk(8)]   ; xmm7=tmp0L
-        movdqa  xmm5, XMMWORD [wk(9)]   ; xmm5=tmp0H
-
-        movdqa  xmm2,xmm3
-        movdqa  xmm0,xmm1
-        paddd   xmm3,xmm7               ; xmm3=data3L
-        paddd   xmm1,xmm5               ; xmm1=data3H
-        psubd   xmm2,xmm7               ; xmm2=data4L
-        psubd   xmm0,xmm5               ; xmm0=data4H
-
-        movdqa  xmm7,[rel PD_DESCALE_P2]        ; xmm7=[rel PD_DESCALE_P2]
-
-        paddd   xmm3,xmm7
-        paddd   xmm1,xmm7
-        psrad   xmm3,DESCALE_P2
-        psrad   xmm1,DESCALE_P2
-        paddd   xmm2,xmm7
-        paddd   xmm0,xmm7
-        psrad   xmm2,DESCALE_P2
-        psrad   xmm0,DESCALE_P2
-
-        movdqa    xmm5,[rel PB_CENTERJSAMP]     ; xmm5=[rel PB_CENTERJSAMP]
-
-        packssdw  xmm3,xmm1             ; xmm3=data3=(03 13 23 33 43 53 63 73)
-        packssdw  xmm2,xmm0             ; xmm2=data4=(04 14 24 34 44 54 64 74)
-
-        movdqa    xmm7, XMMWORD [wk(0)] ; xmm7=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        movdqa    xmm1, XMMWORD [wk(1)] ; xmm1=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        packsswb  xmm6,xmm2             ; xmm6=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
-        packsswb  xmm3,xmm4             ; xmm3=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
-
-        paddb     xmm7,xmm5
-        paddb     xmm1,xmm5
-        paddb     xmm6,xmm5
-        paddb     xmm3,xmm5
-
-        movdqa    xmm0,xmm7     ; transpose coefficients(phase 1)
-        punpcklbw xmm7,xmm1     ; xmm7=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
-        punpckhbw xmm0,xmm1     ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
-        movdqa    xmm2,xmm6     ; transpose coefficients(phase 1)
-        punpcklbw xmm6,xmm3     ; xmm6=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
-        punpckhbw xmm2,xmm3     ; xmm2=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
-
-        movdqa    xmm4,xmm7     ; transpose coefficients(phase 2)
-        punpcklwd xmm7,xmm6     ; xmm7=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
-        punpckhwd xmm4,xmm6     ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
-        movdqa    xmm5,xmm2     ; transpose coefficients(phase 2)
-        punpcklwd xmm2,xmm0     ; xmm2=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
-        punpckhwd xmm5,xmm0     ; xmm5=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
-
-        movdqa    xmm1,xmm7     ; transpose coefficients(phase 3)
-        punpckldq xmm7,xmm2     ; xmm7=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
-        punpckhdq xmm1,xmm2     ; xmm1=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
-        movdqa    xmm3,xmm4     ; transpose coefficients(phase 3)
-        punpckldq xmm4,xmm5     ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
-        punpckhdq xmm3,xmm5     ; xmm3=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
-
-        pshufd  xmm6,xmm7,0x4E  ; xmm6=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
-        pshufd  xmm0,xmm1,0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
-        pshufd  xmm2,xmm4,0x4E  ; xmm2=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
-        pshufd  xmm5,xmm3,0x4E  ; xmm5=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
-
-        mov     rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm7
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm1
-        mov     rdx, JSAMPROW [rdi+4*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+6*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm4
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm3
-
-        mov     rdx, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm6
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm0
-        mov     rdx, JSAMPROW [rdi+5*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+7*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm2
-        movq    XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm5
-
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctint-sse2.asm b/simd/jidctint-sse2.asm
deleted file mode 100644
index 6c7e7d9..0000000
--- a/simd/jidctint-sse2.asm
+++ /dev/null
@@ -1,858 +0,0 @@
-;
-; jidctint.asm - accurate integer IDCT (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains a slow-but-accurate integer implementation of the
-; inverse DCT (Discrete Cosine Transform). The following code is based
-; directly on the IJG's original jidctint.c; see the jidctint.c for
-; more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      13
-%define PASS1_BITS      2
-
-%define DESCALE_P1      (CONST_BITS-PASS1_BITS)
-%define DESCALE_P2      (CONST_BITS+PASS1_BITS+3)
-
-%if CONST_BITS == 13
-F_0_298 equ      2446           ; FIX(0.298631336)
-F_0_390 equ      3196           ; FIX(0.390180644)
-F_0_541 equ      4433           ; FIX(0.541196100)
-F_0_765 equ      6270           ; FIX(0.765366865)
-F_0_899 equ      7373           ; FIX(0.899976223)
-F_1_175 equ      9633           ; FIX(1.175875602)
-F_1_501 equ     12299           ; FIX(1.501321110)
-F_1_847 equ     15137           ; FIX(1.847759065)
-F_1_961 equ     16069           ; FIX(1.961570560)
-F_2_053 equ     16819           ; FIX(2.053119869)
-F_2_562 equ     20995           ; FIX(2.562915447)
-F_3_072 equ     25172           ; FIX(3.072711026)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_298 equ     DESCALE( 320652955,30-CONST_BITS)       ; FIX(0.298631336)
-F_0_390 equ     DESCALE( 418953276,30-CONST_BITS)       ; FIX(0.390180644)
-F_0_541 equ     DESCALE( 581104887,30-CONST_BITS)       ; FIX(0.541196100)
-F_0_765 equ     DESCALE( 821806413,30-CONST_BITS)       ; FIX(0.765366865)
-F_0_899 equ     DESCALE( 966342111,30-CONST_BITS)       ; FIX(0.899976223)
-F_1_175 equ     DESCALE(1262586813,30-CONST_BITS)       ; FIX(1.175875602)
-F_1_501 equ     DESCALE(1612031267,30-CONST_BITS)       ; FIX(1.501321110)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_1_961 equ     DESCALE(2106220350,30-CONST_BITS)       ; FIX(1.961570560)
-F_2_053 equ     DESCALE(2204520673,30-CONST_BITS)       ; FIX(2.053119869)
-F_2_562 equ     DESCALE(2751909506,30-CONST_BITS)       ; FIX(2.562915447)
-F_3_072 equ     DESCALE(3299298341,30-CONST_BITS)       ; FIX(3.072711026)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_idct_islow_sse2)
-
-EXTN(jconst_idct_islow_sse2):
-
-PW_F130_F054    times 4 dw  (F_0_541+F_0_765), F_0_541
-PW_F054_MF130   times 4 dw  F_0_541, (F_0_541-F_1_847)
-PW_MF078_F117   times 4 dw  (F_1_175-F_1_961), F_1_175
-PW_F117_F078    times 4 dw  F_1_175, (F_1_175-F_0_390)
-PW_MF060_MF089  times 4 dw  (F_0_298-F_0_899),-F_0_899
-PW_MF089_F060   times 4 dw -F_0_899, (F_1_501-F_0_899)
-PW_MF050_MF256  times 4 dw  (F_2_053-F_2_562),-F_2_562
-PW_MF256_F050   times 4 dw -F_2_562, (F_3_072-F_2_562)
-PD_DESCALE_P1   times 4 dd  1 << (DESCALE_P1-1)
-PD_DESCALE_P2   times 4 dd  1 << (DESCALE_P2-1)
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Perform dequantization and inverse DCT on one block of coefficients.
-;
-; GLOBAL(void)
-; jsimd_idct_islow_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                        JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-%define dct_table(b)    (b)+8           ; jpeg_component_info *compptr
-%define coef_block(b)   (b)+12          ; JCOEFPTR coef_block
-%define output_buf(b)   (b)+16          ; JSAMPARRAY output_buf
-%define output_col(b)   (b)+20          ; JDIMENSION output_col
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          12
-
-        align   16
-        global  EXTN(jsimd_idct_islow_sse2)
-
-EXTN(jsimd_idct_islow_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic ebx
-;       push    ecx             ; unused
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process columns from input.
-
-;       mov     eax, [original_ebp]
-        mov     edx, POINTER [dct_table(eax)]           ; quantptr
-        mov     esi, JCOEFPTR [coef_block(eax)]         ; inptr
-
-%ifndef NO_ZERO_COLUMN_TEST_ISLOW_SSE2
-        mov     eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        jnz     near .columnDCT
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        por     xmm1,xmm0
-        packsswb xmm1,xmm1
-        packsswb xmm1,xmm1
-        movd    eax,xmm1
-        test    eax,eax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movdqa  xmm5, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm5, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        psllw   xmm5,PASS1_BITS
-
-        movdqa    xmm4,xmm5             ; xmm5=in0=(00 01 02 03 04 05 06 07)
-        punpcklwd xmm5,xmm5             ; xmm5=(00 00 01 01 02 02 03 03)
-        punpckhwd xmm4,xmm4             ; xmm4=(04 04 05 05 06 06 07 07)
-
-        pshufd  xmm7,xmm5,0x00          ; xmm7=col0=(00 00 00 00 00 00 00 00)
-        pshufd  xmm6,xmm5,0x55          ; xmm6=col1=(01 01 01 01 01 01 01 01)
-        pshufd  xmm1,xmm5,0xAA          ; xmm1=col2=(02 02 02 02 02 02 02 02)
-        pshufd  xmm5,xmm5,0xFF          ; xmm5=col3=(03 03 03 03 03 03 03 03)
-        pshufd  xmm0,xmm4,0x00          ; xmm0=col4=(04 04 04 04 04 04 04 04)
-        pshufd  xmm3,xmm4,0x55          ; xmm3=col5=(05 05 05 05 05 05 05 05)
-        pshufd  xmm2,xmm4,0xAA          ; xmm2=col6=(06 06 06 06 06 06 06 06)
-        pshufd  xmm4,xmm4,0xFF          ; xmm4=col7=(07 07 07 07 07 07 07 07)
-
-        movdqa  XMMWORD [wk(8)], xmm6   ; wk(8)=col1
-        movdqa  XMMWORD [wk(9)], xmm5   ; wk(9)=col3
-        movdqa  XMMWORD [wk(10)], xmm3  ; wk(10)=col5
-        movdqa  XMMWORD [wk(11)], xmm4  ; wk(11)=col7
-        jmp     near .column_end
-        alignx  16,7
-%endif
-.columnDCT:
-
-        ; -- Even part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(4,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(4,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        ; (Original)
-        ; z1 = (z2 + z3) * 0.541196100;
-        ; tmp2 = z1 + z3 * -1.847759065;
-        ; tmp3 = z1 + z2 * 0.765366865;
-        ;
-        ; (This implementation)
-        ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
-        ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
-
-        movdqa    xmm4,xmm1             ; xmm1=in2=z2
-        movdqa    xmm5,xmm1
-        punpcklwd xmm4,xmm3             ; xmm3=in6=z3
-        punpckhwd xmm5,xmm3
-        movdqa    xmm1,xmm4
-        movdqa    xmm3,xmm5
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_F130_F054)]       ; xmm4=tmp3L
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F130_F054)]       ; xmm5=tmp3H
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm1=tmp2L
-        pmaddwd   xmm3,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm3=tmp2H
-
-        movdqa    xmm6,xmm0
-        paddw     xmm0,xmm2             ; xmm0=in0+in4
-        psubw     xmm6,xmm2             ; xmm6=in0-in4
-
-        pxor      xmm7,xmm7
-        pxor      xmm2,xmm2
-        punpcklwd xmm7,xmm0             ; xmm7=tmp0L
-        punpckhwd xmm2,xmm0             ; xmm2=tmp0H
-        psrad     xmm7,(16-CONST_BITS)  ; psrad xmm7,16 & pslld xmm7,CONST_BITS
-        psrad     xmm2,(16-CONST_BITS)  ; psrad xmm2,16 & pslld xmm2,CONST_BITS
-
-        movdqa  xmm0,xmm7
-        paddd   xmm7,xmm4               ; xmm7=tmp10L
-        psubd   xmm0,xmm4               ; xmm0=tmp13L
-        movdqa  xmm4,xmm2
-        paddd   xmm2,xmm5               ; xmm2=tmp10H
-        psubd   xmm4,xmm5               ; xmm4=tmp13H
-
-        movdqa  XMMWORD [wk(0)], xmm7   ; wk(0)=tmp10L
-        movdqa  XMMWORD [wk(1)], xmm2   ; wk(1)=tmp10H
-        movdqa  XMMWORD [wk(2)], xmm0   ; wk(2)=tmp13L
-        movdqa  XMMWORD [wk(3)], xmm4   ; wk(3)=tmp13H
-
-        pxor      xmm5,xmm5
-        pxor      xmm7,xmm7
-        punpcklwd xmm5,xmm6             ; xmm5=tmp1L
-        punpckhwd xmm7,xmm6             ; xmm7=tmp1H
-        psrad     xmm5,(16-CONST_BITS)  ; psrad xmm5,16 & pslld xmm5,CONST_BITS
-        psrad     xmm7,(16-CONST_BITS)  ; psrad xmm7,16 & pslld xmm7,CONST_BITS
-
-        movdqa  xmm2,xmm5
-        paddd   xmm5,xmm1               ; xmm5=tmp11L
-        psubd   xmm2,xmm1               ; xmm2=tmp12L
-        movdqa  xmm0,xmm7
-        paddd   xmm7,xmm3               ; xmm7=tmp11H
-        psubd   xmm0,xmm3               ; xmm0=tmp12H
-
-        movdqa  XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
-        movdqa  XMMWORD [wk(5)], xmm7   ; wk(5)=tmp11H
-        movdqa  XMMWORD [wk(6)], xmm2   ; wk(6)=tmp12L
-        movdqa  XMMWORD [wk(7)], xmm0   ; wk(7)=tmp12H
-
-        ; -- Odd part
-
-        movdqa  xmm4, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm6, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm4, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm6, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        movdqa  xmm5,xmm6
-        movdqa  xmm7,xmm4
-        paddw   xmm5,xmm3               ; xmm5=z3
-        paddw   xmm7,xmm1               ; xmm7=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm2,xmm5
-        movdqa    xmm0,xmm5
-        punpcklwd xmm2,xmm7
-        punpckhwd xmm0,xmm7
-        movdqa    xmm5,xmm2
-        movdqa    xmm7,xmm0
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm2=z3L
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm0=z3H
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F117_F078)]       ; xmm5=z4L
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_F117_F078)]       ; xmm7=z4H
-
-        movdqa  XMMWORD [wk(10)], xmm2  ; wk(10)=z3L
-        movdqa  XMMWORD [wk(11)], xmm0  ; wk(11)=z3H
-
-        ; (Original)
-        ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
-        ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
-        ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
-        ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
-        ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
-        ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
-        ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
-        ; tmp0 += z3;  tmp1 += z4;
-        ; tmp2 += z3;  tmp3 += z4;
-
-        movdqa    xmm2,xmm3
-        movdqa    xmm0,xmm3
-        punpcklwd xmm2,xmm4
-        punpckhwd xmm0,xmm4
-        movdqa    xmm3,xmm2
-        movdqa    xmm4,xmm0
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm2=tmp0L
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm0=tmp0H
-        pmaddwd   xmm3,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm3=tmp3L
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm4=tmp3H
-
-        paddd   xmm2, XMMWORD [wk(10)]  ; xmm2=tmp0L
-        paddd   xmm0, XMMWORD [wk(11)]  ; xmm0=tmp0H
-        paddd   xmm3,xmm5               ; xmm3=tmp3L
-        paddd   xmm4,xmm7               ; xmm4=tmp3H
-
-        movdqa  XMMWORD [wk(8)], xmm2   ; wk(8)=tmp0L
-        movdqa  XMMWORD [wk(9)], xmm0   ; wk(9)=tmp0H
-
-        movdqa    xmm2,xmm1
-        movdqa    xmm0,xmm1
-        punpcklwd xmm2,xmm6
-        punpckhwd xmm0,xmm6
-        movdqa    xmm1,xmm2
-        movdqa    xmm6,xmm0
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm2=tmp1L
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm0=tmp1H
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm1=tmp2L
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm6=tmp2H
-
-        paddd   xmm2,xmm5               ; xmm2=tmp1L
-        paddd   xmm0,xmm7               ; xmm0=tmp1H
-        paddd   xmm1, XMMWORD [wk(10)]  ; xmm1=tmp2L
-        paddd   xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
-
-        movdqa  XMMWORD [wk(10)], xmm2  ; wk(10)=tmp1L
-        movdqa  XMMWORD [wk(11)], xmm0  ; wk(11)=tmp1H
-
-        ; -- Final output stage
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
-        movdqa  xmm7, XMMWORD [wk(1)]   ; xmm7=tmp10H
-
-        movdqa  xmm2,xmm5
-        movdqa  xmm0,xmm7
-        paddd   xmm5,xmm3               ; xmm5=data0L
-        paddd   xmm7,xmm4               ; xmm7=data0H
-        psubd   xmm2,xmm3               ; xmm2=data7L
-        psubd   xmm0,xmm4               ; xmm0=data7H
-
-        movdqa  xmm3,[GOTOFF(ebx,PD_DESCALE_P1)]        ; xmm3=[PD_DESCALE_P1]
-
-        paddd   xmm5,xmm3
-        paddd   xmm7,xmm3
-        psrad   xmm5,DESCALE_P1
-        psrad   xmm7,DESCALE_P1
-        paddd   xmm2,xmm3
-        paddd   xmm0,xmm3
-        psrad   xmm2,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-
-        packssdw  xmm5,xmm7             ; xmm5=data0=(00 01 02 03 04 05 06 07)
-        packssdw  xmm2,xmm0             ; xmm2=data7=(70 71 72 73 74 75 76 77)
-
-        movdqa  xmm4, XMMWORD [wk(4)]   ; xmm4=tmp11L
-        movdqa  xmm3, XMMWORD [wk(5)]   ; xmm3=tmp11H
-
-        movdqa  xmm7,xmm4
-        movdqa  xmm0,xmm3
-        paddd   xmm4,xmm1               ; xmm4=data1L
-        paddd   xmm3,xmm6               ; xmm3=data1H
-        psubd   xmm7,xmm1               ; xmm7=data6L
-        psubd   xmm0,xmm6               ; xmm0=data6H
-
-        movdqa  xmm1,[GOTOFF(ebx,PD_DESCALE_P1)]        ; xmm1=[PD_DESCALE_P1]
-
-        paddd   xmm4,xmm1
-        paddd   xmm3,xmm1
-        psrad   xmm4,DESCALE_P1
-        psrad   xmm3,DESCALE_P1
-        paddd   xmm7,xmm1
-        paddd   xmm0,xmm1
-        psrad   xmm7,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-
-        packssdw  xmm4,xmm3             ; xmm4=data1=(10 11 12 13 14 15 16 17)
-        packssdw  xmm7,xmm0             ; xmm7=data6=(60 61 62 63 64 65 66 67)
-
-        movdqa    xmm6,xmm5             ; transpose coefficients(phase 1)
-        punpcklwd xmm5,xmm4             ; xmm5=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm6,xmm4             ; xmm6=(04 14 05 15 06 16 07 17)
-        movdqa    xmm1,xmm7             ; transpose coefficients(phase 1)
-        punpcklwd xmm7,xmm2             ; xmm7=(60 70 61 71 62 72 63 73)
-        punpckhwd xmm1,xmm2             ; xmm1=(64 74 65 75 66 76 67 77)
-
-        movdqa  xmm3, XMMWORD [wk(6)]   ; xmm3=tmp12L
-        movdqa  xmm0, XMMWORD [wk(7)]   ; xmm0=tmp12H
-        movdqa  xmm4, XMMWORD [wk(10)]  ; xmm4=tmp1L
-        movdqa  xmm2, XMMWORD [wk(11)]  ; xmm2=tmp1H
-
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 01 11 02 12 03 13)
-        movdqa  XMMWORD [wk(1)], xmm6   ; wk(1)=(04 14 05 15 06 16 07 17)
-        movdqa  XMMWORD [wk(4)], xmm7   ; wk(4)=(60 70 61 71 62 72 63 73)
-        movdqa  XMMWORD [wk(5)], xmm1   ; wk(5)=(64 74 65 75 66 76 67 77)
-
-        movdqa  xmm5,xmm3
-        movdqa  xmm6,xmm0
-        paddd   xmm3,xmm4               ; xmm3=data2L
-        paddd   xmm0,xmm2               ; xmm0=data2H
-        psubd   xmm5,xmm4               ; xmm5=data5L
-        psubd   xmm6,xmm2               ; xmm6=data5H
-
-        movdqa  xmm7,[GOTOFF(ebx,PD_DESCALE_P1)]        ; xmm7=[PD_DESCALE_P1]
-
-        paddd   xmm3,xmm7
-        paddd   xmm0,xmm7
-        psrad   xmm3,DESCALE_P1
-        psrad   xmm0,DESCALE_P1
-        paddd   xmm5,xmm7
-        paddd   xmm6,xmm7
-        psrad   xmm5,DESCALE_P1
-        psrad   xmm6,DESCALE_P1
-
-        packssdw  xmm3,xmm0             ; xmm3=data2=(20 21 22 23 24 25 26 27)
-        packssdw  xmm5,xmm6             ; xmm5=data5=(50 51 52 53 54 55 56 57)
-
-        movdqa  xmm1, XMMWORD [wk(2)]   ; xmm1=tmp13L
-        movdqa  xmm4, XMMWORD [wk(3)]   ; xmm4=tmp13H
-        movdqa  xmm2, XMMWORD [wk(8)]   ; xmm2=tmp0L
-        movdqa  xmm7, XMMWORD [wk(9)]   ; xmm7=tmp0H
-
-        movdqa  xmm0,xmm1
-        movdqa  xmm6,xmm4
-        paddd   xmm1,xmm2               ; xmm1=data3L
-        paddd   xmm4,xmm7               ; xmm4=data3H
-        psubd   xmm0,xmm2               ; xmm0=data4L
-        psubd   xmm6,xmm7               ; xmm6=data4H
-
-        movdqa  xmm2,[GOTOFF(ebx,PD_DESCALE_P1)]        ; xmm2=[PD_DESCALE_P1]
-
-        paddd   xmm1,xmm2
-        paddd   xmm4,xmm2
-        psrad   xmm1,DESCALE_P1
-        psrad   xmm4,DESCALE_P1
-        paddd   xmm0,xmm2
-        paddd   xmm6,xmm2
-        psrad   xmm0,DESCALE_P1
-        psrad   xmm6,DESCALE_P1
-
-        packssdw  xmm1,xmm4             ; xmm1=data3=(30 31 32 33 34 35 36 37)
-        packssdw  xmm0,xmm6             ; xmm0=data4=(40 41 42 43 44 45 46 47)
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=(00 10 01 11 02 12 03 13)
-        movdqa  xmm2, XMMWORD [wk(1)]   ; xmm2=(04 14 05 15 06 16 07 17)
-
-        movdqa    xmm4,xmm3             ; transpose coefficients(phase 1)
-        punpcklwd xmm3,xmm1             ; xmm3=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm4,xmm1             ; xmm4=(24 34 25 35 26 36 27 37)
-        movdqa    xmm6,xmm0             ; transpose coefficients(phase 1)
-        punpcklwd xmm0,xmm5             ; xmm0=(40 50 41 51 42 52 43 53)
-        punpckhwd xmm6,xmm5             ; xmm6=(44 54 45 55 46 56 47 57)
-
-        movdqa    xmm1,xmm7             ; transpose coefficients(phase 2)
-        punpckldq xmm7,xmm3             ; xmm7=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm1,xmm3             ; xmm1=(02 12 22 32 03 13 23 33)
-        movdqa    xmm5,xmm2             ; transpose coefficients(phase 2)
-        punpckldq xmm2,xmm4             ; xmm2=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm5,xmm4             ; xmm5=(06 16 26 36 07 17 27 37)
-
-        movdqa  xmm3, XMMWORD [wk(4)]   ; xmm3=(60 70 61 71 62 72 63 73)
-        movdqa  xmm4, XMMWORD [wk(5)]   ; xmm4=(64 74 65 75 66 76 67 77)
-
-        movdqa  XMMWORD [wk(6)], xmm2   ; wk(6)=(04 14 24 34 05 15 25 35)
-        movdqa  XMMWORD [wk(7)], xmm5   ; wk(7)=(06 16 26 36 07 17 27 37)
-
-        movdqa    xmm2,xmm0             ; transpose coefficients(phase 2)
-        punpckldq xmm0,xmm3             ; xmm0=(40 50 60 70 41 51 61 71)
-        punpckhdq xmm2,xmm3             ; xmm2=(42 52 62 72 43 53 63 73)
-        movdqa    xmm5,xmm6             ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm4             ; xmm6=(44 54 64 74 45 55 65 75)
-        punpckhdq xmm5,xmm4             ; xmm5=(46 56 66 76 47 57 67 77)
-
-        movdqa     xmm3,xmm7            ; transpose coefficients(phase 3)
-        punpcklqdq xmm7,xmm0            ; xmm7=col0=(00 10 20 30 40 50 60 70)
-        punpckhqdq xmm3,xmm0            ; xmm3=col1=(01 11 21 31 41 51 61 71)
-        movdqa     xmm4,xmm1            ; transpose coefficients(phase 3)
-        punpcklqdq xmm1,xmm2            ; xmm1=col2=(02 12 22 32 42 52 62 72)
-        punpckhqdq xmm4,xmm2            ; xmm4=col3=(03 13 23 33 43 53 63 73)
-
-        movdqa  xmm0, XMMWORD [wk(6)]   ; xmm0=(04 14 24 34 05 15 25 35)
-        movdqa  xmm2, XMMWORD [wk(7)]   ; xmm2=(06 16 26 36 07 17 27 37)
-
-        movdqa  XMMWORD [wk(8)], xmm3   ; wk(8)=col1
-        movdqa  XMMWORD [wk(9)], xmm4   ; wk(9)=col3
-
-        movdqa     xmm3,xmm0            ; transpose coefficients(phase 3)
-        punpcklqdq xmm0,xmm6            ; xmm0=col4=(04 14 24 34 44 54 64 74)
-        punpckhqdq xmm3,xmm6            ; xmm3=col5=(05 15 25 35 45 55 65 75)
-        movdqa     xmm4,xmm2            ; transpose coefficients(phase 3)
-        punpcklqdq xmm2,xmm5            ; xmm2=col6=(06 16 26 36 46 56 66 76)
-        punpckhqdq xmm4,xmm5            ; xmm4=col7=(07 17 27 37 47 57 67 77)
-
-        movdqa  XMMWORD [wk(10)], xmm3  ; wk(10)=col5
-        movdqa  XMMWORD [wk(11)], xmm4  ; wk(11)=col7
-.column_end:
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows from work array, store into output array.
-
-        mov     eax, [original_ebp]
-        mov     edi, JSAMPARRAY [output_buf(eax)]       ; (JSAMPROW *)
-        mov     eax, JDIMENSION [output_col(eax)]
-
-        ; -- Even part
-
-        ; xmm7=col0, xmm1=col2, xmm0=col4, xmm2=col6
-
-        ; (Original)
-        ; z1 = (z2 + z3) * 0.541196100;
-        ; tmp2 = z1 + z3 * -1.847759065;
-        ; tmp3 = z1 + z2 * 0.765366865;
-        ;
-        ; (This implementation)
-        ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
-        ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
-
-        movdqa    xmm6,xmm1             ; xmm1=in2=z2
-        movdqa    xmm5,xmm1
-        punpcklwd xmm6,xmm2             ; xmm2=in6=z3
-        punpckhwd xmm5,xmm2
-        movdqa    xmm1,xmm6
-        movdqa    xmm2,xmm5
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_F130_F054)]       ; xmm6=tmp3L
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F130_F054)]       ; xmm5=tmp3H
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm1=tmp2L
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_F054_MF130)]      ; xmm2=tmp2H
-
-        movdqa    xmm3,xmm7
-        paddw     xmm7,xmm0             ; xmm7=in0+in4
-        psubw     xmm3,xmm0             ; xmm3=in0-in4
-
-        pxor      xmm4,xmm4
-        pxor      xmm0,xmm0
-        punpcklwd xmm4,xmm7             ; xmm4=tmp0L
-        punpckhwd xmm0,xmm7             ; xmm0=tmp0H
-        psrad     xmm4,(16-CONST_BITS)  ; psrad xmm4,16 & pslld xmm4,CONST_BITS
-        psrad     xmm0,(16-CONST_BITS)  ; psrad xmm0,16 & pslld xmm0,CONST_BITS
-
-        movdqa  xmm7,xmm4
-        paddd   xmm4,xmm6               ; xmm4=tmp10L
-        psubd   xmm7,xmm6               ; xmm7=tmp13L
-        movdqa  xmm6,xmm0
-        paddd   xmm0,xmm5               ; xmm0=tmp10H
-        psubd   xmm6,xmm5               ; xmm6=tmp13H
-
-        movdqa  XMMWORD [wk(0)], xmm4   ; wk(0)=tmp10L
-        movdqa  XMMWORD [wk(1)], xmm0   ; wk(1)=tmp10H
-        movdqa  XMMWORD [wk(2)], xmm7   ; wk(2)=tmp13L
-        movdqa  XMMWORD [wk(3)], xmm6   ; wk(3)=tmp13H
-
-        pxor      xmm5,xmm5
-        pxor      xmm4,xmm4
-        punpcklwd xmm5,xmm3             ; xmm5=tmp1L
-        punpckhwd xmm4,xmm3             ; xmm4=tmp1H
-        psrad     xmm5,(16-CONST_BITS)  ; psrad xmm5,16 & pslld xmm5,CONST_BITS
-        psrad     xmm4,(16-CONST_BITS)  ; psrad xmm4,16 & pslld xmm4,CONST_BITS
-
-        movdqa  xmm0,xmm5
-        paddd   xmm5,xmm1               ; xmm5=tmp11L
-        psubd   xmm0,xmm1               ; xmm0=tmp12L
-        movdqa  xmm7,xmm4
-        paddd   xmm4,xmm2               ; xmm4=tmp11H
-        psubd   xmm7,xmm2               ; xmm7=tmp12H
-
-        movdqa  XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
-        movdqa  XMMWORD [wk(5)], xmm4   ; wk(5)=tmp11H
-        movdqa  XMMWORD [wk(6)], xmm0   ; wk(6)=tmp12L
-        movdqa  XMMWORD [wk(7)], xmm7   ; wk(7)=tmp12H
-
-        ; -- Odd part
-
-        movdqa  xmm6, XMMWORD [wk(9)]   ; xmm6=col3
-        movdqa  xmm3, XMMWORD [wk(8)]   ; xmm3=col1
-        movdqa  xmm1, XMMWORD [wk(11)]  ; xmm1=col7
-        movdqa  xmm2, XMMWORD [wk(10)]  ; xmm2=col5
-
-        movdqa  xmm5,xmm6
-        movdqa  xmm4,xmm3
-        paddw   xmm5,xmm1               ; xmm5=z3
-        paddw   xmm4,xmm2               ; xmm4=z4
-
-        ; (Original)
-        ; z5 = (z3 + z4) * 1.175875602;
-        ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
-        ; z3 += z5;  z4 += z5;
-        ;
-        ; (This implementation)
-        ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
-        ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
-
-        movdqa    xmm0,xmm5
-        movdqa    xmm7,xmm5
-        punpcklwd xmm0,xmm4
-        punpckhwd xmm7,xmm4
-        movdqa    xmm5,xmm0
-        movdqa    xmm4,xmm7
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm0=z3L
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_MF078_F117)]      ; xmm7=z3H
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F117_F078)]       ; xmm5=z4L
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_F117_F078)]       ; xmm4=z4H
-
-        movdqa  XMMWORD [wk(10)], xmm0  ; wk(10)=z3L
-        movdqa  XMMWORD [wk(11)], xmm7  ; wk(11)=z3H
-
-        ; (Original)
-        ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
-        ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
-        ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
-        ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
-        ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
-        ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
-        ;
-        ; (This implementation)
-        ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
-        ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
-        ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
-        ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
-        ; tmp0 += z3;  tmp1 += z4;
-        ; tmp2 += z3;  tmp3 += z4;
-
-        movdqa    xmm0,xmm1
-        movdqa    xmm7,xmm1
-        punpcklwd xmm0,xmm3
-        punpckhwd xmm7,xmm3
-        movdqa    xmm1,xmm0
-        movdqa    xmm3,xmm7
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm0=tmp0L
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_MF060_MF089)]     ; xmm7=tmp0H
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm1=tmp3L
-        pmaddwd   xmm3,[GOTOFF(ebx,PW_MF089_F060)]      ; xmm3=tmp3H
-
-        paddd   xmm0, XMMWORD [wk(10)]  ; xmm0=tmp0L
-        paddd   xmm7, XMMWORD [wk(11)]  ; xmm7=tmp0H
-        paddd   xmm1,xmm5               ; xmm1=tmp3L
-        paddd   xmm3,xmm4               ; xmm3=tmp3H
-
-        movdqa  XMMWORD [wk(8)], xmm0   ; wk(8)=tmp0L
-        movdqa  XMMWORD [wk(9)], xmm7   ; wk(9)=tmp0H
-
-        movdqa    xmm0,xmm2
-        movdqa    xmm7,xmm2
-        punpcklwd xmm0,xmm6
-        punpckhwd xmm7,xmm6
-        movdqa    xmm2,xmm0
-        movdqa    xmm6,xmm7
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm0=tmp1L
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_MF050_MF256)]     ; xmm7=tmp1H
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm2=tmp2L
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_MF256_F050)]      ; xmm6=tmp2H
-
-        paddd   xmm0,xmm5               ; xmm0=tmp1L
-        paddd   xmm7,xmm4               ; xmm7=tmp1H
-        paddd   xmm2, XMMWORD [wk(10)]  ; xmm2=tmp2L
-        paddd   xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
-
-        movdqa  XMMWORD [wk(10)], xmm0  ; wk(10)=tmp1L
-        movdqa  XMMWORD [wk(11)], xmm7  ; wk(11)=tmp1H
-
-        ; -- Final output stage
-
-        movdqa  xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
-        movdqa  xmm4, XMMWORD [wk(1)]   ; xmm4=tmp10H
-
-        movdqa  xmm0,xmm5
-        movdqa  xmm7,xmm4
-        paddd   xmm5,xmm1               ; xmm5=data0L
-        paddd   xmm4,xmm3               ; xmm4=data0H
-        psubd   xmm0,xmm1               ; xmm0=data7L
-        psubd   xmm7,xmm3               ; xmm7=data7H
-
-        movdqa  xmm1,[GOTOFF(ebx,PD_DESCALE_P2)]        ; xmm1=[PD_DESCALE_P2]
-
-        paddd   xmm5,xmm1
-        paddd   xmm4,xmm1
-        psrad   xmm5,DESCALE_P2
-        psrad   xmm4,DESCALE_P2
-        paddd   xmm0,xmm1
-        paddd   xmm7,xmm1
-        psrad   xmm0,DESCALE_P2
-        psrad   xmm7,DESCALE_P2
-
-        packssdw  xmm5,xmm4             ; xmm5=data0=(00 10 20 30 40 50 60 70)
-        packssdw  xmm0,xmm7             ; xmm0=data7=(07 17 27 37 47 57 67 77)
-
-        movdqa  xmm3, XMMWORD [wk(4)]   ; xmm3=tmp11L
-        movdqa  xmm1, XMMWORD [wk(5)]   ; xmm1=tmp11H
-
-        movdqa  xmm4,xmm3
-        movdqa  xmm7,xmm1
-        paddd   xmm3,xmm2               ; xmm3=data1L
-        paddd   xmm1,xmm6               ; xmm1=data1H
-        psubd   xmm4,xmm2               ; xmm4=data6L
-        psubd   xmm7,xmm6               ; xmm7=data6H
-
-        movdqa  xmm2,[GOTOFF(ebx,PD_DESCALE_P2)]        ; xmm2=[PD_DESCALE_P2]
-
-        paddd   xmm3,xmm2
-        paddd   xmm1,xmm2
-        psrad   xmm3,DESCALE_P2
-        psrad   xmm1,DESCALE_P2
-        paddd   xmm4,xmm2
-        paddd   xmm7,xmm2
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm7,DESCALE_P2
-
-        packssdw  xmm3,xmm1             ; xmm3=data1=(01 11 21 31 41 51 61 71)
-        packssdw  xmm4,xmm7             ; xmm4=data6=(06 16 26 36 46 56 66 76)
-
-        packsswb  xmm5,xmm4             ; xmm5=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        packsswb  xmm3,xmm0             ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        movdqa  xmm6, XMMWORD [wk(6)]   ; xmm6=tmp12L
-        movdqa  xmm2, XMMWORD [wk(7)]   ; xmm2=tmp12H
-        movdqa  xmm1, XMMWORD [wk(10)]  ; xmm1=tmp1L
-        movdqa  xmm7, XMMWORD [wk(11)]  ; xmm7=tmp1H
-
-        movdqa  XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        movdqa  xmm4,xmm6
-        movdqa  xmm0,xmm2
-        paddd   xmm6,xmm1               ; xmm6=data2L
-        paddd   xmm2,xmm7               ; xmm2=data2H
-        psubd   xmm4,xmm1               ; xmm4=data5L
-        psubd   xmm0,xmm7               ; xmm0=data5H
-
-        movdqa  xmm5,[GOTOFF(ebx,PD_DESCALE_P2)]        ; xmm5=[PD_DESCALE_P2]
-
-        paddd   xmm6,xmm5
-        paddd   xmm2,xmm5
-        psrad   xmm6,DESCALE_P2
-        psrad   xmm2,DESCALE_P2
-        paddd   xmm4,xmm5
-        paddd   xmm0,xmm5
-        psrad   xmm4,DESCALE_P2
-        psrad   xmm0,DESCALE_P2
-
-        packssdw  xmm6,xmm2             ; xmm6=data2=(02 12 22 32 42 52 62 72)
-        packssdw  xmm4,xmm0             ; xmm4=data5=(05 15 25 35 45 55 65 75)
-
-        movdqa  xmm3, XMMWORD [wk(2)]   ; xmm3=tmp13L
-        movdqa  xmm1, XMMWORD [wk(3)]   ; xmm1=tmp13H
-        movdqa  xmm7, XMMWORD [wk(8)]   ; xmm7=tmp0L
-        movdqa  xmm5, XMMWORD [wk(9)]   ; xmm5=tmp0H
-
-        movdqa  xmm2,xmm3
-        movdqa  xmm0,xmm1
-        paddd   xmm3,xmm7               ; xmm3=data3L
-        paddd   xmm1,xmm5               ; xmm1=data3H
-        psubd   xmm2,xmm7               ; xmm2=data4L
-        psubd   xmm0,xmm5               ; xmm0=data4H
-
-        movdqa  xmm7,[GOTOFF(ebx,PD_DESCALE_P2)]        ; xmm7=[PD_DESCALE_P2]
-
-        paddd   xmm3,xmm7
-        paddd   xmm1,xmm7
-        psrad   xmm3,DESCALE_P2
-        psrad   xmm1,DESCALE_P2
-        paddd   xmm2,xmm7
-        paddd   xmm0,xmm7
-        psrad   xmm2,DESCALE_P2
-        psrad   xmm0,DESCALE_P2
-
-        movdqa    xmm5,[GOTOFF(ebx,PB_CENTERJSAMP)]     ; xmm5=[PB_CENTERJSAMP]
-
-        packssdw  xmm3,xmm1             ; xmm3=data3=(03 13 23 33 43 53 63 73)
-        packssdw  xmm2,xmm0             ; xmm2=data4=(04 14 24 34 44 54 64 74)
-
-        movdqa    xmm7, XMMWORD [wk(0)] ; xmm7=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
-        movdqa    xmm1, XMMWORD [wk(1)] ; xmm1=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
-
-        packsswb  xmm6,xmm2             ; xmm6=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
-        packsswb  xmm3,xmm4             ; xmm3=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
-
-        paddb     xmm7,xmm5
-        paddb     xmm1,xmm5
-        paddb     xmm6,xmm5
-        paddb     xmm3,xmm5
-
-        movdqa    xmm0,xmm7     ; transpose coefficients(phase 1)
-        punpcklbw xmm7,xmm1     ; xmm7=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
-        punpckhbw xmm0,xmm1     ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
-        movdqa    xmm2,xmm6     ; transpose coefficients(phase 1)
-        punpcklbw xmm6,xmm3     ; xmm6=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
-        punpckhbw xmm2,xmm3     ; xmm2=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
-
-        movdqa    xmm4,xmm7     ; transpose coefficients(phase 2)
-        punpcklwd xmm7,xmm6     ; xmm7=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
-        punpckhwd xmm4,xmm6     ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
-        movdqa    xmm5,xmm2     ; transpose coefficients(phase 2)
-        punpcklwd xmm2,xmm0     ; xmm2=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
-        punpckhwd xmm5,xmm0     ; xmm5=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
-
-        movdqa    xmm1,xmm7     ; transpose coefficients(phase 3)
-        punpckldq xmm7,xmm2     ; xmm7=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
-        punpckhdq xmm1,xmm2     ; xmm1=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
-        movdqa    xmm3,xmm4     ; transpose coefficients(phase 3)
-        punpckldq xmm4,xmm5     ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
-        punpckhdq xmm3,xmm5     ; xmm3=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
-
-        pshufd  xmm6,xmm7,0x4E  ; xmm6=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
-        pshufd  xmm0,xmm1,0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
-        pshufd  xmm2,xmm4,0x4E  ; xmm2=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
-        pshufd  xmm5,xmm3,0x4E  ; xmm5=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
-
-        mov     edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm7
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm1
-        mov     edx, JSAMPROW [edi+4*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+6*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm4
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm3
-
-        mov     edx, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm6
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm0
-        mov     edx, JSAMPROW [edi+5*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+7*SIZEOF_JSAMPROW]
-        movq    XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE], xmm2
-        movq    XMM_MMWORD [esi+eax*SIZEOF_JSAMPLE], xmm5
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; unused
-        poppic  ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctred-sse2-64.asm b/simd/jidctred-sse2-64.asm
deleted file mode 100644
index a54bbe2..0000000
--- a/simd/jidctred-sse2-64.asm
+++ /dev/null
@@ -1,575 +0,0 @@
-;
-; jidctred.asm - reduced-size IDCT (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains inverse-DCT routines that produce reduced-size
-; output: either 4x4 or 2x2 pixels from an 8x8 DCT block.
-; The following code is based directly on the IJG's original jidctred.c;
-; see the jidctred.c for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      13
-%define PASS1_BITS      2
-
-%define DESCALE_P1_4    (CONST_BITS-PASS1_BITS+1)
-%define DESCALE_P2_4    (CONST_BITS+PASS1_BITS+3+1)
-%define DESCALE_P1_2    (CONST_BITS-PASS1_BITS+2)
-%define DESCALE_P2_2    (CONST_BITS+PASS1_BITS+3+2)
-
-%if CONST_BITS == 13
-F_0_211 equ      1730           ; FIX(0.211164243)
-F_0_509 equ      4176           ; FIX(0.509795579)
-F_0_601 equ      4926           ; FIX(0.601344887)
-F_0_720 equ      5906           ; FIX(0.720959822)
-F_0_765 equ      6270           ; FIX(0.765366865)
-F_0_850 equ      6967           ; FIX(0.850430095)
-F_0_899 equ      7373           ; FIX(0.899976223)
-F_1_061 equ      8697           ; FIX(1.061594337)
-F_1_272 equ     10426           ; FIX(1.272758580)
-F_1_451 equ     11893           ; FIX(1.451774981)
-F_1_847 equ     15137           ; FIX(1.847759065)
-F_2_172 equ     17799           ; FIX(2.172734803)
-F_2_562 equ     20995           ; FIX(2.562915447)
-F_3_624 equ     29692           ; FIX(3.624509785)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_211 equ     DESCALE( 226735879,30-CONST_BITS)       ; FIX(0.211164243)
-F_0_509 equ     DESCALE( 547388834,30-CONST_BITS)       ; FIX(0.509795579)
-F_0_601 equ     DESCALE( 645689155,30-CONST_BITS)       ; FIX(0.601344887)
-F_0_720 equ     DESCALE( 774124714,30-CONST_BITS)       ; FIX(0.720959822)
-F_0_765 equ     DESCALE( 821806413,30-CONST_BITS)       ; FIX(0.765366865)
-F_0_850 equ     DESCALE( 913142361,30-CONST_BITS)       ; FIX(0.850430095)
-F_0_899 equ     DESCALE( 966342111,30-CONST_BITS)       ; FIX(0.899976223)
-F_1_061 equ     DESCALE(1139878239,30-CONST_BITS)       ; FIX(1.061594337)
-F_1_272 equ     DESCALE(1366614119,30-CONST_BITS)       ; FIX(1.272758580)
-F_1_451 equ     DESCALE(1558831516,30-CONST_BITS)       ; FIX(1.451774981)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_2_172 equ     DESCALE(2332956230,30-CONST_BITS)       ; FIX(2.172734803)
-F_2_562 equ     DESCALE(2751909506,30-CONST_BITS)       ; FIX(2.562915447)
-F_3_624 equ     DESCALE(3891787747,30-CONST_BITS)       ; FIX(3.624509785)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_idct_red_sse2)
-
-EXTN(jconst_idct_red_sse2):
-
-PW_F184_MF076   times 4 dw  F_1_847,-F_0_765
-PW_F256_F089    times 4 dw  F_2_562, F_0_899
-PW_F106_MF217   times 4 dw  F_1_061,-F_2_172
-PW_MF060_MF050  times 4 dw -F_0_601,-F_0_509
-PW_F145_MF021   times 4 dw  F_1_451,-F_0_211
-PW_F362_MF127   times 4 dw  F_3_624,-F_1_272
-PW_F085_MF072   times 4 dw  F_0_850,-F_0_720
-PD_DESCALE_P1_4 times 4 dd  1 << (DESCALE_P1_4-1)
-PD_DESCALE_P2_4 times 4 dd  1 << (DESCALE_P2_4-1)
-PD_DESCALE_P1_2 times 4 dd  1 << (DESCALE_P1_2-1)
-PD_DESCALE_P2_2 times 4 dd  1 << (DESCALE_P2_2-1)
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Perform dequantization and inverse DCT on one block of coefficients,
-; producing a reduced-size 4x4 output block.
-;
-; GLOBAL(void)
-; jsimd_idct_4x4_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                      JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-; r10 = void *dct_table
-; r11 = JCOEFPTR coef_block
-; r12 = JSAMPARRAY output_buf
-; r13 = JDIMENSION output_col
-
-%define original_rbp    rbp+0
-%define wk(i)           rbp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_idct_4x4_sse2)
-
-EXTN(jsimd_idct_4x4_sse2):
-        push    rbp
-        mov     rax,rsp                         ; rax = original rbp
-        sub     rsp, byte 4
-        and     rsp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [rsp],rax
-        mov     rbp,rsp                         ; rbp = aligned rbp
-        lea     rsp, [wk(0)]
-        collect_args
-
-        ; ---- Pass 1: process columns from input.
-
-        mov     rdx, r10                ; quantptr
-        mov     rsi, r11                ; inptr
-
-%ifndef NO_ZERO_COLUMN_TEST_4X4_SSE2
-        mov     eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        jnz     short .columnDCT
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        por     xmm0,xmm1
-        packsswb xmm0,xmm0
-        packsswb xmm0,xmm0
-        movd    eax,xmm0
-        test    rax,rax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        psllw   xmm0,PASS1_BITS
-
-        movdqa    xmm3,xmm0     ; xmm0=in0=(00 01 02 03 04 05 06 07)
-        punpcklwd xmm0,xmm0     ; xmm0=(00 00 01 01 02 02 03 03)
-        punpckhwd xmm3,xmm3     ; xmm3=(04 04 05 05 06 06 07 07)
-
-        pshufd  xmm1,xmm0,0x50  ; xmm1=[col0 col1]=(00 00 00 00 01 01 01 01)
-        pshufd  xmm0,xmm0,0xFA  ; xmm0=[col2 col3]=(02 02 02 02 03 03 03 03)
-        pshufd  xmm6,xmm3,0x50  ; xmm6=[col4 col5]=(04 04 04 04 05 05 05 05)
-        pshufd  xmm3,xmm3,0xFA  ; xmm3=[col6 col7]=(06 06 06 06 07 07 07 07)
-
-        jmp     near .column_end
-%endif
-.columnDCT:
-
-        ; -- Odd part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        movdqa    xmm4,xmm0
-        movdqa    xmm5,xmm0
-        punpcklwd xmm4,xmm1
-        punpckhwd xmm5,xmm1
-        movdqa    xmm0,xmm4
-        movdqa    xmm1,xmm5
-        pmaddwd   xmm4,[rel PW_F256_F089]       ; xmm4=(tmp2L)
-        pmaddwd   xmm5,[rel PW_F256_F089]       ; xmm5=(tmp2H)
-        pmaddwd   xmm0,[rel PW_F106_MF217]      ; xmm0=(tmp0L)
-        pmaddwd   xmm1,[rel PW_F106_MF217]      ; xmm1=(tmp0H)
-
-        movdqa    xmm6,xmm2
-        movdqa    xmm7,xmm2
-        punpcklwd xmm6,xmm3
-        punpckhwd xmm7,xmm3
-        movdqa    xmm2,xmm6
-        movdqa    xmm3,xmm7
-        pmaddwd   xmm6,[rel PW_MF060_MF050]     ; xmm6=(tmp2L)
-        pmaddwd   xmm7,[rel PW_MF060_MF050]     ; xmm7=(tmp2H)
-        pmaddwd   xmm2,[rel PW_F145_MF021]      ; xmm2=(tmp0L)
-        pmaddwd   xmm3,[rel PW_F145_MF021]      ; xmm3=(tmp0H)
-
-        paddd   xmm6,xmm4               ; xmm6=tmp2L
-        paddd   xmm7,xmm5               ; xmm7=tmp2H
-        paddd   xmm2,xmm0               ; xmm2=tmp0L
-        paddd   xmm3,xmm1               ; xmm3=tmp0H
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=tmp0L
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=tmp0H
-
-        ; -- Even part
-
-        movdqa  xmm4, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm5, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm0, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm4, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm5, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        pxor      xmm1,xmm1
-        pxor      xmm2,xmm2
-        punpcklwd xmm1,xmm4             ; xmm1=tmp0L
-        punpckhwd xmm2,xmm4             ; xmm2=tmp0H
-        psrad     xmm1,(16-CONST_BITS-1) ; psrad xmm1,16 & pslld xmm1,CONST_BITS+1
-        psrad     xmm2,(16-CONST_BITS-1) ; psrad xmm2,16 & pslld xmm2,CONST_BITS+1
-
-        movdqa    xmm3,xmm5             ; xmm5=in2=z2
-        punpcklwd xmm5,xmm0             ; xmm0=in6=z3
-        punpckhwd xmm3,xmm0
-        pmaddwd   xmm5,[rel PW_F184_MF076]      ; xmm5=tmp2L
-        pmaddwd   xmm3,[rel PW_F184_MF076]      ; xmm3=tmp2H
-
-        movdqa  xmm4,xmm1
-        movdqa  xmm0,xmm2
-        paddd   xmm1,xmm5               ; xmm1=tmp10L
-        paddd   xmm2,xmm3               ; xmm2=tmp10H
-        psubd   xmm4,xmm5               ; xmm4=tmp12L
-        psubd   xmm0,xmm3               ; xmm0=tmp12H
-
-        ; -- Final output stage
-
-        movdqa  xmm5,xmm1
-        movdqa  xmm3,xmm2
-        paddd   xmm1,xmm6               ; xmm1=data0L
-        paddd   xmm2,xmm7               ; xmm2=data0H
-        psubd   xmm5,xmm6               ; xmm5=data3L
-        psubd   xmm3,xmm7               ; xmm3=data3H
-
-        movdqa  xmm6,[rel PD_DESCALE_P1_4]      ; xmm6=[rel PD_DESCALE_P1_4]
-
-        paddd   xmm1,xmm6
-        paddd   xmm2,xmm6
-        psrad   xmm1,DESCALE_P1_4
-        psrad   xmm2,DESCALE_P1_4
-        paddd   xmm5,xmm6
-        paddd   xmm3,xmm6
-        psrad   xmm5,DESCALE_P1_4
-        psrad   xmm3,DESCALE_P1_4
-
-        packssdw  xmm1,xmm2             ; xmm1=data0=(00 01 02 03 04 05 06 07)
-        packssdw  xmm5,xmm3             ; xmm5=data3=(30 31 32 33 34 35 36 37)
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp0L
-        movdqa  xmm6, XMMWORD [wk(1)]   ; xmm6=tmp0H
-
-        movdqa  xmm2,xmm4
-        movdqa  xmm3,xmm0
-        paddd   xmm4,xmm7               ; xmm4=data1L
-        paddd   xmm0,xmm6               ; xmm0=data1H
-        psubd   xmm2,xmm7               ; xmm2=data2L
-        psubd   xmm3,xmm6               ; xmm3=data2H
-
-        movdqa  xmm7,[rel PD_DESCALE_P1_4]      ; xmm7=[rel PD_DESCALE_P1_4]
-
-        paddd   xmm4,xmm7
-        paddd   xmm0,xmm7
-        psrad   xmm4,DESCALE_P1_4
-        psrad   xmm0,DESCALE_P1_4
-        paddd   xmm2,xmm7
-        paddd   xmm3,xmm7
-        psrad   xmm2,DESCALE_P1_4
-        psrad   xmm3,DESCALE_P1_4
-
-        packssdw  xmm4,xmm0             ; xmm4=data1=(10 11 12 13 14 15 16 17)
-        packssdw  xmm2,xmm3             ; xmm2=data2=(20 21 22 23 24 25 26 27)
-
-        movdqa    xmm6,xmm1     ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm4     ; xmm1=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm6,xmm4     ; xmm6=(04 14 05 15 06 16 07 17)
-        movdqa    xmm7,xmm2     ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm5     ; xmm2=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm7,xmm5     ; xmm7=(24 34 25 35 26 36 27 37)
-
-        movdqa    xmm0,xmm1     ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm2     ; xmm1=[col0 col1]=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm0,xmm2     ; xmm0=[col2 col3]=(02 12 22 32 03 13 23 33)
-        movdqa    xmm3,xmm6     ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm7     ; xmm6=[col4 col5]=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm3,xmm7     ; xmm3=[col6 col7]=(06 16 26 36 07 17 27 37)
-.column_end:
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows, store into output array.
-
-        mov     rax, [original_rbp]
-        mov     rdi, r12        ; (JSAMPROW *)
-        mov     eax, r13d
-
-        ; -- Even part
-
-        pxor      xmm4,xmm4
-        punpcklwd xmm4,xmm1             ; xmm4=tmp0
-        psrad     xmm4,(16-CONST_BITS-1) ; psrad xmm4,16 & pslld xmm4,CONST_BITS+1
-
-        ; -- Odd part
-
-        punpckhwd xmm1,xmm0
-        punpckhwd xmm6,xmm3
-        movdqa    xmm5,xmm1
-        movdqa    xmm2,xmm6
-        pmaddwd   xmm1,[rel PW_F256_F089]       ; xmm1=(tmp2)
-        pmaddwd   xmm6,[rel PW_MF060_MF050]     ; xmm6=(tmp2)
-        pmaddwd   xmm5,[rel PW_F106_MF217]      ; xmm5=(tmp0)
-        pmaddwd   xmm2,[rel PW_F145_MF021]      ; xmm2=(tmp0)
-
-        paddd     xmm6,xmm1             ; xmm6=tmp2
-        paddd     xmm2,xmm5             ; xmm2=tmp0
-
-        ; -- Even part
-
-        punpcklwd xmm0,xmm3
-        pmaddwd   xmm0,[rel PW_F184_MF076]      ; xmm0=tmp2
-
-        movdqa    xmm7,xmm4
-        paddd     xmm4,xmm0             ; xmm4=tmp10
-        psubd     xmm7,xmm0             ; xmm7=tmp12
-
-        ; -- Final output stage
-
-        movdqa  xmm1,[rel PD_DESCALE_P2_4]      ; xmm1=[rel PD_DESCALE_P2_4]
-
-        movdqa  xmm5,xmm4
-        movdqa  xmm3,xmm7
-        paddd   xmm4,xmm6               ; xmm4=data0=(00 10 20 30)
-        paddd   xmm7,xmm2               ; xmm7=data1=(01 11 21 31)
-        psubd   xmm5,xmm6               ; xmm5=data3=(03 13 23 33)
-        psubd   xmm3,xmm2               ; xmm3=data2=(02 12 22 32)
-
-        paddd   xmm4,xmm1
-        paddd   xmm7,xmm1
-        psrad   xmm4,DESCALE_P2_4
-        psrad   xmm7,DESCALE_P2_4
-        paddd   xmm5,xmm1
-        paddd   xmm3,xmm1
-        psrad   xmm5,DESCALE_P2_4
-        psrad   xmm3,DESCALE_P2_4
-
-        packssdw  xmm4,xmm3             ; xmm4=(00 10 20 30 02 12 22 32)
-        packssdw  xmm7,xmm5             ; xmm7=(01 11 21 31 03 13 23 33)
-
-        movdqa    xmm0,xmm4             ; transpose coefficients(phase 1)
-        punpcklwd xmm4,xmm7             ; xmm4=(00 01 10 11 20 21 30 31)
-        punpckhwd xmm0,xmm7             ; xmm0=(02 03 12 13 22 23 32 33)
-
-        movdqa    xmm6,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm0             ; xmm4=(00 01 02 03 10 11 12 13)
-        punpckhdq xmm6,xmm0             ; xmm6=(20 21 22 23 30 31 32 33)
-
-        packsswb  xmm4,xmm6             ; xmm4=(00 01 02 03 10 11 12 13 20 ..)
-        paddb     xmm4,[rel PB_CENTERJSAMP]
-
-        pshufd    xmm2,xmm4,0x39        ; xmm2=(10 11 12 13 20 21 22 23 30 ..)
-        pshufd    xmm1,xmm4,0x4E        ; xmm1=(20 21 22 23 30 31 32 33 00 ..)
-        pshufd    xmm3,xmm4,0x93        ; xmm3=(30 31 32 33 00 01 02 03 10 ..)
-
-        mov     rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
-        movd    XMM_DWORD [rdx+rax*SIZEOF_JSAMPLE], xmm4
-        movd    XMM_DWORD [rsi+rax*SIZEOF_JSAMPLE], xmm2
-        mov     rdx, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
-        movd    XMM_DWORD [rdx+rax*SIZEOF_JSAMPLE], xmm1
-        movd    XMM_DWORD [rsi+rax*SIZEOF_JSAMPLE], xmm3
-
-        uncollect_args
-        mov     rsp,rbp         ; rsp <- aligned rbp
-        pop     rsp             ; rsp <- original rbp
-        pop     rbp
-        ret
-
-
-; --------------------------------------------------------------------------
-;
-; Perform dequantization and inverse DCT on one block of coefficients,
-; producing a reduced-size 2x2 output block.
-;
-; GLOBAL(void)
-; jsimd_idct_2x2_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                      JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-; r10 = void *dct_table
-; r11 = JCOEFPTR coef_block
-; r12 = JSAMPARRAY output_buf
-; r13 = JDIMENSION output_col
-
-        align   16
-        global  EXTN(jsimd_idct_2x2_sse2)
-
-EXTN(jsimd_idct_2x2_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-        push    rbx
-
-        ; ---- Pass 1: process columns from input.
-
-        mov     rdx, r10                ; quantptr
-        mov     rsi, r11                ; inptr
-
-        ; | input:                  | result:        |
-        ; | 00 01 ** 03 ** 05 ** 07 |                |
-        ; | 10 11 ** 13 ** 15 ** 17 |                |
-        ; | ** ** ** ** ** ** ** ** |                |
-        ; | 30 31 ** 33 ** 35 ** 37 | A0 A1 A3 A5 A7 |
-        ; | ** ** ** ** ** ** ** ** | B0 B1 B3 B5 B7 |
-        ; | 50 51 ** 53 ** 55 ** 57 |                |
-        ; | ** ** ** ** ** ** ** ** |                |
-        ; | 70 71 ** 73 ** 75 ** 77 |                |
-
-        ; -- Odd part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        ; xmm0=(10 11 ** 13 ** 15 ** 17), xmm1=(30 31 ** 33 ** 35 ** 37)
-        ; xmm2=(50 51 ** 53 ** 55 ** 57), xmm3=(70 71 ** 73 ** 75 ** 77)
-
-        pcmpeqd   xmm7,xmm7
-        pslld     xmm7,WORD_BIT         ; xmm7={0x0000 0xFFFF 0x0000 0xFFFF ..}
-
-        movdqa    xmm4,xmm0             ; xmm4=(10 11 ** 13 ** 15 ** 17)
-        movdqa    xmm5,xmm2             ; xmm5=(50 51 ** 53 ** 55 ** 57)
-        punpcklwd xmm4,xmm1             ; xmm4=(10 30 11 31 ** ** 13 33)
-        punpcklwd xmm5,xmm3             ; xmm5=(50 70 51 71 ** ** 53 73)
-        pmaddwd   xmm4,[rel PW_F362_MF127]
-        pmaddwd   xmm5,[rel PW_F085_MF072]
-
-        psrld   xmm0,WORD_BIT           ; xmm0=(11 -- 13 -- 15 -- 17 --)
-        pand    xmm1,xmm7               ; xmm1=(-- 31 -- 33 -- 35 -- 37)
-        psrld   xmm2,WORD_BIT           ; xmm2=(51 -- 53 -- 55 -- 57 --)
-        pand    xmm3,xmm7               ; xmm3=(-- 71 -- 73 -- 75 -- 77)
-        por     xmm0,xmm1               ; xmm0=(11 31 13 33 15 35 17 37)
-        por     xmm2,xmm3               ; xmm2=(51 71 53 73 55 75 57 77)
-        pmaddwd xmm0,[rel PW_F362_MF127]
-        pmaddwd xmm2,[rel PW_F085_MF072]
-
-        paddd   xmm4,xmm5               ; xmm4=tmp0[col0 col1 **** col3]
-        paddd   xmm0,xmm2               ; xmm0=tmp0[col1 col3 col5 col7]
-
-        ; -- Even part
-
-        movdqa  xmm6, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
-        pmullw  xmm6, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        ; xmm6=(00 01 ** 03 ** 05 ** 07)
-
-        movdqa  xmm1,xmm6               ; xmm1=(00 01 ** 03 ** 05 ** 07)
-        pslld   xmm6,WORD_BIT           ; xmm6=(-- 00 -- ** -- ** -- **)
-        pand    xmm1,xmm7               ; xmm1=(-- 01 -- 03 -- 05 -- 07)
-        psrad   xmm6,(WORD_BIT-CONST_BITS-2) ; xmm6=tmp10[col0 **** **** ****]
-        psrad   xmm1,(WORD_BIT-CONST_BITS-2) ; xmm1=tmp10[col1 col3 col5 col7]
-
-        ; -- Final output stage
-
-        movdqa  xmm3,xmm6
-        movdqa  xmm5,xmm1
-        paddd   xmm6,xmm4       ; xmm6=data0[col0 **** **** ****]=(A0 ** ** **)
-        paddd   xmm1,xmm0       ; xmm1=data0[col1 col3 col5 col7]=(A1 A3 A5 A7)
-        psubd   xmm3,xmm4       ; xmm3=data1[col0 **** **** ****]=(B0 ** ** **)
-        psubd   xmm5,xmm0       ; xmm5=data1[col1 col3 col5 col7]=(B1 B3 B5 B7)
-
-        movdqa  xmm2,[rel PD_DESCALE_P1_2]      ; xmm2=[rel PD_DESCALE_P1_2]
-
-        punpckldq  xmm6,xmm3            ; xmm6=(A0 B0 ** **)
-
-        movdqa     xmm7,xmm1
-        punpcklqdq xmm1,xmm5            ; xmm1=(A1 A3 B1 B3)
-        punpckhqdq xmm7,xmm5            ; xmm7=(A5 A7 B5 B7)
-
-        paddd   xmm6,xmm2
-        psrad   xmm6,DESCALE_P1_2
-
-        paddd   xmm1,xmm2
-        paddd   xmm7,xmm2
-        psrad   xmm1,DESCALE_P1_2
-        psrad   xmm7,DESCALE_P1_2
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows, store into output array.
-
-        mov     rdi, r12        ; (JSAMPROW *)
-        mov     eax, r13d
-
-        ; | input:| result:|
-        ; | A0 B0 |        |
-        ; | A1 B1 | C0 C1  |
-        ; | A3 B3 | D0 D1  |
-        ; | A5 B5 |        |
-        ; | A7 B7 |        |
-
-        ; -- Odd part
-
-        packssdw  xmm1,xmm1             ; xmm1=(A1 A3 B1 B3 A1 A3 B1 B3)
-        packssdw  xmm7,xmm7             ; xmm7=(A5 A7 B5 B7 A5 A7 B5 B7)
-        pmaddwd   xmm1,[rel PW_F362_MF127]
-        pmaddwd   xmm7,[rel PW_F085_MF072]
-
-        paddd     xmm1,xmm7             ; xmm1=tmp0[row0 row1 row0 row1]
-
-        ; -- Even part
-
-        pslld     xmm6,(CONST_BITS+2)   ; xmm6=tmp10[row0 row1 **** ****]
-
-        ; -- Final output stage
-
-        movdqa    xmm4,xmm6
-        paddd     xmm6,xmm1     ; xmm6=data0[row0 row1 **** ****]=(C0 C1 ** **)
-        psubd     xmm4,xmm1     ; xmm4=data1[row0 row1 **** ****]=(D0 D1 ** **)
-
-        punpckldq xmm6,xmm4     ; xmm6=(C0 D0 C1 D1)
-
-        paddd     xmm6,[rel PD_DESCALE_P2_2]
-        psrad     xmm6,DESCALE_P2_2
-
-        packssdw  xmm6,xmm6             ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1)
-        packsswb  xmm6,xmm6             ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1 ..)
-        paddb     xmm6,[rel PB_CENTERJSAMP]
-
-        pextrw  ebx,xmm6,0x00           ; ebx=(C0 D0 -- --)
-        pextrw  ecx,xmm6,0x01           ; ecx=(C1 D1 -- --)
-
-        mov     rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
-        mov     rsi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
-        mov     WORD [rdx+rax*SIZEOF_JSAMPLE], bx
-        mov     WORD [rsi+rax*SIZEOF_JSAMPLE], cx
-
-        pop     rbx
-        uncollect_args
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jidctred-sse2.asm b/simd/jidctred-sse2.asm
deleted file mode 100644
index 232d983..0000000
--- a/simd/jidctred-sse2.asm
+++ /dev/null
@@ -1,593 +0,0 @@
-;
-; jidctred.asm - reduced-size IDCT (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; This file contains inverse-DCT routines that produce reduced-size
-; output: either 4x4 or 2x2 pixels from an 8x8 DCT block.
-; The following code is based directly on the IJG's original jidctred.c;
-; see the jidctred.c for more details.
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-
-%define CONST_BITS      13
-%define PASS1_BITS      2
-
-%define DESCALE_P1_4    (CONST_BITS-PASS1_BITS+1)
-%define DESCALE_P2_4    (CONST_BITS+PASS1_BITS+3+1)
-%define DESCALE_P1_2    (CONST_BITS-PASS1_BITS+2)
-%define DESCALE_P2_2    (CONST_BITS+PASS1_BITS+3+2)
-
-%if CONST_BITS == 13
-F_0_211 equ      1730           ; FIX(0.211164243)
-F_0_509 equ      4176           ; FIX(0.509795579)
-F_0_601 equ      4926           ; FIX(0.601344887)
-F_0_720 equ      5906           ; FIX(0.720959822)
-F_0_765 equ      6270           ; FIX(0.765366865)
-F_0_850 equ      6967           ; FIX(0.850430095)
-F_0_899 equ      7373           ; FIX(0.899976223)
-F_1_061 equ      8697           ; FIX(1.061594337)
-F_1_272 equ     10426           ; FIX(1.272758580)
-F_1_451 equ     11893           ; FIX(1.451774981)
-F_1_847 equ     15137           ; FIX(1.847759065)
-F_2_172 equ     17799           ; FIX(2.172734803)
-F_2_562 equ     20995           ; FIX(2.562915447)
-F_3_624 equ     29692           ; FIX(3.624509785)
-%else
-; NASM cannot do compile-time arithmetic on floating-point constants.
-%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
-F_0_211 equ     DESCALE( 226735879,30-CONST_BITS)       ; FIX(0.211164243)
-F_0_509 equ     DESCALE( 547388834,30-CONST_BITS)       ; FIX(0.509795579)
-F_0_601 equ     DESCALE( 645689155,30-CONST_BITS)       ; FIX(0.601344887)
-F_0_720 equ     DESCALE( 774124714,30-CONST_BITS)       ; FIX(0.720959822)
-F_0_765 equ     DESCALE( 821806413,30-CONST_BITS)       ; FIX(0.765366865)
-F_0_850 equ     DESCALE( 913142361,30-CONST_BITS)       ; FIX(0.850430095)
-F_0_899 equ     DESCALE( 966342111,30-CONST_BITS)       ; FIX(0.899976223)
-F_1_061 equ     DESCALE(1139878239,30-CONST_BITS)       ; FIX(1.061594337)
-F_1_272 equ     DESCALE(1366614119,30-CONST_BITS)       ; FIX(1.272758580)
-F_1_451 equ     DESCALE(1558831516,30-CONST_BITS)       ; FIX(1.451774981)
-F_1_847 equ     DESCALE(1984016188,30-CONST_BITS)       ; FIX(1.847759065)
-F_2_172 equ     DESCALE(2332956230,30-CONST_BITS)       ; FIX(2.172734803)
-F_2_562 equ     DESCALE(2751909506,30-CONST_BITS)       ; FIX(2.562915447)
-F_3_624 equ     DESCALE(3891787747,30-CONST_BITS)       ; FIX(3.624509785)
-%endif
-
-; --------------------------------------------------------------------------
-        SECTION SEG_CONST
-
-        alignz  16
-        global  EXTN(jconst_idct_red_sse2)
-
-EXTN(jconst_idct_red_sse2):
-
-PW_F184_MF076   times 4 dw  F_1_847,-F_0_765
-PW_F256_F089    times 4 dw  F_2_562, F_0_899
-PW_F106_MF217   times 4 dw  F_1_061,-F_2_172
-PW_MF060_MF050  times 4 dw -F_0_601,-F_0_509
-PW_F145_MF021   times 4 dw  F_1_451,-F_0_211
-PW_F362_MF127   times 4 dw  F_3_624,-F_1_272
-PW_F085_MF072   times 4 dw  F_0_850,-F_0_720
-PD_DESCALE_P1_4 times 4 dd  1 << (DESCALE_P1_4-1)
-PD_DESCALE_P2_4 times 4 dd  1 << (DESCALE_P2_4-1)
-PD_DESCALE_P1_2 times 4 dd  1 << (DESCALE_P1_2-1)
-PD_DESCALE_P2_2 times 4 dd  1 << (DESCALE_P2_2-1)
-PB_CENTERJSAMP  times 16 db CENTERJSAMPLE
-
-        alignz  16
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Perform dequantization and inverse DCT on one block of coefficients,
-; producing a reduced-size 4x4 output block.
-;
-; GLOBAL(void)
-; jsimd_idct_4x4_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                      JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-%define dct_table(b)    (b)+8           ; void *dct_table
-%define coef_block(b)   (b)+12          ; JCOEFPTR coef_block
-%define output_buf(b)   (b)+16          ; JSAMPARRAY output_buf
-%define output_col(b)   (b)+20          ; JDIMENSION output_col
-
-%define original_ebp    ebp+0
-%define wk(i)           ebp-(WK_NUM-(i))*SIZEOF_XMMWORD ; xmmword wk[WK_NUM]
-%define WK_NUM          2
-
-        align   16
-        global  EXTN(jsimd_idct_4x4_sse2)
-
-EXTN(jsimd_idct_4x4_sse2):
-        push    ebp
-        mov     eax,esp                         ; eax = original ebp
-        sub     esp, byte 4
-        and     esp, byte (-SIZEOF_XMMWORD)     ; align to 128 bits
-        mov     [esp],eax
-        mov     ebp,esp                         ; ebp = aligned ebp
-        lea     esp, [wk(0)]
-        pushpic ebx
-;       push    ecx             ; unused
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process columns from input.
-
-;       mov     eax, [original_ebp]
-        mov     edx, POINTER [dct_table(eax)]           ; quantptr
-        mov     esi, JCOEFPTR [coef_block(eax)]         ; inptr
-
-%ifndef NO_ZERO_COLUMN_TEST_4X4_SSE2
-        mov     eax, DWORD [DWBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        or      eax, DWORD [DWBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        jnz     short .columnDCT
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        por     xmm0, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-        por     xmm1, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        por     xmm0,xmm1
-        packsswb xmm0,xmm0
-        packsswb xmm0,xmm0
-        movd    eax,xmm0
-        test    eax,eax
-        jnz     short .columnDCT
-
-        ; -- AC terms all zero
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        psllw   xmm0,PASS1_BITS
-
-        movdqa    xmm3,xmm0     ; xmm0=in0=(00 01 02 03 04 05 06 07)
-        punpcklwd xmm0,xmm0     ; xmm0=(00 00 01 01 02 02 03 03)
-        punpckhwd xmm3,xmm3     ; xmm3=(04 04 05 05 06 06 07 07)
-
-        pshufd  xmm1,xmm0,0x50  ; xmm1=[col0 col1]=(00 00 00 00 01 01 01 01)
-        pshufd  xmm0,xmm0,0xFA  ; xmm0=[col2 col3]=(02 02 02 02 03 03 03 03)
-        pshufd  xmm6,xmm3,0x50  ; xmm6=[col4 col5]=(04 04 04 04 05 05 05 05)
-        pshufd  xmm3,xmm3,0xFA  ; xmm3=[col6 col7]=(06 06 06 06 07 07 07 07)
-
-        jmp     near .column_end
-        alignx  16,7
-%endif
-.columnDCT:
-
-        ; -- Odd part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        movdqa    xmm4,xmm0
-        movdqa    xmm5,xmm0
-        punpcklwd xmm4,xmm1
-        punpckhwd xmm5,xmm1
-        movdqa    xmm0,xmm4
-        movdqa    xmm1,xmm5
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_F256_F089)]       ; xmm4=(tmp2L)
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F256_F089)]       ; xmm5=(tmp2H)
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_F106_MF217)]      ; xmm0=(tmp0L)
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_F106_MF217)]      ; xmm1=(tmp0H)
-
-        movdqa    xmm6,xmm2
-        movdqa    xmm7,xmm2
-        punpcklwd xmm6,xmm3
-        punpckhwd xmm7,xmm3
-        movdqa    xmm2,xmm6
-        movdqa    xmm3,xmm7
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_MF060_MF050)]     ; xmm6=(tmp2L)
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_MF060_MF050)]     ; xmm7=(tmp2H)
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_F145_MF021)]      ; xmm2=(tmp0L)
-        pmaddwd   xmm3,[GOTOFF(ebx,PW_F145_MF021)]      ; xmm3=(tmp0H)
-
-        paddd   xmm6,xmm4               ; xmm6=tmp2L
-        paddd   xmm7,xmm5               ; xmm7=tmp2H
-        paddd   xmm2,xmm0               ; xmm2=tmp0L
-        paddd   xmm3,xmm1               ; xmm3=tmp0H
-
-        movdqa  XMMWORD [wk(0)], xmm2   ; wk(0)=tmp0L
-        movdqa  XMMWORD [wk(1)], xmm3   ; wk(1)=tmp0H
-
-        ; -- Even part
-
-        movdqa  xmm4, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm5, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm0, XMMWORD [XMMBLOCK(6,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm4, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm5, XMMWORD [XMMBLOCK(2,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(6,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        pxor      xmm1,xmm1
-        pxor      xmm2,xmm2
-        punpcklwd xmm1,xmm4             ; xmm1=tmp0L
-        punpckhwd xmm2,xmm4             ; xmm2=tmp0H
-        psrad     xmm1,(16-CONST_BITS-1) ; psrad xmm1,16 & pslld xmm1,CONST_BITS+1
-        psrad     xmm2,(16-CONST_BITS-1) ; psrad xmm2,16 & pslld xmm2,CONST_BITS+1
-
-        movdqa    xmm3,xmm5             ; xmm5=in2=z2
-        punpcklwd xmm5,xmm0             ; xmm0=in6=z3
-        punpckhwd xmm3,xmm0
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F184_MF076)]      ; xmm5=tmp2L
-        pmaddwd   xmm3,[GOTOFF(ebx,PW_F184_MF076)]      ; xmm3=tmp2H
-
-        movdqa  xmm4,xmm1
-        movdqa  xmm0,xmm2
-        paddd   xmm1,xmm5               ; xmm1=tmp10L
-        paddd   xmm2,xmm3               ; xmm2=tmp10H
-        psubd   xmm4,xmm5               ; xmm4=tmp12L
-        psubd   xmm0,xmm3               ; xmm0=tmp12H
-
-        ; -- Final output stage
-
-        movdqa  xmm5,xmm1
-        movdqa  xmm3,xmm2
-        paddd   xmm1,xmm6               ; xmm1=data0L
-        paddd   xmm2,xmm7               ; xmm2=data0H
-        psubd   xmm5,xmm6               ; xmm5=data3L
-        psubd   xmm3,xmm7               ; xmm3=data3H
-
-        movdqa  xmm6,[GOTOFF(ebx,PD_DESCALE_P1_4)]      ; xmm6=[PD_DESCALE_P1_4]
-
-        paddd   xmm1,xmm6
-        paddd   xmm2,xmm6
-        psrad   xmm1,DESCALE_P1_4
-        psrad   xmm2,DESCALE_P1_4
-        paddd   xmm5,xmm6
-        paddd   xmm3,xmm6
-        psrad   xmm5,DESCALE_P1_4
-        psrad   xmm3,DESCALE_P1_4
-
-        packssdw  xmm1,xmm2             ; xmm1=data0=(00 01 02 03 04 05 06 07)
-        packssdw  xmm5,xmm3             ; xmm5=data3=(30 31 32 33 34 35 36 37)
-
-        movdqa  xmm7, XMMWORD [wk(0)]   ; xmm7=tmp0L
-        movdqa  xmm6, XMMWORD [wk(1)]   ; xmm6=tmp0H
-
-        movdqa  xmm2,xmm4
-        movdqa  xmm3,xmm0
-        paddd   xmm4,xmm7               ; xmm4=data1L
-        paddd   xmm0,xmm6               ; xmm0=data1H
-        psubd   xmm2,xmm7               ; xmm2=data2L
-        psubd   xmm3,xmm6               ; xmm3=data2H
-
-        movdqa  xmm7,[GOTOFF(ebx,PD_DESCALE_P1_4)]      ; xmm7=[PD_DESCALE_P1_4]
-
-        paddd   xmm4,xmm7
-        paddd   xmm0,xmm7
-        psrad   xmm4,DESCALE_P1_4
-        psrad   xmm0,DESCALE_P1_4
-        paddd   xmm2,xmm7
-        paddd   xmm3,xmm7
-        psrad   xmm2,DESCALE_P1_4
-        psrad   xmm3,DESCALE_P1_4
-
-        packssdw  xmm4,xmm0             ; xmm4=data1=(10 11 12 13 14 15 16 17)
-        packssdw  xmm2,xmm3             ; xmm2=data2=(20 21 22 23 24 25 26 27)
-
-        movdqa    xmm6,xmm1     ; transpose coefficients(phase 1)
-        punpcklwd xmm1,xmm4     ; xmm1=(00 10 01 11 02 12 03 13)
-        punpckhwd xmm6,xmm4     ; xmm6=(04 14 05 15 06 16 07 17)
-        movdqa    xmm7,xmm2     ; transpose coefficients(phase 1)
-        punpcklwd xmm2,xmm5     ; xmm2=(20 30 21 31 22 32 23 33)
-        punpckhwd xmm7,xmm5     ; xmm7=(24 34 25 35 26 36 27 37)
-
-        movdqa    xmm0,xmm1     ; transpose coefficients(phase 2)
-        punpckldq xmm1,xmm2     ; xmm1=[col0 col1]=(00 10 20 30 01 11 21 31)
-        punpckhdq xmm0,xmm2     ; xmm0=[col2 col3]=(02 12 22 32 03 13 23 33)
-        movdqa    xmm3,xmm6     ; transpose coefficients(phase 2)
-        punpckldq xmm6,xmm7     ; xmm6=[col4 col5]=(04 14 24 34 05 15 25 35)
-        punpckhdq xmm3,xmm7     ; xmm3=[col6 col7]=(06 16 26 36 07 17 27 37)
-.column_end:
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows, store into output array.
-
-        mov     eax, [original_ebp]
-        mov     edi, JSAMPARRAY [output_buf(eax)]       ; (JSAMPROW *)
-        mov     eax, JDIMENSION [output_col(eax)]
-
-        ; -- Even part
-
-        pxor      xmm4,xmm4
-        punpcklwd xmm4,xmm1             ; xmm4=tmp0
-        psrad     xmm4,(16-CONST_BITS-1) ; psrad xmm4,16 & pslld xmm4,CONST_BITS+1
-
-        ; -- Odd part
-
-        punpckhwd xmm1,xmm0
-        punpckhwd xmm6,xmm3
-        movdqa    xmm5,xmm1
-        movdqa    xmm2,xmm6
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_F256_F089)]       ; xmm1=(tmp2)
-        pmaddwd   xmm6,[GOTOFF(ebx,PW_MF060_MF050)]     ; xmm6=(tmp2)
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F106_MF217)]      ; xmm5=(tmp0)
-        pmaddwd   xmm2,[GOTOFF(ebx,PW_F145_MF021)]      ; xmm2=(tmp0)
-
-        paddd     xmm6,xmm1             ; xmm6=tmp2
-        paddd     xmm2,xmm5             ; xmm2=tmp0
-
-        ; -- Even part
-
-        punpcklwd xmm0,xmm3
-        pmaddwd   xmm0,[GOTOFF(ebx,PW_F184_MF076)]      ; xmm0=tmp2
-
-        movdqa    xmm7,xmm4
-        paddd     xmm4,xmm0             ; xmm4=tmp10
-        psubd     xmm7,xmm0             ; xmm7=tmp12
-
-        ; -- Final output stage
-
-        movdqa  xmm1,[GOTOFF(ebx,PD_DESCALE_P2_4)]      ; xmm1=[PD_DESCALE_P2_4]
-
-        movdqa  xmm5,xmm4
-        movdqa  xmm3,xmm7
-        paddd   xmm4,xmm6               ; xmm4=data0=(00 10 20 30)
-        paddd   xmm7,xmm2               ; xmm7=data1=(01 11 21 31)
-        psubd   xmm5,xmm6               ; xmm5=data3=(03 13 23 33)
-        psubd   xmm3,xmm2               ; xmm3=data2=(02 12 22 32)
-
-        paddd   xmm4,xmm1
-        paddd   xmm7,xmm1
-        psrad   xmm4,DESCALE_P2_4
-        psrad   xmm7,DESCALE_P2_4
-        paddd   xmm5,xmm1
-        paddd   xmm3,xmm1
-        psrad   xmm5,DESCALE_P2_4
-        psrad   xmm3,DESCALE_P2_4
-
-        packssdw  xmm4,xmm3             ; xmm4=(00 10 20 30 02 12 22 32)
-        packssdw  xmm7,xmm5             ; xmm7=(01 11 21 31 03 13 23 33)
-
-        movdqa    xmm0,xmm4             ; transpose coefficients(phase 1)
-        punpcklwd xmm4,xmm7             ; xmm4=(00 01 10 11 20 21 30 31)
-        punpckhwd xmm0,xmm7             ; xmm0=(02 03 12 13 22 23 32 33)
-
-        movdqa    xmm6,xmm4             ; transpose coefficients(phase 2)
-        punpckldq xmm4,xmm0             ; xmm4=(00 01 02 03 10 11 12 13)
-        punpckhdq xmm6,xmm0             ; xmm6=(20 21 22 23 30 31 32 33)
-
-        packsswb  xmm4,xmm6             ; xmm4=(00 01 02 03 10 11 12 13 20 ..)
-        paddb     xmm4,[GOTOFF(ebx,PB_CENTERJSAMP)]
-
-        pshufd    xmm2,xmm4,0x39        ; xmm2=(10 11 12 13 20 21 22 23 30 ..)
-        pshufd    xmm1,xmm4,0x4E        ; xmm1=(20 21 22 23 30 31 32 33 00 ..)
-        pshufd    xmm3,xmm4,0x93        ; xmm3=(30 31 32 33 00 01 02 03 10 ..)
-
-        mov     edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
-        movd    XMM_DWORD [edx+eax*SIZEOF_JSAMPLE], xmm4
-        movd    XMM_DWORD [esi+eax*SIZEOF_JSAMPLE], xmm2
-        mov     edx, JSAMPROW [edi+2*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+3*SIZEOF_JSAMPROW]
-        movd    XMM_DWORD [edx+eax*SIZEOF_JSAMPLE], xmm1
-        movd    XMM_DWORD [esi+eax*SIZEOF_JSAMPLE], xmm3
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; unused
-        poppic  ebx
-        mov     esp,ebp         ; esp <- aligned ebp
-        pop     esp             ; esp <- original ebp
-        pop     ebp
-        ret
-
-
-; --------------------------------------------------------------------------
-;
-; Perform dequantization and inverse DCT on one block of coefficients,
-; producing a reduced-size 2x2 output block.
-;
-; GLOBAL(void)
-; jsimd_idct_2x2_sse2 (void *dct_table, JCOEFPTR coef_block,
-;                      JSAMPARRAY output_buf, JDIMENSION output_col)
-;
-
-%define dct_table(b)    (b)+8           ; void *dct_table
-%define coef_block(b)   (b)+12          ; JCOEFPTR coef_block
-%define output_buf(b)   (b)+16          ; JSAMPARRAY output_buf
-%define output_col(b)   (b)+20          ; JDIMENSION output_col
-
-        align   16
-        global  EXTN(jsimd_idct_2x2_sse2)
-
-EXTN(jsimd_idct_2x2_sse2):
-        push    ebp
-        mov     ebp,esp
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        get_GOT ebx             ; get GOT address
-
-        ; ---- Pass 1: process columns from input.
-
-        mov     edx, POINTER [dct_table(ebp)]           ; quantptr
-        mov     esi, JCOEFPTR [coef_block(ebp)]         ; inptr
-
-        ; | input:                  | result:        |
-        ; | 00 01 ** 03 ** 05 ** 07 |                |
-        ; | 10 11 ** 13 ** 15 ** 17 |                |
-        ; | ** ** ** ** ** ** ** ** |                |
-        ; | 30 31 ** 33 ** 35 ** 37 | A0 A1 A3 A5 A7 |
-        ; | ** ** ** ** ** ** ** ** | B0 B1 B3 B5 B7 |
-        ; | 50 51 ** 53 ** 55 ** 57 |                |
-        ; | ** ** ** ** ** ** ** ** |                |
-        ; | 70 71 ** 73 ** 75 ** 77 |                |
-
-        ; -- Odd part
-
-        movdqa  xmm0, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm1, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm0, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm1, XMMWORD [XMMBLOCK(3,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        movdqa  xmm2, XMMWORD [XMMBLOCK(5,0,esi,SIZEOF_JCOEF)]
-        movdqa  xmm3, XMMWORD [XMMBLOCK(7,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm2, XMMWORD [XMMBLOCK(5,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-        pmullw  xmm3, XMMWORD [XMMBLOCK(7,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        ; xmm0=(10 11 ** 13 ** 15 ** 17), xmm1=(30 31 ** 33 ** 35 ** 37)
-        ; xmm2=(50 51 ** 53 ** 55 ** 57), xmm3=(70 71 ** 73 ** 75 ** 77)
-
-        pcmpeqd   xmm7,xmm7
-        pslld     xmm7,WORD_BIT         ; xmm7={0x0000 0xFFFF 0x0000 0xFFFF ..}
-
-        movdqa    xmm4,xmm0             ; xmm4=(10 11 ** 13 ** 15 ** 17)
-        movdqa    xmm5,xmm2             ; xmm5=(50 51 ** 53 ** 55 ** 57)
-        punpcklwd xmm4,xmm1             ; xmm4=(10 30 11 31 ** ** 13 33)
-        punpcklwd xmm5,xmm3             ; xmm5=(50 70 51 71 ** ** 53 73)
-        pmaddwd   xmm4,[GOTOFF(ebx,PW_F362_MF127)]
-        pmaddwd   xmm5,[GOTOFF(ebx,PW_F085_MF072)]
-
-        psrld   xmm0,WORD_BIT           ; xmm0=(11 -- 13 -- 15 -- 17 --)
-        pand    xmm1,xmm7               ; xmm1=(-- 31 -- 33 -- 35 -- 37)
-        psrld   xmm2,WORD_BIT           ; xmm2=(51 -- 53 -- 55 -- 57 --)
-        pand    xmm3,xmm7               ; xmm3=(-- 71 -- 73 -- 75 -- 77)
-        por     xmm0,xmm1               ; xmm0=(11 31 13 33 15 35 17 37)
-        por     xmm2,xmm3               ; xmm2=(51 71 53 73 55 75 57 77)
-        pmaddwd xmm0,[GOTOFF(ebx,PW_F362_MF127)]
-        pmaddwd xmm2,[GOTOFF(ebx,PW_F085_MF072)]
-
-        paddd   xmm4,xmm5               ; xmm4=tmp0[col0 col1 **** col3]
-        paddd   xmm0,xmm2               ; xmm0=tmp0[col1 col3 col5 col7]
-
-        ; -- Even part
-
-        movdqa  xmm6, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_JCOEF)]
-        pmullw  xmm6, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_ISLOW_MULT_TYPE)]
-
-        ; xmm6=(00 01 ** 03 ** 05 ** 07)
-
-        movdqa  xmm1,xmm6               ; xmm1=(00 01 ** 03 ** 05 ** 07)
-        pslld   xmm6,WORD_BIT           ; xmm6=(-- 00 -- ** -- ** -- **)
-        pand    xmm1,xmm7               ; xmm1=(-- 01 -- 03 -- 05 -- 07)
-        psrad   xmm6,(WORD_BIT-CONST_BITS-2) ; xmm6=tmp10[col0 **** **** ****]
-        psrad   xmm1,(WORD_BIT-CONST_BITS-2) ; xmm1=tmp10[col1 col3 col5 col7]
-
-        ; -- Final output stage
-
-        movdqa  xmm3,xmm6
-        movdqa  xmm5,xmm1
-        paddd   xmm6,xmm4       ; xmm6=data0[col0 **** **** ****]=(A0 ** ** **)
-        paddd   xmm1,xmm0       ; xmm1=data0[col1 col3 col5 col7]=(A1 A3 A5 A7)
-        psubd   xmm3,xmm4       ; xmm3=data1[col0 **** **** ****]=(B0 ** ** **)
-        psubd   xmm5,xmm0       ; xmm5=data1[col1 col3 col5 col7]=(B1 B3 B5 B7)
-
-        movdqa  xmm2,[GOTOFF(ebx,PD_DESCALE_P1_2)]      ; xmm2=[PD_DESCALE_P1_2]
-
-        punpckldq  xmm6,xmm3            ; xmm6=(A0 B0 ** **)
-
-        movdqa     xmm7,xmm1
-        punpcklqdq xmm1,xmm5            ; xmm1=(A1 A3 B1 B3)
-        punpckhqdq xmm7,xmm5            ; xmm7=(A5 A7 B5 B7)
-
-        paddd   xmm6,xmm2
-        psrad   xmm6,DESCALE_P1_2
-
-        paddd   xmm1,xmm2
-        paddd   xmm7,xmm2
-        psrad   xmm1,DESCALE_P1_2
-        psrad   xmm7,DESCALE_P1_2
-
-        ; -- Prefetch the next coefficient block
-
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
-        prefetchnta [esi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
-
-        ; ---- Pass 2: process rows, store into output array.
-
-        mov     edi, JSAMPARRAY [output_buf(ebp)]       ; (JSAMPROW *)
-        mov     eax, JDIMENSION [output_col(ebp)]
-
-        ; | input:| result:|
-        ; | A0 B0 |        |
-        ; | A1 B1 | C0 C1  |
-        ; | A3 B3 | D0 D1  |
-        ; | A5 B5 |        |
-        ; | A7 B7 |        |
-
-        ; -- Odd part
-
-        packssdw  xmm1,xmm1             ; xmm1=(A1 A3 B1 B3 A1 A3 B1 B3)
-        packssdw  xmm7,xmm7             ; xmm7=(A5 A7 B5 B7 A5 A7 B5 B7)
-        pmaddwd   xmm1,[GOTOFF(ebx,PW_F362_MF127)]
-        pmaddwd   xmm7,[GOTOFF(ebx,PW_F085_MF072)]
-
-        paddd     xmm1,xmm7             ; xmm1=tmp0[row0 row1 row0 row1]
-
-        ; -- Even part
-
-        pslld     xmm6,(CONST_BITS+2)   ; xmm6=tmp10[row0 row1 **** ****]
-
-        ; -- Final output stage
-
-        movdqa    xmm4,xmm6
-        paddd     xmm6,xmm1     ; xmm6=data0[row0 row1 **** ****]=(C0 C1 ** **)
-        psubd     xmm4,xmm1     ; xmm4=data1[row0 row1 **** ****]=(D0 D1 ** **)
-
-        punpckldq xmm6,xmm4     ; xmm6=(C0 D0 C1 D1)
-
-        paddd     xmm6,[GOTOFF(ebx,PD_DESCALE_P2_2)]
-        psrad     xmm6,DESCALE_P2_2
-
-        packssdw  xmm6,xmm6             ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1)
-        packsswb  xmm6,xmm6             ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1 ..)
-        paddb     xmm6,[GOTOFF(ebx,PB_CENTERJSAMP)]
-
-        pextrw  ebx,xmm6,0x00           ; ebx=(C0 D0 -- --)
-        pextrw  ecx,xmm6,0x01           ; ecx=(C1 D1 -- --)
-
-        mov     edx, JSAMPROW [edi+0*SIZEOF_JSAMPROW]
-        mov     esi, JSAMPROW [edi+1*SIZEOF_JSAMPROW]
-        mov     WORD [edx+eax*SIZEOF_JSAMPLE], bx
-        mov     WORD [esi+eax*SIZEOF_JSAMPLE], cx
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jquantf-sse2-64.asm b/simd/jquantf-sse2-64.asm
deleted file mode 100644
index ef5c1f9..0000000
--- a/simd/jquantf-sse2-64.asm
+++ /dev/null
@@ -1,157 +0,0 @@
-;
-; jquantf.asm - sample data conversion and quantization (64-bit SSE & SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Load data into workspace, applying unsigned->signed conversion
-;
-; GLOBAL(void)
-; jsimd_convsamp_float_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
-;                            FAST_FLOAT *workspace);
-;
-
-; r10 = JSAMPARRAY sample_data
-; r11 = JDIMENSION start_col
-; r12 = FAST_FLOAT *workspace
-
-        align   16
-        global  EXTN(jsimd_convsamp_float_sse2)
-
-EXTN(jsimd_convsamp_float_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-        push    rbx
-
-        pcmpeqw  xmm7,xmm7
-        psllw    xmm7,7
-        packsswb xmm7,xmm7              ; xmm7 = PB_CENTERJSAMPLE (0x808080..)
-
-        mov rsi, r10
-        mov     eax, r11d
-        mov rdi, r12
-        mov     rcx, DCTSIZE/2
-.convloop:
-        mov     rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-        mov rdx, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]       ; (JSAMPLE *)
-
-        movq    xmm0, XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE]
-        movq    xmm1, XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE]
-
-        psubb   xmm0,xmm7                       ; xmm0=(01234567)
-        psubb   xmm1,xmm7                       ; xmm1=(89ABCDEF)
-
-        punpcklbw xmm0,xmm0                     ; xmm0=(*0*1*2*3*4*5*6*7)
-        punpcklbw xmm1,xmm1                     ; xmm1=(*8*9*A*B*C*D*E*F)
-
-        punpcklwd xmm2,xmm0                     ; xmm2=(***0***1***2***3)
-        punpckhwd xmm0,xmm0                     ; xmm0=(***4***5***6***7)
-        punpcklwd xmm3,xmm1                     ; xmm3=(***8***9***A***B)
-        punpckhwd xmm1,xmm1                     ; xmm1=(***C***D***E***F)
-
-        psrad     xmm2,(DWORD_BIT-BYTE_BIT)     ; xmm2=(0123)
-        psrad     xmm0,(DWORD_BIT-BYTE_BIT)     ; xmm0=(4567)
-        cvtdq2ps  xmm2,xmm2                     ; xmm2=(0123)
-        cvtdq2ps  xmm0,xmm0                     ; xmm0=(4567)
-        psrad     xmm3,(DWORD_BIT-BYTE_BIT)     ; xmm3=(89AB)
-        psrad     xmm1,(DWORD_BIT-BYTE_BIT)     ; xmm1=(CDEF)
-        cvtdq2ps  xmm3,xmm3                     ; xmm3=(89AB)
-        cvtdq2ps  xmm1,xmm1                     ; xmm1=(CDEF)
-
-        movaps  XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_FAST_FLOAT)], xmm2
-        movaps  XMMWORD [XMMBLOCK(0,1,rdi,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_FAST_FLOAT)], xmm3
-        movaps  XMMWORD [XMMBLOCK(1,1,rdi,SIZEOF_FAST_FLOAT)], xmm1
-
-        add     rsi, byte 2*SIZEOF_JSAMPROW
-        add     rdi, byte 2*DCTSIZE*SIZEOF_FAST_FLOAT
-        dec     rcx
-        jnz     short .convloop
-
-        pop     rbx
-        uncollect_args
-        pop     rbp
-        ret
-
-
-; --------------------------------------------------------------------------
-;
-; Quantize/descale the coefficients, and store into coef_block
-;
-; GLOBAL(void)
-; jsimd_quantize_float_sse2 (JCOEFPTR coef_block, FAST_FLOAT *divisors,
-;                         FAST_FLOAT *workspace);
-;
-
-; r10 = JCOEFPTR coef_block
-; r11 = FAST_FLOAT *divisors
-; r12 = FAST_FLOAT *workspace
-
-        align   16
-        global  EXTN(jsimd_quantize_float_sse2)
-
-EXTN(jsimd_quantize_float_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-
-        mov rsi, r12
-        mov rdx, r11
-        mov rdi, r10
-        mov     rax, DCTSIZE2/16
-.quantloop:
-        movaps  xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(0,1,rsi,SIZEOF_FAST_FLOAT)]
-        mulps   xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)]
-        mulps   xmm1, XMMWORD [XMMBLOCK(0,1,rdx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(1,1,rsi,SIZEOF_FAST_FLOAT)]
-        mulps   xmm2, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)]
-        mulps   xmm3, XMMWORD [XMMBLOCK(1,1,rdx,SIZEOF_FAST_FLOAT)]
-
-        cvtps2dq xmm0,xmm0
-        cvtps2dq xmm1,xmm1
-        cvtps2dq xmm2,xmm2
-        cvtps2dq xmm3,xmm3
-
-        packssdw xmm0,xmm1
-        packssdw xmm2,xmm3
-
-        movdqa  XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_JCOEF)], xmm0
-        movdqa  XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_JCOEF)], xmm2
-
-        add     rsi, byte 16*SIZEOF_FAST_FLOAT
-        add     rdx, byte 16*SIZEOF_FAST_FLOAT
-        add     rdi, byte 16*SIZEOF_JCOEF
-        dec     rax
-        jnz     short .quantloop
-
-        uncollect_args
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jquantf-sse2.asm b/simd/jquantf-sse2.asm
deleted file mode 100644
index 1cbc267..0000000
--- a/simd/jquantf-sse2.asm
+++ /dev/null
@@ -1,170 +0,0 @@
-;
-; jquantf.asm - sample data conversion and quantization (SSE & SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Load data into workspace, applying unsigned->signed conversion
-;
-; GLOBAL(void)
-; jsimd_convsamp_float_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
-;                            FAST_FLOAT *workspace);
-;
-
-%define sample_data     ebp+8           ; JSAMPARRAY sample_data
-%define start_col       ebp+12          ; JDIMENSION start_col
-%define workspace       ebp+16          ; FAST_FLOAT *workspace
-
-        align   16
-        global  EXTN(jsimd_convsamp_float_sse2)
-
-EXTN(jsimd_convsamp_float_sse2):
-        push    ebp
-        mov     ebp,esp
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        pcmpeqw  xmm7,xmm7
-        psllw    xmm7,7
-        packsswb xmm7,xmm7              ; xmm7 = PB_CENTERJSAMPLE (0x808080..)
-
-        mov     esi, JSAMPARRAY [sample_data]   ; (JSAMPROW *)
-        mov     eax, JDIMENSION [start_col]
-        mov     edi, POINTER [workspace]        ; (DCTELEM *)
-        mov     ecx, DCTSIZE/2
-        alignx  16,7
-.convloop:
-        mov     ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-        mov     edx, JSAMPROW [esi+1*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-
-        movq    xmm0, XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE]
-        movq    xmm1, XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE]
-
-        psubb   xmm0,xmm7                       ; xmm0=(01234567)
-        psubb   xmm1,xmm7                       ; xmm1=(89ABCDEF)
-
-        punpcklbw xmm0,xmm0                     ; xmm0=(*0*1*2*3*4*5*6*7)
-        punpcklbw xmm1,xmm1                     ; xmm1=(*8*9*A*B*C*D*E*F)
-
-        punpcklwd xmm2,xmm0                     ; xmm2=(***0***1***2***3)
-        punpckhwd xmm0,xmm0                     ; xmm0=(***4***5***6***7)
-        punpcklwd xmm3,xmm1                     ; xmm3=(***8***9***A***B)
-        punpckhwd xmm1,xmm1                     ; xmm1=(***C***D***E***F)
-
-        psrad     xmm2,(DWORD_BIT-BYTE_BIT)     ; xmm2=(0123)
-        psrad     xmm0,(DWORD_BIT-BYTE_BIT)     ; xmm0=(4567)
-        cvtdq2ps  xmm2,xmm2                     ; xmm2=(0123)
-        cvtdq2ps  xmm0,xmm0                     ; xmm0=(4567)
-        psrad     xmm3,(DWORD_BIT-BYTE_BIT)     ; xmm3=(89AB)
-        psrad     xmm1,(DWORD_BIT-BYTE_BIT)     ; xmm1=(CDEF)
-        cvtdq2ps  xmm3,xmm3                     ; xmm3=(89AB)
-        cvtdq2ps  xmm1,xmm1                     ; xmm1=(CDEF)
-
-        movaps  XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_FAST_FLOAT)], xmm2
-        movaps  XMMWORD [XMMBLOCK(0,1,edi,SIZEOF_FAST_FLOAT)], xmm0
-        movaps  XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_FAST_FLOAT)], xmm3
-        movaps  XMMWORD [XMMBLOCK(1,1,edi,SIZEOF_FAST_FLOAT)], xmm1
-
-        add     esi, byte 2*SIZEOF_JSAMPROW
-        add     edi, byte 2*DCTSIZE*SIZEOF_FAST_FLOAT
-        dec     ecx
-        jnz     short .convloop
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        pop     ebp
-        ret
-
-
-; --------------------------------------------------------------------------
-;
-; Quantize/descale the coefficients, and store into coef_block
-;
-; GLOBAL(void)
-; jsimd_quantize_float_sse2 (JCOEFPTR coef_block, FAST_FLOAT *divisors,
-;                            FAST_FLOAT *workspace);
-;
-
-%define coef_block      ebp+8           ; JCOEFPTR coef_block
-%define divisors        ebp+12          ; FAST_FLOAT *divisors
-%define workspace       ebp+16          ; FAST_FLOAT *workspace
-
-        align   16
-        global  EXTN(jsimd_quantize_float_sse2)
-
-EXTN(jsimd_quantize_float_sse2):
-        push    ebp
-        mov     ebp,esp
-;       push    ebx             ; unused
-;       push    ecx             ; unused
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        mov     esi, POINTER [workspace]
-        mov     edx, POINTER [divisors]
-        mov     edi, JCOEFPTR [coef_block]
-        mov     eax, DCTSIZE2/16
-        alignx  16,7
-.quantloop:
-        movaps  xmm0, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm1, XMMWORD [XMMBLOCK(0,1,esi,SIZEOF_FAST_FLOAT)]
-        mulps   xmm0, XMMWORD [XMMBLOCK(0,0,edx,SIZEOF_FAST_FLOAT)]
-        mulps   xmm1, XMMWORD [XMMBLOCK(0,1,edx,SIZEOF_FAST_FLOAT)]
-        movaps  xmm2, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_FAST_FLOAT)]
-        movaps  xmm3, XMMWORD [XMMBLOCK(1,1,esi,SIZEOF_FAST_FLOAT)]
-        mulps   xmm2, XMMWORD [XMMBLOCK(1,0,edx,SIZEOF_FAST_FLOAT)]
-        mulps   xmm3, XMMWORD [XMMBLOCK(1,1,edx,SIZEOF_FAST_FLOAT)]
-
-        cvtps2dq xmm0,xmm0
-        cvtps2dq xmm1,xmm1
-        cvtps2dq xmm2,xmm2
-        cvtps2dq xmm3,xmm3
-
-        packssdw xmm0,xmm1
-        packssdw xmm2,xmm3
-
-        movdqa  XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_JCOEF)], xmm0
-        movdqa  XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_JCOEF)], xmm2
-
-        add     esi, byte 16*SIZEOF_FAST_FLOAT
-        add     edx, byte 16*SIZEOF_FAST_FLOAT
-        add     edi, byte 16*SIZEOF_JCOEF
-        dec     eax
-        jnz     short .quantloop
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; unused
-;       pop     ebx             ; unused
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jquanti-sse2-64.asm b/simd/jquanti-sse2-64.asm
deleted file mode 100644
index 66c4e51..0000000
--- a/simd/jquanti-sse2-64.asm
+++ /dev/null
@@ -1,186 +0,0 @@
-;
-; jquanti.asm - sample data conversion and quantization (64-bit SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
-;
-; Load data into workspace, applying unsigned->signed conversion
-;
-; GLOBAL(void)
-; jsimd_convsamp_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
-;                      DCTELEM *workspace);
-;
-
-; r10 = JSAMPARRAY sample_data
-; r11 = JDIMENSION start_col
-; r12 = DCTELEM *workspace
-
-        align   16
-        global  EXTN(jsimd_convsamp_sse2)
-
-EXTN(jsimd_convsamp_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-        push    rbx
-
-        pxor    xmm6,xmm6               ; xmm6=(all 0's)
-        pcmpeqw xmm7,xmm7
-        psllw   xmm7,7                  ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
-
-        mov rsi, r10
-        mov eax, r11d
-        mov rdi, r12
-        mov     rcx, DCTSIZE/4
-.convloop:
-        mov     rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-        mov rdx, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]       ; (JSAMPLE *)
-
-        movq    xmm0, XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE]       ; xmm0=(01234567)
-        movq    xmm1, XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE]       ; xmm1=(89ABCDEF)
-
-        mov     rbx, JSAMPROW [rsi+2*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-        mov     rdx, JSAMPROW [rsi+3*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-
-        movq    xmm2, XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE]       ; xmm2=(GHIJKLMN)
-        movq    xmm3, XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE]       ; xmm3=(OPQRSTUV)
-
-        punpcklbw xmm0,xmm6             ; xmm0=(01234567)
-        punpcklbw xmm1,xmm6             ; xmm1=(89ABCDEF)
-        paddw     xmm0,xmm7
-        paddw     xmm1,xmm7
-        punpcklbw xmm2,xmm6             ; xmm2=(GHIJKLMN)
-        punpcklbw xmm3,xmm6             ; xmm3=(OPQRSTUV)
-        paddw     xmm2,xmm7
-        paddw     xmm3,xmm7
-
-        movdqa  XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_DCTELEM)], xmm0
-        movdqa  XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_DCTELEM)], xmm1
-        movdqa  XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_DCTELEM)], xmm2
-        movdqa  XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_DCTELEM)], xmm3
-
-        add     rsi, byte 4*SIZEOF_JSAMPROW
-        add     rdi, byte 4*DCTSIZE*SIZEOF_DCTELEM
-        dec     rcx
-        jnz     short .convloop
-
-        pop     rbx
-        uncollect_args
-        pop     rbp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Quantize/descale the coefficients, and store into coef_block
-;
-; This implementation is based on an algorithm described in
-;   "How to optimize for the Pentium family of microprocessors"
-;   (http://www.agner.org/assem/).
-;
-; GLOBAL(void)
-; jsimd_quantize_sse2 (JCOEFPTR coef_block, DCTELEM *divisors,
-;                      DCTELEM *workspace);
-;
-
-%define RECIPROCAL(m,n,b) XMMBLOCK(DCTSIZE*0+(m),(n),(b),SIZEOF_DCTELEM)
-%define CORRECTION(m,n,b) XMMBLOCK(DCTSIZE*1+(m),(n),(b),SIZEOF_DCTELEM)
-%define SCALE(m,n,b)      XMMBLOCK(DCTSIZE*2+(m),(n),(b),SIZEOF_DCTELEM)
-
-; r10 = JCOEFPTR coef_block
-; r11 = DCTELEM *divisors
-; r12 = DCTELEM *workspace
-
-        align   16
-        global  EXTN(jsimd_quantize_sse2)
-
-EXTN(jsimd_quantize_sse2):
-        push    rbp
-        mov     rax,rsp
-        mov     rbp,rsp
-        collect_args
-
-        mov rsi, r12
-        mov rdx, r11
-        mov rdi, r10
-        mov     rax, DCTSIZE2/32
-.quantloop:
-        movdqa  xmm4, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_DCTELEM)]
-        movdqa  xmm5, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_DCTELEM)]
-        movdqa  xmm6, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_DCTELEM)]
-        movdqa  xmm7, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_DCTELEM)]
-        movdqa  xmm0,xmm4
-        movdqa  xmm1,xmm5
-        movdqa  xmm2,xmm6
-        movdqa  xmm3,xmm7
-        psraw   xmm4,(WORD_BIT-1)
-        psraw   xmm5,(WORD_BIT-1)
-        psraw   xmm6,(WORD_BIT-1)
-        psraw   xmm7,(WORD_BIT-1)
-        pxor    xmm0,xmm4
-        pxor    xmm1,xmm5
-        pxor    xmm2,xmm6
-        pxor    xmm3,xmm7
-        psubw   xmm0,xmm4               ; if (xmm0 < 0) xmm0 = -xmm0;
-        psubw   xmm1,xmm5               ; if (xmm1 < 0) xmm1 = -xmm1;
-        psubw   xmm2,xmm6               ; if (xmm2 < 0) xmm2 = -xmm2;
-        psubw   xmm3,xmm7               ; if (xmm3 < 0) xmm3 = -xmm3;
-
-        paddw   xmm0, XMMWORD [CORRECTION(0,0,rdx)]  ; correction + roundfactor
-        paddw   xmm1, XMMWORD [CORRECTION(1,0,rdx)]
-        paddw   xmm2, XMMWORD [CORRECTION(2,0,rdx)]
-        paddw   xmm3, XMMWORD [CORRECTION(3,0,rdx)]
-        pmulhuw xmm0, XMMWORD [RECIPROCAL(0,0,rdx)]  ; reciprocal
-        pmulhuw xmm1, XMMWORD [RECIPROCAL(1,0,rdx)]
-        pmulhuw xmm2, XMMWORD [RECIPROCAL(2,0,rdx)]
-        pmulhuw xmm3, XMMWORD [RECIPROCAL(3,0,rdx)]
-        pmulhuw xmm0, XMMWORD [SCALE(0,0,rdx)]  ; scale
-        pmulhuw xmm1, XMMWORD [SCALE(1,0,rdx)]
-        pmulhuw xmm2, XMMWORD [SCALE(2,0,rdx)]
-        pmulhuw xmm3, XMMWORD [SCALE(3,0,rdx)]
-
-        pxor    xmm0,xmm4
-        pxor    xmm1,xmm5
-        pxor    xmm2,xmm6
-        pxor    xmm3,xmm7
-        psubw   xmm0,xmm4
-        psubw   xmm1,xmm5
-        psubw   xmm2,xmm6
-        psubw   xmm3,xmm7
-        movdqa  XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_DCTELEM)], xmm0
-        movdqa  XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_DCTELEM)], xmm1
-        movdqa  XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_DCTELEM)], xmm2
-        movdqa  XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_DCTELEM)], xmm3
-
-        add     rsi, byte 32*SIZEOF_DCTELEM
-        add     rdx, byte 32*SIZEOF_DCTELEM
-        add     rdi, byte 32*SIZEOF_JCOEF
-        dec     rax
-        jnz     near .quantloop
-
-        uncollect_args
-        pop     rbp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jquanti-sse2.asm b/simd/jquanti-sse2.asm
deleted file mode 100644
index aea8604..0000000
--- a/simd/jquanti-sse2.asm
+++ /dev/null
@@ -1,199 +0,0 @@
-;
-; jquanti.asm - sample data conversion and quantization (SSE2)
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-%include "jdct.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Load data into workspace, applying unsigned->signed conversion
-;
-; GLOBAL(void)
-; jsimd_convsamp_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
-;                      DCTELEM *workspace);
-;
-
-%define sample_data     ebp+8           ; JSAMPARRAY sample_data
-%define start_col       ebp+12          ; JDIMENSION start_col
-%define workspace       ebp+16          ; DCTELEM *workspace
-
-        align   16
-        global  EXTN(jsimd_convsamp_sse2)
-
-EXTN(jsimd_convsamp_sse2):
-        push    ebp
-        mov     ebp,esp
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        pxor    xmm6,xmm6               ; xmm6=(all 0's)
-        pcmpeqw xmm7,xmm7
-        psllw   xmm7,7                  ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
-
-        mov     esi, JSAMPARRAY [sample_data]   ; (JSAMPROW *)
-        mov     eax, JDIMENSION [start_col]
-        mov     edi, POINTER [workspace]        ; (DCTELEM *)
-        mov     ecx, DCTSIZE/4
-        alignx  16,7
-.convloop:
-        mov     ebx, JSAMPROW [esi+0*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-        mov     edx, JSAMPROW [esi+1*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-
-        movq    xmm0, XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE]       ; xmm0=(01234567)
-        movq    xmm1, XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE]       ; xmm1=(89ABCDEF)
-
-        mov     ebx, JSAMPROW [esi+2*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-        mov     edx, JSAMPROW [esi+3*SIZEOF_JSAMPROW]   ; (JSAMPLE *)
-
-        movq    xmm2, XMM_MMWORD [ebx+eax*SIZEOF_JSAMPLE]       ; xmm2=(GHIJKLMN)
-        movq    xmm3, XMM_MMWORD [edx+eax*SIZEOF_JSAMPLE]       ; xmm3=(OPQRSTUV)
-
-        punpcklbw xmm0,xmm6             ; xmm0=(01234567)
-        punpcklbw xmm1,xmm6             ; xmm1=(89ABCDEF)
-        paddw     xmm0,xmm7
-        paddw     xmm1,xmm7
-        punpcklbw xmm2,xmm6             ; xmm2=(GHIJKLMN)
-        punpcklbw xmm3,xmm6             ; xmm3=(OPQRSTUV)
-        paddw     xmm2,xmm7
-        paddw     xmm3,xmm7
-
-        movdqa  XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_DCTELEM)], xmm0
-        movdqa  XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_DCTELEM)], xmm1
-        movdqa  XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_DCTELEM)], xmm2
-        movdqa  XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_DCTELEM)], xmm3
-
-        add     esi, byte 4*SIZEOF_JSAMPROW
-        add     edi, byte 4*DCTSIZE*SIZEOF_DCTELEM
-        dec     ecx
-        jnz     short .convloop
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        pop     ebp
-        ret
-
-; --------------------------------------------------------------------------
-;
-; Quantize/descale the coefficients, and store into coef_block
-;
-; This implementation is based on an algorithm described in
-;   "How to optimize for the Pentium family of microprocessors"
-;   (http://www.agner.org/assem/).
-;
-; GLOBAL(void)
-; jsimd_quantize_sse2 (JCOEFPTR coef_block, DCTELEM *divisors,
-;                      DCTELEM *workspace);
-;
-
-%define RECIPROCAL(m,n,b) XMMBLOCK(DCTSIZE*0+(m),(n),(b),SIZEOF_DCTELEM)
-%define CORRECTION(m,n,b) XMMBLOCK(DCTSIZE*1+(m),(n),(b),SIZEOF_DCTELEM)
-%define SCALE(m,n,b)      XMMBLOCK(DCTSIZE*2+(m),(n),(b),SIZEOF_DCTELEM)
-
-%define coef_block      ebp+8           ; JCOEFPTR coef_block
-%define divisors        ebp+12          ; DCTELEM *divisors
-%define workspace       ebp+16          ; DCTELEM *workspace
-
-        align   16
-        global  EXTN(jsimd_quantize_sse2)
-
-EXTN(jsimd_quantize_sse2):
-        push    ebp
-        mov     ebp,esp
-;       push    ebx             ; unused
-;       push    ecx             ; unused
-;       push    edx             ; need not be preserved
-        push    esi
-        push    edi
-
-        mov     esi, POINTER [workspace]
-        mov     edx, POINTER [divisors]
-        mov     edi, JCOEFPTR [coef_block]
-        mov     eax, DCTSIZE2/32
-        alignx  16,7
-.quantloop:
-        movdqa  xmm4, XMMWORD [XMMBLOCK(0,0,esi,SIZEOF_DCTELEM)]
-        movdqa  xmm5, XMMWORD [XMMBLOCK(1,0,esi,SIZEOF_DCTELEM)]
-        movdqa  xmm6, XMMWORD [XMMBLOCK(2,0,esi,SIZEOF_DCTELEM)]
-        movdqa  xmm7, XMMWORD [XMMBLOCK(3,0,esi,SIZEOF_DCTELEM)]
-        movdqa  xmm0,xmm4
-        movdqa  xmm1,xmm5
-        movdqa  xmm2,xmm6
-        movdqa  xmm3,xmm7
-        psraw   xmm4,(WORD_BIT-1)
-        psraw   xmm5,(WORD_BIT-1)
-        psraw   xmm6,(WORD_BIT-1)
-        psraw   xmm7,(WORD_BIT-1)
-        pxor    xmm0,xmm4
-        pxor    xmm1,xmm5
-        pxor    xmm2,xmm6
-        pxor    xmm3,xmm7
-        psubw   xmm0,xmm4               ; if (xmm0 < 0) xmm0 = -xmm0;
-        psubw   xmm1,xmm5               ; if (xmm1 < 0) xmm1 = -xmm1;
-        psubw   xmm2,xmm6               ; if (xmm2 < 0) xmm2 = -xmm2;
-        psubw   xmm3,xmm7               ; if (xmm3 < 0) xmm3 = -xmm3;
-
-        paddw   xmm0, XMMWORD [CORRECTION(0,0,edx)]  ; correction + roundfactor
-        paddw   xmm1, XMMWORD [CORRECTION(1,0,edx)]
-        paddw   xmm2, XMMWORD [CORRECTION(2,0,edx)]
-        paddw   xmm3, XMMWORD [CORRECTION(3,0,edx)]
-        pmulhuw xmm0, XMMWORD [RECIPROCAL(0,0,edx)]  ; reciprocal
-        pmulhuw xmm1, XMMWORD [RECIPROCAL(1,0,edx)]
-        pmulhuw xmm2, XMMWORD [RECIPROCAL(2,0,edx)]
-        pmulhuw xmm3, XMMWORD [RECIPROCAL(3,0,edx)]
-        pmulhuw xmm0, XMMWORD [SCALE(0,0,edx)]  ; scale
-        pmulhuw xmm1, XMMWORD [SCALE(1,0,edx)]
-        pmulhuw xmm2, XMMWORD [SCALE(2,0,edx)]
-        pmulhuw xmm3, XMMWORD [SCALE(3,0,edx)]
-
-        pxor    xmm0,xmm4
-        pxor    xmm1,xmm5
-        pxor    xmm2,xmm6
-        pxor    xmm3,xmm7
-        psubw   xmm0,xmm4
-        psubw   xmm1,xmm5
-        psubw   xmm2,xmm6
-        psubw   xmm3,xmm7
-        movdqa  XMMWORD [XMMBLOCK(0,0,edi,SIZEOF_DCTELEM)], xmm0
-        movdqa  XMMWORD [XMMBLOCK(1,0,edi,SIZEOF_DCTELEM)], xmm1
-        movdqa  XMMWORD [XMMBLOCK(2,0,edi,SIZEOF_DCTELEM)], xmm2
-        movdqa  XMMWORD [XMMBLOCK(3,0,edi,SIZEOF_DCTELEM)], xmm3
-
-        add     esi, byte 32*SIZEOF_DCTELEM
-        add     edx, byte 32*SIZEOF_DCTELEM
-        add     edi, byte 32*SIZEOF_JCOEF
-        dec     eax
-        jnz     near .quantloop
-
-        pop     edi
-        pop     esi
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; unused
-;       pop     ebx             ; unused
-        pop     ebp
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jsimd.h b/simd/jsimd.h
index dc6ec43..f3ead87 100644
--- a/simd/jsimd.h
+++ b/simd/jsimd.h
@@ -23,6 +23,7 @@
 #define JSIMD_ARM_NEON   0x10
 #define JSIMD_MIPS_DSPR2 0x20
 #define JSIMD_ALTIVEC    0x40
+#define JSIMD_AVX2       0x80
 
 /* SIMD Ext: retrieve SIMD/CPU information */
 EXTERN(unsigned int) jpeg_simd_cpu_support (void);
@@ -73,6 +74,29 @@ EXTERN(void) jsimd_extxrgb_ycc_convert_sse2
         (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
          JDIMENSION output_row, int num_rows);
 
+extern const int jconst_rgb_ycc_convert_avx2[];
+EXTERN(void) jsimd_rgb_ycc_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgb_ycc_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgbx_ycc_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgr_ycc_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgrx_ycc_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxbgr_ycc_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxrgb_ycc_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+
 EXTERN(void) jsimd_rgb_ycc_convert_neon
         (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
          JDIMENSION output_row, int num_rows);
@@ -192,6 +216,29 @@ EXTERN(void) jsimd_extxrgb_gray_convert_sse2
         (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
          JDIMENSION output_row, int num_rows);
 
+extern const int jconst_rgb_gray_convert_avx2[];
+EXTERN(void) jsimd_rgb_gray_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgb_gray_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extrgbx_gray_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgr_gray_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extbgrx_gray_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxbgr_gray_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+EXTERN(void) jsimd_extxrgb_gray_convert_avx2
+        (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+         JDIMENSION output_row, int num_rows);
+
 EXTERN(void) jsimd_rgb_gray_convert_mips_dspr2
         (JDIMENSION img_width, JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
          JDIMENSION output_row, int num_rows);
@@ -282,6 +329,29 @@ EXTERN(void) jsimd_ycc_extxrgb_convert_sse2
         (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
          JSAMPARRAY output_buf, int num_rows);
 
+extern const int jconst_ycc_rgb_convert_avx2[];
+EXTERN(void) jsimd_ycc_rgb_convert_avx2
+        (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+         JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extrgb_convert_avx2
+        (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+         JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extrgbx_convert_avx2
+        (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+         JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extbgr_convert_avx2
+        (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+         JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extbgrx_convert_avx2
+        (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+         JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extxbgr_convert_avx2
+        (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+         JSAMPARRAY output_buf, int num_rows);
+EXTERN(void) jsimd_ycc_extxrgb_convert_avx2
+        (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
+         JSAMPARRAY output_buf, int num_rows);
+
 EXTERN(void) jsimd_ycc_rgb_convert_neon
         (JDIMENSION out_width, JSAMPIMAGE input_buf, JDIMENSION input_row,
          JSAMPARRAY output_buf, int num_rows);
@@ -374,6 +444,11 @@ EXTERN(void) jsimd_h2v1_downsample_sse2
          JDIMENSION v_samp_factor, JDIMENSION width_blocks,
          JSAMPARRAY input_data, JSAMPARRAY output_data);
 
+EXTERN(void) jsimd_h2v1_downsample_avx2
+        (JDIMENSION image_width, int max_v_samp_factor,
+         JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+         JSAMPARRAY input_data, JSAMPARRAY output_data);
+
 EXTERN(void) jsimd_h2v1_downsample_neon
         (JDIMENSION image_width, int max_v_samp_factor,
          JDIMENSION v_samp_factor, JDIMENSION width_blocks,
@@ -400,6 +475,11 @@ EXTERN(void) jsimd_h2v2_downsample_sse2
          JDIMENSION v_samp_factor, JDIMENSION width_blocks,
          JSAMPARRAY input_data, JSAMPARRAY output_data);
 
+EXTERN(void) jsimd_h2v2_downsample_avx2
+        (JDIMENSION image_width, int max_v_samp_factor,
+         JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+         JSAMPARRAY input_data, JSAMPARRAY output_data);
+
 EXTERN(void) jsimd_h2v2_downsample_neon
         (JDIMENSION image_width, int max_v_samp_factor,
          JDIMENSION v_samp_factor, JDIMENSION width_blocks,
@@ -438,6 +518,13 @@ EXTERN(void) jsimd_h2v2_upsample_sse2
         (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
          JSAMPARRAY *output_data_ptr);
 
+EXTERN(void) jsimd_h2v1_upsample_avx2
+        (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
+         JSAMPARRAY *output_data_ptr);
+EXTERN(void) jsimd_h2v2_upsample_avx2
+        (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
+         JSAMPARRAY *output_data_ptr);
+
 EXTERN(void) jsimd_h2v1_upsample_mips_dspr2
         (int max_v_samp_factor, JDIMENSION output_width, JSAMPARRAY input_data,
          JSAMPARRAY *output_data_ptr);
@@ -473,6 +560,14 @@ EXTERN(void) jsimd_h2v2_fancy_upsample_sse2
         (int max_v_samp_factor, JDIMENSION downsampled_width,
          JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr);
 
+extern const int jconst_fancy_upsample_avx2[];
+EXTERN(void) jsimd_h2v1_fancy_upsample_avx2
+        (int max_v_samp_factor, JDIMENSION downsampled_width,
+         JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr);
+EXTERN(void) jsimd_h2v2_fancy_upsample_avx2
+        (int max_v_samp_factor, JDIMENSION downsampled_width,
+         JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr);
+
 EXTERN(void) jsimd_h2v1_fancy_upsample_neon
         (int max_v_samp_factor, JDIMENSION downsampled_width,
          JSAMPARRAY input_data, JSAMPARRAY *output_data_ptr);
@@ -581,6 +676,51 @@ EXTERN(void) jsimd_h2v2_extxrgb_merged_upsample_sse2
         (JDIMENSION output_width, JSAMPIMAGE input_buf,
          JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
 
+extern const int jconst_merged_upsample_avx2[];
+EXTERN(void) jsimd_h2v1_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extrgb_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extrgbx_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extbgr_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extbgrx_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extxbgr_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v1_extxrgb_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+
+EXTERN(void) jsimd_h2v2_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extrgb_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extrgbx_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extbgr_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extbgrx_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extxbgr_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+EXTERN(void) jsimd_h2v2_extxrgb_merged_upsample_avx2
+        (JDIMENSION output_width, JSAMPIMAGE input_buf,
+         JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf);
+
 EXTERN(void) jsimd_h2v1_merged_upsample_mips_dspr2
         (JDIMENSION output_width, JSAMPIMAGE input_buf,
          JDIMENSION in_row_group_ctr, JSAMPARRAY output_buf, JSAMPLE* range);
@@ -735,6 +875,9 @@ EXTERN(void) jsimd_quantize_mmx
 EXTERN(void) jsimd_quantize_sse2
         (JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace);
 
+EXTERN(void) jsimd_quantize_avx2
+        (JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace);
+
 EXTERN(void) jsimd_quantize_neon
         (JCOEFPTR coef_block, DCTELEM *divisors, DCTELEM *workspace);
 
diff --git a/simd/jsimdcfg.inc.h b/simd/jsimdcfg.inc.h
index d2b499f..7ff7e29 100644
--- a/simd/jsimdcfg.inc.h
+++ b/simd/jsimdcfg.inc.h
@@ -19,79 +19,79 @@
 ; -- jpeglib.h
 ;
 
-%define _cpp_protection_DCTSIZE DCTSIZE
-%define _cpp_protection_DCTSIZE2 DCTSIZE2
+%define _cpp_protection_DCTSIZE   DCTSIZE
+%define _cpp_protection_DCTSIZE2  DCTSIZE2
 
 ;
 ; -- jmorecfg.h
 ;
 
-%define _cpp_protection_RGB_RED RGB_RED
-%define _cpp_protection_RGB_GREEN RGB_GREEN
-%define _cpp_protection_RGB_BLUE RGB_BLUE
-%define _cpp_protection_RGB_PIXELSIZE RGB_PIXELSIZE
+%define _cpp_protection_RGB_RED             RGB_RED
+%define _cpp_protection_RGB_GREEN           RGB_GREEN
+%define _cpp_protection_RGB_BLUE            RGB_BLUE
+%define _cpp_protection_RGB_PIXELSIZE       RGB_PIXELSIZE
 
-%define _cpp_protection_EXT_RGB_RED EXT_RGB_RED
-%define _cpp_protection_EXT_RGB_GREEN EXT_RGB_GREEN
-%define _cpp_protection_EXT_RGB_BLUE EXT_RGB_BLUE
-%define _cpp_protection_EXT_RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define _cpp_protection_EXT_RGB_RED         EXT_RGB_RED
+%define _cpp_protection_EXT_RGB_GREEN       EXT_RGB_GREEN
+%define _cpp_protection_EXT_RGB_BLUE        EXT_RGB_BLUE
+%define _cpp_protection_EXT_RGB_PIXELSIZE   EXT_RGB_PIXELSIZE
 
-%define _cpp_protection_EXT_RGBX_RED EXT_RGBX_RED
-%define _cpp_protection_EXT_RGBX_GREEN EXT_RGBX_GREEN
-%define _cpp_protection_EXT_RGBX_BLUE EXT_RGBX_BLUE
-%define _cpp_protection_EXT_RGBX_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define _cpp_protection_EXT_RGBX_RED        EXT_RGBX_RED
+%define _cpp_protection_EXT_RGBX_GREEN      EXT_RGBX_GREEN
+%define _cpp_protection_EXT_RGBX_BLUE       EXT_RGBX_BLUE
+%define _cpp_protection_EXT_RGBX_PIXELSIZE  EXT_RGBX_PIXELSIZE
 
-%define _cpp_protection_EXT_BGR_RED EXT_BGR_RED
-%define _cpp_protection_EXT_BGR_GREEN EXT_BGR_GREEN
-%define _cpp_protection_EXT_BGR_BLUE EXT_BGR_BLUE
-%define _cpp_protection_EXT_BGR_PIXELSIZE EXT_BGR_PIXELSIZE
+%define _cpp_protection_EXT_BGR_RED         EXT_BGR_RED
+%define _cpp_protection_EXT_BGR_GREEN       EXT_BGR_GREEN
+%define _cpp_protection_EXT_BGR_BLUE        EXT_BGR_BLUE
+%define _cpp_protection_EXT_BGR_PIXELSIZE   EXT_BGR_PIXELSIZE
 
-%define _cpp_protection_EXT_BGRX_RED EXT_BGRX_RED
-%define _cpp_protection_EXT_BGRX_GREEN EXT_BGRX_GREEN
-%define _cpp_protection_EXT_BGRX_BLUE EXT_BGRX_BLUE
-%define _cpp_protection_EXT_BGRX_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define _cpp_protection_EXT_BGRX_RED        EXT_BGRX_RED
+%define _cpp_protection_EXT_BGRX_GREEN      EXT_BGRX_GREEN
+%define _cpp_protection_EXT_BGRX_BLUE       EXT_BGRX_BLUE
+%define _cpp_protection_EXT_BGRX_PIXELSIZE  EXT_BGRX_PIXELSIZE
 
-%define _cpp_protection_EXT_XBGR_RED EXT_XBGR_RED
-%define _cpp_protection_EXT_XBGR_GREEN EXT_XBGR_GREEN
-%define _cpp_protection_EXT_XBGR_BLUE EXT_XBGR_BLUE
-%define _cpp_protection_EXT_XBGR_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define _cpp_protection_EXT_XBGR_RED        EXT_XBGR_RED
+%define _cpp_protection_EXT_XBGR_GREEN      EXT_XBGR_GREEN
+%define _cpp_protection_EXT_XBGR_BLUE       EXT_XBGR_BLUE
+%define _cpp_protection_EXT_XBGR_PIXELSIZE  EXT_XBGR_PIXELSIZE
 
-%define _cpp_protection_EXT_XRGB_RED EXT_XRGB_RED
-%define _cpp_protection_EXT_XRGB_GREEN EXT_XRGB_GREEN
-%define _cpp_protection_EXT_XRGB_BLUE EXT_XRGB_BLUE
-%define _cpp_protection_EXT_XRGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define _cpp_protection_EXT_XRGB_RED        EXT_XRGB_RED
+%define _cpp_protection_EXT_XRGB_GREEN      EXT_XRGB_GREEN
+%define _cpp_protection_EXT_XRGB_BLUE       EXT_XRGB_BLUE
+%define _cpp_protection_EXT_XRGB_PIXELSIZE  EXT_XRGB_PIXELSIZE
 
-%define RGBX_FILLER_0XFF        1
+%define RGBX_FILLER_0XFF  1
 
 ; Representation of a single sample (pixel element value).
 ; On this SIMD implementation, this must be 'unsigned char'.
 ;
 
-%define JSAMPLE                 byte          ; unsigned char
-%define SIZEOF_JSAMPLE          SIZEOF_BYTE   ; sizeof(JSAMPLE)
+%define JSAMPLE            byte            ; unsigned char
+%define SIZEOF_JSAMPLE     SIZEOF_BYTE     ; sizeof(JSAMPLE)
 
-%define _cpp_protection_CENTERJSAMPLE CENTERJSAMPLE
+%define _cpp_protection_CENTERJSAMPLE  CENTERJSAMPLE
 
 ; Representation of a DCT frequency coefficient.
 ; On this SIMD implementation, this must be 'short'.
 ;
-%define JCOEF                   word          ; short
-%define SIZEOF_JCOEF            SIZEOF_WORD   ; sizeof(JCOEF)
+%define JCOEF              word            ; short
+%define SIZEOF_JCOEF       SIZEOF_WORD     ; sizeof(JCOEF)
 
 ; Datatype used for image dimensions.
 ; On this SIMD implementation, this must be 'unsigned int'.
 ;
-%define JDIMENSION              dword         ; unsigned int
-%define SIZEOF_JDIMENSION       SIZEOF_DWORD  ; sizeof(JDIMENSION)
-
-%define JSAMPROW                POINTER       ; JSAMPLE *     (jpeglib.h)
-%define JSAMPARRAY              POINTER       ; JSAMPROW *    (jpeglib.h)
-%define JSAMPIMAGE              POINTER       ; JSAMPARRAY *  (jpeglib.h)
-%define JCOEFPTR                POINTER       ; JCOEF *       (jpeglib.h)
-%define SIZEOF_JSAMPROW         SIZEOF_POINTER  ; sizeof(JSAMPROW)
-%define SIZEOF_JSAMPARRAY       SIZEOF_POINTER  ; sizeof(JSAMPARRAY)
-%define SIZEOF_JSAMPIMAGE       SIZEOF_POINTER  ; sizeof(JSAMPIMAGE)
-%define SIZEOF_JCOEFPTR         SIZEOF_POINTER  ; sizeof(JCOEFPTR)
+%define JDIMENSION         dword           ; unsigned int
+%define SIZEOF_JDIMENSION  SIZEOF_DWORD    ; sizeof(JDIMENSION)
+
+%define JSAMPROW           POINTER         ; JSAMPLE *     (jpeglib.h)
+%define JSAMPARRAY         POINTER         ; JSAMPROW *    (jpeglib.h)
+%define JSAMPIMAGE         POINTER         ; JSAMPARRAY *  (jpeglib.h)
+%define JCOEFPTR           POINTER         ; JCOEF *       (jpeglib.h)
+%define SIZEOF_JSAMPROW    SIZEOF_POINTER  ; sizeof(JSAMPROW)
+%define SIZEOF_JSAMPARRAY  SIZEOF_POINTER  ; sizeof(JSAMPARRAY)
+%define SIZEOF_JSAMPIMAGE  SIZEOF_POINTER  ; sizeof(JSAMPIMAGE)
+%define SIZEOF_JCOEFPTR    SIZEOF_POINTER  ; sizeof(JCOEFPTR)
 
 ;
 ; -- jdct.h
@@ -101,30 +101,31 @@
 ; the DCT is to be performed in-place in that buffer.
 ; To maximize parallelism, Type DCTELEM is changed to short (originally, int).
 ;
-%define DCTELEM                 word          ; short
-%define SIZEOF_DCTELEM          SIZEOF_WORD   ; sizeof(DCTELEM)
+%define DCTELEM                 word         ; short
+%define SIZEOF_DCTELEM          SIZEOF_WORD  ; sizeof(DCTELEM)
 
-%define FAST_FLOAT              FP32            ; float
-%define SIZEOF_FAST_FLOAT       SIZEOF_FP32     ; sizeof(FAST_FLOAT)
+%define FAST_FLOAT              FP32         ; float
+%define SIZEOF_FAST_FLOAT       SIZEOF_FP32  ; sizeof(FAST_FLOAT)
 
 ; To maximize parallelism, Type MULTIPLIER is changed to short.
 ;
-%define ISLOW_MULT_TYPE         word          ; must be short
-%define SIZEOF_ISLOW_MULT_TYPE  SIZEOF_WORD   ; sizeof(ISLOW_MULT_TYPE)
+%define ISLOW_MULT_TYPE         word         ; must be short
+%define SIZEOF_ISLOW_MULT_TYPE  SIZEOF_WORD  ; sizeof(ISLOW_MULT_TYPE)
 
-%define IFAST_MULT_TYPE         word          ; must be short
-%define SIZEOF_IFAST_MULT_TYPE  SIZEOF_WORD   ; sizeof(IFAST_MULT_TYPE)
-%define IFAST_SCALE_BITS        2             ; fractional bits in scale factors
+%define IFAST_MULT_TYPE         word         ; must be short
+%define SIZEOF_IFAST_MULT_TYPE  SIZEOF_WORD  ; sizeof(IFAST_MULT_TYPE)
+%define IFAST_SCALE_BITS        2            ; fractional bits in scale factors
 
-%define FLOAT_MULT_TYPE         FP32          ; must be float
-%define SIZEOF_FLOAT_MULT_TYPE  SIZEOF_FP32   ; sizeof(FLOAT_MULT_TYPE)
+%define FLOAT_MULT_TYPE         FP32         ; must be float
+%define SIZEOF_FLOAT_MULT_TYPE  SIZEOF_FP32  ; sizeof(FLOAT_MULT_TYPE)
 
 ;
 ; -- jsimd.h
 ;
 
-%define _cpp_protection_JSIMD_NONE JSIMD_NONE
-%define _cpp_protection_JSIMD_MMX JSIMD_MMX
-%define _cpp_protection_JSIMD_3DNOW JSIMD_3DNOW
-%define _cpp_protection_JSIMD_SSE JSIMD_SSE
-%define _cpp_protection_JSIMD_SSE2 JSIMD_SSE2
+%define _cpp_protection_JSIMD_NONE   JSIMD_NONE
+%define _cpp_protection_JSIMD_MMX    JSIMD_MMX
+%define _cpp_protection_JSIMD_3DNOW  JSIMD_3DNOW
+%define _cpp_protection_JSIMD_SSE    JSIMD_SSE
+%define _cpp_protection_JSIMD_SSE2   JSIMD_SSE2
+%define _cpp_protection_JSIMD_AVX2   JSIMD_AVX2
diff --git a/simd/jsimdcpu.asm b/simd/jsimdcpu.asm
deleted file mode 100644
index 599083b..0000000
--- a/simd/jsimdcpu.asm
+++ /dev/null
@@ -1,104 +0,0 @@
-;
-; jsimdcpu.asm - SIMD instruction support check
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-;
-; Based on the x86 SIMD extension for IJG JPEG library
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-; For conditions of distribution and use, see copyright notice in jsimdext.inc
-;
-; This file should be assembled with NASM (Netwide Assembler),
-; can *not* be assembled with Microsoft's MASM or any compatible
-; assembler (including Borland's Turbo Assembler).
-; NASM is available from http://nasm.sourceforge.net/ or
-; http://sourceforge.net/project/showfiles.php?group_id=6208
-;
-; [TAB8]
-
-%include "jsimdext.inc"
-
-; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    32
-;
-; Check if the CPU supports SIMD instructions
-;
-; GLOBAL(unsigned int)
-; jpeg_simd_cpu_support (void)
-;
-
-        align   16
-        global  EXTN(jpeg_simd_cpu_support)
-
-EXTN(jpeg_simd_cpu_support):
-        push    ebx
-;       push    ecx             ; need not be preserved
-;       push    edx             ; need not be preserved
-;       push    esi             ; unused
-        push    edi
-
-        xor     edi,edi                 ; simd support flag
-
-        pushfd
-        pop     eax
-        mov     edx,eax
-        xor     eax, 1<<21              ; flip ID bit in EFLAGS
-        push    eax
-        popfd
-        pushfd
-        pop     eax
-        xor     eax,edx
-        jz      short .return           ; CPUID is not supported
-
-        ; Check for MMX instruction support
-        xor     eax,eax
-        cpuid
-        test    eax,eax
-        jz      short .return
-
-        xor     eax,eax
-        inc     eax
-        cpuid
-        mov     eax,edx                 ; eax = Standard feature flags
-
-        test    eax, 1<<23              ; bit23:MMX
-        jz      short .no_mmx
-        or      edi, byte JSIMD_MMX
-.no_mmx:
-        test    eax, 1<<25              ; bit25:SSE
-        jz      short .no_sse
-        or      edi, byte JSIMD_SSE
-.no_sse:
-        test    eax, 1<<26              ; bit26:SSE2
-        jz      short .no_sse2
-        or      edi, byte JSIMD_SSE2
-.no_sse2:
-
-        ; Check for 3DNow! instruction support
-        mov     eax, 0x80000000
-        cpuid
-        cmp     eax, 0x80000000
-        jbe     short .return
-
-        mov     eax, 0x80000001
-        cpuid
-        mov     eax,edx                 ; eax = Extended feature flags
-
-        test    eax, 1<<31              ; bit31:3DNow!(vendor independent)
-        jz      short .no_3dnow
-        or      edi, byte JSIMD_3DNOW
-.no_3dnow:
-
-.return:
-        mov     eax,edi
-
-        pop     edi
-;       pop     esi             ; unused
-;       pop     edx             ; need not be preserved
-;       pop     ecx             ; need not be preserved
-        pop     ebx
-        ret
-
-; For some reason, the OS X linker does not honor the request to align the
-; segment unless we do this.
-        align   16
diff --git a/simd/jsimdext.inc b/simd/jsimdext.inc
deleted file mode 100644
index f28db60..0000000
--- a/simd/jsimdext.inc
+++ /dev/null
@@ -1,375 +0,0 @@
-;
-; jsimdext.inc - common declarations
-;
-; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2010, D. R. Commander.
-;
-; Based on the x86 SIMD extension for IJG JPEG library - version 1.02
-;
-; Copyright (C) 1999-2006, MIYASAKA Masaru.
-;
-; This software is provided 'as-is', without any express or implied
-; warranty.  In no event will the authors be held liable for any damages
-; arising from the use of this software.
-;
-; Permission is granted to anyone to use this software for any purpose,
-; including commercial applications, and to alter it and redistribute it
-; freely, subject to the following restrictions:
-;
-; 1. The origin of this software must not be misrepresented; you must not
-;    claim that you wrote the original software. If you use this software
-;    in a product, an acknowledgment in the product documentation would be
-;    appreciated but is not required.
-; 2. Altered source versions must be plainly marked as such, and must not be
-;    misrepresented as being the original software.
-; 3. This notice may not be removed or altered from any source distribution.
-;
-; [TAB8]
-
-; ==========================================================================
-;  System-dependent configurations
-
-%ifdef WIN32    ; ----(nasm -fwin32 -DWIN32 ...)--------
-; * Microsoft Visual C++
-; * MinGW (Minimalist GNU for Windows)
-; * CygWin
-; * LCC-Win32
-
-; -- segment definition --
-;
-%ifdef __YASM_VER__
-%define SEG_TEXT    .text  align=16
-%define SEG_CONST   .rdata align=16
-%else
-%define SEG_TEXT    .text  align=16 public use32 class=CODE
-%define SEG_CONST   .rdata align=16 public use32 class=CONST
-%endif
-
-%elifdef WIN64  ; ----(nasm -fwin64 -DWIN64 ...)--------
-; * Microsoft Visual C++
-
-; -- segment definition --
-;
-%ifdef __YASM_VER__
-%define SEG_TEXT    .text  align=16
-%define SEG_CONST   .rdata align=16
-%else
-%define SEG_TEXT    .text  align=16 public use64 class=CODE
-%define SEG_CONST   .rdata align=16 public use64 class=CONST
-%endif
-%define EXTN(name)  name                        ; foo() -> foo
-
-%elifdef OBJ32  ; ----(nasm -fobj -DOBJ32 ...)----------
-; * Borland C++ (Win32)
-
-; -- segment definition --
-;
-%define SEG_TEXT    _text  align=16 public use32 class=CODE
-%define SEG_CONST   _data  align=16 public use32 class=DATA
-
-%elifdef ELF    ; ----(nasm -felf[64] -DELF ...)------------
-; * Linux
-; * *BSD family Unix using elf format
-; * Unix System V, including Solaris x86, UnixWare and SCO Unix
-
-; mark stack as non-executable
-section .note.GNU-stack noalloc noexec nowrite progbits
-
-; -- segment definition --
-;
-%ifdef __x86_64__
-%define SEG_TEXT    .text   progbits align=16
-%define SEG_CONST   .rodata progbits align=16
-%else
-%define SEG_TEXT    .text   progbits alloc exec   nowrite align=16
-%define SEG_CONST   .rodata progbits alloc noexec nowrite align=16
-%endif
-
-; To make the code position-independent, append -DPIC to the commandline
-;
-%define GOT_SYMBOL  _GLOBAL_OFFSET_TABLE_       ; ELF supports PIC
-%define EXTN(name)  name                        ; foo() -> foo
-
-%elifdef AOUT   ; ----(nasm -faoutb/aout -DAOUT ...)----
-; * Older Linux using a.out format  (nasm -f aout -DAOUT ...)
-; * *BSD family Unix using a.out format  (nasm -f aoutb -DAOUT ...)
-
-; -- segment definition --
-;
-%define SEG_TEXT    .text
-%define SEG_CONST   .data
-
-; To make the code position-independent, append -DPIC to the commandline
-;
-%define GOT_SYMBOL  __GLOBAL_OFFSET_TABLE_      ; BSD-style a.out supports PIC
-
-%elifdef MACHO  ; ----(nasm -fmacho -DMACHO ...)--------
-; * NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X (Mach-O format)
-
-; -- segment definition --
-;
-%define SEG_TEXT    .text  ;align=16    ; nasm doesn't accept align=16. why?
-%define SEG_CONST   .rodata align=16
-
-; The generation of position-independent code (PIC) is the default on Darwin.
-;
-%define PIC
-%define GOT_SYMBOL  _MACHO_PIC_         ; Mach-O style code-relative addressing
-
-%else           ; ----(Other case)----------------------
-
-; -- segment definition --
-;
-%define SEG_TEXT    .text
-%define SEG_CONST   .data
-
-%endif  ; ----------------------------------------------
-
-; ==========================================================================
-
-; --------------------------------------------------------------------------
-;  Common types
-;
-%ifdef __x86_64__
-%define POINTER                 qword           ; general pointer type
-%define SIZEOF_POINTER          SIZEOF_QWORD    ; sizeof(POINTER)
-%define POINTER_BIT             QWORD_BIT       ; sizeof(POINTER)*BYTE_BIT
-%else
-%define POINTER                 dword           ; general pointer type
-%define SIZEOF_POINTER          SIZEOF_DWORD    ; sizeof(POINTER)
-%define POINTER_BIT             DWORD_BIT       ; sizeof(POINTER)*BYTE_BIT
-%endif
-
-%define INT                     dword           ; signed integer type
-%define SIZEOF_INT              SIZEOF_DWORD    ; sizeof(INT)
-%define INT_BIT                 DWORD_BIT       ; sizeof(INT)*BYTE_BIT
-
-%define FP32                    dword           ; IEEE754 single
-%define SIZEOF_FP32             SIZEOF_DWORD    ; sizeof(FP32)
-%define FP32_BIT                DWORD_BIT       ; sizeof(FP32)*BYTE_BIT
-
-%define MMWORD                  qword           ; int64  (MMX register)
-%define SIZEOF_MMWORD           SIZEOF_QWORD    ; sizeof(MMWORD)
-%define MMWORD_BIT              QWORD_BIT       ; sizeof(MMWORD)*BYTE_BIT
-
-; NASM is buggy and doesn't properly handle operand sizes for SSE
-; instructions, so for now we have to define XMMWORD as blank.
-%define XMMWORD                                 ; int128 (SSE register)
-%define SIZEOF_XMMWORD          SIZEOF_OWORD    ; sizeof(XMMWORD)
-%define XMMWORD_BIT             OWORD_BIT       ; sizeof(XMMWORD)*BYTE_BIT
-
-; Similar hacks for when we load a dword or MMWORD into an xmm# register
-%define XMM_DWORD
-%define XMM_MMWORD
-
-%define SIZEOF_BYTE             1               ; sizeof(BYTE)
-%define SIZEOF_WORD             2               ; sizeof(WORD)
-%define SIZEOF_DWORD            4               ; sizeof(DWORD)
-%define SIZEOF_QWORD            8               ; sizeof(QWORD)
-%define SIZEOF_OWORD            16              ; sizeof(OWORD)
-
-%define BYTE_BIT                8               ; CHAR_BIT in C
-%define WORD_BIT                16              ; sizeof(WORD)*BYTE_BIT
-%define DWORD_BIT               32              ; sizeof(DWORD)*BYTE_BIT
-%define QWORD_BIT               64              ; sizeof(QWORD)*BYTE_BIT
-%define OWORD_BIT               128             ; sizeof(OWORD)*BYTE_BIT
-
-; --------------------------------------------------------------------------
-;  External Symbol Name
-;
-%ifndef EXTN
-%define EXTN(name)   _ %+ name          ; foo() -> _foo
-%endif
-
-; --------------------------------------------------------------------------
-;  Macros for position-independent code (PIC) support
-;
-%ifndef GOT_SYMBOL
-%undef PIC
-%endif
-
-%ifdef PIC ; -------------------------------------------
-
-%ifidn GOT_SYMBOL,_MACHO_PIC_ ; --------------------
-
-; At present, nasm doesn't seem to support PIC generation for Mach-O.
-; The PIC support code below is a little tricky.
-
-        SECTION SEG_CONST
-const_base:
-
-%define GOTOFF(got,sym) (got) + (sym) - const_base
-
-%imacro get_GOT 1
-        ; NOTE: this macro destroys ecx resister.
-        call    %%geteip
-        add     ecx, byte (%%ref - $)
-        jmp     short %%adjust
-%%geteip:
-        mov     ecx, POINTER [esp]
-        ret
-%%adjust:
-        push    ebp
-        xor     ebp,ebp         ; ebp = 0
-%ifidni %1,ebx  ; (%1 == ebx)
-        ; db 0x8D,0x9C + jmp near const_base =
-        ;   lea ebx, [ecx+ebp*8+(const_base-%%ref)] ; 8D,9C,E9,(offset32)
-        db      0x8D,0x9C               ; 8D,9C
-        jmp     near const_base         ; E9,(const_base-%%ref)
-%%ref:
-%else  ; (%1 != ebx)
-        ; db 0x8D,0x8C + jmp near const_base =
-        ;   lea ecx, [ecx+ebp*8+(const_base-%%ref)] ; 8D,8C,E9,(offset32)
-        db      0x8D,0x8C               ; 8D,8C
-        jmp     near const_base         ; E9,(const_base-%%ref)
-%%ref:  mov     %1, ecx
-%endif ; (%1 == ebx)
-        pop     ebp
-%endmacro
-
-%else   ; GOT_SYMBOL != _MACHO_PIC_ ----------------
-
-%define GOTOFF(got,sym) (got) + (sym) wrt ..gotoff
-
-%imacro get_GOT 1
-        extern  GOT_SYMBOL
-        call    %%geteip
-        add     %1, GOT_SYMBOL + $$ - $ wrt ..gotpc
-        jmp     short %%done
-%%geteip:
-        mov     %1, POINTER [esp]
-        ret
-%%done:
-%endmacro
-
-%endif  ; GOT_SYMBOL == _MACHO_PIC_ ----------------
-
-%imacro pushpic 1.nolist
-        push    %1
-%endmacro
-%imacro poppic  1.nolist
-        pop     %1
-%endmacro
-%imacro movpic  2.nolist
-        mov     %1,%2
-%endmacro
-
-%else   ; !PIC -----------------------------------------
-
-%define GOTOFF(got,sym) (sym)
-
-%imacro get_GOT 1.nolist
-%endmacro
-%imacro pushpic 1.nolist
-%endmacro
-%imacro poppic  1.nolist
-%endmacro
-%imacro movpic  2.nolist
-%endmacro
-
-%endif  ;  PIC -----------------------------------------
-
-; --------------------------------------------------------------------------
-;  Align the next instruction on {2,4,8,16,..}-byte boundary.
-;  ".balign n,,m" in GNU as
-;
-%define MSKLE(x,y)  (~(((y) & 0xFFFF) - ((x) & 0xFFFF)) >> 16)
-%define FILLB(b,n)  (($$-(b)) & ((n)-1))
-
-%imacro alignx 1-2.nolist 0xFFFF
-%%bs:   times MSKLE(FILLB(%%bs,%1),%2) & MSKLE(16,FILLB($,%1)) & FILLB($,%1) \
-               db 0x90                               ; nop
-        times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/9 \
-               db 0x8D,0x9C,0x23,0x00,0x00,0x00,0x00 ; lea ebx,[ebx+0x00000000]
-        times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/7 \
-               db 0x8D,0xAC,0x25,0x00,0x00,0x00,0x00 ; lea ebp,[ebp+0x00000000]
-        times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/6 \
-               db 0x8D,0xAD,0x00,0x00,0x00,0x00      ; lea ebp,[ebp+0x00000000]
-        times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/4 \
-               db 0x8D,0x6C,0x25,0x00                ; lea ebp,[ebp+0x00]
-        times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/3 \
-               db 0x8D,0x6D,0x00                     ; lea ebp,[ebp+0x00]
-        times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/2 \
-               db 0x8B,0xED                          ; mov ebp,ebp
-        times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/1 \
-               db 0x90                               ; nop
-%endmacro
-
-; Align the next data on {2,4,8,16,..}-byte boundary.
-;
-%imacro alignz 1.nolist
-        align %1, db 0          ; filling zeros
-%endmacro
-
-%ifdef __x86_64__
-
-%ifdef WIN64
-
-%imacro collect_args 0
-        push r12
-        push r13
-        push r14
-        push r15
-        mov r10, rcx
-        mov r11, rdx
-        mov r12, r8
-        mov r13, r9
-        mov r14, [rax+48]
-        mov r15, [rax+56]
-        push rsi
-        push rdi
-        sub     rsp, SIZEOF_XMMWORD
-        movaps  XMMWORD [rsp], xmm6
-        sub     rsp, SIZEOF_XMMWORD
-        movaps  XMMWORD [rsp], xmm7
-%endmacro
-
-%imacro uncollect_args 0
-        movaps  xmm7, XMMWORD [rsp]
-        add     rsp, SIZEOF_XMMWORD
-        movaps  xmm6, XMMWORD [rsp]
-        add     rsp, SIZEOF_XMMWORD
-        pop rdi
-        pop rsi
-        pop r15
-        pop r14
-        pop r13
-        pop r12
-%endmacro
-
-%else
-
-%imacro collect_args 0
-        push r10
-        push r11
-        push r12
-        push r13
-        push r14
-        push r15
-        mov r10, rdi
-        mov r11, rsi
-        mov r12, rdx
-        mov r13, rcx
-        mov r14, r8
-        mov r15, r9
-%endmacro
-
-%imacro uncollect_args 0
-        pop r15
-        pop r14
-        pop r13
-        pop r12
-        pop r11
-        pop r10
-%endmacro
-
-%endif
-
-%endif
-
-; --------------------------------------------------------------------------
-;  Defines picked up from the C headers
-;
-%include "jsimdcfg.inc"
-
-; --------------------------------------------------------------------------
diff --git a/simd/jsimd_mips.c b/simd/mips/jsimd.c
similarity index 99%
rename from simd/jsimd_mips.c
rename to simd/mips/jsimd.c
index 02e90cd..05ab13a 100644
--- a/simd/jsimd_mips.c
+++ b/simd/mips/jsimd.c
@@ -16,12 +16,12 @@
  */
 
 #define JPEG_INTERNALS
-#include "../jinclude.h"
-#include "../jpeglib.h"
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "../jdct.h"
-#include "../jsimddct.h"
-#include "jsimd.h"
 
 #include <stdio.h>
 #include <string.h>
diff --git a/simd/jsimd_mips_dspr2.S b/simd/mips/jsimd_dspr2.S
similarity index 99%
rename from simd/jsimd_mips_dspr2.S
rename to simd/mips/jsimd_dspr2.S
index c8c286c..60ff6f9 100644
--- a/simd/jsimd_mips_dspr2.S
+++ b/simd/mips/jsimd_dspr2.S
@@ -23,7 +23,7 @@
  * 3. This notice may not be removed or altered from any source distribution.
  */
 
-#include "jsimd_mips_dspr2_asm.h"
+#include "jsimd_dspr2_asm.h"
 
 /*****************************************************************************/
 LEAF_MIPS_DSPR2(jsimd_c_null_convert_mips_dspr2)
@@ -4484,4 +4484,3 @@ LEAF_MIPS_DSPR2(jsimd_convsamp_float_mips_dspr2)
 END(jsimd_convsamp_float_mips_dspr2)
 
 /*****************************************************************************/
-
diff --git a/simd/jsimd_mips_dspr2_asm.h b/simd/mips/jsimd_dspr2_asm.h
similarity index 99%
rename from simd/jsimd_mips_dspr2_asm.h
rename to simd/mips/jsimd_dspr2_asm.h
index 64f9880..499e34b 100644
--- a/simd/jsimd_mips_dspr2_asm.h
+++ b/simd/mips/jsimd_dspr2_asm.h
@@ -281,5 +281,3 @@ LEAF_MIPS32R2(symbol)                                   \
     addiu           sp, sp, \stack_offset
     .endif
 .endm
-
-
diff --git a/simd/jcolsamp.inc b/simd/nasm/jcolsamp.inc
similarity index 76%
rename from simd/jcolsamp.inc
rename to simd/nasm/jcolsamp.inc
index 3be446e..3fa6214 100644
--- a/simd/jcolsamp.inc
+++ b/simd/nasm/jcolsamp.inc
@@ -2,6 +2,7 @@
 ; jcolsamp.inc - private declarations for color conversion & up/downsampling
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2015, Intel Corporation.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -18,21 +19,29 @@
 %define  mmB  mm1
 %define xmmA xmm0
 %define xmmB xmm1
+%define ymmA ymm0
+%define ymmB ymm1
 %elif RGB_GREEN == 0
 %define  mmA  mm2
 %define  mmB  mm3
 %define xmmA xmm2
 %define xmmB xmm3
+%define ymmA ymm2
+%define ymmB ymm3
 %elif RGB_BLUE == 0
 %define  mmA  mm4
 %define  mmB  mm5
 %define xmmA xmm4
 %define xmmB xmm5
+%define ymmA ymm4
+%define ymmB ymm5
 %else
 %define  mmA  mm6
 %define  mmB  mm7
 %define xmmA xmm6
 %define xmmB xmm7
+%define ymmA ymm6
+%define ymmB ymm7
 %endif
 
 %if RGB_RED == 1
@@ -40,21 +49,29 @@
 %define  mmD  mm1
 %define xmmC xmm0
 %define xmmD xmm1
+%define ymmC ymm0
+%define ymmD ymm1
 %elif RGB_GREEN == 1
 %define  mmC  mm2
 %define  mmD  mm3
 %define xmmC xmm2
 %define xmmD xmm3
+%define ymmC ymm2
+%define ymmD ymm3
 %elif RGB_BLUE == 1
 %define  mmC  mm4
 %define  mmD  mm5
 %define xmmC xmm4
 %define xmmD xmm5
+%define ymmC ymm4
+%define ymmD ymm5
 %else
 %define  mmC  mm6
 %define  mmD  mm7
 %define xmmC xmm6
 %define xmmD xmm7
+%define ymmC ymm6
+%define ymmD ymm7
 %endif
 
 %if RGB_RED == 2
@@ -62,21 +79,29 @@
 %define  mmF  mm1
 %define xmmE xmm0
 %define xmmF xmm1
+%define ymmE ymm0
+%define ymmF ymm1
 %elif RGB_GREEN == 2
 %define  mmE  mm2
 %define  mmF  mm3
 %define xmmE xmm2
 %define xmmF xmm3
+%define ymmE ymm2
+%define ymmF ymm3
 %elif RGB_BLUE == 2
 %define  mmE  mm4
 %define  mmF  mm5
 %define xmmE xmm4
 %define xmmF xmm5
+%define ymmE ymm4
+%define ymmF ymm5
 %else
 %define  mmE  mm6
 %define  mmF  mm7
 %define xmmE xmm6
 %define xmmF xmm7
+%define ymmE ymm6
+%define ymmF ymm7
 %endif
 
 %if RGB_RED == 3
@@ -84,21 +109,29 @@
 %define  mmH  mm1
 %define xmmG xmm0
 %define xmmH xmm1
+%define ymmG ymm0
+%define ymmH ymm1
 %elif RGB_GREEN == 3
 %define  mmG  mm2
 %define  mmH  mm3
 %define xmmG xmm2
 %define xmmH xmm3
+%define ymmG ymm2
+%define ymmH ymm3
 %elif RGB_BLUE == 3
 %define  mmG  mm4
 %define  mmH  mm5
 %define xmmG xmm4
 %define xmmH xmm5
+%define ymmG ymm4
+%define ymmH ymm5
 %else
 %define  mmG  mm6
 %define  mmH  mm7
 %define xmmG xmm6
 %define xmmH xmm7
+%define ymmG ymm6
+%define ymmH ymm7
 %endif
 
 ; --------------------------------------------------------------------------
diff --git a/simd/jdct.inc b/simd/nasm/jdct.inc
similarity index 72%
rename from simd/jdct.inc
rename to simd/nasm/jdct.inc
index b976107..7ae2ca4 100644
--- a/simd/jdct.inc
+++ b/simd/nasm/jdct.inc
@@ -17,11 +17,11 @@
 ;
 %define RANGE_MASK  (MAXJSAMPLE * 4 + 3)  ; 2 bits wider than legal samples
 
-%define ROW(n,b,s)              ((b)+(n)*(s))
-%define COL(n,b,s)              ((b)+(n)*(s)*DCTSIZE)
+%define ROW(n,b,s)         ((b)+(n)*(s))
+%define COL(n,b,s)         ((b)+(n)*(s)*DCTSIZE)
 
-%define DWBLOCK(m,n,b,s)        ((b)+(m)*DCTSIZE*(s)+(n)*SIZEOF_DWORD)
-%define MMBLOCK(m,n,b,s)        ((b)+(m)*DCTSIZE*(s)+(n)*SIZEOF_MMWORD)
-%define XMMBLOCK(m,n,b,s)       ((b)+(m)*DCTSIZE*(s)+(n)*SIZEOF_XMMWORD)
+%define DWBLOCK(m,n,b,s)   ((b)+(m)*DCTSIZE*(s)+(n)*SIZEOF_DWORD)
+%define MMBLOCK(m,n,b,s)   ((b)+(m)*DCTSIZE*(s)+(n)*SIZEOF_MMWORD)
+%define XMMBLOCK(m,n,b,s)  ((b)+(m)*DCTSIZE*(s)+(n)*SIZEOF_XMMWORD)
 
 ; --------------------------------------------------------------------------
diff --git a/simd/jpeg_nbits_table.inc b/simd/nasm/jpeg_nbits_table.inc
similarity index 100%
rename from simd/jpeg_nbits_table.inc
rename to simd/nasm/jpeg_nbits_table.inc
diff --git a/simd/nasm/jsimdext.inc b/simd/nasm/jsimdext.inc
new file mode 100644
index 0000000..3485d6d
--- /dev/null
+++ b/simd/nasm/jsimdext.inc
@@ -0,0 +1,455 @@
+;
+; jsimdext.inc - common declarations
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2010, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library - version 1.02
+;
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+;
+; This software is provided 'as-is', without any express or implied
+; warranty.  In no event will the authors be held liable for any damages
+; arising from the use of this software.
+;
+; Permission is granted to anyone to use this software for any purpose,
+; including commercial applications, and to alter it and redistribute it
+; freely, subject to the following restrictions:
+;
+; 1. The origin of this software must not be misrepresented; you must not
+;    claim that you wrote the original software. If you use this software
+;    in a product, an acknowledgment in the product documentation would be
+;    appreciated but is not required.
+; 2. Altered source versions must be plainly marked as such, and must not be
+;    misrepresented as being the original software.
+; 3. This notice may not be removed or altered from any source distribution.
+;
+; [TAB8]
+
+; ==========================================================================
+;  System-dependent configurations
+
+%ifdef WIN32    ; ----(nasm -fwin32 -DWIN32 ...)--------
+; * Microsoft Visual C++
+; * MinGW (Minimalist GNU for Windows)
+; * CygWin
+; * LCC-Win32
+
+; -- segment definition --
+;
+%ifdef __YASM_VER__
+%define SEG_TEXT   .text  align=32
+%define SEG_CONST  .rdata align=32
+%else
+%define SEG_TEXT   .text  align=32 public use32 class=CODE
+%define SEG_CONST  .rdata align=32 public use32 class=CONST
+%endif
+
+%elifdef WIN64  ; ----(nasm -fwin64 -DWIN64 ...)--------
+; * Microsoft Visual C++
+
+; -- segment definition --
+;
+%ifdef __YASM_VER__
+%define SEG_TEXT    .text  align=32
+%define SEG_CONST   .rdata align=32
+%else
+%define SEG_TEXT    .text  align=32 public use64 class=CODE
+%define SEG_CONST   .rdata align=32 public use64 class=CONST
+%endif
+%define EXTN(name)  name                ; foo() -> foo
+
+%elifdef OBJ32  ; ----(nasm -fobj -DOBJ32 ...)----------
+; * Borland C++ (Win32)
+
+; -- segment definition --
+;
+%define SEG_TEXT   _text align=32 public use32 class=CODE
+%define SEG_CONST  _data align=32 public use32 class=DATA
+
+%elifdef ELF    ; ----(nasm -felf[64] -DELF ...)------------
+; * Linux
+; * *BSD family Unix using elf format
+; * Unix System V, including Solaris x86, UnixWare and SCO Unix
+
+; mark stack as non-executable
+section .note.GNU-stack noalloc noexec nowrite progbits
+
+; -- segment definition --
+;
+%ifdef __x86_64__
+%define SEG_TEXT   .text   progbits align=32
+%define SEG_CONST  .rodata progbits align=32
+%else
+%define SEG_TEXT   .text   progbits alloc exec   nowrite align=32
+%define SEG_CONST  .rodata progbits alloc noexec nowrite align=32
+%endif
+
+; To make the code position-independent, append -DPIC to the commandline
+;
+%define GOT_SYMBOL  _GLOBAL_OFFSET_TABLE_  ; ELF supports PIC
+%define EXTN(name)  name                   ; foo() -> foo
+
+%elifdef AOUT   ; ----(nasm -faoutb/aout -DAOUT ...)----
+; * Older Linux using a.out format  (nasm -f aout -DAOUT ...)
+; * *BSD family Unix using a.out format  (nasm -f aoutb -DAOUT ...)
+
+; -- segment definition --
+;
+%define SEG_TEXT   .text
+%define SEG_CONST  .data
+
+; To make the code position-independent, append -DPIC to the commandline
+;
+%define GOT_SYMBOL  __GLOBAL_OFFSET_TABLE_  ; BSD-style a.out supports PIC
+
+%elifdef MACHO  ; ----(nasm -fmacho -DMACHO ...)--------
+; * NeXTstep/OpenStep/Rhapsody/Darwin/MacOS X (Mach-O format)
+
+; -- segment definition --
+;
+%define SEG_TEXT   .text  ;align=32     ; nasm doesn't accept align=32. why?
+%define SEG_CONST  .rodata align=32
+
+; The generation of position-independent code (PIC) is the default on Darwin.
+;
+%define PIC
+%define GOT_SYMBOL  _MACHO_PIC_         ; Mach-O style code-relative addressing
+
+%else           ; ----(Other case)----------------------
+
+; -- segment definition --
+;
+%define SEG_TEXT   .text
+%define SEG_CONST  .data
+
+%endif          ; ----------------------------------------------
+
+; ==========================================================================
+
+; --------------------------------------------------------------------------
+;  Common types
+;
+%ifdef __x86_64__
+%define POINTER         qword           ; general pointer type
+%define SIZEOF_POINTER  SIZEOF_QWORD    ; sizeof(POINTER)
+%define POINTER_BIT     QWORD_BIT       ; sizeof(POINTER)*BYTE_BIT
+%else
+%define POINTER         dword           ; general pointer type
+%define SIZEOF_POINTER  SIZEOF_DWORD    ; sizeof(POINTER)
+%define POINTER_BIT     DWORD_BIT       ; sizeof(POINTER)*BYTE_BIT
+%endif
+
+%define INT             dword           ; signed integer type
+%define SIZEOF_INT      SIZEOF_DWORD    ; sizeof(INT)
+%define INT_BIT         DWORD_BIT       ; sizeof(INT)*BYTE_BIT
+
+%define FP32            dword           ; IEEE754 single
+%define SIZEOF_FP32     SIZEOF_DWORD    ; sizeof(FP32)
+%define FP32_BIT        DWORD_BIT       ; sizeof(FP32)*BYTE_BIT
+
+%define MMWORD          qword           ; int64  (MMX register)
+%define SIZEOF_MMWORD   SIZEOF_QWORD    ; sizeof(MMWORD)
+%define MMWORD_BIT      QWORD_BIT       ; sizeof(MMWORD)*BYTE_BIT
+
+; NASM is buggy and doesn't properly handle operand sizes for SSE
+; instructions, so for now we have to define XMMWORD as blank.
+%define XMMWORD                         ; int128 (SSE register)
+%define SIZEOF_XMMWORD  SIZEOF_OWORD    ; sizeof(XMMWORD)
+%define XMMWORD_BIT     OWORD_BIT       ; sizeof(XMMWORD)*BYTE_BIT
+
+%define YMMWORD                         ; int256 (AVX register)
+%define SIZEOF_YMMWORD  SIZEOF_YWORD    ; sizeof(YMMWORD)
+%define YMMWORD_BIT     YWORD_BIT       ; sizeof(YMMWORD)*BYTE_BIT
+
+; Similar hacks for when we load a dword or MMWORD into an xmm# register
+%define XMM_DWORD
+%define XMM_MMWORD
+
+%define SIZEOF_BYTE   1                 ; sizeof(BYTE)
+%define SIZEOF_WORD   2                 ; sizeof(WORD)
+%define SIZEOF_DWORD  4                 ; sizeof(DWORD)
+%define SIZEOF_QWORD  8                 ; sizeof(QWORD)
+%define SIZEOF_OWORD  16                ; sizeof(OWORD)
+%define SIZEOF_YWORD  32                ; sizeof(YWORD)
+
+%define BYTE_BIT      8                 ; CHAR_BIT in C
+%define WORD_BIT      16                ; sizeof(WORD)*BYTE_BIT
+%define DWORD_BIT     32                ; sizeof(DWORD)*BYTE_BIT
+%define QWORD_BIT     64                ; sizeof(QWORD)*BYTE_BIT
+%define OWORD_BIT     128               ; sizeof(OWORD)*BYTE_BIT
+%define YWORD_BIT     256               ; sizeof(YWORD)*BYTE_BIT
+
+; --------------------------------------------------------------------------
+;  External Symbol Name
+;
+%ifndef EXTN
+%define EXTN(name)  _ %+ name           ; foo() -> _foo
+%endif
+
+; --------------------------------------------------------------------------
+;  Macros for position-independent code (PIC) support
+;
+%ifndef GOT_SYMBOL
+%undef PIC
+%endif
+
+%ifdef PIC  ; -------------------------------------------
+
+%ifidn GOT_SYMBOL, _MACHO_PIC_  ; --------------------
+
+; At present, nasm doesn't seem to support PIC generation for Mach-O.
+; The PIC support code below is a little tricky.
+
+    SECTION     SEG_CONST
+const_base:
+
+%define GOTOFF(got,sym)  (got) + (sym) - const_base
+
+%imacro get_GOT 1
+    ; NOTE: this macro destroys ecx resister.
+    call        %%geteip
+    add         ecx, byte (%%ref - $)
+    jmp         short %%adjust
+%%geteip:
+    mov         ecx, POINTER [esp]
+    ret
+%%adjust:
+    push        ebp
+    xor         ebp, ebp                ; ebp = 0
+%ifidni %1, ebx  ; (%1 == ebx)
+    ; db 0x8D,0x9C + jmp near const_base =
+    ;   lea ebx, [ecx+ebp*8+(const_base-%%ref)] ; 8D,9C,E9,(offset32)
+    db          0x8D, 0x9C              ; 8D,9C
+    jmp         near const_base         ; E9,(const_base-%%ref)
+%%ref:
+%else  ; (%1 != ebx)
+    ; db 0x8D,0x8C + jmp near const_base =
+    ;   lea ecx, [ecx+ebp*8+(const_base-%%ref)] ; 8D,8C,E9,(offset32)
+    db          0x8D, 0x8C              ; 8D,8C
+    jmp         near const_base         ; E9,(const_base-%%ref)
+%%ref:
+    mov         %1, ecx
+%endif  ; (%1 == ebx)
+    pop         ebp
+%endmacro
+
+%else     ; GOT_SYMBOL != _MACHO_PIC_ ----------------
+
+%define GOTOFF(got,sym)  (got) + (sym) wrt ..gotoff
+
+%imacro get_GOT 1
+    extern      GOT_SYMBOL
+    call        %%geteip
+    add         %1, GOT_SYMBOL + $$ - $ wrt ..gotpc
+    jmp         short %%done
+%%geteip:
+    mov         %1, POINTER [esp]
+    ret
+%%done:
+%endmacro
+
+%endif    ; GOT_SYMBOL == _MACHO_PIC_ ----------------
+
+%imacro pushpic 1.nolist
+    push        %1
+%endmacro
+%imacro poppic  1.nolist
+    pop         %1
+%endmacro
+%imacro movpic  2.nolist
+    mov         %1, %2
+%endmacro
+
+%else    ; !PIC -----------------------------------------
+
+%define GOTOFF(got,sym)  (sym)
+
+%imacro get_GOT 1.nolist
+%endmacro
+%imacro pushpic 1.nolist
+%endmacro
+%imacro poppic  1.nolist
+%endmacro
+%imacro movpic  2.nolist
+%endmacro
+
+%endif   ;  PIC -----------------------------------------
+
+; --------------------------------------------------------------------------
+;  Align the next instruction on {2,4,8,16,..}-byte boundary.
+;  ".balign n,,m" in GNU as
+;
+%define MSKLE(x,y)  (~(((y) & 0xFFFF) - ((x) & 0xFFFF)) >> 16)
+%define FILLB(b,n)  (($$-(b)) & ((n)-1))
+
+%imacro alignx 1-2.nolist 0xFFFF
+%%bs:  \
+    times MSKLE(FILLB(%%bs,%1),%2) & MSKLE(16,FILLB($,%1)) & FILLB($,%1)  \
+          db 0x90                                   ; nop
+    times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/9  \
+          db 0x8D,0x9C,0x23,0x00,0x00,0x00,0x00     ; lea ebx,[ebx+0x00000000]
+    times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/7  \
+          db 0x8D,0xAC,0x25,0x00,0x00,0x00,0x00     ; lea ebp,[ebp+0x00000000]
+    times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/6  \
+          db 0x8D,0xAD,0x00,0x00,0x00,0x00          ; lea ebp,[ebp+0x00000000]
+    times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/4  \
+          db 0x8D,0x6C,0x25,0x00                    ; lea ebp,[ebp+0x00]
+    times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/3  \
+          db 0x8D,0x6D,0x00                         ; lea ebp,[ebp+0x00]
+    times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/2  \
+          db 0x8B,0xED                              ; mov ebp,ebp
+    times MSKLE(FILLB(%%bs,%1),%2) & FILLB($,%1)/1  \
+          db 0x90                                   ; nop
+%endmacro
+
+; Align the next data on {2,4,8,16,..}-byte boundary.
+;
+%imacro alignz 1.nolist
+    align       %1, db 0                ; filling zeros
+%endmacro
+
+%ifdef __x86_64__
+
+%ifdef WIN64
+
+%imacro collect_args 1
+    sub         rsp, SIZEOF_XMMWORD
+    movaps      XMMWORD [rsp], xmm6
+    sub         rsp, SIZEOF_XMMWORD
+    movaps      XMMWORD [rsp], xmm7
+    mov         r10, rcx
+%if %1 > 1
+    mov         r11, rdx
+%endif
+%if %1 > 2
+    push        r12
+    mov         r12, r8
+%endif
+%if %1 > 3
+    push        r13
+    mov         r13, r9
+%endif
+%if %1 > 4
+    push        r14
+    mov         r14, [rax+48]
+%endif
+%if %1 > 5
+    push        r15
+    mov         r15, [rax+56]
+%endif
+    push        rsi
+    push        rdi
+%endmacro
+
+%imacro uncollect_args 1
+    pop         rdi
+    pop         rsi
+%if %1 > 5
+    pop         r15
+%endif
+%if %1 > 4
+    pop         r14
+%endif
+%if %1 > 3
+    pop         r13
+%endif
+%if %1 > 2
+    pop         r12
+%endif
+    movaps      xmm7, XMMWORD [rsp]
+    add         rsp, SIZEOF_XMMWORD
+    movaps      xmm6, XMMWORD [rsp]
+    add         rsp, SIZEOF_XMMWORD
+%endmacro
+
+%imacro push_xmm 1
+    movaps      XMMWORD [rsp-1*SIZEOF_XMMWORD], xmm8
+%if %1 > 1
+    movaps      XMMWORD [rsp-2*SIZEOF_XMMWORD], xmm9
+%endif
+%if %1 > 2
+    movaps      XMMWORD [rsp-3*SIZEOF_XMMWORD], xmm10
+%endif
+%if %1 > 3
+    movaps      XMMWORD [rsp-4*SIZEOF_XMMWORD], xmm11
+%endif
+    sub         rsp, %1 * SIZEOF_XMMWORD
+%endmacro
+
+%imacro pop_xmm 1
+%if %1 > 3
+    movaps      xmm11, XMMWORD [rsp+0*SIZEOF_XMMWORD]
+%endif
+%if %1 > 2
+    movaps      xmm10, XMMWORD [rsp+1*SIZEOF_XMMWORD]
+%endif
+%if %1 > 1
+    movaps      xmm9, XMMWORD [rsp+2*SIZEOF_XMMWORD]
+%endif
+    movaps      xmm8, XMMWORD [rsp+3*SIZEOF_XMMWORD]
+    add         rsp, %1 * SIZEOF_XMMWORD
+%endmacro
+
+%else
+
+%imacro collect_args 1
+    push        r10
+    mov         r10, rdi
+%if %1 > 1
+    push        r11
+    mov         r11, rsi
+%endif
+%if %1 > 2
+    push        r12
+    mov         r12, rdx
+%endif
+%if %1 > 3
+    push        r13
+    mov         r13, rcx
+%endif
+%if %1 > 4
+    push        r14
+    mov         r14, r8
+%endif
+%if %1 > 5
+    push        r15
+    mov         r15, r9
+%endif
+%endmacro
+
+%imacro uncollect_args 1
+%if %1 > 5
+    pop         r15
+%endif
+%if %1 > 4
+    pop         r14
+%endif
+%if %1 > 3
+    pop         r13
+%endif
+%if %1 > 2
+    pop         r12
+%endif
+%if %1 > 1
+    pop         r11
+%endif
+    pop         r10
+%endmacro
+
+%imacro push_xmm 1
+%endmacro
+
+%imacro pop_xmm 1
+%endmacro
+
+%endif
+
+%endif
+
+; --------------------------------------------------------------------------
+;  Defines picked up from the C headers
+;
+%include "jsimdcfg.inc"
+
+; --------------------------------------------------------------------------
diff --git a/simd/nasm_lt.sh b/simd/nasm_lt.sh
deleted file mode 100755
index 817be16..0000000
--- a/simd/nasm_lt.sh
+++ /dev/null
@@ -1,60 +0,0 @@
-#! /bin/sh
-command=""
-infile=""
-o_opt=no
-pic=no
-while [ $# -gt 0 ]; do
-    case "$1" in
-        --silent)
-            exec > /dev/null
-            ;;
-        -DPIC|-fPIC|-fpic|-Kpic|-KPIC)
-            if [ "$pic" != "yes" ] ; then
-                command="$command -DPIC"
-                pic=yes
-            fi
-            ;;
-        -f|-fbin|-faout|-faoutb|-fcoff|-felf|-felf64|-fas86| \
-        -fobj|-fwin32|-fwin64|-frdf|-fieee|-fmacho|-fmacho64)
-            # it's a file format specifier for nasm.
-            command="$command $1"
-            ;;
-        -f*)
-            # maybe a code-generation flag for gcc.
-            ;;
-        -[Ii]*)
-            incdir=`echo "$1" | sed 's/^-[Ii]//'`
-            if [ "x$incdir" = x -a "x$2" != x ] ; then
-                case "$2" in
-                    -*) ;;
-                    *) incdir="$2"; shift;;
-                esac
-            fi
-            if [ "x$incdir" != x ] ; then
-                # In the case of NASM, the trailing slash is necessary.
-                incdir=`echo "$incdir" | sed 's%/*$%/%'`
-                command="$command -I$incdir"
-            fi
-            ;;
-        -o*)
-            o_opt=yes
-            command="$command $1"
-            ;;
-        *.asm)
-            infile=$1
-            command="$command $1"
-            ;;
-        *)
-            command="$command $1"
-            ;;
-    esac
-    shift
-done
-if [ "$o_opt" != yes ] ; then
-    # By default, NASM creates an output file
-    # in the same directory as the input file.
-    outfile="-o `echo $infile | sed -e 's%^.*/%%' -e 's%\.[^.]*$%%'`.o"
-    command="$command $outfile"
-fi
-echo $command
-exec $command
diff --git a/simd/jccolext-altivec.c b/simd/powerpc/jccolext-altivec.c
similarity index 100%
rename from simd/jccolext-altivec.c
rename to simd/powerpc/jccolext-altivec.c
diff --git a/simd/jccolor-altivec.c b/simd/powerpc/jccolor-altivec.c
similarity index 100%
rename from simd/jccolor-altivec.c
rename to simd/powerpc/jccolor-altivec.c
diff --git a/simd/jcgray-altivec.c b/simd/powerpc/jcgray-altivec.c
similarity index 100%
rename from simd/jcgray-altivec.c
rename to simd/powerpc/jcgray-altivec.c
diff --git a/simd/jcgryext-altivec.c b/simd/powerpc/jcgryext-altivec.c
similarity index 100%
rename from simd/jcgryext-altivec.c
rename to simd/powerpc/jcgryext-altivec.c
diff --git a/simd/jcsample-altivec.c b/simd/powerpc/jcsample-altivec.c
similarity index 100%
rename from simd/jcsample-altivec.c
rename to simd/powerpc/jcsample-altivec.c
diff --git a/simd/jcsample.h b/simd/powerpc/jcsample.h
similarity index 100%
rename from simd/jcsample.h
rename to simd/powerpc/jcsample.h
diff --git a/simd/jdcolext-altivec.c b/simd/powerpc/jdcolext-altivec.c
similarity index 100%
rename from simd/jdcolext-altivec.c
rename to simd/powerpc/jdcolext-altivec.c
diff --git a/simd/jdcolor-altivec.c b/simd/powerpc/jdcolor-altivec.c
similarity index 100%
rename from simd/jdcolor-altivec.c
rename to simd/powerpc/jdcolor-altivec.c
diff --git a/simd/jdmerge-altivec.c b/simd/powerpc/jdmerge-altivec.c
similarity index 100%
rename from simd/jdmerge-altivec.c
rename to simd/powerpc/jdmerge-altivec.c
diff --git a/simd/jdmrgext-altivec.c b/simd/powerpc/jdmrgext-altivec.c
similarity index 100%
rename from simd/jdmrgext-altivec.c
rename to simd/powerpc/jdmrgext-altivec.c
diff --git a/simd/jdsample-altivec.c b/simd/powerpc/jdsample-altivec.c
similarity index 100%
rename from simd/jdsample-altivec.c
rename to simd/powerpc/jdsample-altivec.c
diff --git a/simd/jfdctfst-altivec.c b/simd/powerpc/jfdctfst-altivec.c
similarity index 100%
rename from simd/jfdctfst-altivec.c
rename to simd/powerpc/jfdctfst-altivec.c
diff --git a/simd/jfdctint-altivec.c b/simd/powerpc/jfdctint-altivec.c
similarity index 100%
rename from simd/jfdctint-altivec.c
rename to simd/powerpc/jfdctint-altivec.c
diff --git a/simd/jidctfst-altivec.c b/simd/powerpc/jidctfst-altivec.c
similarity index 100%
rename from simd/jidctfst-altivec.c
rename to simd/powerpc/jidctfst-altivec.c
diff --git a/simd/jidctint-altivec.c b/simd/powerpc/jidctint-altivec.c
similarity index 100%
rename from simd/jidctint-altivec.c
rename to simd/powerpc/jidctint-altivec.c
diff --git a/simd/jquanti-altivec.c b/simd/powerpc/jquanti-altivec.c
similarity index 100%
rename from simd/jquanti-altivec.c
rename to simd/powerpc/jquanti-altivec.c
diff --git a/simd/jsimd_powerpc.c b/simd/powerpc/jsimd.c
similarity index 99%
rename from simd/jsimd_powerpc.c
rename to simd/powerpc/jsimd.c
index 47dd746..56e4d22 100644
--- a/simd/jsimd_powerpc.c
+++ b/simd/powerpc/jsimd.c
@@ -20,12 +20,12 @@
 #endif
 
 #define JPEG_INTERNALS
-#include "../jinclude.h"
-#include "../jpeglib.h"
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "../jdct.h"
-#include "../jsimddct.h"
-#include "jsimd.h"
 
 #include <stdio.h>
 #include <string.h>
diff --git a/simd/jsimd_altivec.h b/simd/powerpc/jsimd_altivec.h
similarity index 96%
rename from simd/jsimd_altivec.h
rename to simd/powerpc/jsimd_altivec.h
index 62dbc5c..e204997 100644
--- a/simd/jsimd_altivec.h
+++ b/simd/powerpc/jsimd_altivec.h
@@ -21,12 +21,12 @@
  */
 
 #define JPEG_INTERNALS
-#include "../jinclude.h"
-#include "../jpeglib.h"
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "../jdct.h"
-#include "../jsimddct.h"
-#include "jsimd.h"
 #include <altivec.h>
 
 
diff --git a/simd/x86_64/jccolext-avx2.asm b/simd/x86_64/jccolext-avx2.asm
new file mode 100644
index 0000000..a7e977a
--- /dev/null
+++ b/simd/x86_64/jccolext-avx2.asm
@@ -0,0 +1,562 @@
+;
+; jccolext.asm - colorspace conversion (64-bit AVX2)
+;
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_ycc_convert_avx2 (JDIMENSION img_width,
+;                             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                             JDIMENSION output_row, int num_rows);
+;
+
+; r10d = JDIMENSION img_width
+; r11 = JSAMPARRAY input_buf
+; r12 = JSAMPIMAGE output_buf
+; r13d = JDIMENSION output_row
+; r14d = int num_rows
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM  8
+
+    align       32
+
+    global      EXTN(jsimd_rgb_ycc_convert_avx2)
+
+EXTN(jsimd_rgb_ycc_convert_avx2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 5
+    push        rbx
+
+    mov         ecx, r10d
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rsi, r12
+    mov         ecx, r13d
+    mov         rdi, JSAMPARRAY [rsi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rsi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rsi+2*SIZEOF_JSAMPARRAY]
+    lea         rdi, [rdi+rcx*SIZEOF_JSAMPROW]
+    lea         rbx, [rbx+rcx*SIZEOF_JSAMPROW]
+    lea         rdx, [rdx+rcx*SIZEOF_JSAMPROW]
+
+    pop         rcx
+
+    mov         rsi, r11
+    mov         eax, r14d
+    test        rax, rax
+    jle         near .return
+.rowloop:
+    push        rdx
+    push        rbx
+    push        rdi
+    push        rsi
+    push        rcx                     ; col
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr0
+    mov         rbx, JSAMPROW [rbx]     ; outptr1
+    mov         rdx, JSAMPROW [rdx]     ; outptr2
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        rax
+    push        rdx
+    lea         rcx, [rcx+rcx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_BYTE
+    movzx       rax, BYTE [rsi+rcx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_WORD
+    movzx       rdx, WORD [rsi+rcx]
+    shl         rax, WORD_BIT
+    or          rax, rdx
+.column_ld4:
+    vmovd       xmmA, eax
+    pop         rdx
+    pop         rax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_DWORD
+    vmovd       xmmF, XMM_DWORD [rsi+rcx]
+    vpslldq     xmmA, xmmA, SIZEOF_DWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         rcx, byte SIZEOF_MMWORD
+    vmovq       xmmB, XMM_MMWORD [rsi+rcx]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    sub         rcx, byte SIZEOF_XMMWORD
+    vmovdqu     xmmB, XMM_MMWORD [rsi+rcx]
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    vpor        ymmA, ymmB
+.column_ld32:
+    test        cl, SIZEOF_YMMWORD
+    jz          short .column_ld64
+    sub         rcx, byte SIZEOF_YMMWORD
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+.column_ld64:
+    test        cl, 2*SIZEOF_YMMWORD
+    mov         rcx, SIZEOF_YMMWORD
+    jz          short .rgb_ycc_cnv
+    vmovdqa     ymmB, ymmA
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_ycc_cnv
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmB, YMMWORD [rsi+2*SIZEOF_YMMWORD]
+
+.rgb_ycc_cnv:
+    ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+    ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+    ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    ; ymmB=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+    ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vmovdqu     ymmC, ymmA
+    vinserti128 ymmA, ymmF, xmmA, 0  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                     ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vinserti128 ymmC, ymmC, xmmB, 0  ; ymmC=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                     ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vinserti128 ymmB, ymmB, xmmF, 0  ; ymmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                     ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+    vperm2i128  ymmF, ymmC, ymmC, 1  ; ymmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                     ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+
+    vmovdqa     ymmG, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12
+                                  ;       22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I)
+    vpsrldq     ymmG, ymmG, 8     ; ymmG=(22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I
+                                  ;       2I 0J 1J 2J 0K 1K 2K 0L -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmF  ; ymmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A
+                                  ;       0G 0O 1G 1O 2G 2O 0H 0P 1H 1P 2H 2P 0I 0Q 1I 1Q)
+    vpslldq     ymmF, ymmF, 8     ; ymmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27
+                                  ;       08 18 28 09 19 29 0A 1A 1L 2L 0M 1M 2M 0N 1N 2N)
+
+    vpunpcklbw  ymmG, ymmG, ymmB  ; ymmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D
+                                  ;       2I 2Q 0J 0R 1J 1R 2J 2R 0K 0S 1K 1S 2K 2S 0L 0T)
+    vpunpckhbw  ymmF, ymmF, ymmB  ; ymmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F
+                                  ;       1L 1T 2L 2T 0M 0U 1M 1U 2M 2U 0N 0V 1N 1V 2N 2V)
+
+    vmovdqa     ymmD, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09
+                                  ;       11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P)
+    vpsrldq     ymmD, ymmD, 8     ; ymmD=(11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P
+                                  ;       1H 1P 2H 2P 0I 0Q 1I 1Q -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmG  ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D
+                                  ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 0H 0L 0P 0T)
+    vpslldq     ymmG, ymmG, 8     ; ymmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B
+                                  ;       04 0C 14 1C 24 2C 05 0D 2I 2Q 0J 0R 1J 1R 2J 2R)
+
+    vpunpcklbw  ymmD, ymmD, ymmF  ; ymmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E
+                                  ;       1H 1L 1P 1T 2H 2L 2P 2T 0I 0M 0Q 0U 1I 1M 1Q 1U)
+    vpunpckhbw  ymmG, ymmG, ymmF  ; ymmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F
+                                  ;       2I 2M 2Q 2U 0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V)
+
+    vmovdqa     ymmE, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C
+                                  ;       20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S)
+    vpsrldq     ymmE, ymmE, 8     ; ymmE=(20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S
+                                  ;       2G 2K 2O 2S 0H 0L 0P 0T -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmD  ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                  ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpslldq     ymmD, ymmD, 8     ; ymmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D
+                                  ;       02 06 0A 0E 12 16 1A 1E 1H 1L 1P 1T 2H 2L 2P 2T)
+
+    vpunpcklbw  ymmE, ymmE, ymmG  ; ymmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F
+                                  ;       2G 2I 2K 2M 2O 2Q 2S 2U 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmG  ; ymmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F
+                                  ;       1H 1J 1L 1N 1P 1R 1T 1V 2H 2J 2L 2N 2P 2R 2T 2V)
+
+    vpxor       ymmH, ymmH, ymmH
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmH  ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmH  ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmB, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmH  ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmB, ymmB, ymmH  ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+
+    vmovdqa     ymmF, ymmD
+    vpunpcklbw  ymmD, ymmD, ymmH  ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmF, ymmF, ymmH  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_XMMWORD/16
+    vmovd       xmmA, XMM_DWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_XMMWORD/8
+    vmovq       xmmF, XMM_MMWORD [rsi+rcx*RGB_PIXELSIZE]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_XMMWORD/4
+    vmovdqa     xmmF, xmmA
+    vperm2i128  ymmF, ymmF, ymmF, 1
+    vmovdqu     xmmA, XMMWORD [rsi+rcx*RGB_PIXELSIZE]
+    vpor        ymmA, ymmA, ymmF
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    jz          short .column_ld16
+    sub         rcx, byte SIZEOF_XMMWORD/2
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    mov         rcx, SIZEOF_YMMWORD
+    jz          short .rgb_ycc_cnv
+    vmovdqa     ymmE, ymmA
+    vmovdqa     ymmH, ymmF
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_ycc_cnv
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmE, YMMWORD [rsi+2*SIZEOF_YMMWORD]
+    vmovdqu     ymmH, YMMWORD [rsi+3*SIZEOF_YMMWORD]
+
+.rgb_ycc_cnv:
+    ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+    ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+    ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    ; ymmE=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+    ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+    ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmB, ymmA
+    vinserti128 ymmA, ymmA, xmmE, 1     ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vperm2i128  ymmE, ymmB, ymmE, 0x31  ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+
+    vmovdqa     ymmB, ymmF
+    vinserti128 ymmF, ymmF, xmmH, 1     ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+    vperm2i128  ymmH, ymmB, ymmH, 0x31  ; ymmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmD, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmE      ; ymmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35
+                                      ;       0G 0K 1G 1K 2G 2K 3G 3K 0H 0L 1H 1L 2H 2L 3H 3L)
+    vpunpckhbw  ymmD, ymmD, ymmE      ; ymmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37
+                                      ;       0I 0M 1I 1M 2I 2M 3I 3M 0J 0N 1J 1N 2J 2N 3J 3N)
+
+    vmovdqa     ymmC, ymmF
+    vpunpcklbw  ymmF, ymmF, ymmH      ; ymmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D
+                                      ;       0O 0S 1O 1S 2O 2S 3O 3S 0P 0T 1P 1T 2P 2T 3P 3T)
+    vpunpckhbw  ymmC, ymmC, ymmH      ; ymmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F
+                                      ;       0Q 0U 1Q 1U 2Q 2U 3Q 3U 0R 0V 1R 1V 2R 2V 3R 3V)
+
+    vmovdqa     ymmB, ymmA
+    vpunpcklwd  ymmA, ymmA, ymmF      ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C
+                                      ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 3G 3K 3O 3S)
+    vpunpckhwd  ymmB, ymmB, ymmF      ; ymmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D
+                                      ;       0H 0L 0P 0T 1H 1L 1P 1T 2H 2L 2P 2T 3H 3L 3P 3T)
+
+    vmovdqa     ymmG, ymmD
+    vpunpcklwd  ymmD, ymmD, ymmC      ; ymmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E
+                                      ;       0I 0M 0Q 0U 1I 1M 1Q 1U 2I 2M 2Q 2U 3I 3M 3Q 3U)
+    vpunpckhwd  ymmG, ymmG, ymmC      ; ymmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F
+                                      ;       0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V 3J 3N 3R 3V)
+
+    vmovdqa     ymmE, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmD      ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                      ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpunpckhbw  ymmE, ymmE, ymmD      ; ymmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E
+                                      ;       2G 2I 2K 2M 2O 2Q 2S 2U 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vmovdqa     ymmH, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmG      ; ymmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F
+                                      ;       0H 0J 0L 0N 0P 0R 0T 0V 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmH, ymmH, ymmG      ; ymmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F
+                                      ;       2H 2J 2L 2N 2P 2R 2T 2V 3H 3J 3L 3N 3P 3R 3T 3V)
+
+    vpxor       ymmF, ymmF, ymmF
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmF      ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmF      ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmD, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmF      ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmF      ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+
+    vmovdqa     ymmG, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmF      ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmG, ymmG, ymmF      ; ymmG=(30 32 34 36 38 3A 3C 3E 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vpunpcklbw  ymmF, ymmF, ymmH
+    vpunpckhbw  ymmH, ymmH, ymmH
+    vpsrlw      ymmF, ymmF, BYTE_BIT  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+    vpsrlw      ymmH, ymmH, BYTE_BIT  ; ymmH=(31 33 35 37 39 3B 3D 3F 3H 3J 3L 3N 3P 3R 3T 3V)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; ymm0=R(02468ACEGIKMOQSU)=RE, ymm2=G(02468ACEGIKMOQSU)=GE, ymm4=B(02468ACEGIKMOQSU)=BE
+    ; ymm1=R(13579BDFHJLNPRTV)=RO, ymm3=G(13579BDFHJLNPRTV)=GO, ymm5=B(13579BDFHJLNPRTV)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+
+    vmovdqa     YMMWORD [wk(0)], ymm0   ; wk(0)=RE
+    vmovdqa     YMMWORD [wk(1)], ymm1   ; wk(1)=RO
+    vmovdqa     YMMWORD [wk(2)], ymm4   ; wk(2)=BE
+    vmovdqa     YMMWORD [wk(3)], ymm5   ; wk(3)=BO
+
+    vmovdqa     ymm6, ymm1
+    vpunpcklwd  ymm1, ymm1, ymm3
+    vpunpckhwd  ymm6, ymm6, ymm3
+    vmovdqa     ymm7, ymm1
+    vmovdqa     ymm4, ymm6
+    vpmaddwd    ymm1, ymm1, [rel PW_F0299_F0337]  ; ymm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [rel PW_F0299_F0337]  ; ymm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+    vpmaddwd    ymm7, ymm7, [rel PW_MF016_MF033]  ; ymm7=ROL*-FIX(0.168)+GOL*-FIX(0.331)
+    vpmaddwd    ymm4, ymm4, [rel PW_MF016_MF033]  ; ymm4=ROH*-FIX(0.168)+GOH*-FIX(0.331)
+
+    vmovdqa     YMMWORD [wk(4)], ymm1   ; wk(4)=ROL*FIX(0.299)+GOL*FIX(0.337)
+    vmovdqa     YMMWORD [wk(5)], ymm6   ; wk(5)=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    vpxor       ymm1, ymm1, ymm1
+    vpxor       ymm6, ymm6, ymm6
+    vpunpcklwd  ymm1, ymm1, ymm5        ; ymm1=BOL
+    vpunpckhwd  ymm6, ymm6, ymm5        ; ymm6=BOH
+    vpsrld      ymm1, ymm1, 1           ; ymm1=BOL*FIX(0.500)
+    vpsrld      ymm6, ymm6, 1           ; ymm6=BOH*FIX(0.500)
+
+    vmovdqa     ymm5, [rel PD_ONEHALFM1_CJ]  ; ymm5=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm7, ymm7, ymm1
+    vpaddd      ymm4, ymm4, ymm6
+    vpaddd      ymm7, ymm7, ymm5
+    vpaddd      ymm4, ymm4, ymm5
+    vpsrld      ymm7, ymm7, SCALEBITS   ; ymm7=CbOL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=CbOH
+    vpackssdw   ymm7, ymm7, ymm4        ; ymm7=CbO
+
+    vmovdqa     ymm1, YMMWORD [wk(2)]   ; ymm1=BE
+
+    vmovdqa     ymm6, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm2
+    vpunpckhwd  ymm6, ymm6, ymm2
+    vmovdqa     ymm5, ymm0
+    vmovdqa     ymm4, ymm6
+    vpmaddwd    ymm0, ymm0, [rel PW_F0299_F0337]  ; ymm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [rel PW_F0299_F0337]  ; ymm6=REH*FIX(0.299)+GEH*FIX(0.337)
+    vpmaddwd    ymm5, ymm5, [rel PW_MF016_MF033]  ; ymm5=REL*-FIX(0.168)+GEL*-FIX(0.331)
+    vpmaddwd    ymm4, ymm4, [rel PW_MF016_MF033]  ; ymm4=REH*-FIX(0.168)+GEH*-FIX(0.331)
+
+    vmovdqa     YMMWORD [wk(6)], ymm0   ; wk(6)=REL*FIX(0.299)+GEL*FIX(0.337)
+    vmovdqa     YMMWORD [wk(7)], ymm6   ; wk(7)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    vpxor       ymm0, ymm0, ymm0
+    vpxor       ymm6, ymm6, ymm6
+    vpunpcklwd  ymm0, ymm0, ymm1        ; ymm0=BEL
+    vpunpckhwd  ymm6, ymm6, ymm1        ; ymm6=BEH
+    vpsrld      ymm0, ymm0, 1           ; ymm0=BEL*FIX(0.500)
+    vpsrld      ymm6, ymm6, 1           ; ymm6=BEH*FIX(0.500)
+
+
+    vmovdqa     ymm1, [rel PD_ONEHALFM1_CJ]  ; ymm1=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm5, ymm5, ymm0
+    vpaddd      ymm4, ymm4, ymm6
+    vpaddd      ymm5, ymm5, ymm1
+    vpaddd      ymm4, ymm4, ymm1
+    vpsrld      ymm5, ymm5, SCALEBITS   ; ymm5=CbEL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=CbEH
+    vpackssdw   ymm5, ymm5, ymm4        ; ymm5=CbE
+
+    vpsllw      ymm7, ymm7, BYTE_BIT
+    vpor        ymm5, ymm5, ymm7        ; ymm5=Cb
+    vmovdqu     YMMWORD [rbx], ymm5     ; Save Cb
+
+    vmovdqa     ymm0, YMMWORD [wk(3)]   ; ymm0=BO
+    vmovdqa     ymm6, YMMWORD [wk(2)]   ; ymm6=BE
+    vmovdqa     ymm1, YMMWORD [wk(1)]   ; ymm1=RO
+
+    vmovdqa     ymm4, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm3
+    vpunpckhwd  ymm4, ymm4, ymm3
+    vmovdqa     ymm7, ymm0
+    vmovdqa     ymm5, ymm4
+    vpmaddwd    ymm0, ymm0, [rel PW_F0114_F0250]  ; ymm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [rel PW_F0114_F0250]  ; ymm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+    vpmaddwd    ymm7, ymm7, [rel PW_MF008_MF041]  ; ymm7=BOL*-FIX(0.081)+GOL*-FIX(0.418)
+    vpmaddwd    ymm5, ymm5, [rel PW_MF008_MF041]  ; ymm5=BOH*-FIX(0.081)+GOH*-FIX(0.418)
+
+    vmovdqa     ymm3, [rel PD_ONEHALF]            ; ymm3=[PD_ONEHALF]
+
+    vpaddd      ymm0, ymm0, YMMWORD [wk(4)]
+    vpaddd      ymm4, ymm4, YMMWORD [wk(5)]
+    vpaddd      ymm0, ymm0, ymm3
+    vpaddd      ymm4, ymm4, ymm3
+    vpsrld      ymm0, ymm0, SCALEBITS   ; ymm0=YOL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YOH
+    vpackssdw   ymm0, ymm0, ymm4        ; ymm0=YO
+
+    vpxor       ymm3, ymm3, ymm3
+    vpxor       ymm4, ymm4, ymm4
+    vpunpcklwd  ymm3, ymm3, ymm1        ; ymm3=ROL
+    vpunpckhwd  ymm4, ymm4, ymm1        ; ymm4=ROH
+    vpsrld      ymm3, ymm3, 1           ; ymm3=ROL*FIX(0.500)
+    vpsrld      ymm4, ymm4, 1           ; ymm4=ROH*FIX(0.500)
+
+    vmovdqa     ymm1, [rel PD_ONEHALFM1_CJ]  ; ymm1=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm7, ymm7, ymm3
+    vpaddd      ymm5, ymm5, ymm4
+    vpaddd      ymm7, ymm7, ymm1
+    vpaddd      ymm5, ymm5, ymm1
+    vpsrld      ymm7, ymm7, SCALEBITS   ; ymm7=CrOL
+    vpsrld      ymm5, ymm5, SCALEBITS   ; ymm5=CrOH
+    vpackssdw   ymm7, ymm7, ymm5        ; ymm7=CrO
+
+    vmovdqa     ymm3, YMMWORD [wk(0)]   ; ymm3=RE
+
+    vmovdqa     ymm4, ymm6
+    vpunpcklwd  ymm6, ymm6, ymm2
+    vpunpckhwd  ymm4, ymm4, ymm2
+    vmovdqa     ymm1, ymm6
+    vmovdqa     ymm5, ymm4
+    vpmaddwd    ymm6, ymm6, [rel PW_F0114_F0250]  ; ymm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [rel PW_F0114_F0250]  ; ymm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+    vpmaddwd    ymm1, ymm1, [rel PW_MF008_MF041]  ; ymm1=BEL*-FIX(0.081)+GEL*-FIX(0.418)
+    vpmaddwd    ymm5, ymm5, [rel PW_MF008_MF041]  ; ymm5=BEH*-FIX(0.081)+GEH*-FIX(0.418)
+
+    vmovdqa     ymm2, [rel PD_ONEHALF]            ; ymm2=[PD_ONEHALF]
+
+    vpaddd      ymm6, ymm6, YMMWORD [wk(6)]
+    vpaddd      ymm4, ymm4, YMMWORD [wk(7)]
+    vpaddd      ymm6, ymm6, ymm2
+    vpaddd      ymm4, ymm4, ymm2
+    vpsrld      ymm6, ymm6, SCALEBITS   ; ymm6=YEL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YEH
+    vpackssdw   ymm6, ymm6, ymm4        ; ymm6=YE
+
+    vpsllw      ymm0, ymm0, BYTE_BIT
+    vpor        ymm6, ymm6, ymm0        ; ymm6=Y
+    vmovdqu     YMMWORD [rdi], ymm6     ; Save Y
+
+    vpxor       ymm2, ymm2, ymm2
+    vpxor       ymm4, ymm4, ymm4
+    vpunpcklwd  ymm2, ymm2, ymm3        ; ymm2=REL
+    vpunpckhwd  ymm4, ymm4, ymm3        ; ymm4=REH
+    vpsrld      ymm2, ymm2, 1           ; ymm2=REL*FIX(0.500)
+    vpsrld      ymm4, ymm4, 1           ; ymm4=REH*FIX(0.500)
+
+    vmovdqa     ymm0, [rel PD_ONEHALFM1_CJ]  ; ymm0=[PD_ONEHALFM1_CJ]
+
+    vpaddd      ymm1, ymm1, ymm2
+    vpaddd      ymm5, ymm5, ymm4
+    vpaddd      ymm1, ymm1, ymm0
+    vpaddd      ymm5, ymm5, ymm0
+    vpsrld      ymm1, ymm1, SCALEBITS   ; ymm1=CrEL
+    vpsrld      ymm5, ymm5, SCALEBITS   ; ymm5=CrEH
+    vpackssdw   ymm1, ymm1, ymm5        ; ymm1=CrE
+
+    vpsllw      ymm7, ymm7, BYTE_BIT
+    vpor        ymm1, ymm1, ymm7        ; ymm1=Cr
+    vmovdqu     YMMWORD [rdx], ymm1     ; Save Cr
+
+    sub         rcx, byte SIZEOF_YMMWORD
+    add         rsi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; inptr
+    add         rdi, byte SIZEOF_YMMWORD           ; outptr0
+    add         rbx, byte SIZEOF_YMMWORD           ; outptr1
+    add         rdx, byte SIZEOF_YMMWORD           ; outptr2
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    test        rcx, rcx
+    jnz         near .column_ld1
+
+    pop         rcx                     ; col
+    pop         rsi
+    pop         rdi
+    pop         rbx
+    pop         rdx
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         rdi, byte SIZEOF_JSAMPROW
+    add         rbx, byte SIZEOF_JSAMPROW
+    add         rdx, byte SIZEOF_JSAMPROW
+    dec         rax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    vzeroupper
+    uncollect_args 5
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jccolext-sse2.asm b/simd/x86_64/jccolext-sse2.asm
new file mode 100644
index 0000000..8fe072d
--- /dev/null
+++ b/simd/x86_64/jccolext-sse2.asm
@@ -0,0 +1,486 @@
+;
+; jccolext.asm - colorspace conversion (64-bit SSE2)
+;
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_ycc_convert_sse2 (JDIMENSION img_width,
+;                             JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                             JDIMENSION output_row, int num_rows);
+;
+
+; r10d = JDIMENSION img_width
+; r11 = JSAMPARRAY input_buf
+; r12 = JSAMPIMAGE output_buf
+; r13d = JDIMENSION output_row
+; r14d = int num_rows
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  8
+
+    align       32
+
+    global      EXTN(jsimd_rgb_ycc_convert_sse2)
+
+EXTN(jsimd_rgb_ycc_convert_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 5
+    push        rbx
+
+    mov         ecx, r10d
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rsi, r12
+    mov         ecx, r13d
+    mov         rdi, JSAMPARRAY [rsi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rsi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rsi+2*SIZEOF_JSAMPARRAY]
+    lea         rdi, [rdi+rcx*SIZEOF_JSAMPROW]
+    lea         rbx, [rbx+rcx*SIZEOF_JSAMPROW]
+    lea         rdx, [rdx+rcx*SIZEOF_JSAMPROW]
+
+    pop         rcx
+
+    mov         rsi, r11
+    mov         eax, r14d
+    test        rax, rax
+    jle         near .return
+.rowloop:
+    push        rdx
+    push        rbx
+    push        rdi
+    push        rsi
+    push        rcx                     ; col
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr0
+    mov         rbx, JSAMPROW [rbx]     ; outptr1
+    mov         rdx, JSAMPROW [rdx]     ; outptr2
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        rax
+    push        rdx
+    lea         rcx, [rcx+rcx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_BYTE
+    movzx       rax, BYTE [rsi+rcx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_WORD
+    movzx       rdx, WORD [rsi+rcx]
+    shl         rax, WORD_BIT
+    or          rax, rdx
+.column_ld4:
+    movd        xmmA, eax
+    pop         rdx
+    pop         rax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_DWORD
+    movd        xmmF, XMM_DWORD [rsi+rcx]
+    pslldq      xmmA, SIZEOF_DWORD
+    por         xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         rcx, byte SIZEOF_MMWORD
+    movq        xmmB, XMM_MMWORD [rsi+rcx]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    movdqa      xmmF, xmmA
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    mov         rcx, SIZEOF_XMMWORD
+    jmp         short .rgb_ycc_cnv
+.column_ld32:
+    test        cl, 2*SIZEOF_XMMWORD
+    mov         rcx, SIZEOF_XMMWORD
+    jz          short .rgb_ycc_cnv
+    movdqa      xmmB, xmmA
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_ycc_cnv
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    movdqu      xmmB, XMMWORD [rsi+2*SIZEOF_XMMWORD]
+
+.rgb_ycc_cnv:
+    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    movdqa      xmmG, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
+    psrldq      xmmG, 8     ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmF  ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
+    pslldq      xmmF, 8     ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
+
+    punpcklbw   xmmG, xmmB  ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
+    punpckhbw   xmmF, xmmB  ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
+
+    movdqa      xmmD, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
+    psrldq      xmmD, 8     ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmG  ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
+    pslldq      xmmG, 8     ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
+
+    punpcklbw   xmmD, xmmF  ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
+    punpckhbw   xmmG, xmmF  ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
+
+    movdqa      xmmE, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
+    psrldq      xmmE, 8     ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmD  ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    pslldq      xmmD, 8     ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
+
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmG  ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
+
+    pxor        xmmH, xmmH
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmH  ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmH  ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmB, xmmE
+    punpcklbw   xmmE, xmmH  ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmB, xmmH  ; xmmB=(01 03 05 07 09 0B 0D 0F)
+
+    movdqa      xmmF, xmmD
+    punpcklbw   xmmD, xmmH  ; xmmD=(11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmF, xmmH  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_XMMWORD/16
+    movd        xmmA, XMM_DWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_XMMWORD/8
+    movq        xmmE, XMM_MMWORD [rsi+rcx*RGB_PIXELSIZE]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmE
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_XMMWORD/4
+    movdqa      xmmE, xmmA
+    movdqu      xmmA, XMMWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    mov         rcx, SIZEOF_XMMWORD
+    jz          short .rgb_ycc_cnv
+    movdqa      xmmF, xmmA
+    movdqa      xmmH, xmmE
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_ycc_cnv
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [rsi+2*SIZEOF_XMMWORD]
+    movdqu      xmmH, XMMWORD [rsi+3*SIZEOF_XMMWORD]
+
+.rgb_ycc_cnv:
+    ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpcklbw   xmmA, xmmE      ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
+    punpckhbw   xmmD, xmmE      ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
+
+    movdqa      xmmC, xmmF
+    punpcklbw   xmmF, xmmH      ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
+    punpckhbw   xmmC, xmmH      ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
+
+    movdqa      xmmB, xmmA
+    punpcklwd   xmmA, xmmF      ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
+    punpckhwd   xmmB, xmmF      ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
+
+    movdqa      xmmG, xmmD
+    punpcklwd   xmmD, xmmC      ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
+    punpckhwd   xmmG, xmmC      ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
+
+    movdqa      xmmE, xmmA
+    punpcklbw   xmmA, xmmD      ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    punpckhbw   xmmE, xmmD      ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
+
+    movdqa      xmmH, xmmB
+    punpcklbw   xmmB, xmmG      ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmH, xmmG      ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
+
+    pxor        xmmF, xmmF
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmF      ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmF      ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmD, xmmB
+    punpcklbw   xmmB, xmmF      ; xmmB=(01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmF      ; xmmD=(11 13 15 17 19 1B 1D 1F)
+
+    movdqa      xmmG, xmmE
+    punpcklbw   xmmE, xmmF      ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmG, xmmF      ; xmmG=(30 32 34 36 38 3A 3C 3E)
+
+    punpcklbw   xmmF, xmmH
+    punpckhbw   xmmH, xmmH
+    psrlw       xmmF, BYTE_BIT  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+    psrlw       xmmH, BYTE_BIT  ; xmmH=(31 33 35 37 39 3B 3D 3F)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
+    ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+    ; Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B + CENTERJSAMPLE
+    ; Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B + CENTERJSAMPLE
+
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=RE
+    movdqa      XMMWORD [wk(1)], xmm1   ; wk(1)=RO
+    movdqa      XMMWORD [wk(2)], xmm4   ; wk(2)=BE
+    movdqa      XMMWORD [wk(3)], xmm5   ; wk(3)=BO
+
+    movdqa      xmm6, xmm1
+    punpcklwd   xmm1, xmm3
+    punpckhwd   xmm6, xmm3
+    movdqa      xmm7, xmm1
+    movdqa      xmm4, xmm6
+    pmaddwd     xmm1, [rel PW_F0299_F0337]  ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    pmaddwd     xmm6, [rel PW_F0299_F0337]  ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+    pmaddwd     xmm7, [rel PW_MF016_MF033]  ; xmm7=ROL*-FIX(0.168)+GOL*-FIX(0.331)
+    pmaddwd     xmm4, [rel PW_MF016_MF033]  ; xmm4=ROH*-FIX(0.168)+GOH*-FIX(0.331)
+
+    movdqa      XMMWORD [wk(4)], xmm1   ; wk(4)=ROL*FIX(0.299)+GOL*FIX(0.337)
+    movdqa      XMMWORD [wk(5)], xmm6   ; wk(5)=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    pxor        xmm1, xmm1
+    pxor        xmm6, xmm6
+    punpcklwd   xmm1, xmm5              ; xmm1=BOL
+    punpckhwd   xmm6, xmm5              ; xmm6=BOH
+    psrld       xmm1, 1                 ; xmm1=BOL*FIX(0.500)
+    psrld       xmm6, 1                 ; xmm6=BOH*FIX(0.500)
+
+    movdqa      xmm5, [rel PD_ONEHALFM1_CJ]  ; xmm5=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm7, xmm1
+    paddd       xmm4, xmm6
+    paddd       xmm7, xmm5
+    paddd       xmm4, xmm5
+    psrld       xmm7, SCALEBITS         ; xmm7=CbOL
+    psrld       xmm4, SCALEBITS         ; xmm4=CbOH
+    packssdw    xmm7, xmm4              ; xmm7=CbO
+
+    movdqa      xmm1, XMMWORD [wk(2)]   ; xmm1=BE
+
+    movdqa      xmm6, xmm0
+    punpcklwd   xmm0, xmm2
+    punpckhwd   xmm6, xmm2
+    movdqa      xmm5, xmm0
+    movdqa      xmm4, xmm6
+    pmaddwd     xmm0, [rel PW_F0299_F0337]  ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    pmaddwd     xmm6, [rel PW_F0299_F0337]  ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
+    pmaddwd     xmm5, [rel PW_MF016_MF033]  ; xmm5=REL*-FIX(0.168)+GEL*-FIX(0.331)
+    pmaddwd     xmm4, [rel PW_MF016_MF033]  ; xmm4=REH*-FIX(0.168)+GEH*-FIX(0.331)
+
+    movdqa      XMMWORD [wk(6)], xmm0   ; wk(6)=REL*FIX(0.299)+GEL*FIX(0.337)
+    movdqa      XMMWORD [wk(7)], xmm6   ; wk(7)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    pxor        xmm0, xmm0
+    pxor        xmm6, xmm6
+    punpcklwd   xmm0, xmm1              ; xmm0=BEL
+    punpckhwd   xmm6, xmm1              ; xmm6=BEH
+    psrld       xmm0, 1                 ; xmm0=BEL*FIX(0.500)
+    psrld       xmm6, 1                 ; xmm6=BEH*FIX(0.500)
+
+    movdqa      xmm1, [rel PD_ONEHALFM1_CJ]  ; xmm1=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm5, xmm0
+    paddd       xmm4, xmm6
+    paddd       xmm5, xmm1
+    paddd       xmm4, xmm1
+    psrld       xmm5, SCALEBITS         ; xmm5=CbEL
+    psrld       xmm4, SCALEBITS         ; xmm4=CbEH
+    packssdw    xmm5, xmm4              ; xmm5=CbE
+
+    psllw       xmm7, BYTE_BIT
+    por         xmm5, xmm7              ; xmm5=Cb
+    movdqa      XMMWORD [rbx], xmm5     ; Save Cb
+
+    movdqa      xmm0, XMMWORD [wk(3)]   ; xmm0=BO
+    movdqa      xmm6, XMMWORD [wk(2)]   ; xmm6=BE
+    movdqa      xmm1, XMMWORD [wk(1)]   ; xmm1=RO
+
+    movdqa      xmm4, xmm0
+    punpcklwd   xmm0, xmm3
+    punpckhwd   xmm4, xmm3
+    movdqa      xmm7, xmm0
+    movdqa      xmm5, xmm4
+    pmaddwd     xmm0, [rel PW_F0114_F0250]  ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    pmaddwd     xmm4, [rel PW_F0114_F0250]  ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+    pmaddwd     xmm7, [rel PW_MF008_MF041]  ; xmm7=BOL*-FIX(0.081)+GOL*-FIX(0.418)
+    pmaddwd     xmm5, [rel PW_MF008_MF041]  ; xmm5=BOH*-FIX(0.081)+GOH*-FIX(0.418)
+
+    movdqa      xmm3, [rel PD_ONEHALF]      ; xmm3=[PD_ONEHALF]
+
+    paddd       xmm0, XMMWORD [wk(4)]
+    paddd       xmm4, XMMWORD [wk(5)]
+    paddd       xmm0, xmm3
+    paddd       xmm4, xmm3
+    psrld       xmm0, SCALEBITS         ; xmm0=YOL
+    psrld       xmm4, SCALEBITS         ; xmm4=YOH
+    packssdw    xmm0, xmm4              ; xmm0=YO
+
+    pxor        xmm3, xmm3
+    pxor        xmm4, xmm4
+    punpcklwd   xmm3, xmm1              ; xmm3=ROL
+    punpckhwd   xmm4, xmm1              ; xmm4=ROH
+    psrld       xmm3, 1                 ; xmm3=ROL*FIX(0.500)
+    psrld       xmm4, 1                 ; xmm4=ROH*FIX(0.500)
+
+    movdqa      xmm1, [rel PD_ONEHALFM1_CJ]  ; xmm1=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm7, xmm3
+    paddd       xmm5, xmm4
+    paddd       xmm7, xmm1
+    paddd       xmm5, xmm1
+    psrld       xmm7, SCALEBITS         ; xmm7=CrOL
+    psrld       xmm5, SCALEBITS         ; xmm5=CrOH
+    packssdw    xmm7, xmm5              ; xmm7=CrO
+
+    movdqa      xmm3, XMMWORD [wk(0)]   ; xmm3=RE
+
+    movdqa      xmm4, xmm6
+    punpcklwd   xmm6, xmm2
+    punpckhwd   xmm4, xmm2
+    movdqa      xmm1, xmm6
+    movdqa      xmm5, xmm4
+    pmaddwd     xmm6, [rel PW_F0114_F0250]  ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    pmaddwd     xmm4, [rel PW_F0114_F0250]  ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+    pmaddwd     xmm1, [rel PW_MF008_MF041]  ; xmm1=BEL*-FIX(0.081)+GEL*-FIX(0.418)
+    pmaddwd     xmm5, [rel PW_MF008_MF041]  ; xmm5=BEH*-FIX(0.081)+GEH*-FIX(0.418)
+
+    movdqa      xmm2, [rel PD_ONEHALF]      ; xmm2=[PD_ONEHALF]
+
+    paddd       xmm6, XMMWORD [wk(6)]
+    paddd       xmm4, XMMWORD [wk(7)]
+    paddd       xmm6, xmm2
+    paddd       xmm4, xmm2
+    psrld       xmm6, SCALEBITS         ; xmm6=YEL
+    psrld       xmm4, SCALEBITS         ; xmm4=YEH
+    packssdw    xmm6, xmm4              ; xmm6=YE
+
+    psllw       xmm0, BYTE_BIT
+    por         xmm6, xmm0              ; xmm6=Y
+    movdqa      XMMWORD [rdi], xmm6     ; Save Y
+
+    pxor        xmm2, xmm2
+    pxor        xmm4, xmm4
+    punpcklwd   xmm2, xmm3              ; xmm2=REL
+    punpckhwd   xmm4, xmm3              ; xmm4=REH
+    psrld       xmm2, 1                 ; xmm2=REL*FIX(0.500)
+    psrld       xmm4, 1                 ; xmm4=REH*FIX(0.500)
+
+    movdqa      xmm0, [rel PD_ONEHALFM1_CJ]  ; xmm0=[PD_ONEHALFM1_CJ]
+
+    paddd       xmm1, xmm2
+    paddd       xmm5, xmm4
+    paddd       xmm1, xmm0
+    paddd       xmm5, xmm0
+    psrld       xmm1, SCALEBITS         ; xmm1=CrEL
+    psrld       xmm5, SCALEBITS         ; xmm5=CrEH
+    packssdw    xmm1, xmm5              ; xmm1=CrE
+
+    psllw       xmm7, BYTE_BIT
+    por         xmm1, xmm7              ; xmm1=Cr
+    movdqa      XMMWORD [rdx], xmm1     ; Save Cr
+
+    sub         rcx, byte SIZEOF_XMMWORD
+    add         rsi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
+    add         rdi, byte SIZEOF_XMMWORD                ; outptr0
+    add         rbx, byte SIZEOF_XMMWORD                ; outptr1
+    add         rdx, byte SIZEOF_XMMWORD                ; outptr2
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    test        rcx, rcx
+    jnz         near .column_ld1
+
+    pop         rcx                     ; col
+    pop         rsi
+    pop         rdi
+    pop         rbx
+    pop         rdx
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         rdi, byte SIZEOF_JSAMPROW
+    add         rbx, byte SIZEOF_JSAMPROW
+    add         rdx, byte SIZEOF_JSAMPROW
+    dec         rax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    uncollect_args 5
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jccolor-avx2.asm b/simd/x86_64/jccolor-avx2.asm
new file mode 100644
index 0000000..805c03d
--- /dev/null
+++ b/simd/x86_64/jccolor-avx2.asm
@@ -0,0 +1,122 @@
+;
+; jccolor.asm - colorspace conversion (64-bit AVX2)
+;
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_081 equ  5329                ; FIX(0.08131)
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_168 equ 11059                ; FIX(0.16874)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_331 equ 21709                ; FIX(0.33126)
+F_0_418 equ 27439                ; FIX(0.41869)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_rgb_ycc_convert_avx2)
+
+EXTN(jconst_rgb_ycc_convert_avx2):
+
+PW_F0299_F0337  times 8 dw  F_0_299, F_0_337
+PW_F0114_F0250  times 8 dw  F_0_114, F_0_250
+PW_MF016_MF033  times 8 dw -F_0_168,-F_0_331
+PW_MF008_MF041  times 8 dw -F_0_081,-F_0_418
+PD_ONEHALFM1_CJ times 8 dd  (1 << (SCALEBITS-1)) - 1 + (CENTERJSAMPLE << SCALEBITS)
+PD_ONEHALF      times 8 dd  (1 << (SCALEBITS-1))
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extrgb_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extrgbx_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extbgr_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extbgrx_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extxbgr_ycc_convert_avx2
+%include "jccolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_rgb_ycc_convert_avx2 jsimd_extxrgb_ycc_convert_avx2
+%include "jccolext-avx2.asm"
diff --git a/simd/jccolor-sse2-64.asm b/simd/x86_64/jccolor-sse2.asm
similarity index 74%
rename from simd/jccolor-sse2-64.asm
rename to simd/x86_64/jccolor-sse2.asm
index bd2188b..c2179db 100644
--- a/simd/jccolor-sse2-64.asm
+++ b/simd/x86_64/jccolor-sse2.asm
@@ -1,7 +1,7 @@
 ;
 ; jccolor.asm - colorspace conversion (64-bit SSE2)
 ;
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -19,23 +19,23 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_081 equ      5329                   ; FIX(0.08131)
-F_0_114 equ      7471                   ; FIX(0.11400)
-F_0_168 equ     11059                   ; FIX(0.16874)
-F_0_250 equ     16384                   ; FIX(0.25000)
-F_0_299 equ     19595                   ; FIX(0.29900)
-F_0_331 equ     21709                   ; FIX(0.33126)
-F_0_418 equ     27439                   ; FIX(0.41869)
-F_0_587 equ     38470                   ; FIX(0.58700)
-F_0_337 equ     (F_0_587 - F_0_250)     ; FIX(0.58700) - FIX(0.25000)
+F_0_081 equ  5329                ; FIX(0.08131)
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_168 equ 11059                ; FIX(0.16874)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_331 equ 21709                ; FIX(0.33126)
+F_0_418 equ 27439                ; FIX(0.41869)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_rgb_ycc_convert_sse2)
+    alignz      32
+    global      EXTN(jconst_rgb_ycc_convert_sse2)
 
 EXTN(jconst_rgb_ycc_convert_sse2):
 
@@ -46,13 +46,13 @@ PW_MF008_MF041  times 4 dw -F_0_081,-F_0_418
 PD_ONEHALFM1_CJ times 4 dd  (1 << (SCALEBITS-1)) - 1 + (CENTERJSAMPLE << SCALEBITS)
 PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
+    SECTION     SEG_TEXT
+    BITS        64
 
-%include "jccolext-sse2-64.asm"
+%include "jccolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -63,7 +63,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_RGB_BLUE
 %define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extrgb_ycc_convert_sse2
-%include "jccolext-sse2-64.asm"
+%include "jccolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -74,7 +74,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_RGBX_BLUE
 %define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extrgbx_ycc_convert_sse2
-%include "jccolext-sse2-64.asm"
+%include "jccolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -85,7 +85,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_BGR_BLUE
 %define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extbgr_ycc_convert_sse2
-%include "jccolext-sse2-64.asm"
+%include "jccolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -96,7 +96,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_BGRX_BLUE
 %define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extbgrx_ycc_convert_sse2
-%include "jccolext-sse2-64.asm"
+%include "jccolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -107,7 +107,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_XBGR_BLUE
 %define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extxbgr_ycc_convert_sse2
-%include "jccolext-sse2-64.asm"
+%include "jccolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -118,4 +118,4 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_XRGB_BLUE
 %define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_rgb_ycc_convert_sse2 jsimd_extxrgb_ycc_convert_sse2
-%include "jccolext-sse2-64.asm"
+%include "jccolext-sse2.asm"
diff --git a/simd/x86_64/jcgray-avx2.asm b/simd/x86_64/jcgray-avx2.asm
new file mode 100644
index 0000000..e6ea21e
--- /dev/null
+++ b/simd/x86_64/jcgray-avx2.asm
@@ -0,0 +1,115 @@
+;
+; jcgray.asm - grayscale colorspace conversion (64-bit AVX2)
+;
+; Copyright (C) 2011, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_rgb_gray_convert_avx2)
+
+EXTN(jconst_rgb_gray_convert_avx2):
+
+PW_F0299_F0337 times 8 dw F_0_299, F_0_337
+PW_F0114_F0250 times 8 dw F_0_114, F_0_250
+PD_ONEHALF     times 8 dd (1 << (SCALEBITS-1))
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extrgb_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extrgbx_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extbgr_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extbgrx_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extxbgr_gray_convert_avx2
+%include "jcgryext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_rgb_gray_convert_avx2 jsimd_extxrgb_gray_convert_avx2
+%include "jcgryext-avx2.asm"
diff --git a/simd/jcgray-sse2-64.asm b/simd/x86_64/jcgray-sse2.asm
similarity index 73%
rename from simd/jcgray-sse2-64.asm
rename to simd/x86_64/jcgray-sse2.asm
index bafd302..7cb9819 100644
--- a/simd/jcgray-sse2-64.asm
+++ b/simd/x86_64/jcgray-sse2.asm
@@ -1,7 +1,7 @@
 ;
 ; jcgray.asm - grayscale colorspace conversion (64-bit SSE2)
 ;
-; Copyright (C) 2011, D. R. Commander.
+; Copyright (C) 2011, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -19,33 +19,33 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_114 equ      7471                   ; FIX(0.11400)
-F_0_250 equ     16384                   ; FIX(0.25000)
-F_0_299 equ     19595                   ; FIX(0.29900)
-F_0_587 equ     38470                   ; FIX(0.58700)
-F_0_337 equ     (F_0_587 - F_0_250)     ; FIX(0.58700) - FIX(0.25000)
+F_0_114 equ  7471                ; FIX(0.11400)
+F_0_250 equ 16384                ; FIX(0.25000)
+F_0_299 equ 19595                ; FIX(0.29900)
+F_0_587 equ 38470                ; FIX(0.58700)
+F_0_337 equ (F_0_587 - F_0_250)  ; FIX(0.58700) - FIX(0.25000)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_rgb_gray_convert_sse2)
+    alignz      32
+    global      EXTN(jconst_rgb_gray_convert_sse2)
 
 EXTN(jconst_rgb_gray_convert_sse2):
 
-PW_F0299_F0337  times 4 dw  F_0_299, F_0_337
-PW_F0114_F0250  times 4 dw  F_0_114, F_0_250
-PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
+PW_F0299_F0337 times 4 dw F_0_299, F_0_337
+PW_F0114_F0250 times 4 dw F_0_114, F_0_250
+PD_ONEHALF     times 4 dd (1 << (SCALEBITS-1))
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
+    SECTION     SEG_TEXT
+    BITS        64
 
-%include "jcgryext-sse2-64.asm"
+%include "jcgryext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -56,7 +56,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_RGB_BLUE
 %define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_rgb_gray_convert_sse2 jsimd_extrgb_gray_convert_sse2
-%include "jcgryext-sse2-64.asm"
+%include "jcgryext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -67,7 +67,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_RGBX_BLUE
 %define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_rgb_gray_convert_sse2 jsimd_extrgbx_gray_convert_sse2
-%include "jcgryext-sse2-64.asm"
+%include "jcgryext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -78,7 +78,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_BGR_BLUE
 %define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_rgb_gray_convert_sse2 jsimd_extbgr_gray_convert_sse2
-%include "jcgryext-sse2-64.asm"
+%include "jcgryext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -89,7 +89,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_BGRX_BLUE
 %define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_rgb_gray_convert_sse2 jsimd_extbgrx_gray_convert_sse2
-%include "jcgryext-sse2-64.asm"
+%include "jcgryext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -100,7 +100,7 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_XBGR_BLUE
 %define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_rgb_gray_convert_sse2 jsimd_extxbgr_gray_convert_sse2
-%include "jcgryext-sse2-64.asm"
+%include "jcgryext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -111,4 +111,4 @@ PD_ONEHALF      times 4 dd  (1 << (SCALEBITS-1))
 %define RGB_BLUE EXT_XRGB_BLUE
 %define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_rgb_gray_convert_sse2 jsimd_extxrgb_gray_convert_sse2
-%include "jcgryext-sse2-64.asm"
+%include "jcgryext-sse2.asm"
diff --git a/simd/x86_64/jcgryext-avx2.asm b/simd/x86_64/jcgryext-avx2.asm
new file mode 100644
index 0000000..8824a45
--- /dev/null
+++ b/simd/x86_64/jcgryext-avx2.asm
@@ -0,0 +1,440 @@
+;
+; jcgryext.asm - grayscale colorspace conversion (64-bit AVX2)
+;
+; Copyright (C) 2011, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_gray_convert_avx2 (JDIMENSION img_width,
+;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                              JDIMENSION output_row, int num_rows);
+;
+
+; r10d = JDIMENSION img_width
+; r11 = JSAMPARRAY input_buf
+; r12 = JSAMPIMAGE output_buf
+; r13d = JDIMENSION output_row
+; r14d = int num_rows
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM  2
+
+    align       32
+
+    global      EXTN(jsimd_rgb_gray_convert_avx2)
+
+EXTN(jsimd_rgb_gray_convert_avx2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 5
+    push        rbx
+
+    mov         ecx, r10d
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rsi, r12
+    mov         ecx, r13d
+    mov         rdi, JSAMPARRAY [rsi+0*SIZEOF_JSAMPARRAY]
+    lea         rdi, [rdi+rcx*SIZEOF_JSAMPROW]
+
+    pop         rcx
+
+    mov         rsi, r11
+    mov         eax, r14d
+    test        rax, rax
+    jle         near .return
+.rowloop:
+    push        rdi
+    push        rsi
+    push        rcx                     ; col
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr0
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        rax
+    push        rdx
+    lea         rcx, [rcx+rcx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_BYTE
+    movzx       rax, BYTE [rsi+rcx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_WORD
+    movzx       rdx, WORD [rsi+rcx]
+    shl         rax, WORD_BIT
+    or          rax, rdx
+.column_ld4:
+    vmovd       xmmA, eax
+    pop         rdx
+    pop         rax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_DWORD
+    vmovd       xmmF, XMM_DWORD [rsi+rcx]
+    vpslldq     xmmA, xmmA, SIZEOF_DWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         rcx, byte SIZEOF_MMWORD
+    vmovq       xmmB, XMM_MMWORD [rsi+rcx]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    sub         rcx, byte SIZEOF_XMMWORD
+    vmovdqu     xmmB, XMM_MMWORD [rsi+rcx]
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    vpor        ymmA, ymmB
+.column_ld32:
+    test        cl, SIZEOF_YMMWORD
+    jz          short .column_ld64
+    sub         rcx, byte SIZEOF_YMMWORD
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+.column_ld64:
+    test        cl, 2*SIZEOF_YMMWORD
+    mov         rcx, SIZEOF_YMMWORD
+    jz          short .rgb_gray_cnv
+    vmovdqa     ymmB, ymmA
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_gray_cnv
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmB, YMMWORD [rsi+2*SIZEOF_YMMWORD]
+
+.rgb_gray_cnv:
+    ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+    ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+    ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    ; ymmB=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+    ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vmovdqu     ymmC, ymmA
+    vinserti128 ymmA, ymmF, xmmA, 0  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                     ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vinserti128 ymmC, ymmC, xmmB, 0  ; ymmC=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                     ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vinserti128 ymmB, ymmB, xmmF, 0  ; ymmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                     ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+    vperm2i128  ymmF, ymmC, ymmC, 1  ; ymmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                     ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+
+    vmovdqa     ymmG, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12
+                                  ;       22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I)
+    vpsrldq     ymmG, ymmG, 8     ; ymmG=(22 03 13 23 04 14 24 05 0G 1G 2G 0H 1H 2H 0I 1I
+                                  ;       2I 0J 1J 2J 0K 1K 2K 0L -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmF  ; ymmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A
+                                  ;       0G 0O 1G 1O 2G 2O 0H 0P 1H 1P 2H 2P 0I 0Q 1I 1Q)
+    vpslldq     ymmF, ymmF, 8     ; ymmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27
+                                  ;       08 18 28 09 19 29 0A 1A 1L 2L 0M 1M 2M 0N 1N 2N)
+
+    vpunpcklbw  ymmG, ymmG, ymmB  ; ymmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D
+                                  ;       2I 2Q 0J 0R 1J 1R 2J 2R 0K 0S 1K 1S 2K 2S 0L 0T)
+    vpunpckhbw  ymmF, ymmF, ymmB  ; ymmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F
+                                  ;       1L 1T 2L 2T 0M 0U 1M 1U 2M 2U 0N 0V 1N 1V 2N 2V)
+
+    vmovdqa     ymmD, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09
+                                  ;       11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P)
+    vpsrldq     ymmD, ymmD, 8     ; ymmD=(11 19 21 29 02 0A 12 1A 0G 0O 1G 1O 2G 2O 0H 0P
+                                  ;       1H 1P 2H 2P 0I 0Q 1I 1Q -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmG  ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D
+                                  ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 0H 0L 0P 0T)
+    vpslldq     ymmG, ymmG, 8     ; ymmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B
+                                  ;       04 0C 14 1C 24 2C 05 0D 2I 2Q 0J 0R 1J 1R 2J 2R)
+
+    vpunpcklbw  ymmD, ymmD, ymmF  ; ymmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E
+                                  ;       1H 1L 1P 1T 2H 2L 2P 2T 0I 0M 0Q 0U 1I 1M 1Q 1U)
+    vpunpckhbw  ymmG, ymmG, ymmF  ; ymmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F
+                                  ;       2I 2M 2Q 2U 0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V)
+
+    vmovdqa     ymmE, ymmA
+    vpslldq     ymmA, ymmA, 8     ; ymmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C
+                                  ;       20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S)
+    vpsrldq     ymmE, ymmE, 8     ; ymmE=(20 24 28 2C 01 05 09 0D 0G 0K 0O 0S 1G 1K 1O 1S
+                                  ;       2G 2K 2O 2S 0H 0L 0P 0T -- -- -- -- -- -- -- --)
+
+    vpunpckhbw  ymmA, ymmA, ymmD  ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                  ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpslldq     ymmD, ymmD, 8     ; ymmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D
+                                  ;       02 06 0A 0E 12 16 1A 1E 1H 1L 1P 1T 2H 2L 2P 2T)
+
+    vpunpcklbw  ymmE, ymmE, ymmG  ; ymmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F
+                                  ;       2G 2I 2K 2M 2O 2Q 2S 2U 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmG  ; ymmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F
+                                  ;       1H 1J 1L 1N 1P 1R 1T 1V 2H 2J 2L 2N 2P 2R 2T 2V)
+
+    vpxor       ymmH, ymmH, ymmH
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmH  ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmH  ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmB, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmH  ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmB, ymmB, ymmH  ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+
+    vmovdqa     ymmF, ymmD
+    vpunpcklbw  ymmD, ymmD, ymmH  ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmF, ymmF, ymmH  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_XMMWORD/16
+    vmovd       xmmA, XMM_DWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_XMMWORD/8
+    vmovq       xmmF, XMM_MMWORD [rsi+rcx*RGB_PIXELSIZE]
+    vpslldq     xmmA, xmmA, SIZEOF_MMWORD
+    vpor        xmmA, xmmA, xmmF
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_XMMWORD/4
+    vmovdqa     xmmF, xmmA
+    vperm2i128  ymmF, ymmF, ymmF, 1
+    vmovdqu     xmmA, XMMWORD [rsi+rcx*RGB_PIXELSIZE]
+    vpor        ymmA, ymmA, ymmF
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    jz          short .column_ld16
+    sub         rcx, byte SIZEOF_XMMWORD/2
+    vmovdqa     ymmF, ymmA
+    vmovdqu     ymmA, YMMWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    mov         rcx, SIZEOF_YMMWORD
+    jz          short .rgb_gray_cnv
+    vmovdqa     ymmE, ymmA
+    vmovdqa     ymmH, ymmF
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    jmp         short .rgb_gray_cnv
+
+.columnloop:
+    vmovdqu     ymmA, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymmF, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    vmovdqu     ymmE, YMMWORD [rsi+2*SIZEOF_YMMWORD]
+    vmovdqu     ymmH, YMMWORD [rsi+3*SIZEOF_YMMWORD]
+
+.rgb_gray_cnv:
+    ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+    ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+    ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    ; ymmE=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+    ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+    ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmB, ymmA
+    vinserti128 ymmA, ymmA, xmmE, 1     ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vperm2i128  ymmE, ymmB, ymmE, 0x31  ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+
+    vmovdqa     ymmB, ymmF
+    vinserti128 ymmF, ymmF, xmmH, 1     ; ymmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+    vperm2i128  ymmH, ymmB, ymmH, 0x31  ; ymmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    vmovdqa     ymmD, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmE      ; ymmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35
+                                      ;       0G 0K 1G 1K 2G 2K 3G 3K 0H 0L 1H 1L 2H 2L 3H 3L)
+    vpunpckhbw  ymmD, ymmD, ymmE      ; ymmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37
+                                      ;       0I 0M 1I 1M 2I 2M 3I 3M 0J 0N 1J 1N 2J 2N 3J 3N)
+
+    vmovdqa     ymmC, ymmF
+    vpunpcklbw  ymmF, ymmF, ymmH      ; ymmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D
+                                      ;       0O 0S 1O 1S 2O 2S 3O 3S 0P 0T 1P 1T 2P 2T 3P 3T)
+    vpunpckhbw  ymmC, ymmC, ymmH      ; ymmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F
+                                      ;       0Q 0U 1Q 1U 2Q 2U 3Q 3U 0R 0V 1R 1V 2R 2V 3R 3V)
+
+    vmovdqa     ymmB, ymmA
+    vpunpcklwd  ymmA, ymmA, ymmF      ; ymmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C
+                                      ;       0G 0K 0O 0S 1G 1K 1O 1S 2G 2K 2O 2S 3G 3K 3O 3S)
+    vpunpckhwd  ymmB, ymmB, ymmF      ; ymmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D
+                                      ;       0H 0L 0P 0T 1H 1L 1P 1T 2H 2L 2P 2T 3H 3L 3P 3T)
+
+    vmovdqa     ymmG, ymmD
+    vpunpcklwd  ymmD, ymmD, ymmC      ; ymmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E
+                                      ;       0I 0M 0Q 0U 1I 1M 1Q 1U 2I 2M 2Q 2U 3I 3M 3Q 3U)
+    vpunpckhwd  ymmG, ymmG, ymmC      ; ymmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F
+                                      ;       0J 0N 0R 0V 1J 1N 1R 1V 2J 2N 2R 2V 3J 3N 3R 3V)
+
+    vmovdqa     ymmE, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmD      ; ymmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E
+                                      ;       0G 0I 0K 0M 0O 0Q 0S 0U 1G 1I 1K 1M 1O 1Q 1S 1U)
+    vpunpckhbw  ymmE, ymmE, ymmD      ; ymmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E
+                                      ;       2G 2I 2K 2M 2O 2Q 2S 2U 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vmovdqa     ymmH, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmG      ; ymmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F
+                                      ;       0H 0J 0L 0N 0P 0R 0T 0V 1H 1J 1L 1N 1P 1R 1T 1V)
+    vpunpckhbw  ymmH, ymmH, ymmG      ; ymmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F
+                                      ;       2H 2J 2L 2N 2P 2R 2T 2V 3H 3J 3L 3N 3P 3R 3T 3V)
+
+    vpxor       ymmF, ymmF, ymmF
+
+    vmovdqa     ymmC, ymmA
+    vpunpcklbw  ymmA, ymmA, ymmF      ; ymmA=(00 02 04 06 08 0A 0C 0E 0G 0I 0K 0M 0O 0Q 0S 0U)
+    vpunpckhbw  ymmC, ymmC, ymmF      ; ymmC=(10 12 14 16 18 1A 1C 1E 1G 1I 1K 1M 1O 1Q 1S 1U)
+
+    vmovdqa     ymmD, ymmB
+    vpunpcklbw  ymmB, ymmB, ymmF      ; ymmB=(01 03 05 07 09 0B 0D 0F 0H 0J 0L 0N 0P 0R 0T 0V)
+    vpunpckhbw  ymmD, ymmD, ymmF      ; ymmD=(11 13 15 17 19 1B 1D 1F 1H 1J 1L 1N 1P 1R 1T 1V)
+
+    vmovdqa     ymmG, ymmE
+    vpunpcklbw  ymmE, ymmE, ymmF      ; ymmE=(20 22 24 26 28 2A 2C 2E 2G 2I 2K 2M 2O 2Q 2S 2U)
+    vpunpckhbw  ymmG, ymmG, ymmF      ; ymmG=(30 32 34 36 38 3A 3C 3E 3G 3I 3K 3M 3O 3Q 3S 3U)
+
+    vpunpcklbw  ymmF, ymmF, ymmH
+    vpunpckhbw  ymmH, ymmH, ymmH
+    vpsrlw      ymmF, ymmF, BYTE_BIT  ; ymmF=(21 23 25 27 29 2B 2D 2F 2H 2J 2L 2N 2P 2R 2T 2V)
+    vpsrlw      ymmH, ymmH, BYTE_BIT  ; ymmH=(31 33 35 37 39 3B 3D 3F 3H 3J 3L 3N 3P 3R 3T 3V)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; ymm0=R(02468ACEGIKMOQSU)=RE, ymm2=G(02468ACEGIKMOQSU)=GE, ymm4=B(02468ACEGIKMOQSU)=BE
+    ; ymm1=R(13579BDFHJLNPRTV)=RO, ymm3=G(13579BDFHJLNPRTV)=GO, ymm5=B(13579BDFHJLNPRTV)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+
+    vmovdqa     ymm6, ymm1
+    vpunpcklwd  ymm1, ymm1, ymm3
+    vpunpckhwd  ymm6, ymm6, ymm3
+    vpmaddwd    ymm1, ymm1, [rel PW_F0299_F0337]  ; ymm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [rel PW_F0299_F0337]  ; ymm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    vmovdqa     ymm7, ymm6              ; ymm7=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    vmovdqa     ymm6, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm2
+    vpunpckhwd  ymm6, ymm6, ymm2
+    vpmaddwd    ymm0, ymm0, [rel PW_F0299_F0337]  ; ymm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    vpmaddwd    ymm6, ymm6, [rel PW_F0299_F0337]  ; ymm6=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    vmovdqa     YMMWORD [wk(0)], ymm0   ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
+    vmovdqa     YMMWORD [wk(1)], ymm6   ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    vmovdqa     ymm0, ymm5              ; ymm0=BO
+    vmovdqa     ymm6, ymm4              ; ymm6=BE
+
+    vmovdqa     ymm4, ymm0
+    vpunpcklwd  ymm0, ymm0, ymm3
+    vpunpckhwd  ymm4, ymm4, ymm3
+    vpmaddwd    ymm0, ymm0, [rel PW_F0114_F0250]  ; ymm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [rel PW_F0114_F0250]  ; ymm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+
+    vmovdqa     ymm3, [rel PD_ONEHALF]            ; ymm3=[PD_ONEHALF]
+
+    vpaddd      ymm0, ymm0, ymm1
+    vpaddd      ymm4, ymm4, ymm7
+    vpaddd      ymm0, ymm0, ymm3
+    vpaddd      ymm4, ymm4, ymm3
+    vpsrld      ymm0, ymm0, SCALEBITS   ; ymm0=YOL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YOH
+    vpackssdw   ymm0, ymm0, ymm4        ; ymm0=YO
+
+    vmovdqa     ymm4, ymm6
+    vpunpcklwd  ymm6, ymm6, ymm2
+    vpunpckhwd  ymm4, ymm4, ymm2
+    vpmaddwd    ymm6, ymm6, [rel PW_F0114_F0250]  ; ymm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    vpmaddwd    ymm4, ymm4, [rel PW_F0114_F0250]  ; ymm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+
+    vmovdqa     ymm2, [rel PD_ONEHALF]            ; ymm2=[PD_ONEHALF]
+
+    vpaddd      ymm6, ymm6, YMMWORD [wk(0)]
+    vpaddd      ymm4, ymm4, YMMWORD [wk(1)]
+    vpaddd      ymm6, ymm6, ymm2
+    vpaddd      ymm4, ymm4, ymm2
+    vpsrld      ymm6, ymm6, SCALEBITS   ; ymm6=YEL
+    vpsrld      ymm4, ymm4, SCALEBITS   ; ymm4=YEH
+    vpackssdw   ymm6, ymm6, ymm4        ; ymm6=YE
+
+    vpsllw      ymm0, ymm0, BYTE_BIT
+    vpor        ymm6, ymm6, ymm0        ; ymm6=Y
+    vmovdqu     YMMWORD [rdi], ymm6     ; Save Y
+
+    sub         rcx, byte SIZEOF_YMMWORD
+    add         rsi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; inptr
+    add         rdi, byte SIZEOF_YMMWORD           ; outptr0
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    test        rcx, rcx
+    jnz         near .column_ld1
+
+    pop         rcx                     ; col
+    pop         rsi
+    pop         rdi
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         rdi, byte SIZEOF_JSAMPROW
+    dec         rax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    vzeroupper
+    uncollect_args 5
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jcgryext-sse2.asm b/simd/x86_64/jcgryext-sse2.asm
new file mode 100644
index 0000000..d26ada3
--- /dev/null
+++ b/simd/x86_64/jcgryext-sse2.asm
@@ -0,0 +1,365 @@
+;
+; jcgryext.asm - grayscale colorspace conversion (64-bit SSE2)
+;
+; Copyright (C) 2011, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_rgb_gray_convert_sse2 (JDIMENSION img_width,
+;                              JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+;                              JDIMENSION output_row, int num_rows);
+;
+
+; r10d = JDIMENSION img_width
+; r11 = JSAMPARRAY input_buf
+; r12 = JSAMPIMAGE output_buf
+; r13d = JDIMENSION output_row
+; r14d = int num_rows
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  2
+
+    align       32
+
+    global      EXTN(jsimd_rgb_gray_convert_sse2)
+
+EXTN(jsimd_rgb_gray_convert_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 5
+    push        rbx
+
+    mov         ecx, r10d
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rsi, r12
+    mov         ecx, r13d
+    mov         rdi, JSAMPARRAY [rsi+0*SIZEOF_JSAMPARRAY]
+    lea         rdi, [rdi+rcx*SIZEOF_JSAMPROW]
+
+    pop         rcx
+
+    mov         rsi, r11
+    mov         eax, r14d
+    test        rax, rax
+    jle         near .return
+.rowloop:
+    push        rdi
+    push        rsi
+    push        rcx                     ; col
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr0
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+.column_ld1:
+    push        rax
+    push        rdx
+    lea         rcx, [rcx+rcx*2]        ; imul ecx,RGB_PIXELSIZE
+    test        cl, SIZEOF_BYTE
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_BYTE
+    movzx       rax, BYTE [rsi+rcx]
+.column_ld2:
+    test        cl, SIZEOF_WORD
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_WORD
+    movzx       rdx, WORD [rsi+rcx]
+    shl         rax, WORD_BIT
+    or          rax, rdx
+.column_ld4:
+    movd        xmmA, eax
+    pop         rdx
+    pop         rax
+    test        cl, SIZEOF_DWORD
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_DWORD
+    movd        xmmF, XMM_DWORD [rsi+rcx]
+    pslldq      xmmA, SIZEOF_DWORD
+    por         xmmA, xmmF
+.column_ld8:
+    test        cl, SIZEOF_MMWORD
+    jz          short .column_ld16
+    sub         rcx, byte SIZEOF_MMWORD
+    movq        xmmB, XMM_MMWORD [rsi+rcx]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmB
+.column_ld16:
+    test        cl, SIZEOF_XMMWORD
+    jz          short .column_ld32
+    movdqa      xmmF, xmmA
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    mov         rcx, SIZEOF_XMMWORD
+    jmp         short .rgb_gray_cnv
+.column_ld32:
+    test        cl, 2*SIZEOF_XMMWORD
+    mov         rcx, SIZEOF_XMMWORD
+    jz          short .rgb_gray_cnv
+    movdqa      xmmB, xmmA
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_gray_cnv
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    movdqu      xmmB, XMMWORD [rsi+2*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    ; xmmF=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    ; xmmB=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    movdqa      xmmG, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 10 20 01 11 21 02 12)
+    psrldq      xmmG, 8     ; xmmG=(22 03 13 23 04 14 24 05 -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmF  ; xmmA=(00 08 10 18 20 28 01 09 11 19 21 29 02 0A 12 1A)
+    pslldq      xmmF, 8     ; xmmF=(-- -- -- -- -- -- -- -- 15 25 06 16 26 07 17 27)
+
+    punpcklbw   xmmG, xmmB  ; xmmG=(22 2A 03 0B 13 1B 23 2B 04 0C 14 1C 24 2C 05 0D)
+    punpckhbw   xmmF, xmmB  ; xmmF=(15 1D 25 2D 06 0E 16 1E 26 2E 07 0F 17 1F 27 2F)
+
+    movdqa      xmmD, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 08 10 18 20 28 01 09)
+    psrldq      xmmD, 8     ; xmmD=(11 19 21 29 02 0A 12 1A -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmG  ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 01 05 09 0D)
+    pslldq      xmmG, 8     ; xmmG=(-- -- -- -- -- -- -- -- 22 2A 03 0B 13 1B 23 2B)
+
+    punpcklbw   xmmD, xmmF  ; xmmD=(11 15 19 1D 21 25 29 2D 02 06 0A 0E 12 16 1A 1E)
+    punpckhbw   xmmG, xmmF  ; xmmG=(22 26 2A 2E 03 07 0B 0F 13 17 1B 1F 23 27 2B 2F)
+
+    movdqa      xmmE, xmmA
+    pslldq      xmmA, 8     ; xmmA=(-- -- -- -- -- -- -- -- 00 04 08 0C 10 14 18 1C)
+    psrldq      xmmE, 8     ; xmmE=(20 24 28 2C 01 05 09 0D -- -- -- -- -- -- -- --)
+
+    punpckhbw   xmmA, xmmD  ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    pslldq      xmmD, 8     ; xmmD=(-- -- -- -- -- -- -- -- 11 15 19 1D 21 25 29 2D)
+
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 22 24 26 28 2A 2C 2E 01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmG  ; xmmD=(11 13 15 17 19 1B 1D 1F 21 23 25 27 29 2B 2D 2F)
+
+    pxor        xmmH, xmmH
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmH  ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmH  ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmB, xmmE
+    punpcklbw   xmmE, xmmH  ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmB, xmmH  ; xmmB=(01 03 05 07 09 0B 0D 0F)
+
+    movdqa      xmmF, xmmD
+    punpcklbw   xmmD, xmmH  ; xmmD=(11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmF, xmmH  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+.column_ld1:
+    test        cl, SIZEOF_XMMWORD/16
+    jz          short .column_ld2
+    sub         rcx, byte SIZEOF_XMMWORD/16
+    movd        xmmA, XMM_DWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld2:
+    test        cl, SIZEOF_XMMWORD/8
+    jz          short .column_ld4
+    sub         rcx, byte SIZEOF_XMMWORD/8
+    movq        xmmE, XMM_MMWORD [rsi+rcx*RGB_PIXELSIZE]
+    pslldq      xmmA, SIZEOF_MMWORD
+    por         xmmA, xmmE
+.column_ld4:
+    test        cl, SIZEOF_XMMWORD/4
+    jz          short .column_ld8
+    sub         rcx, byte SIZEOF_XMMWORD/4
+    movdqa      xmmE, xmmA
+    movdqu      xmmA, XMMWORD [rsi+rcx*RGB_PIXELSIZE]
+.column_ld8:
+    test        cl, SIZEOF_XMMWORD/2
+    mov         rcx, SIZEOF_XMMWORD
+    jz          short .rgb_gray_cnv
+    movdqa      xmmF, xmmA
+    movdqa      xmmH, xmmE
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    jmp         short .rgb_gray_cnv
+
+.columnloop:
+    movdqu      xmmA, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqu      xmmE, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    movdqu      xmmF, XMMWORD [rsi+2*SIZEOF_XMMWORD]
+    movdqu      xmmH, XMMWORD [rsi+3*SIZEOF_XMMWORD]
+
+.rgb_gray_cnv:
+    ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    ; xmmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    ; xmmF=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpcklbw   xmmA, xmmE      ; xmmA=(00 04 10 14 20 24 30 34 01 05 11 15 21 25 31 35)
+    punpckhbw   xmmD, xmmE      ; xmmD=(02 06 12 16 22 26 32 36 03 07 13 17 23 27 33 37)
+
+    movdqa      xmmC, xmmF
+    punpcklbw   xmmF, xmmH      ; xmmF=(08 0C 18 1C 28 2C 38 3C 09 0D 19 1D 29 2D 39 3D)
+    punpckhbw   xmmC, xmmH      ; xmmC=(0A 0E 1A 1E 2A 2E 3A 3E 0B 0F 1B 1F 2B 2F 3B 3F)
+
+    movdqa      xmmB, xmmA
+    punpcklwd   xmmA, xmmF      ; xmmA=(00 04 08 0C 10 14 18 1C 20 24 28 2C 30 34 38 3C)
+    punpckhwd   xmmB, xmmF      ; xmmB=(01 05 09 0D 11 15 19 1D 21 25 29 2D 31 35 39 3D)
+
+    movdqa      xmmG, xmmD
+    punpcklwd   xmmD, xmmC      ; xmmD=(02 06 0A 0E 12 16 1A 1E 22 26 2A 2E 32 36 3A 3E)
+    punpckhwd   xmmG, xmmC      ; xmmG=(03 07 0B 0F 13 17 1B 1F 23 27 2B 2F 33 37 3B 3F)
+
+    movdqa      xmmE, xmmA
+    punpcklbw   xmmA, xmmD      ; xmmA=(00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A 1C 1E)
+    punpckhbw   xmmE, xmmD      ; xmmE=(20 22 24 26 28 2A 2C 2E 30 32 34 36 38 3A 3C 3E)
+
+    movdqa      xmmH, xmmB
+    punpcklbw   xmmB, xmmG      ; xmmB=(01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B 1D 1F)
+    punpckhbw   xmmH, xmmG      ; xmmH=(21 23 25 27 29 2B 2D 2F 31 33 35 37 39 3B 3D 3F)
+
+    pxor        xmmF, xmmF
+
+    movdqa      xmmC, xmmA
+    punpcklbw   xmmA, xmmF      ; xmmA=(00 02 04 06 08 0A 0C 0E)
+    punpckhbw   xmmC, xmmF      ; xmmC=(10 12 14 16 18 1A 1C 1E)
+
+    movdqa      xmmD, xmmB
+    punpcklbw   xmmB, xmmF      ; xmmB=(01 03 05 07 09 0B 0D 0F)
+    punpckhbw   xmmD, xmmF      ; xmmD=(11 13 15 17 19 1B 1D 1F)
+
+    movdqa      xmmG, xmmE
+    punpcklbw   xmmE, xmmF      ; xmmE=(20 22 24 26 28 2A 2C 2E)
+    punpckhbw   xmmG, xmmF      ; xmmG=(30 32 34 36 38 3A 3C 3E)
+
+    punpcklbw   xmmF, xmmH
+    punpckhbw   xmmH, xmmH
+    psrlw       xmmF, BYTE_BIT  ; xmmF=(21 23 25 27 29 2B 2D 2F)
+    psrlw       xmmH, BYTE_BIT  ; xmmH=(31 33 35 37 39 3B 3D 3F)
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+    ; xmm0=R(02468ACE)=RE, xmm2=G(02468ACE)=GE, xmm4=B(02468ACE)=BE
+    ; xmm1=R(13579BDF)=RO, xmm3=G(13579BDF)=GO, xmm5=B(13579BDF)=BO
+
+    ; (Original)
+    ; Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
+    ;
+    ; (This implementation)
+    ; Y  =  0.29900 * R + 0.33700 * G + 0.11400 * B + 0.25000 * G
+
+    movdqa      xmm6, xmm1
+    punpcklwd   xmm1, xmm3
+    punpckhwd   xmm6, xmm3
+    pmaddwd     xmm1, [rel PW_F0299_F0337]  ; xmm1=ROL*FIX(0.299)+GOL*FIX(0.337)
+    pmaddwd     xmm6, [rel PW_F0299_F0337]  ; xmm6=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa      xmm7, xmm6              ; xmm7=ROH*FIX(0.299)+GOH*FIX(0.337)
+
+    movdqa      xmm6, xmm0
+    punpcklwd   xmm0, xmm2
+    punpckhwd   xmm6, xmm2
+    pmaddwd     xmm0, [rel PW_F0299_F0337]  ; xmm0=REL*FIX(0.299)+GEL*FIX(0.337)
+    pmaddwd     xmm6, [rel PW_F0299_F0337]  ; xmm6=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=REL*FIX(0.299)+GEL*FIX(0.337)
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=REH*FIX(0.299)+GEH*FIX(0.337)
+
+    movdqa      xmm0, xmm5              ; xmm0=BO
+    movdqa      xmm6, xmm4              ; xmm6=BE
+
+    movdqa      xmm4, xmm0
+    punpcklwd   xmm0, xmm3
+    punpckhwd   xmm4, xmm3
+    pmaddwd     xmm0, [rel PW_F0114_F0250]  ; xmm0=BOL*FIX(0.114)+GOL*FIX(0.250)
+    pmaddwd     xmm4, [rel PW_F0114_F0250]  ; xmm4=BOH*FIX(0.114)+GOH*FIX(0.250)
+
+    movdqa      xmm3, [rel PD_ONEHALF]      ; xmm3=[PD_ONEHALF]
+
+    paddd       xmm0, xmm1
+    paddd       xmm4, xmm7
+    paddd       xmm0, xmm3
+    paddd       xmm4, xmm3
+    psrld       xmm0, SCALEBITS         ; xmm0=YOL
+    psrld       xmm4, SCALEBITS         ; xmm4=YOH
+    packssdw    xmm0, xmm4              ; xmm0=YO
+
+    movdqa      xmm4, xmm6
+    punpcklwd   xmm6, xmm2
+    punpckhwd   xmm4, xmm2
+    pmaddwd     xmm6, [rel PW_F0114_F0250]  ; xmm6=BEL*FIX(0.114)+GEL*FIX(0.250)
+    pmaddwd     xmm4, [rel PW_F0114_F0250]  ; xmm4=BEH*FIX(0.114)+GEH*FIX(0.250)
+
+    movdqa      xmm2, [rel PD_ONEHALF]      ; xmm2=[PD_ONEHALF]
+
+    paddd       xmm6, XMMWORD [wk(0)]
+    paddd       xmm4, XMMWORD [wk(1)]
+    paddd       xmm6, xmm2
+    paddd       xmm4, xmm2
+    psrld       xmm6, SCALEBITS         ; xmm6=YEL
+    psrld       xmm4, SCALEBITS         ; xmm4=YEH
+    packssdw    xmm6, xmm4              ; xmm6=YE
+
+    psllw       xmm0, BYTE_BIT
+    por         xmm6, xmm0              ; xmm6=Y
+    movdqa      XMMWORD [rdi], xmm6     ; Save Y
+
+    sub         rcx, byte SIZEOF_XMMWORD
+    add         rsi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; inptr
+    add         rdi, byte SIZEOF_XMMWORD                ; outptr0
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    test        rcx, rcx
+    jnz         near .column_ld1
+
+    pop         rcx                     ; col
+    pop         rsi
+    pop         rdi
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_buf
+    add         rdi, byte SIZEOF_JSAMPROW
+    dec         rax                        ; num_rows
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    uncollect_args 5
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jchuff-sse2.asm b/simd/x86_64/jchuff-sse2.asm
new file mode 100644
index 0000000..bedc639
--- /dev/null
+++ b/simd/x86_64/jchuff-sse2.asm
@@ -0,0 +1,348 @@
+;
+; jchuff-sse2.asm - Huffman entropy encoding (64-bit SSE2)
+;
+; Copyright (C) 2009-2011, 2014-2016, D. R. Commander.
+; Copyright (C) 2015, Matthieu Darbois.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains an SSE2 implementation for Huffman coding of one block.
+; The following code is based directly on jchuff.c; see jchuff.c for more
+; details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_huff_encode_one_block)
+
+EXTN(jconst_huff_encode_one_block):
+
+%include "jpeg_nbits_table.inc"
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+
+; These macros perform the same task as the emit_bits() function in the
+; original libjpeg code.  In addition to reducing overhead by explicitly
+; inlining the code, additional performance is achieved by taking into
+; account the size of the bit buffer and waiting until it is almost full
+; before emptying it.  This mostly benefits 64-bit platforms, since 6
+; bytes can be stored in a 64-bit bit buffer before it has to be emptied.
+
+%macro EMIT_BYTE 0
+    sub         put_bits, 8             ; put_bits -= 8;
+    mov         rdx, put_buffer
+    mov         ecx, put_bits
+    shr         rdx, cl                 ; c = (JOCTET)GETJOCTET(put_buffer >> put_bits);
+    mov         byte [buffer], dl       ; *buffer++ = c;
+    add         buffer, 1
+    cmp         dl, 0xFF                ; need to stuff a zero byte?
+    jne         %%.EMIT_BYTE_END
+    mov         byte [buffer], 0        ; *buffer++ = 0;
+    add         buffer, 1
+%%.EMIT_BYTE_END:
+%endmacro
+
+%macro PUT_BITS 1
+    add         put_bits, ecx           ; put_bits += size;
+    shl         put_buffer, cl          ; put_buffer = (put_buffer << size);
+    or          put_buffer, %1
+%endmacro
+
+%macro CHECKBUF31 0
+    cmp         put_bits, 32            ; if (put_bits > 31) {
+    jl          %%.CHECKBUF31_END
+    EMIT_BYTE
+    EMIT_BYTE
+    EMIT_BYTE
+    EMIT_BYTE
+%%.CHECKBUF31_END:
+%endmacro
+
+%macro CHECKBUF47 0
+    cmp         put_bits, 48            ; if (put_bits > 47) {
+    jl          %%.CHECKBUF47_END
+    EMIT_BYTE
+    EMIT_BYTE
+    EMIT_BYTE
+    EMIT_BYTE
+    EMIT_BYTE
+    EMIT_BYTE
+%%.CHECKBUF47_END:
+%endmacro
+
+%macro EMIT_BITS 2
+    CHECKBUF47
+    mov         ecx, %2
+    PUT_BITS    %1
+%endmacro
+
+%macro kloop_prepare 37                 ;(ko, jno0, ..., jno31, xmm0, xmm1, xmm2, xmm3)
+    pxor        xmm8, xmm8              ; __m128i neg = _mm_setzero_si128();
+    pxor        xmm9, xmm9              ; __m128i neg = _mm_setzero_si128();
+    pxor        xmm10, xmm10            ; __m128i neg = _mm_setzero_si128();
+    pxor        xmm11, xmm11            ; __m128i neg = _mm_setzero_si128();
+    pinsrw      %34, word [r12 + %2  * SIZEOF_WORD], 0  ; xmm_shadow[0] = block[jno0];
+    pinsrw      %35, word [r12 + %10 * SIZEOF_WORD], 0  ; xmm_shadow[8] = block[jno8];
+    pinsrw      %36, word [r12 + %18 * SIZEOF_WORD], 0  ; xmm_shadow[16] = block[jno16];
+    pinsrw      %37, word [r12 + %26 * SIZEOF_WORD], 0  ; xmm_shadow[24] = block[jno24];
+    pinsrw      %34, word [r12 + %3  * SIZEOF_WORD], 1  ; xmm_shadow[1] = block[jno1];
+    pinsrw      %35, word [r12 + %11 * SIZEOF_WORD], 1  ; xmm_shadow[9] = block[jno9];
+    pinsrw      %36, word [r12 + %19 * SIZEOF_WORD], 1  ; xmm_shadow[17] = block[jno17];
+    pinsrw      %37, word [r12 + %27 * SIZEOF_WORD], 1  ; xmm_shadow[25] = block[jno25];
+    pinsrw      %34, word [r12 + %4  * SIZEOF_WORD], 2  ; xmm_shadow[2] = block[jno2];
+    pinsrw      %35, word [r12 + %12 * SIZEOF_WORD], 2  ; xmm_shadow[10] = block[jno10];
+    pinsrw      %36, word [r12 + %20 * SIZEOF_WORD], 2  ; xmm_shadow[18] = block[jno18];
+    pinsrw      %37, word [r12 + %28 * SIZEOF_WORD], 2  ; xmm_shadow[26] = block[jno26];
+    pinsrw      %34, word [r12 + %5  * SIZEOF_WORD], 3  ; xmm_shadow[3] = block[jno3];
+    pinsrw      %35, word [r12 + %13 * SIZEOF_WORD], 3  ; xmm_shadow[11] = block[jno11];
+    pinsrw      %36, word [r12 + %21 * SIZEOF_WORD], 3  ; xmm_shadow[19] = block[jno19];
+    pinsrw      %37, word [r12 + %29 * SIZEOF_WORD], 3  ; xmm_shadow[27] = block[jno27];
+    pinsrw      %34, word [r12 + %6  * SIZEOF_WORD], 4  ; xmm_shadow[4] = block[jno4];
+    pinsrw      %35, word [r12 + %14 * SIZEOF_WORD], 4  ; xmm_shadow[12] = block[jno12];
+    pinsrw      %36, word [r12 + %22 * SIZEOF_WORD], 4  ; xmm_shadow[20] = block[jno20];
+    pinsrw      %37, word [r12 + %30 * SIZEOF_WORD], 4  ; xmm_shadow[28] = block[jno28];
+    pinsrw      %34, word [r12 + %7  * SIZEOF_WORD], 5  ; xmm_shadow[5] = block[jno5];
+    pinsrw      %35, word [r12 + %15 * SIZEOF_WORD], 5  ; xmm_shadow[13] = block[jno13];
+    pinsrw      %36, word [r12 + %23 * SIZEOF_WORD], 5  ; xmm_shadow[21] = block[jno21];
+    pinsrw      %37, word [r12 + %31 * SIZEOF_WORD], 5  ; xmm_shadow[29] = block[jno29];
+    pinsrw      %34, word [r12 + %8  * SIZEOF_WORD], 6  ; xmm_shadow[6] = block[jno6];
+    pinsrw      %35, word [r12 + %16 * SIZEOF_WORD], 6  ; xmm_shadow[14] = block[jno14];
+    pinsrw      %36, word [r12 + %24 * SIZEOF_WORD], 6  ; xmm_shadow[22] = block[jno22];
+    pinsrw      %37, word [r12 + %32 * SIZEOF_WORD], 6  ; xmm_shadow[30] = block[jno30];
+    pinsrw      %34, word [r12 + %9  * SIZEOF_WORD], 7  ; xmm_shadow[7] = block[jno7];
+    pinsrw      %35, word [r12 + %17 * SIZEOF_WORD], 7  ; xmm_shadow[15] = block[jno15];
+    pinsrw      %36, word [r12 + %25 * SIZEOF_WORD], 7  ; xmm_shadow[23] = block[jno23];
+%if %1 != 32
+    pinsrw      %37, word [r12 + %33 * SIZEOF_WORD], 7  ; xmm_shadow[31] = block[jno31];
+%else
+    pinsrw      %37, ebx, 7             ; xmm_shadow[31] = block[jno31];
+%endif
+    pcmpgtw     xmm8, %34               ; neg = _mm_cmpgt_epi16(neg, x1);
+    pcmpgtw     xmm9, %35               ; neg = _mm_cmpgt_epi16(neg, x1);
+    pcmpgtw     xmm10, %36              ; neg = _mm_cmpgt_epi16(neg, x1);
+    pcmpgtw     xmm11, %37              ; neg = _mm_cmpgt_epi16(neg, x1);
+    paddw       %34, xmm8               ; x1 = _mm_add_epi16(x1, neg);
+    paddw       %35, xmm9               ; x1 = _mm_add_epi16(x1, neg);
+    paddw       %36, xmm10              ; x1 = _mm_add_epi16(x1, neg);
+    paddw       %37, xmm11              ; x1 = _mm_add_epi16(x1, neg);
+    pxor        %34, xmm8               ; x1 = _mm_xor_si128(x1, neg);
+    pxor        %35, xmm9               ; x1 = _mm_xor_si128(x1, neg);
+    pxor        %36, xmm10              ; x1 = _mm_xor_si128(x1, neg);
+    pxor        %37, xmm11              ; x1 = _mm_xor_si128(x1, neg);
+    pxor        xmm8, %34               ; neg = _mm_xor_si128(neg, x1);
+    pxor        xmm9, %35               ; neg = _mm_xor_si128(neg, x1);
+    pxor        xmm10, %36              ; neg = _mm_xor_si128(neg, x1);
+    pxor        xmm11, %37              ; neg = _mm_xor_si128(neg, x1);
+    movdqa      XMMWORD [t1 + %1 * SIZEOF_WORD], %34           ; _mm_storeu_si128((__m128i *)(t1 + ko), x1);
+    movdqa      XMMWORD [t1 + (%1 + 8) * SIZEOF_WORD], %35     ; _mm_storeu_si128((__m128i *)(t1 + ko + 8), x1);
+    movdqa      XMMWORD [t1 + (%1 + 16) * SIZEOF_WORD], %36    ; _mm_storeu_si128((__m128i *)(t1 + ko + 16), x1);
+    movdqa      XMMWORD [t1 + (%1 + 24) * SIZEOF_WORD], %37    ; _mm_storeu_si128((__m128i *)(t1 + ko + 24), x1);
+    movdqa      XMMWORD [t2 + %1 * SIZEOF_WORD], xmm8          ; _mm_storeu_si128((__m128i *)(t2 + ko), neg);
+    movdqa      XMMWORD [t2 + (%1 + 8) * SIZEOF_WORD], xmm9    ; _mm_storeu_si128((__m128i *)(t2 + ko + 8), neg);
+    movdqa      XMMWORD [t2 + (%1 + 16) * SIZEOF_WORD], xmm10  ; _mm_storeu_si128((__m128i *)(t2 + ko + 16), neg);
+    movdqa      XMMWORD [t2 + (%1 + 24) * SIZEOF_WORD], xmm11  ; _mm_storeu_si128((__m128i *)(t2 + ko + 24), neg);
+%endmacro
+
+;
+; Encode a single block's worth of coefficients.
+;
+; GLOBAL(JOCTET*)
+; jsimd_huff_encode_one_block_sse2 (working_state *state, JOCTET *buffer,
+;                                   JCOEFPTR block, int last_dc_val,
+;                                   c_derived_tbl *dctbl, c_derived_tbl *actbl)
+;
+
+; r10 = working_state *state
+; r11 = JOCTET *buffer
+; r12 = JCOEFPTR block
+; r13d = int last_dc_val
+; r14 = c_derived_tbl *dctbl
+; r15 = c_derived_tbl *actbl
+
+%define t1          rbp-(DCTSIZE2*SIZEOF_WORD)
+%define t2          t1-(DCTSIZE2*SIZEOF_WORD)
+%define put_buffer  r8
+%define put_bits    r9d
+%define buffer      rax
+
+    align       32
+    global      EXTN(jsimd_huff_encode_one_block_sse2)
+
+EXTN(jsimd_huff_encode_one_block_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp,rsp                      ; rbp = aligned rbp
+    lea         rsp, [t2]
+    push_xmm    4
+    collect_args 6
+    push        rbx
+
+    mov         buffer, r11                  ; r11 is now sratch
+
+    mov         put_buffer, MMWORD [r10+16]  ; put_buffer = state->cur.put_buffer;
+    mov         put_bits,    DWORD [r10+24]  ; put_bits = state->cur.put_bits;
+    push        r10                          ; r10 is now scratch
+
+    ; Encode the DC coefficient difference per section F.1.2.1
+    movsx       edi, word [r12]         ; temp = temp2 = block[0] - last_dc_val;
+    sub         edi, r13d               ; r13 is not used anymore
+    mov         ebx, edi
+
+    ; This is a well-known technique for obtaining the absolute value
+    ; without a branch.  It is derived from an assembly language technique
+    ; presented in "How to Optimize for the Pentium Processors",
+    ; Copyright (c) 1996, 1997 by Agner Fog.
+    mov         esi, edi
+    sar         esi, 31                 ; temp3 = temp >> (CHAR_BIT * sizeof(int) - 1);
+    xor         edi, esi                ; temp ^= temp3;
+    sub         edi, esi                ; temp -= temp3;
+
+    ; For a negative input, want temp2 = bitwise complement of abs(input)
+    ; This code assumes we are on a two's complement machine
+    add         ebx, esi                ; temp2 += temp3;
+
+    ; Find the number of bits needed for the magnitude of the coefficient
+    lea         r11, [rel jpeg_nbits_table]
+    movzx       rdi, byte [r11 + rdi]         ; nbits = JPEG_NBITS(temp);
+    ; Emit the Huffman-coded symbol for the number of bits
+    mov         r11d,  INT [r14 + rdi * 4]    ; code = dctbl->ehufco[nbits];
+    movzx       esi, byte [r14 + rdi + 1024]  ; size = dctbl->ehufsi[nbits];
+    EMIT_BITS   r11, esi                      ; EMIT_BITS(code, size)
+
+    ; Mask off any extra bits in code
+    mov         esi, 1
+    mov         ecx, edi
+    shl         esi, cl
+    dec         esi
+    and         ebx, esi                ; temp2 &= (((JLONG) 1)<<nbits) - 1;
+
+    ; Emit that number of bits of the value, if positive,
+    ; or the complement of its magnitude, if negative.
+    EMIT_BITS   rbx, edi                ; EMIT_BITS(temp2, nbits)
+
+    ; Prepare data
+    xor         ebx, ebx
+    kloop_prepare  0,  1,  8,  16, 9,  2,  3,  10, 17, 24, 32, 25, \
+                   18, 11, 4,  5,  12, 19, 26, 33, 40, 48, 41, 34, \
+                   27, 20, 13, 6,  7,  14, 21, 28, 35, \
+                   xmm0, xmm1, xmm2, xmm3
+    kloop_prepare  32, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, \
+                   30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, \
+                   53, 60, 61, 54, 47, 55, 62, 63, 63, \
+                   xmm4, xmm5, xmm6, xmm7
+
+    pxor        xmm8, xmm8
+    pcmpeqw     xmm0, xmm8              ; tmp0 = _mm_cmpeq_epi16(tmp0, zero);
+    pcmpeqw     xmm1, xmm8              ; tmp1 = _mm_cmpeq_epi16(tmp1, zero);
+    pcmpeqw     xmm2, xmm8              ; tmp2 = _mm_cmpeq_epi16(tmp2, zero);
+    pcmpeqw     xmm3, xmm8              ; tmp3 = _mm_cmpeq_epi16(tmp3, zero);
+    pcmpeqw     xmm4, xmm8              ; tmp4 = _mm_cmpeq_epi16(tmp4, zero);
+    pcmpeqw     xmm5, xmm8              ; tmp5 = _mm_cmpeq_epi16(tmp5, zero);
+    pcmpeqw     xmm6, xmm8              ; tmp6 = _mm_cmpeq_epi16(tmp6, zero);
+    pcmpeqw     xmm7, xmm8              ; tmp7 = _mm_cmpeq_epi16(tmp7, zero);
+    packsswb    xmm0, xmm1              ; tmp0 = _mm_packs_epi16(tmp0, tmp1);
+    packsswb    xmm2, xmm3              ; tmp2 = _mm_packs_epi16(tmp2, tmp3);
+    packsswb    xmm4, xmm5              ; tmp4 = _mm_packs_epi16(tmp4, tmp5);
+    packsswb    xmm6, xmm7              ; tmp6 = _mm_packs_epi16(tmp6, tmp7);
+    pmovmskb    r11d, xmm0              ; index  = ((uint64_t)_mm_movemask_epi8(tmp0)) << 0;
+    pmovmskb    r12d, xmm2              ; index  = ((uint64_t)_mm_movemask_epi8(tmp2)) << 16;
+    pmovmskb    r13d, xmm4              ; index  = ((uint64_t)_mm_movemask_epi8(tmp4)) << 32;
+    pmovmskb    r14d, xmm6              ; index  = ((uint64_t)_mm_movemask_epi8(tmp6)) << 48;
+    shl         r12, 16
+    shl         r14, 16
+    or          r11, r12
+    or          r13, r14
+    shl         r13, 32
+    or          r11, r13
+    not         r11                     ; index = ~index;
+
+    ;mov MMWORD [ t1 + DCTSIZE2 * SIZEOF_WORD ], r11
+    ;jmp .EFN
+
+    mov         r13d,  INT [r15 + 240 * 4]     ; code_0xf0 = actbl->ehufco[0xf0];
+    movzx       r14d, byte [r15 + 1024 + 240]  ; size_0xf0 = actbl->ehufsi[0xf0];
+    lea         rsi, [t1]
+.BLOOP:
+    bsf         r12, r11                     ; r = __builtin_ctzl(index);
+    jz          .ELOOP
+    mov         rcx, r12
+    lea         rsi, [rsi+r12*2]             ; k += r;
+    shr         r11, cl                      ; index >>= r;
+    movzx       rdi, word [rsi]              ; temp = t1[k];
+    lea         rbx, [rel jpeg_nbits_table]
+    movzx       rdi, byte [rbx + rdi]        ; nbits = JPEG_NBITS(temp);
+.BRLOOP:
+    cmp         r12, 16                 ; while (r > 15) {
+    jl          .ERLOOP
+    EMIT_BITS   r13, r14d               ; EMIT_BITS(code_0xf0, size_0xf0)
+    sub         r12, 16                 ; r -= 16;
+    jmp         .BRLOOP
+.ERLOOP:
+    ; Emit Huffman symbol for run length / number of bits
+    CHECKBUF31  ; uses rcx, rdx
+
+    shl         r12, 4                        ; temp3 = (r << 4) + nbits;
+    add         r12, rdi
+    mov         ebx,  INT [r15 + r12 * 4]     ; code = actbl->ehufco[temp3];
+    movzx       ecx, byte [r15 + r12 + 1024]  ; size = actbl->ehufsi[temp3];
+    PUT_BITS    rbx
+
+    ;EMIT_CODE(code, size)
+
+    movsx       ebx, word [rsi-DCTSIZE2*2]    ; temp2 = t2[k];
+    ; Mask off any extra bits in code
+    mov         rcx, rdi
+    mov         rdx, 1
+    shl         rdx, cl
+    dec         rdx
+    and         rbx, rdx                ; temp2 &= (((JLONG) 1)<<nbits) - 1;
+    PUT_BITS    rbx                     ; PUT_BITS(temp2, nbits)
+
+    shr         r11, 1                  ; index >>= 1;
+    add         rsi, 2                  ; ++k;
+    jmp         .BLOOP
+.ELOOP:
+    ; If the last coef(s) were zero, emit an end-of-block code
+    lea         rdi, [t1 + (DCTSIZE2-1) * 2]  ; r = DCTSIZE2-1-k;
+    cmp         rdi, rsi                      ; if (r > 0) {
+    je          .EFN
+    mov         ebx,  INT [r15]               ; code = actbl->ehufco[0];
+    movzx       r12d, byte [r15 + 1024]       ; size = actbl->ehufsi[0];
+    EMIT_BITS   rbx, r12d
+.EFN:
+    pop         r10
+    ; Save put_buffer & put_bits
+    mov         MMWORD [r10+16], put_buffer  ; state->cur.put_buffer = put_buffer;
+    mov         DWORD  [r10+24], put_bits    ; state->cur.put_bits = put_bits;
+
+    pop         rbx
+    uncollect_args 6
+    pop_xmm     4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jcsample-avx2.asm b/simd/x86_64/jcsample-avx2.asm
new file mode 100644
index 0000000..d7877ea
--- /dev/null
+++ b/simd/x86_64/jcsample-avx2.asm
@@ -0,0 +1,366 @@
+;
+; jcsample.asm - downsampling (64-bit AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Downsample pixel values of a single component.
+; This version handles the common case of 2:1 horizontal and 1:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v1_downsample_avx2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+; r10d = JDIMENSION image_width
+; r11 = int max_v_samp_factor
+; r12d = JDIMENSION v_samp_factor
+; r13d = JDIMENSION width_blocks
+; r14 = JSAMPARRAY input_data
+; r15 = JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v1_downsample_avx2)
+
+EXTN(jsimd_h2v1_downsample_avx2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 6
+
+    mov         ecx, r13d
+    shl         rcx, 3                  ; imul rcx,DCTSIZE (rcx = output_cols)
+    jz          near .return
+
+    mov         edx, r10d
+
+    ; -- expand_right_edge
+
+    push        rcx
+    shl         rcx, 1                  ; output_cols * 2
+    sub         rcx, rdx
+    jle         short .expand_end
+
+    mov         rax, r11
+    test        rax, rax
+    jle         short .expand_end
+
+    cld
+    mov         rsi, r14                ; input_data
+.expandloop:
+    push        rax
+    push        rcx
+
+    mov         rdi, JSAMPROW [rsi]
+    add         rdi, rdx
+    mov         al, JSAMPLE [rdi-1]
+
+    rep stosb
+
+    pop         rcx
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW
+    dec         rax
+    jg          short .expandloop
+
+.expand_end:
+    pop         rcx                     ; output_cols
+
+    ; -- h2v1_downsample
+
+    mov         eax, r12d               ; rowctr
+    test        eax, eax
+    jle         near .return
+
+    mov         rdx, 0x00010000         ; bias pattern
+    vmovd       xmm7, edx
+    vpshufd     xmm7, xmm7, 0x00        ; xmm7={0, 1, 0, 1, 0, 1, 0, 1}
+    vperm2i128  ymm7, ymm7, ymm7, 0     ; ymm7={xmm7, xmm7}
+    vpcmpeqw    ymm6, ymm6, ymm6
+    vpsrlw      ymm6, ymm6, BYTE_BIT    ; ymm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         rsi, r14                ; input_data
+    mov         rdi, r15                ; output_data
+.rowloop:
+    push        rcx
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         short .columnloop
+
+.columnloop_r24:
+    ; rcx can possibly be 8, 16, 24
+    cmp         rcx, 24
+    jne         .columnloop_r16
+    vmovdqu     ymm0, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     xmm1, XMMWORD [rsi+1*SIZEOF_YMMWORD]
+    mov         rcx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r16:
+    cmp         rcx, 16
+    jne         .columnloop_r8
+    vmovdqu     ymm0, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vpxor       ymm1, ymm1, ymm1
+    mov         rcx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r8:
+    vmovdqu     xmm0, XMMWORD[rsi+0*SIZEOF_YMMWORD]
+    vpxor       ymm1, ymm1, ymm1
+    mov         rcx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop:
+    vmovdqu     ymm0, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+
+.downsample:
+    vpsrlw      ymm2, ymm0, BYTE_BIT
+    vpand       ymm0, ymm0, ymm6
+    vpsrlw      ymm3, ymm1, BYTE_BIT
+    vpand       ymm1, ymm1, ymm6
+
+    vpaddw      ymm0, ymm0, ymm2
+    vpaddw      ymm1, ymm1, ymm3
+    vpaddw      ymm0, ymm0, ymm7
+    vpaddw      ymm1, ymm1, ymm7
+    vpsrlw      ymm0, ymm0, 1
+    vpsrlw      ymm1, ymm1, 1
+
+    vpackuswb   ymm0, ymm0, ymm1
+    vpermq      ymm0, ymm0, 0xd8
+
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymm0
+
+    sub         rcx, byte SIZEOF_YMMWORD    ; outcol
+    add         rsi, byte 2*SIZEOF_YMMWORD  ; inptr
+    add         rdi, byte 1*SIZEOF_YMMWORD  ; outptr
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         short .columnloop
+    test        rcx, rcx
+    jnz         near .columnloop_r24
+
+    pop         rsi
+    pop         rdi
+    pop         rcx
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         rax                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    uncollect_args 6
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Downsample pixel values of a single component.
+; This version handles the standard case of 2:1 horizontal and 2:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v2_downsample_avx2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+; r10d = JDIMENSION image_width
+; r11 = int max_v_samp_factor
+; r12d = JDIMENSION v_samp_factor
+; r13d = JDIMENSION width_blocks
+; r14 = JSAMPARRAY input_data
+; r15 = JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v2_downsample_avx2)
+
+EXTN(jsimd_h2v2_downsample_avx2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 6
+
+    mov         ecx, r13d
+    shl         rcx, 3                  ; imul rcx,DCTSIZE (rcx = output_cols)
+    jz          near .return
+
+    mov         edx, r10d
+
+    ; -- expand_right_edge
+
+    push        rcx
+    shl         rcx, 1                  ; output_cols * 2
+    sub         rcx, rdx
+    jle         short .expand_end
+
+    mov         rax, r11
+    test        rax, rax
+    jle         short .expand_end
+
+    cld
+    mov         rsi, r14                ; input_data
+.expandloop:
+    push        rax
+    push        rcx
+
+    mov         rdi, JSAMPROW [rsi]
+    add         rdi, rdx
+    mov         al, JSAMPLE [rdi-1]
+
+    rep stosb
+
+    pop         rcx
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW
+    dec         rax
+    jg          short .expandloop
+
+.expand_end:
+    pop         rcx                     ; output_cols
+
+    ; -- h2v2_downsample
+
+    mov         eax, r12d               ; rowctr
+    test        rax, rax
+    jle         near .return
+
+    mov         rdx, 0x00020001         ; bias pattern
+    vmovd       xmm7, edx
+    vpcmpeqw    ymm6, ymm6, ymm6
+    vpshufd     xmm7, xmm7, 0x00        ; ymm7={1, 2, 1, 2, 1, 2, 1, 2}
+    vperm2i128  ymm7, ymm7, ymm7, 0
+    vpsrlw      ymm6, ymm6, BYTE_BIT    ; ymm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         rsi, r14                ; input_data
+    mov         rdi, r15                ; output_data
+.rowloop:
+    push        rcx
+    push        rdi
+    push        rsi
+
+    mov         rdx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         rsi, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]  ; inptr1
+    mov         rdi, JSAMPROW [rdi]                    ; outptr
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         short .columnloop
+
+.columnloop_r24:
+    cmp         rcx, 24
+    jne         .columnloop_r16
+    vmovdqu     ymm0, YMMWORD [rdx+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     xmm2, XMMWORD [rdx+1*SIZEOF_YMMWORD]
+    vmovdqu     xmm3, XMMWORD [rsi+1*SIZEOF_YMMWORD]
+    mov         rcx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r16:
+    cmp         rcx, 16
+    jne         .columnloop_r8
+    vmovdqu     ymm0, YMMWORD [rdx+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vpxor       ymm2, ymm2, ymm2
+    vpxor       ymm3, ymm3, ymm3
+    mov         rcx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop_r8:
+    vmovdqu     xmm0, XMMWORD [rdx+0*SIZEOF_XMMWORD]
+    vmovdqu     xmm1, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    vpxor       ymm2, ymm2, ymm2
+    vpxor       ymm3, ymm3, ymm3
+    mov         rcx, SIZEOF_YMMWORD
+    jmp         short .downsample
+
+.columnloop:
+    vmovdqu     ymm0, YMMWORD [rdx+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm1, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vmovdqu     ymm2, YMMWORD [rdx+1*SIZEOF_YMMWORD]
+    vmovdqu     ymm3, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+
+.downsample:
+    vpand       ymm4, ymm0, ymm6
+    vpsrlw      ymm0, ymm0, BYTE_BIT
+    vpand       ymm5, ymm1, ymm6
+    vpsrlw      ymm1, ymm1, BYTE_BIT
+    vpaddw      ymm0, ymm0, ymm4
+    vpaddw      ymm1, ymm1, ymm5
+
+    vpand       ymm4, ymm2, ymm6
+    vpsrlw      ymm2, ymm2, BYTE_BIT
+    vpand       ymm5, ymm3, ymm6
+    vpsrlw      ymm3, ymm3, BYTE_BIT
+    vpaddw      ymm2, ymm2, ymm4
+    vpaddw      ymm3, ymm3, ymm5
+
+    vpaddw      ymm0, ymm0, ymm1
+    vpaddw      ymm2, ymm2, ymm3
+    vpaddw      ymm0, ymm0, ymm7
+    vpaddw      ymm2, ymm2, ymm7
+    vpsrlw      ymm0, ymm0, 2
+    vpsrlw      ymm2, ymm2, 2
+
+    vpackuswb   ymm0, ymm0, ymm2
+    vpermq      ymm0, ymm0, 0xd8
+
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymm0
+
+    sub         rcx, byte SIZEOF_YMMWORD    ; outcol
+    add         rdx, byte 2*SIZEOF_YMMWORD  ; inptr0
+    add         rsi, byte 2*SIZEOF_YMMWORD  ; inptr1
+    add         rdi, byte 1*SIZEOF_YMMWORD  ; outptr
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jae         near .columnloop
+    test        rcx, rcx
+    jnz         near .columnloop_r24
+
+    pop         rsi
+    pop         rdi
+    pop         rcx
+
+    add         rsi, byte 2*SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte 1*SIZEOF_JSAMPROW  ; output_data
+    dec         rax                          ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    uncollect_args 6
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jcsample-sse2.asm b/simd/x86_64/jcsample-sse2.asm
new file mode 100644
index 0000000..2e5d3f5
--- /dev/null
+++ b/simd/x86_64/jcsample-sse2.asm
@@ -0,0 +1,329 @@
+;
+; jcsample.asm - downsampling (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Downsample pixel values of a single component.
+; This version handles the common case of 2:1 horizontal and 1:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v1_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+; r10d = JDIMENSION image_width
+; r11 = int max_v_samp_factor
+; r12d = JDIMENSION v_samp_factor
+; r13d = JDIMENSION width_blocks
+; r14 = JSAMPARRAY input_data
+; r15 = JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v1_downsample_sse2)
+
+EXTN(jsimd_h2v1_downsample_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 6
+
+    mov         ecx, r13d
+    shl         rcx, 3                  ; imul rcx,DCTSIZE (rcx = output_cols)
+    jz          near .return
+
+    mov         edx, r10d
+
+    ; -- expand_right_edge
+
+    push        rcx
+    shl         rcx, 1                  ; output_cols * 2
+    sub         rcx, rdx
+    jle         short .expand_end
+
+    mov         rax, r11
+    test        rax, rax
+    jle         short .expand_end
+
+    cld
+    mov         rsi, r14                ; input_data
+.expandloop:
+    push        rax
+    push        rcx
+
+    mov         rdi, JSAMPROW [rsi]
+    add         rdi, rdx
+    mov         al, JSAMPLE [rdi-1]
+
+    rep stosb
+
+    pop         rcx
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW
+    dec         rax
+    jg          short .expandloop
+
+.expand_end:
+    pop         rcx                     ; output_cols
+
+    ; -- h2v1_downsample
+
+    mov         eax, r12d               ; rowctr
+    test        eax, eax
+    jle         near .return
+
+    mov         rdx, 0x00010000         ; bias pattern
+    movd        xmm7, edx
+    pcmpeqw     xmm6, xmm6
+    pshufd      xmm7, xmm7, 0x00        ; xmm7={0, 1, 0, 1, 0, 1, 0, 1}
+    psrlw       xmm6, BYTE_BIT          ; xmm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         rsi, r14                ; input_data
+    mov         rdi, r15                ; output_data
+.rowloop:
+    push        rcx
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         short .columnloop
+
+.columnloop_r8:
+    movdqa      xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    pxor        xmm1, xmm1
+    mov         rcx, SIZEOF_XMMWORD
+    jmp         short .downsample
+
+.columnloop:
+    movdqa      xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqa      xmm1, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+
+.downsample:
+    movdqa      xmm2, xmm0
+    movdqa      xmm3, xmm1
+
+    pand        xmm0, xmm6
+    psrlw       xmm2, BYTE_BIT
+    pand        xmm1, xmm6
+    psrlw       xmm3, BYTE_BIT
+
+    paddw       xmm0, xmm2
+    paddw       xmm1, xmm3
+    paddw       xmm0, xmm7
+    paddw       xmm1, xmm7
+    psrlw       xmm0, 1
+    psrlw       xmm1, 1
+
+    packuswb    xmm0, xmm1
+
+    movdqa      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
+
+    sub         rcx, byte SIZEOF_XMMWORD    ; outcol
+    add         rsi, byte 2*SIZEOF_XMMWORD  ; inptr
+    add         rdi, byte 1*SIZEOF_XMMWORD  ; outptr
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         short .columnloop
+    test        rcx, rcx
+    jnz         short .columnloop_r8
+
+    pop         rsi
+    pop         rdi
+    pop         rcx
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         rax                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    uncollect_args 6
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Downsample pixel values of a single component.
+; This version handles the standard case of 2:1 horizontal and 2:1 vertical,
+; without smoothing.
+;
+; GLOBAL(void)
+; jsimd_h2v2_downsample_sse2 (JDIMENSION image_width, int max_v_samp_factor,
+;                             JDIMENSION v_samp_factor, JDIMENSION width_blocks,
+;                             JSAMPARRAY input_data, JSAMPARRAY output_data);
+;
+
+; r10d = JDIMENSION image_width
+; r11 = int max_v_samp_factor
+; r12d = JDIMENSION v_samp_factor
+; r13d = JDIMENSION width_blocks
+; r14 = JSAMPARRAY input_data
+; r15 = JSAMPARRAY output_data
+
+    align       32
+    global      EXTN(jsimd_h2v2_downsample_sse2)
+
+EXTN(jsimd_h2v2_downsample_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 6
+
+    mov         ecx, r13d
+    shl         rcx, 3                  ; imul rcx,DCTSIZE (rcx = output_cols)
+    jz          near .return
+
+    mov         edx, r10d
+
+    ; -- expand_right_edge
+
+    push        rcx
+    shl         rcx, 1                  ; output_cols * 2
+    sub         rcx, rdx
+    jle         short .expand_end
+
+    mov         rax, r11
+    test        rax, rax
+    jle         short .expand_end
+
+    cld
+    mov         rsi, r14                ; input_data
+.expandloop:
+    push        rax
+    push        rcx
+
+    mov         rdi, JSAMPROW [rsi]
+    add         rdi, rdx
+    mov         al, JSAMPLE [rdi-1]
+
+    rep stosb
+
+    pop         rcx
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW
+    dec         rax
+    jg          short .expandloop
+
+.expand_end:
+    pop         rcx                     ; output_cols
+
+    ; -- h2v2_downsample
+
+    mov         eax, r12d               ; rowctr
+    test        rax, rax
+    jle         near .return
+
+    mov         rdx, 0x00020001         ; bias pattern
+    movd        xmm7, edx
+    pcmpeqw     xmm6, xmm6
+    pshufd      xmm7, xmm7, 0x00        ; xmm7={1, 2, 1, 2, 1, 2, 1, 2}
+    psrlw       xmm6, BYTE_BIT          ; xmm6={0xFF 0x00 0xFF 0x00 ..}
+
+    mov         rsi, r14                ; input_data
+    mov         rdi, r15                ; output_data
+.rowloop:
+    push        rcx
+    push        rdi
+    push        rsi
+
+    mov         rdx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         rsi, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]  ; inptr1
+    mov         rdi, JSAMPROW [rdi]                    ; outptr
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         short .columnloop
+
+.columnloop_r8:
+    movdqa      xmm0, XMMWORD [rdx+0*SIZEOF_XMMWORD]
+    movdqa      xmm1, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    pxor        xmm2, xmm2
+    pxor        xmm3, xmm3
+    mov         rcx, SIZEOF_XMMWORD
+    jmp         short .downsample
+
+.columnloop:
+    movdqa      xmm0, XMMWORD [rdx+0*SIZEOF_XMMWORD]
+    movdqa      xmm1, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqa      xmm2, XMMWORD [rdx+1*SIZEOF_XMMWORD]
+    movdqa      xmm3, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+
+.downsample:
+    movdqa      xmm4, xmm0
+    movdqa      xmm5, xmm1
+    pand        xmm0, xmm6
+    psrlw       xmm4, BYTE_BIT
+    pand        xmm1, xmm6
+    psrlw       xmm5, BYTE_BIT
+    paddw       xmm0, xmm4
+    paddw       xmm1, xmm5
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm5, xmm3
+    pand        xmm2, xmm6
+    psrlw       xmm4, BYTE_BIT
+    pand        xmm3, xmm6
+    psrlw       xmm5, BYTE_BIT
+    paddw       xmm2, xmm4
+    paddw       xmm3, xmm5
+
+    paddw       xmm0, xmm1
+    paddw       xmm2, xmm3
+    paddw       xmm0, xmm7
+    paddw       xmm2, xmm7
+    psrlw       xmm0, 2
+    psrlw       xmm2, 2
+
+    packuswb    xmm0, xmm2
+
+    movdqa      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
+
+    sub         rcx, byte SIZEOF_XMMWORD    ; outcol
+    add         rdx, byte 2*SIZEOF_XMMWORD  ; inptr0
+    add         rsi, byte 2*SIZEOF_XMMWORD  ; inptr1
+    add         rdi, byte 1*SIZEOF_XMMWORD  ; outptr
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jae         near .columnloop
+    test        rcx, rcx
+    jnz         near .columnloop_r8
+
+    pop         rsi
+    pop         rdi
+    pop         rcx
+
+    add         rsi, byte 2*SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte 1*SIZEOF_JSAMPROW  ; output_data
+    dec         rax                          ; rowctr
+    jg          near .rowloop
+
+.return:
+    uncollect_args 6
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jdcolext-avx2.asm b/simd/x86_64/jdcolext-avx2.asm
new file mode 100644
index 0000000..ca81ad8
--- /dev/null
+++ b/simd/x86_64/jdcolext-avx2.asm
@@ -0,0 +1,497 @@
+;
+; jdcolext.asm - colorspace conversion (64-bit AVX2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2012, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_ycc_rgb_convert_avx2 (JDIMENSION out_width,
+;                             JSAMPIMAGE input_buf, JDIMENSION input_row,
+;                             JSAMPARRAY output_buf, int num_rows)
+;
+
+; r10d = JDIMENSION out_width
+; r11 = JSAMPIMAGE input_buf
+; r12d = JDIMENSION input_row
+; r13 = JSAMPARRAY output_buf
+; r14d = int num_rows
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM  2
+
+    align       32
+    global      EXTN(jsimd_ycc_rgb_convert_avx2)
+
+EXTN(jsimd_ycc_rgb_convert_avx2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 5
+    push        rbx
+
+    mov         ecx, r10d               ; num_cols
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rdi, r11
+    mov         ecx, r12d
+    mov         rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
+    lea         rsi, [rsi+rcx*SIZEOF_JSAMPROW]
+    lea         rbx, [rbx+rcx*SIZEOF_JSAMPROW]
+    lea         rdx, [rdx+rcx*SIZEOF_JSAMPROW]
+
+    pop         rcx
+
+    mov         rdi, r13
+    mov         eax, r14d
+    test        rax, rax
+    jle         near .return
+.rowloop:
+    push        rax
+    push        rdi
+    push        rdx
+    push        rbx
+    push        rsi
+    push        rcx                     ; col
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr0
+    mov         rbx, JSAMPROW [rbx]     ; inptr1
+    mov         rdx, JSAMPROW [rdx]     ; inptr2
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+.columnloop:
+
+    vmovdqu     ymm5, YMMWORD [rbx]     ; ymm5=Cb(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+    vmovdqu     ymm1, YMMWORD [rdx]     ; ymm1=Cr(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpcmpeqw    ymm0, ymm0, ymm0
+    vpcmpeqw    ymm7, ymm7, ymm7
+    vpsrlw      ymm0, ymm0, BYTE_BIT    ; ymm0={0xFF 0x00 0xFF 0x00 ..}
+    vpsllw      ymm7, ymm7, 7           ; ymm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    vpand       ymm4, ymm0, ymm5        ; ymm4=Cb(02468ACEGIKMOQSU)=CbE
+    vpsrlw      ymm5, ymm5, BYTE_BIT    ; ymm5=Cb(13579BDFHJLNPRTV)=CbO
+    vpand       ymm0, ymm0, ymm1        ; ymm0=Cr(02468ACEGIKMOQSU)=CrE
+    vpsrlw      ymm1, ymm1, BYTE_BIT    ; ymm1=Cr(13579BDFHJLNPRTV)=CrO
+
+    vpaddw      ymm2, ymm4, ymm7
+    vpaddw      ymm3, ymm5, ymm7
+    vpaddw      ymm6, ymm0, ymm7
+    vpaddw      ymm7, ymm1, ymm7
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    vpaddw      ymm4, ymm2, ymm2             ; ymm4=2*CbE
+    vpaddw      ymm5, ymm3, ymm3             ; ymm5=2*CbO
+    vpaddw      ymm0, ymm6, ymm6             ; ymm0=2*CrE
+    vpaddw      ymm1, ymm7, ymm7             ; ymm1=2*CrO
+
+    vpmulhw     ymm4, ymm4, [rel PW_MF0228]  ; ymm4=(2*CbE * -FIX(0.22800))
+    vpmulhw     ymm5, ymm5, [rel PW_MF0228]  ; ymm5=(2*CbO * -FIX(0.22800))
+    vpmulhw     ymm0, ymm0, [rel PW_F0402]   ; ymm0=(2*CrE * FIX(0.40200))
+    vpmulhw     ymm1, ymm1, [rel PW_F0402]   ; ymm1=(2*CrO * FIX(0.40200))
+
+    vpaddw      ymm4, ymm4, [rel PW_ONE]
+    vpaddw      ymm5, ymm5, [rel PW_ONE]
+    vpsraw      ymm4, ymm4, 1                ; ymm4=(CbE * -FIX(0.22800))
+    vpsraw      ymm5, ymm5, 1                ; ymm5=(CbO * -FIX(0.22800))
+    vpaddw      ymm0, ymm0, [rel PW_ONE]
+    vpaddw      ymm1, ymm1, [rel PW_ONE]
+    vpsraw      ymm0, ymm0, 1                ; ymm0=(CrE * FIX(0.40200))
+    vpsraw      ymm1, ymm1, 1                ; ymm1=(CrO * FIX(0.40200))
+
+    vpaddw      ymm4, ymm4, ymm2
+    vpaddw      ymm5, ymm5, ymm3
+    vpaddw      ymm4, ymm4, ymm2             ; ymm4=(CbE * FIX(1.77200))=(B-Y)E
+    vpaddw      ymm5, ymm5, ymm3             ; ymm5=(CbO * FIX(1.77200))=(B-Y)O
+    vpaddw      ymm0, ymm0, ymm6             ; ymm0=(CrE * FIX(1.40200))=(R-Y)E
+    vpaddw      ymm1, ymm1, ymm7             ; ymm1=(CrO * FIX(1.40200))=(R-Y)O
+
+    vmovdqa     YMMWORD [wk(0)], ymm4        ; wk(0)=(B-Y)E
+    vmovdqa     YMMWORD [wk(1)], ymm5        ; wk(1)=(B-Y)O
+
+    vpunpckhwd  ymm4, ymm2, ymm6
+    vpunpcklwd  ymm2, ymm2, ymm6
+    vpmaddwd    ymm2, ymm2, [rel PW_MF0344_F0285]
+    vpmaddwd    ymm4, ymm4, [rel PW_MF0344_F0285]
+    vpunpckhwd  ymm5, ymm3, ymm7
+    vpunpcklwd  ymm3, ymm3, ymm7
+    vpmaddwd    ymm3, ymm3, [rel PW_MF0344_F0285]
+    vpmaddwd    ymm5, ymm5, [rel PW_MF0344_F0285]
+
+    vpaddd      ymm2, ymm2, [rel PD_ONEHALF]
+    vpaddd      ymm4, ymm4, [rel PD_ONEHALF]
+    vpsrad      ymm2, ymm2, SCALEBITS
+    vpsrad      ymm4, ymm4, SCALEBITS
+    vpaddd      ymm3, ymm3, [rel PD_ONEHALF]
+    vpaddd      ymm5, ymm5, [rel PD_ONEHALF]
+    vpsrad      ymm3, ymm3, SCALEBITS
+    vpsrad      ymm5, ymm5, SCALEBITS
+
+    vpackssdw   ymm2, ymm2, ymm4             ; ymm2=CbE*-FIX(0.344)+CrE*FIX(0.285)
+    vpackssdw   ymm3, ymm3, ymm5             ; ymm3=CbO*-FIX(0.344)+CrO*FIX(0.285)
+    vpsubw      ymm2, ymm2, ymm6             ; ymm2=CbE*-FIX(0.344)+CrE*-FIX(0.714)=(G-Y)E
+    vpsubw      ymm3, ymm3, ymm7             ; ymm3=CbO*-FIX(0.344)+CrO*-FIX(0.714)=(G-Y)O
+
+    vmovdqu     ymm5, YMMWORD [rsi]          ; ymm5=Y(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpcmpeqw    ymm4, ymm4, ymm4
+    vpsrlw      ymm4, ymm4, BYTE_BIT         ; ymm4={0xFF 0x00 0xFF 0x00 ..}
+    vpand       ymm4, ymm4, ymm5             ; ymm4=Y(02468ACEGIKMOQSU)=YE
+    vpsrlw      ymm5, ymm5, BYTE_BIT         ; ymm5=Y(13579BDFHJLNPRTV)=YO
+
+    vpaddw      ymm0, ymm0, ymm4             ; ymm0=((R-Y)E+YE)=RE=R(02468ACEGIKMOQSU)
+    vpaddw      ymm1, ymm1, ymm5             ; ymm1=((R-Y)O+YO)=RO=R(13579BDFHJLNPRTV)
+    vpackuswb   ymm0, ymm0, ymm0             ; ymm0=R(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm1, ymm1, ymm1             ; ymm1=R(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm2, ymm2, ymm4             ; ymm2=((G-Y)E+YE)=GE=G(02468ACEGIKMOQSU)
+    vpaddw      ymm3, ymm3, ymm5             ; ymm3=((G-Y)O+YO)=GO=G(13579BDFHJLNPRTV)
+    vpackuswb   ymm2, ymm2, ymm2             ; ymm2=G(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm3, ymm3, ymm3             ; ymm3=G(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm4, ymm4, YMMWORD [wk(0)]  ; ymm4=(YE+(B-Y)E)=BE=B(02468ACEGIKMOQSU)
+    vpaddw      ymm5, ymm5, YMMWORD [wk(1)]  ; ymm5=(YO+(B-Y)O)=BO=B(13579BDFHJLNPRTV)
+    vpackuswb   ymm4, ymm4, ymm4             ; ymm4=B(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm5, ymm5, ymm5             ; ymm5=B(13579BDF********HJLNPRTV********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+    ; ymmH=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmB        ; ymmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F
+                                        ;       2G 0H 2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V)
+    vpunpcklbw  ymmD, ymmD, ymmF        ; ymmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F
+                                        ;       1H 2H 1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V)
+
+    vpsrldq     ymmH, ymmA, 2           ; ymmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E 0G 1G
+                                        ;       0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U -- --)
+    vpunpckhwd  ymmG, ymmA, ymmE        ; ymmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F
+                                        ;       0O 1O 2O 0P 0Q 1Q 2Q 0R 0S 1S 2S 0T 0U 1U 2U 0V)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07
+                                        ;       0G 1G 2G 0H 0I 1I 2I 0J 0K 1K 2K 0L 0M 1M 2M 0N)
+
+    vpsrldq     ymmE, ymmE, 2           ; ymmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F 2G 0H
+                                        ;       2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V -- --)
+
+    vpsrldq     ymmB, ymmD, 2           ; ymmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F 1H 2H
+                                        ;       1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V -- --)
+    vpunpckhwd  ymmC, ymmD, ymmH        ; ymmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F 0G 1G
+                                        ;       1P 2P 0Q 1Q 1R 2R 0S 1S 1T 2T 0U 1U 1V 2V -- --)
+    vpunpcklwd  ymmD, ymmD, ymmH        ; ymmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18
+                                        ;       1H 2H 0I 1I 1J 2J 0K 1K 1L 2L 0M 1M 1N 2N 0O 1O)
+
+    vpunpckhwd  ymmF, ymmE, ymmB        ; ymmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F 2G 0H 1H 2H
+                                        ;       2Q 0R 1R 2R 2S 0T 1T 2T 2U 0V 1V 2V -- -- -- --)
+    vpunpcklwd  ymmE, ymmE, ymmB        ; ymmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29
+                                        ;       2I 0J 1J 2J 2K 0L 1L 2L 2M 0N 1N 2N 2O 0P 1P 2P)
+
+    vpshufd     ymmH, ymmA, 0x4E        ; ymmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03
+                                        ;       0K 1K 2K 0L 0M 1M 2M 0N 0G 1G 2G 0H 0I 1I 2I 0J)
+    vpunpckldq  ymmA, ymmA, ymmD        ; ymmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 0I 1I 2I 0J 1J 2J 0K 1K)
+    vpunpckhdq  ymmD, ymmD, ymmE        ; ymmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 1N 2N 0O 1O 2O 0P 1P 2P)
+    vpunpckldq  ymmE, ymmE, ymmH        ; ymmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07
+                                        ;       2I 0J 1J 2J 0K 1K 2K 0L 2K 0L 1L 2L 0M 1M 2M 0N)
+
+    vpshufd     ymmH, ymmG, 0x4E        ; ymmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B
+                                        ;       0S 1S 2S 0T 0U 1U 2U 0V 0O 1O 2O 0P 0Q 1Q 2Q 0R)
+    vpunpckldq  ymmG, ymmG, ymmC        ; ymmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C
+                                        ;       0O 1O 2O 0P 1P 2P 0Q 1Q 0Q 1Q 2Q 0R 1R 2R 0S 1S)
+    vpunpckhdq  ymmC, ymmC, ymmF        ; ymmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F 0G 1G 2G 0H 1H 2H
+                                        ;       1T 2T 0U 1U 2U 0V 1V 2V 1V 2V -- -- -- -- -- --)
+    vpunpckldq  ymmF, ymmF, ymmH        ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 2S 0T 1T 2T 0U 1U 2U 0V)
+
+    vpunpcklqdq ymmH, ymmA, ymmE        ; ymmH=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vpunpcklqdq ymmG, ymmD, ymmG        ; ymmG=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+    vpunpcklqdq ymmC, ymmF, ymmC        ; ymmC=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vperm2i128  ymmA, ymmH, ymmG, 0x20  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vperm2i128  ymmD, ymmC, ymmH, 0x30  ; ymmD=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vperm2i128  ymmF, ymmG, ymmC, 0x31  ; ymmF=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        rdi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmF
+.out0:
+    add         rdi, byte RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_YMMWORD
+    jz          near .nextrow
+
+    add         rsi, byte SIZEOF_YMMWORD  ; inptr0
+    add         rbx, byte SIZEOF_YMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st64:
+    lea         rcx, [rcx+rcx*2]            ; imul ecx, RGB_PIXELSIZE
+    cmp         rcx, byte 2*SIZEOF_YMMWORD
+    jb          short .column_st32
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    add         rdi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmF
+    sub         rcx, byte 2*SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st32:
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jb          short .column_st31
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    add         rdi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         rcx, byte SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st31:
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    vmovdqu     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    sub         rcx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    vmovq       XMM_MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_MMWORD
+    sub         rcx, byte SIZEOF_MMWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    vmovd       XMM_DWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_DWORD
+    sub         rcx, byte SIZEOF_DWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of rax to the output when it has enough
+    ; space.
+    vmovd       eax, xmmA
+    cmp         rcx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [rdi], ax
+    add         rdi, byte SIZEOF_WORD
+    sub         rcx, byte SIZEOF_WORD
+    shr         rax, 16
+.column_st1:
+    ; Store the lower 1 byte of rax to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .nextrow
+    mov         BYTE [rdi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    vpcmpeqb    ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpcmpeqb    ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%else
+    vpxor       ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpxor       ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%endif
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(30 32 34 36 38 3A 3C 3E ** 3G 3I 3K 3M 3O 3Q 3S 3U **)
+    ; ymmH=(31 33 35 37 39 3B 3D 3F ** 3H 3J 3L 3N 3P 3R 3T 3V **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmG        ; ymmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E
+                                        ;       2G 3G 2I 3I 2K 3K 2M 3M 2O 3O 2Q 3Q 2S 3S 2U 3U)
+    vpunpcklbw  ymmB, ymmB, ymmD        ; ymmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F
+                                        ;       0H 1H 0J 1J 0L 1L 0N 1N 0P 1P 0R 1R 0T 1T 0V 1V)
+    vpunpcklbw  ymmF, ymmF, ymmH        ; ymmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F
+                                        ;       2H 3H 2J 3J 2L 3L 2N 3N 2P 3P 2R 3R 2T 3T 2V 3V)
+
+    vpunpckhwd  ymmC, ymmA, ymmE        ; ymmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E
+                                        ;       0O 1O 2O 3O 0Q 1Q 2Q 3Q 0S 1S 2S 3S 0U 1U 2U 3U)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36
+                                        ;       0G 1G 2G 3G 0I 1I 2I 3I 0K 1K 2K 3K 0M 1M 2M 3M)
+    vpunpckhwd  ymmG, ymmB, ymmF        ; ymmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F
+                                        ;       0P 1P 2P 3P 0R 1R 2R 3R 0T 1T 2T 3T 0V 1V 2V 3V)
+    vpunpcklwd  ymmB, ymmB, ymmF        ; ymmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37
+                                        ;       0H 1H 2H 3H 0J 1J 2J 3J 0L 1L 2L 3L 0N 1N 2N 3N)
+
+    vpunpckhdq  ymmE, ymmA, ymmB        ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vpunpckldq  ymmB, ymmA, ymmB        ; ymmB=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vpunpckhdq  ymmF, ymmC, ymmG        ; ymmF=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+    vpunpckldq  ymmG, ymmC, ymmG        ; ymmG=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+
+    vperm2i128  ymmA, ymmB, ymmE, 0x20  ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    vperm2i128  ymmD, ymmG, ymmF, 0x20  ; ymmD=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    vperm2i128  ymmC, ymmB, ymmE, 0x31  ; ymmC=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vperm2i128  ymmH, ymmG, ymmF, 0x31  ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        rdi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmC
+    vmovntdq    YMMWORD [rdi+3*SIZEOF_YMMWORD], ymmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmC
+    vmovdqu     YMMWORD [rdi+3*SIZEOF_YMMWORD], ymmH
+.out0:
+    add         rdi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_YMMWORD
+    jz          near .nextrow
+
+    add         rsi, byte SIZEOF_YMMWORD  ; inptr0
+    add         rbx, byte SIZEOF_YMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st64:
+    cmp         rcx, byte SIZEOF_YMMWORD/2
+    jb          short .column_st32
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    add         rdi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmC
+    vmovdqa     ymmD, ymmH
+    sub         rcx, byte SIZEOF_YMMWORD/2
+.column_st32:
+    cmp         rcx, byte SIZEOF_YMMWORD/4
+    jb          short .column_st16
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    add         rdi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         rcx, byte SIZEOF_YMMWORD/4
+.column_st16:
+    cmp         rcx, byte SIZEOF_YMMWORD/8
+    jb          short .column_st15
+    vmovdqu     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    sub         rcx, byte SIZEOF_YMMWORD/8
+.column_st15:
+    ; Store two pixels (8 bytes) of ymmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_YMMWORD/16
+    jb          short .column_st7
+    vmovq       MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_YMMWORD/16*4
+    sub         rcx, byte SIZEOF_YMMWORD/16
+    vpsrldq     xmmA, SIZEOF_YMMWORD/16*4
+.column_st7:
+    ; Store one pixel (4 bytes) of ymmA to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .nextrow
+    vmovd       XMM_DWORD [rdi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+.nextrow:
+    pop         rcx
+    pop         rsi
+    pop         rbx
+    pop         rdx
+    pop         rdi
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW
+    add         rbx, byte SIZEOF_JSAMPROW
+    add         rdx, byte SIZEOF_JSAMPROW
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_buf
+    dec         rax                        ; num_rows
+    jg          near .rowloop
+
+    sfence                              ; flush the write buffer
+
+.return:
+    pop         rbx
+    vzeroupper
+    uncollect_args 5
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jdcolext-sse2.asm b/simd/x86_64/jdcolext-sse2.asm
new file mode 100644
index 0000000..f49709f
--- /dev/null
+++ b/simd/x86_64/jdcolext-sse2.asm
@@ -0,0 +1,440 @@
+;
+; jdcolext.asm - colorspace conversion (64-bit SSE2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2012, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Convert some rows of samples to the output colorspace.
+;
+; GLOBAL(void)
+; jsimd_ycc_rgb_convert_sse2 (JDIMENSION out_width,
+;                             JSAMPIMAGE input_buf, JDIMENSION input_row,
+;                             JSAMPARRAY output_buf, int num_rows)
+;
+
+; r10d = JDIMENSION out_width
+; r11 = JSAMPIMAGE input_buf
+; r12d = JDIMENSION input_row
+; r13 = JSAMPARRAY output_buf
+; r14d = int num_rows
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  2
+
+    align       32
+    global      EXTN(jsimd_ycc_rgb_convert_sse2)
+
+EXTN(jsimd_ycc_rgb_convert_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 5
+    push        rbx
+
+    mov         ecx, r10d               ; num_cols
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rdi, r11
+    mov         ecx, r12d
+    mov         rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
+    lea         rsi, [rsi+rcx*SIZEOF_JSAMPROW]
+    lea         rbx, [rbx+rcx*SIZEOF_JSAMPROW]
+    lea         rdx, [rdx+rcx*SIZEOF_JSAMPROW]
+
+    pop         rcx
+
+    mov         rdi, r13
+    mov         eax, r14d
+    test        rax, rax
+    jle         near .return
+.rowloop:
+    push        rax
+    push        rdi
+    push        rdx
+    push        rbx
+    push        rsi
+    push        rcx                     ; col
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr0
+    mov         rbx, JSAMPROW [rbx]     ; inptr1
+    mov         rdx, JSAMPROW [rdx]     ; inptr2
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+.columnloop:
+
+    movdqa      xmm5, XMMWORD [rbx]     ; xmm5=Cb(0123456789ABCDEF)
+    movdqa      xmm1, XMMWORD [rdx]     ; xmm1=Cr(0123456789ABCDEF)
+
+    pcmpeqw     xmm4, xmm4
+    pcmpeqw     xmm7, xmm7
+    psrlw       xmm4, BYTE_BIT
+    psllw       xmm7, 7                 ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+    movdqa      xmm0, xmm4              ; xmm0=xmm4={0xFF 0x00 0xFF 0x00 ..}
+
+    pand        xmm4, xmm5              ; xmm4=Cb(02468ACE)=CbE
+    psrlw       xmm5, BYTE_BIT          ; xmm5=Cb(13579BDF)=CbO
+    pand        xmm0, xmm1              ; xmm0=Cr(02468ACE)=CrE
+    psrlw       xmm1, BYTE_BIT          ; xmm1=Cr(13579BDF)=CrO
+
+    paddw       xmm4, xmm7
+    paddw       xmm5, xmm7
+    paddw       xmm0, xmm7
+    paddw       xmm1, xmm7
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    movdqa      xmm2, xmm4              ; xmm2=CbE
+    movdqa      xmm3, xmm5              ; xmm3=CbO
+    paddw       xmm4, xmm4              ; xmm4=2*CbE
+    paddw       xmm5, xmm5              ; xmm5=2*CbO
+    movdqa      xmm6, xmm0              ; xmm6=CrE
+    movdqa      xmm7, xmm1              ; xmm7=CrO
+    paddw       xmm0, xmm0              ; xmm0=2*CrE
+    paddw       xmm1, xmm1              ; xmm1=2*CrO
+
+    pmulhw      xmm4, [rel PW_MF0228]   ; xmm4=(2*CbE * -FIX(0.22800))
+    pmulhw      xmm5, [rel PW_MF0228]   ; xmm5=(2*CbO * -FIX(0.22800))
+    pmulhw      xmm0, [rel PW_F0402]    ; xmm0=(2*CrE * FIX(0.40200))
+    pmulhw      xmm1, [rel PW_F0402]    ; xmm1=(2*CrO * FIX(0.40200))
+
+    paddw       xmm4, [rel PW_ONE]
+    paddw       xmm5, [rel PW_ONE]
+    psraw       xmm4, 1                 ; xmm4=(CbE * -FIX(0.22800))
+    psraw       xmm5, 1                 ; xmm5=(CbO * -FIX(0.22800))
+    paddw       xmm0, [rel PW_ONE]
+    paddw       xmm1, [rel PW_ONE]
+    psraw       xmm0, 1                 ; xmm0=(CrE * FIX(0.40200))
+    psraw       xmm1, 1                 ; xmm1=(CrO * FIX(0.40200))
+
+    paddw       xmm4, xmm2
+    paddw       xmm5, xmm3
+    paddw       xmm4, xmm2              ; xmm4=(CbE * FIX(1.77200))=(B-Y)E
+    paddw       xmm5, xmm3              ; xmm5=(CbO * FIX(1.77200))=(B-Y)O
+    paddw       xmm0, xmm6              ; xmm0=(CrE * FIX(1.40200))=(R-Y)E
+    paddw       xmm1, xmm7              ; xmm1=(CrO * FIX(1.40200))=(R-Y)O
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=(B-Y)E
+    movdqa      XMMWORD [wk(1)], xmm5   ; wk(1)=(B-Y)O
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm5, xmm3
+    punpcklwd   xmm2, xmm6
+    punpckhwd   xmm4, xmm6
+    pmaddwd     xmm2, [rel PW_MF0344_F0285]
+    pmaddwd     xmm4, [rel PW_MF0344_F0285]
+    punpcklwd   xmm3, xmm7
+    punpckhwd   xmm5, xmm7
+    pmaddwd     xmm3, [rel PW_MF0344_F0285]
+    pmaddwd     xmm5, [rel PW_MF0344_F0285]
+
+    paddd       xmm2, [rel PD_ONEHALF]
+    paddd       xmm4, [rel PD_ONEHALF]
+    psrad       xmm2, SCALEBITS
+    psrad       xmm4, SCALEBITS
+    paddd       xmm3, [rel PD_ONEHALF]
+    paddd       xmm5, [rel PD_ONEHALF]
+    psrad       xmm3, SCALEBITS
+    psrad       xmm5, SCALEBITS
+
+    packssdw    xmm2, xmm4              ; xmm2=CbE*-FIX(0.344)+CrE*FIX(0.285)
+    packssdw    xmm3, xmm5              ; xmm3=CbO*-FIX(0.344)+CrO*FIX(0.285)
+    psubw       xmm2, xmm6              ; xmm2=CbE*-FIX(0.344)+CrE*-FIX(0.714)=(G-Y)E
+    psubw       xmm3, xmm7              ; xmm3=CbO*-FIX(0.344)+CrO*-FIX(0.714)=(G-Y)O
+
+    movdqa      xmm5, XMMWORD [rsi]     ; xmm5=Y(0123456789ABCDEF)
+
+    pcmpeqw     xmm4, xmm4
+    psrlw       xmm4, BYTE_BIT          ; xmm4={0xFF 0x00 0xFF 0x00 ..}
+    pand        xmm4, xmm5              ; xmm4=Y(02468ACE)=YE
+    psrlw       xmm5, BYTE_BIT          ; xmm5=Y(13579BDF)=YO
+
+    paddw       xmm0, xmm4              ; xmm0=((R-Y)E+YE)=RE=R(02468ACE)
+    paddw       xmm1, xmm5              ; xmm1=((R-Y)O+YO)=RO=R(13579BDF)
+    packuswb    xmm0, xmm0              ; xmm0=R(02468ACE********)
+    packuswb    xmm1, xmm1              ; xmm1=R(13579BDF********)
+
+    paddw       xmm2, xmm4              ; xmm2=((G-Y)E+YE)=GE=G(02468ACE)
+    paddw       xmm3, xmm5              ; xmm3=((G-Y)O+YO)=GO=G(13579BDF)
+    packuswb    xmm2, xmm2              ; xmm2=G(02468ACE********)
+    packuswb    xmm3, xmm3              ; xmm3=G(13579BDF********)
+
+    paddw       xmm4, XMMWORD [wk(0)]   ; xmm4=(YE+(B-Y)E)=BE=B(02468ACE)
+    paddw       xmm5, XMMWORD [wk(1)]   ; xmm5=(YO+(B-Y)O)=BO=B(13579BDF)
+    packuswb    xmm4, xmm4              ; xmm4=B(02468ACE********)
+    packuswb    xmm5, xmm5              ; xmm5=B(13579BDF********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
+
+    punpcklbw   xmmA, xmmC        ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmB        ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
+    punpcklbw   xmmD, xmmF        ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
+
+    movdqa      xmmG, xmmA
+    movdqa      xmmH, xmmA
+    punpcklwd   xmmA, xmmE        ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
+    punpckhwd   xmmG, xmmE        ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
+
+    psrldq      xmmH, 2           ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
+    psrldq      xmmE, 2           ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
+
+    movdqa      xmmC, xmmD
+    movdqa      xmmB, xmmD
+    punpcklwd   xmmD, xmmH        ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
+    punpckhwd   xmmC, xmmH        ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
+
+    psrldq      xmmB, 2           ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
+
+    movdqa      xmmF, xmmE
+    punpcklwd   xmmE, xmmB        ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
+    punpckhwd   xmmF, xmmB        ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
+
+    pshufd      xmmH, xmmA, 0x4E  ; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
+    movdqa      xmmB, xmmE
+    punpckldq   xmmA, xmmD        ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
+    punpckldq   xmmE, xmmH        ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
+    punpckhdq   xmmD, xmmB        ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
+
+    pshufd      xmmH, xmmG, 0x4E  ; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
+    movdqa      xmmB, xmmF
+    punpckldq   xmmG, xmmC        ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
+    punpckldq   xmmF, xmmH        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
+    punpckhdq   xmmC, xmmB        ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
+
+    punpcklqdq  xmmA, xmmE        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    punpcklqdq  xmmD, xmmG        ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    punpcklqdq  xmmF, xmmC        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        rdi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
+.out0:
+    add         rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_XMMWORD
+    jz          near .nextrow
+
+    add         rsi, byte SIZEOF_XMMWORD  ; inptr0
+    add         rbx, byte SIZEOF_XMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st32:
+    lea         rcx, [rcx+rcx*2]            ; imul ecx, RGB_PIXELSIZE
+    cmp         rcx, byte 2*SIZEOF_XMMWORD
+    jb          short .column_st16
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    add         rdi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmF
+    sub         rcx, byte 2*SIZEOF_XMMWORD
+    jmp         short .column_st15
+.column_st16:
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         rcx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    movq        XMM_MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_MMWORD
+    sub         rcx, byte SIZEOF_MMWORD
+    psrldq      xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    movd        XMM_DWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_DWORD
+    sub         rcx, byte SIZEOF_DWORD
+    psrldq      xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of rax to the output when it has enough
+    ; space.
+    movd        eax, xmmA
+    cmp         rcx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [rdi], ax
+    add         rdi, byte SIZEOF_WORD
+    sub         rcx, byte SIZEOF_WORD
+    shr         rax, 16
+.column_st1:
+    ; Store the lower 1 byte of rax to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .nextrow
+    mov         BYTE [rdi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    pcmpeqb     xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pcmpeqb     xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%else
+    pxor        xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pxor        xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%endif
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
+
+    punpcklbw   xmmA, xmmC  ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
+    punpcklbw   xmmB, xmmD  ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
+    punpcklbw   xmmF, xmmH  ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
+
+    movdqa      xmmC, xmmA
+    punpcklwd   xmmA, xmmE  ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
+    punpckhwd   xmmC, xmmE  ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
+    movdqa      xmmG, xmmB
+    punpcklwd   xmmB, xmmF  ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
+    punpckhwd   xmmG, xmmF  ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpckldq   xmmA, xmmB  ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    punpckhdq   xmmD, xmmB  ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    movdqa      xmmH, xmmC
+    punpckldq   xmmC, xmmG  ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    punpckhdq   xmmH, xmmG  ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        rdi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
+    movntdq     XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
+    movdqu      XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
+.out0:
+    add         rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_XMMWORD
+    jz          near .nextrow
+
+    add         rsi, byte SIZEOF_XMMWORD  ; inptr0
+    add         rbx, byte SIZEOF_XMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st32:
+    cmp         rcx, byte SIZEOF_XMMWORD/2
+    jb          short .column_st16
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    add         rdi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmC
+    movdqa      xmmD, xmmH
+    sub         rcx, byte SIZEOF_XMMWORD/2
+.column_st16:
+    cmp         rcx, byte SIZEOF_XMMWORD/4
+    jb          short .column_st15
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         rcx, byte SIZEOF_XMMWORD/4
+.column_st15:
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_XMMWORD/8
+    jb          short .column_st7
+    movq        MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_XMMWORD/8*4
+    sub         rcx, byte SIZEOF_XMMWORD/8
+    psrldq      xmmA, SIZEOF_XMMWORD/8*4
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .nextrow
+    movd        XMM_DWORD [rdi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+.nextrow:
+    pop         rcx
+    pop         rsi
+    pop         rbx
+    pop         rdx
+    pop         rdi
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW
+    add         rbx, byte SIZEOF_JSAMPROW
+    add         rdx, byte SIZEOF_JSAMPROW
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_buf
+    dec         rax                        ; num_rows
+    jg          near .rowloop
+
+    sfence                              ; flush the write buffer
+
+.return:
+    pop         rbx
+    uncollect_args 5
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jdcolor-avx2.asm b/simd/x86_64/jdcolor-avx2.asm
new file mode 100644
index 0000000..dd878a9
--- /dev/null
+++ b/simd/x86_64/jdcolor-avx2.asm
@@ -0,0 +1,120 @@
+;
+; jdcolor.asm - colorspace conversion (64-bit AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_ycc_rgb_convert_avx2)
+
+EXTN(jconst_ycc_rgb_convert_avx2):
+
+PW_F0402        times 16 dw  F_0_402
+PW_MF0228       times 16 dw -F_0_228
+PW_MF0344_F0285 times 8  dw -F_0_344, F_0_285
+PW_ONE          times 16 dw  1
+PD_ONEHALF      times 8  dd  1 << (SCALEBITS-1)
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extrgb_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extrgbx_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extbgr_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extbgrx_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extxbgr_convert_avx2
+%include "jdcolext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_ycc_rgb_convert_avx2 jsimd_ycc_extxrgb_convert_avx2
+%include "jdcolext-avx2.asm"
diff --git a/simd/jdcolor-sse2-64.asm b/simd/x86_64/jdcolor-sse2.asm
similarity index 75%
rename from simd/jdcolor-sse2-64.asm
rename to simd/x86_64/jdcolor-sse2.asm
index d2bf210..55e10a4 100644
--- a/simd/jdcolor-sse2-64.asm
+++ b/simd/x86_64/jdcolor-sse2.asm
@@ -2,7 +2,7 @@
 ; jdcolor.asm - colorspace conversion (64-bit SSE2)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -20,21 +20,21 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_344 equ      22554                  ; FIX(0.34414)
-F_0_714 equ      46802                  ; FIX(0.71414)
-F_1_402 equ      91881                  ; FIX(1.40200)
-F_1_772 equ     116130                  ; FIX(1.77200)
-F_0_402 equ     (F_1_402 - 65536)       ; FIX(1.40200) - FIX(1)
-F_0_285 equ     ( 65536 - F_0_714)      ; FIX(1) - FIX(0.71414)
-F_0_228 equ     (131072 - F_1_772)      ; FIX(2) - FIX(1.77200)
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_ycc_rgb_convert_sse2)
+    alignz      32
+    global      EXTN(jconst_ycc_rgb_convert_sse2)
 
 EXTN(jconst_ycc_rgb_convert_sse2):
 
@@ -44,13 +44,13 @@ PW_MF0344_F0285 times 4 dw -F_0_344, F_0_285
 PW_ONE          times 8 dw  1
 PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
+    SECTION     SEG_TEXT
+    BITS        64
 
-%include "jdcolext-sse2-64.asm"
+%include "jdcolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -61,7 +61,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_BLUE EXT_RGB_BLUE
 %define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extrgb_convert_sse2
-%include "jdcolext-sse2-64.asm"
+%include "jdcolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -72,7 +72,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_BLUE EXT_RGBX_BLUE
 %define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extrgbx_convert_sse2
-%include "jdcolext-sse2-64.asm"
+%include "jdcolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -83,7 +83,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_BLUE EXT_BGR_BLUE
 %define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extbgr_convert_sse2
-%include "jdcolext-sse2-64.asm"
+%include "jdcolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -94,7 +94,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_BLUE EXT_BGRX_BLUE
 %define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extbgrx_convert_sse2
-%include "jdcolext-sse2-64.asm"
+%include "jdcolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -105,7 +105,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_BLUE EXT_XBGR_BLUE
 %define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extxbgr_convert_sse2
-%include "jdcolext-sse2-64.asm"
+%include "jdcolext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -116,4 +116,4 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_BLUE EXT_XRGB_BLUE
 %define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_ycc_rgb_convert_sse2 jsimd_ycc_extxrgb_convert_sse2
-%include "jdcolext-sse2-64.asm"
+%include "jdcolext-sse2.asm"
diff --git a/simd/x86_64/jdmerge-avx2.asm b/simd/x86_64/jdmerge-avx2.asm
new file mode 100644
index 0000000..fa3a321
--- /dev/null
+++ b/simd/x86_64/jdmerge-avx2.asm
@@ -0,0 +1,126 @@
+;
+; jdmerge.asm - merged upsampling/color conversion (64-bit AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+
+%define SCALEBITS  16
+
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_merged_upsample_avx2)
+
+EXTN(jconst_merged_upsample_avx2):
+
+PW_F0402        times 16 dw  F_0_402
+PW_MF0228       times 16 dw -F_0_228
+PW_MF0344_F0285 times 8  dw -F_0_344, F_0_285
+PW_ONE          times 16 dw  1
+PD_ONEHALF      times 8  dd  1 << (SCALEBITS-1)
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGB_RED
+%define RGB_GREEN EXT_RGB_GREEN
+%define RGB_BLUE EXT_RGB_BLUE
+%define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extrgb_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extrgb_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_RGBX_RED
+%define RGB_GREEN EXT_RGBX_GREEN
+%define RGB_BLUE EXT_RGBX_BLUE
+%define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extrgbx_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extrgbx_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGR_RED
+%define RGB_GREEN EXT_BGR_GREEN
+%define RGB_BLUE EXT_BGR_BLUE
+%define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extbgr_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extbgr_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_BGRX_RED
+%define RGB_GREEN EXT_BGRX_GREEN
+%define RGB_BLUE EXT_BGRX_BLUE
+%define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extbgrx_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extbgrx_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XBGR_RED
+%define RGB_GREEN EXT_XBGR_GREEN
+%define RGB_BLUE EXT_XBGR_BLUE
+%define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extxbgr_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extxbgr_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
+
+%undef RGB_RED
+%undef RGB_GREEN
+%undef RGB_BLUE
+%undef RGB_PIXELSIZE
+%define RGB_RED EXT_XRGB_RED
+%define RGB_GREEN EXT_XRGB_GREEN
+%define RGB_BLUE EXT_XRGB_BLUE
+%define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
+%define jsimd_h2v1_merged_upsample_avx2 jsimd_h2v1_extxrgb_merged_upsample_avx2
+%define jsimd_h2v2_merged_upsample_avx2 jsimd_h2v2_extxrgb_merged_upsample_avx2
+%include "jdmrgext-avx2.asm"
diff --git a/simd/jdmerge-sse2-64.asm b/simd/x86_64/jdmerge-sse2.asm
similarity index 79%
rename from simd/jdmerge-sse2-64.asm
rename to simd/x86_64/jdmerge-sse2.asm
index 244bd40..a488916 100644
--- a/simd/jdmerge-sse2-64.asm
+++ b/simd/x86_64/jdmerge-sse2.asm
@@ -2,7 +2,7 @@
 ; jdmerge.asm - merged upsampling/color conversion (64-bit SSE2)
 ;
 ; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
-; Copyright (C) 2009, D. R. Commander.
+; Copyright (C) 2009, 2016, D. R. Commander.
 ;
 ; Based on the x86 SIMD extension for IJG JPEG library
 ; Copyright (C) 1999-2006, MIYASAKA Masaru.
@@ -20,21 +20,21 @@
 
 ; --------------------------------------------------------------------------
 
-%define SCALEBITS       16
+%define SCALEBITS  16
 
-F_0_344 equ      22554                  ; FIX(0.34414)
-F_0_714 equ      46802                  ; FIX(0.71414)
-F_1_402 equ      91881                  ; FIX(1.40200)
-F_1_772 equ     116130                  ; FIX(1.77200)
-F_0_402 equ     (F_1_402 - 65536)       ; FIX(1.40200) - FIX(1)
-F_0_285 equ     ( 65536 - F_0_714)      ; FIX(1) - FIX(0.71414)
-F_0_228 equ     (131072 - F_1_772)      ; FIX(2) - FIX(1.77200)
+F_0_344 equ  22554              ; FIX(0.34414)
+F_0_714 equ  46802              ; FIX(0.71414)
+F_1_402 equ  91881              ; FIX(1.40200)
+F_1_772 equ 116130              ; FIX(1.77200)
+F_0_402 equ (F_1_402 - 65536)   ; FIX(1.40200) - FIX(1)
+F_0_285 equ ( 65536 - F_0_714)  ; FIX(1) - FIX(0.71414)
+F_0_228 equ (131072 - F_1_772)  ; FIX(2) - FIX(1.77200)
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_CONST
+    SECTION     SEG_CONST
 
-        alignz  16
-        global  EXTN(jconst_merged_upsample_sse2)
+    alignz      32
+    global      EXTN(jconst_merged_upsample_sse2)
 
 EXTN(jconst_merged_upsample_sse2):
 
@@ -44,13 +44,13 @@ PW_MF0344_F0285 times 4 dw -F_0_344, F_0_285
 PW_ONE          times 8 dw  1
 PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 
-        alignz  16
+    alignz      32
 
 ; --------------------------------------------------------------------------
-        SECTION SEG_TEXT
-        BITS    64
+    SECTION     SEG_TEXT
+    BITS        64
 
-%include "jdmrgext-sse2-64.asm"
+%include "jdmrgext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -62,7 +62,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_PIXELSIZE EXT_RGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extrgb_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extrgb_merged_upsample_sse2
-%include "jdmrgext-sse2-64.asm"
+%include "jdmrgext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -74,7 +74,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_PIXELSIZE EXT_RGBX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extrgbx_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extrgbx_merged_upsample_sse2
-%include "jdmrgext-sse2-64.asm"
+%include "jdmrgext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -86,7 +86,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_PIXELSIZE EXT_BGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extbgr_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extbgr_merged_upsample_sse2
-%include "jdmrgext-sse2-64.asm"
+%include "jdmrgext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -98,7 +98,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_PIXELSIZE EXT_BGRX_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extbgrx_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extbgrx_merged_upsample_sse2
-%include "jdmrgext-sse2-64.asm"
+%include "jdmrgext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -110,7 +110,7 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_PIXELSIZE EXT_XBGR_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extxbgr_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extxbgr_merged_upsample_sse2
-%include "jdmrgext-sse2-64.asm"
+%include "jdmrgext-sse2.asm"
 
 %undef RGB_RED
 %undef RGB_GREEN
@@ -122,4 +122,4 @@ PD_ONEHALF      times 4 dd  1 << (SCALEBITS-1)
 %define RGB_PIXELSIZE EXT_XRGB_PIXELSIZE
 %define jsimd_h2v1_merged_upsample_sse2 jsimd_h2v1_extxrgb_merged_upsample_sse2
 %define jsimd_h2v2_merged_upsample_sse2 jsimd_h2v2_extxrgb_merged_upsample_sse2
-%include "jdmrgext-sse2-64.asm"
+%include "jdmrgext-sse2.asm"
diff --git a/simd/x86_64/jdmrgext-avx2.asm b/simd/x86_64/jdmrgext-avx2.asm
new file mode 100644
index 0000000..546a9e5
--- /dev/null
+++ b/simd/x86_64/jdmrgext-avx2.asm
@@ -0,0 +1,595 @@
+;
+; jdmrgext.asm - merged upsampling/color conversion (64-bit AVX2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2012, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v1_merged_upsample_avx2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+; r10d = JDIMENSION output_width
+; r11 = JSAMPIMAGE input_buf
+; r12d = JDIMENSION in_row_group_ctr
+; r13 = JSAMPARRAY output_buf
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM  3
+
+    align       32
+    global      EXTN(jsimd_h2v1_merged_upsample_avx2)
+
+EXTN(jsimd_h2v1_merged_upsample_avx2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 4
+    push        rbx
+
+    mov         ecx, r10d               ; col
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rdi, r11
+    mov         ecx, r12d
+    mov         rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
+    mov         rdi, r13
+    mov         rsi, JSAMPROW [rsi+rcx*SIZEOF_JSAMPROW]  ; inptr0
+    mov         rbx, JSAMPROW [rbx+rcx*SIZEOF_JSAMPROW]  ; inptr1
+    mov         rdx, JSAMPROW [rdx+rcx*SIZEOF_JSAMPROW]  ; inptr2
+    mov         rdi, JSAMPROW [rdi]                      ; outptr
+
+    pop         rcx                     ; col
+
+.columnloop:
+
+    vmovdqu     ymm6, YMMWORD [rbx]     ; ymm6=Cb(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+    vmovdqu     ymm7, YMMWORD [rdx]     ; ymm7=Cr(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpxor       ymm1, ymm1, ymm1        ; ymm1=(all 0's)
+    vpcmpeqw    ymm3, ymm3, ymm3
+    vpsllw      ymm3, ymm3, 7           ; ymm3={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    vpermq      ymm6, ymm6, 0xd8        ; ymm6=Cb(01234567GHIJKLMN89ABCDEFOPQRSTUV)
+    vpermq      ymm7, ymm7, 0xd8        ; ymm7=Cr(01234567GHIJKLMN89ABCDEFOPQRSTUV)
+    vpunpcklbw  ymm4, ymm6, ymm1        ; ymm4=Cb(0123456789ABCDEF)=CbL
+    vpunpckhbw  ymm6, ymm6, ymm1        ; ymm6=Cb(GHIJKLMNOPQRSTUV)=CbH
+    vpunpcklbw  ymm0, ymm7, ymm1        ; ymm0=Cr(0123456789ABCDEF)=CrL
+    vpunpckhbw  ymm7, ymm7, ymm1        ; ymm7=Cr(GHIJKLMNOPQRSTUV)=CrH
+
+    vpaddw      ymm5, ymm6, ymm3
+    vpaddw      ymm2, ymm4, ymm3
+    vpaddw      ymm1, ymm7, ymm3
+    vpaddw      ymm3, ymm0, ymm3
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    vpaddw      ymm6, ymm5, ymm5             ; ymm6=2*CbH
+    vpaddw      ymm4, ymm2, ymm2             ; ymm4=2*CbL
+    vpaddw      ymm7, ymm1, ymm1             ; ymm7=2*CrH
+    vpaddw      ymm0, ymm3, ymm3             ; ymm0=2*CrL
+
+    vpmulhw     ymm6, ymm6, [rel PW_MF0228]  ; ymm6=(2*CbH * -FIX(0.22800))
+    vpmulhw     ymm4, ymm4, [rel PW_MF0228]  ; ymm4=(2*CbL * -FIX(0.22800))
+    vpmulhw     ymm7, ymm7, [rel PW_F0402]   ; ymm7=(2*CrH * FIX(0.40200))
+    vpmulhw     ymm0, ymm0, [rel PW_F0402]   ; ymm0=(2*CrL * FIX(0.40200))
+
+    vpaddw      ymm6, ymm6, [rel PW_ONE]
+    vpaddw      ymm4, ymm4, [rel PW_ONE]
+    vpsraw      ymm6, ymm6, 1                ; ymm6=(CbH * -FIX(0.22800))
+    vpsraw      ymm4, ymm4, 1                ; ymm4=(CbL * -FIX(0.22800))
+    vpaddw      ymm7, ymm7, [rel PW_ONE]
+    vpaddw      ymm0, ymm0, [rel PW_ONE]
+    vpsraw      ymm7, ymm7, 1                ; ymm7=(CrH * FIX(0.40200))
+    vpsraw      ymm0, ymm0, 1                ; ymm0=(CrL * FIX(0.40200))
+
+    vpaddw      ymm6, ymm6, ymm5
+    vpaddw      ymm4, ymm4, ymm2
+    vpaddw      ymm6, ymm6, ymm5             ; ymm6=(CbH * FIX(1.77200))=(B-Y)H
+    vpaddw      ymm4, ymm4, ymm2             ; ymm4=(CbL * FIX(1.77200))=(B-Y)L
+    vpaddw      ymm7, ymm7, ymm1             ; ymm7=(CrH * FIX(1.40200))=(R-Y)H
+    vpaddw      ymm0, ymm0, ymm3             ; ymm0=(CrL * FIX(1.40200))=(R-Y)L
+
+    vmovdqa     YMMWORD [wk(0)], ymm6        ; wk(0)=(B-Y)H
+    vmovdqa     YMMWORD [wk(1)], ymm7        ; wk(1)=(R-Y)H
+
+    vpunpckhwd  ymm6, ymm5, ymm1
+    vpunpcklwd  ymm5, ymm5, ymm1
+    vpmaddwd    ymm5, ymm5, [rel PW_MF0344_F0285]
+    vpmaddwd    ymm6, ymm6, [rel PW_MF0344_F0285]
+    vpunpckhwd  ymm7, ymm2, ymm3
+    vpunpcklwd  ymm2, ymm2, ymm3
+    vpmaddwd    ymm2, ymm2, [rel PW_MF0344_F0285]
+    vpmaddwd    ymm7, ymm7, [rel PW_MF0344_F0285]
+
+    vpaddd      ymm5, ymm5, [rel PD_ONEHALF]
+    vpaddd      ymm6, ymm6, [rel PD_ONEHALF]
+    vpsrad      ymm5, ymm5, SCALEBITS
+    vpsrad      ymm6, ymm6, SCALEBITS
+    vpaddd      ymm2, ymm2, [rel PD_ONEHALF]
+    vpaddd      ymm7, ymm7, [rel PD_ONEHALF]
+    vpsrad      ymm2, ymm2, SCALEBITS
+    vpsrad      ymm7, ymm7, SCALEBITS
+
+    vpackssdw   ymm5, ymm5, ymm6        ; ymm5=CbH*-FIX(0.344)+CrH*FIX(0.285)
+    vpackssdw   ymm2, ymm2, ymm7        ; ymm2=CbL*-FIX(0.344)+CrL*FIX(0.285)
+    vpsubw      ymm5, ymm5, ymm1        ; ymm5=CbH*-FIX(0.344)+CrH*-FIX(0.714)=(G-Y)H
+    vpsubw      ymm2, ymm2, ymm3        ; ymm2=CbL*-FIX(0.344)+CrL*-FIX(0.714)=(G-Y)L
+
+    vmovdqa     YMMWORD [wk(2)], ymm5   ; wk(2)=(G-Y)H
+
+    mov         al, 2                   ; Yctr
+    jmp         short .Yloop_1st
+
+.Yloop_2nd:
+    vmovdqa     ymm0, YMMWORD [wk(1)]   ; ymm0=(R-Y)H
+    vmovdqa     ymm2, YMMWORD [wk(2)]   ; ymm2=(G-Y)H
+    vmovdqa     ymm4, YMMWORD [wk(0)]   ; ymm4=(B-Y)H
+
+.Yloop_1st:
+    vmovdqu     ymm7, YMMWORD [rsi]     ; ymm7=Y(0123456789ABCDEFGHIJKLMNOPQRSTUV)
+
+    vpcmpeqw    ymm6, ymm6, ymm6
+    vpsrlw      ymm6, ymm6, BYTE_BIT    ; ymm6={0xFF 0x00 0xFF 0x00 ..}
+    vpand       ymm6, ymm6, ymm7        ; ymm6=Y(02468ACEGIKMOQSU)=YE
+    vpsrlw      ymm7, ymm7, BYTE_BIT    ; ymm7=Y(13579BDFHJLNPRTV)=YO
+
+    vmovdqa     ymm1, ymm0              ; ymm1=ymm0=(R-Y)(L/H)
+    vmovdqa     ymm3, ymm2              ; ymm3=ymm2=(G-Y)(L/H)
+    vmovdqa     ymm5, ymm4              ; ymm5=ymm4=(B-Y)(L/H)
+
+    vpaddw      ymm0, ymm0, ymm6        ; ymm0=((R-Y)+YE)=RE=R(02468ACEGIKMOQSU)
+    vpaddw      ymm1, ymm1, ymm7        ; ymm1=((R-Y)+YO)=RO=R(13579BDFHJLNPRTV)
+    vpackuswb   ymm0, ymm0, ymm0        ; ymm0=R(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm1, ymm1, ymm1        ; ymm1=R(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm2, ymm2, ymm6        ; ymm2=((G-Y)+YE)=GE=G(02468ACEGIKMOQSU)
+    vpaddw      ymm3, ymm3, ymm7        ; ymm3=((G-Y)+YO)=GO=G(13579BDFHJLNPRTV)
+    vpackuswb   ymm2, ymm2, ymm2        ; ymm2=G(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm3, ymm3, ymm3        ; ymm3=G(13579BDF********HJLNPRTV********)
+
+    vpaddw      ymm4, ymm4, ymm6        ; ymm4=((B-Y)+YE)=BE=B(02468ACEGIKMOQSU)
+    vpaddw      ymm5, ymm5, ymm7        ; ymm5=((B-Y)+YO)=BO=B(13579BDFHJLNPRTV)
+    vpackuswb   ymm4, ymm4, ymm4        ; ymm4=B(02468ACE********GIKMOQSU********)
+    vpackuswb   ymm5, ymm5, ymm5        ; ymm5=B(13579BDF********HJLNPRTV********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+    ; ymmH=(** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** ** **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmB        ; ymmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F
+                                        ;       2G 0H 2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V)
+    vpunpcklbw  ymmD, ymmD, ymmF        ; ymmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F
+                                        ;       1H 2H 1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V)
+
+    vpsrldq     ymmH, ymmA, 2           ; ymmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E 0G 1G
+                                        ;       0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U -- --)
+    vpunpckhwd  ymmG, ymmA, ymmE        ; ymmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F
+                                        ;       0O 1O 2O 0P 0Q 1Q 2Q 0R 0S 1S 2S 0T 0U 1U 2U 0V)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07
+                                        ;       0G 1G 2G 0H 0I 1I 2I 0J 0K 1K 2K 0L 0M 1M 2M 0N)
+
+    vpsrldq     ymmE, ymmE, 2           ; ymmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F 2G 0H
+                                        ;       2I 0J 2K 0L 2M 0N 2O 0P 2Q 0R 2S 0T 2U 0V -- --)
+
+    vpsrldq     ymmB, ymmD, 2           ; ymmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F 1H 2H
+                                        ;       1J 2J 1L 2L 1N 2N 1P 2P 1R 2R 1T 2T 1V 2V -- --)
+    vpunpckhwd  ymmC, ymmD, ymmH        ; ymmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F 0G 1G
+                                        ;       1P 2P 0Q 1Q 1R 2R 0S 1S 1T 2T 0U 1U 1V 2V -- --)
+    vpunpcklwd  ymmD, ymmD, ymmH        ; ymmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18
+                                        ;       1H 2H 0I 1I 1J 2J 0K 1K 1L 2L 0M 1M 1N 2N 0O 1O)
+
+    vpunpckhwd  ymmF, ymmE, ymmB        ; ymmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F 2G 0H 1H 2H
+                                        ;       2Q 0R 1R 2R 2S 0T 1T 2T 2U 0V 1V 2V -- -- -- --)
+    vpunpcklwd  ymmE, ymmE, ymmB        ; ymmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29
+                                        ;       2I 0J 1J 2J 2K 0L 1L 2L 2M 0N 1N 2N 2O 0P 1P 2P)
+
+    vpshufd     ymmH, ymmA, 0x4E        ; ymmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03
+                                        ;       0K 1K 2K 0L 0M 1M 2M 0N 0G 1G 2G 0H 0I 1I 2I 0J)
+    vpunpckldq  ymmA, ymmA, ymmD        ; ymmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 0I 1I 2I 0J 1J 2J 0K 1K)
+    vpunpckhdq  ymmD, ymmD, ymmE        ; ymmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 1N 2N 0O 1O 2O 0P 1P 2P)
+    vpunpckldq  ymmE, ymmE, ymmH        ; ymmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07
+                                        ;       2I 0J 1J 2J 0K 1K 2K 0L 2K 0L 1L 2L 0M 1M 2M 0N)
+
+    vpshufd     ymmH, ymmG, 0x4E        ; ymmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B
+                                        ;       0S 1S 2S 0T 0U 1U 2U 0V 0O 1O 2O 0P 0Q 1Q 2Q 0R)
+    vpunpckldq  ymmG, ymmG, ymmC        ; ymmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C
+                                        ;       0O 1O 2O 0P 1P 2P 0Q 1Q 0Q 1Q 2Q 0R 1R 2R 0S 1S)
+    vpunpckhdq  ymmC, ymmC, ymmF        ; ymmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F 0G 1G 2G 0H 1H 2H
+                                        ;       1T 2T 0U 1U 2U 0V 1V 2V 1V 2V -- -- -- -- -- --)
+    vpunpckldq  ymmF, ymmF, ymmH        ; ymmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 2S 0T 1T 2T 0U 1U 2U 0V)
+
+    vpunpcklqdq ymmH, ymmA, ymmE        ; ymmH=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vpunpcklqdq ymmG, ymmD, ymmG        ; ymmG=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A
+                                        ;       1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q)
+    vpunpcklqdq ymmC, ymmF, ymmC        ; ymmC=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    vperm2i128  ymmA, ymmH, ymmG, 0x20  ; ymmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05
+                                        ;       15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    vperm2i128  ymmD, ymmC, ymmH, 0x30  ; ymmD=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F
+                                        ;       0G 1G 2G 0H 1H 2H 0I 1I 2I 0J 1J 2J 0K 1K 2K 0L)
+    vperm2i128  ymmF, ymmG, ymmC, 0x31  ; ymmF=(1L 2L 0M 1M 2M 0N 1N 2N 0O 1O 2O 0P 1P 2P 0Q 1Q
+                                        ;       2Q 0R 1R 2R 0S 1S 2S 0T 1T 2T 0U 1U 2U 0V 1V 2V)
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        rdi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmF
+.out0:
+    add         rdi, byte RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_YMMWORD
+    jz          near .endcolumn
+
+    add         rsi, byte SIZEOF_YMMWORD  ; inptr0
+    dec         al                        ; Yctr
+    jnz         near .Yloop_2nd
+
+    add         rbx, byte SIZEOF_YMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st64:
+    lea         rcx, [rcx+rcx*2]            ; imul ecx, RGB_PIXELSIZE
+    cmp         rcx, byte 2*SIZEOF_YMMWORD
+    jb          short .column_st32
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    add         rdi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmF
+    sub         rcx, byte 2*SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st32:
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jb          short .column_st31
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    add         rdi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         rcx, byte SIZEOF_YMMWORD
+    jmp         short .column_st31
+.column_st31:
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    vmovdqu     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    sub         rcx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    vmovq       XMM_MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_MMWORD
+    sub         rcx, byte SIZEOF_MMWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    vmovd       XMM_DWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_DWORD
+    sub         rcx, byte SIZEOF_DWORD
+    vpsrldq     xmmA, xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of rax to the output when it has enough
+    ; space.
+    vmovd       eax, xmmA
+    cmp         rcx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [rdi], ax
+    add         rdi, byte SIZEOF_WORD
+    sub         rcx, byte SIZEOF_WORD
+    shr         rax, 16
+.column_st1:
+    ; Store the lower 1 byte of rax to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .endcolumn
+    mov         BYTE [rdi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    vpcmpeqb    ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpcmpeqb    ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%else
+    vpxor       ymm6, ymm6, ymm6        ; ymm6=XE=X(02468ACE********GIKMOQSU********)
+    vpxor       ymm7, ymm7, ymm7        ; ymm7=XO=X(13579BDF********HJLNPRTV********)
+%endif
+    ; ymmA=(00 02 04 06 08 0A 0C 0E ** 0G 0I 0K 0M 0O 0Q 0S 0U **)
+    ; ymmB=(01 03 05 07 09 0B 0D 0F ** 0H 0J 0L 0N 0P 0R 0T 0V **)
+    ; ymmC=(10 12 14 16 18 1A 1C 1E ** 1G 1I 1K 1M 1O 1Q 1S 1U **)
+    ; ymmD=(11 13 15 17 19 1B 1D 1F ** 1H 1J 1L 1N 1P 1R 1T 1V **)
+    ; ymmE=(20 22 24 26 28 2A 2C 2E ** 2G 2I 2K 2M 2O 2Q 2S 2U **)
+    ; ymmF=(21 23 25 27 29 2B 2D 2F ** 2H 2J 2L 2N 2P 2R 2T 2V **)
+    ; ymmG=(30 32 34 36 38 3A 3C 3E ** 3G 3I 3K 3M 3O 3Q 3S 3U **)
+    ; ymmH=(31 33 35 37 39 3B 3D 3F ** 3H 3J 3L 3N 3P 3R 3T 3V **)
+
+    vpunpcklbw  ymmA, ymmA, ymmC        ; ymmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E
+                                        ;       0G 1G 0I 1I 0K 1K 0M 1M 0O 1O 0Q 1Q 0S 1S 0U 1U)
+    vpunpcklbw  ymmE, ymmE, ymmG        ; ymmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E
+                                        ;       2G 3G 2I 3I 2K 3K 2M 3M 2O 3O 2Q 3Q 2S 3S 2U 3U)
+    vpunpcklbw  ymmB, ymmB, ymmD        ; ymmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F
+                                        ;       0H 1H 0J 1J 0L 1L 0N 1N 0P 1P 0R 1R 0T 1T 0V 1V)
+    vpunpcklbw  ymmF, ymmF, ymmH        ; ymmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F
+                                        ;       2H 3H 2J 3J 2L 3L 2N 3N 2P 3P 2R 3R 2T 3T 2V 3V)
+
+    vpunpckhwd  ymmC, ymmA, ymmE        ; ymmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E
+                                        ;       0O 1O 2O 3O 0Q 1Q 2Q 3Q 0S 1S 2S 3S 0U 1U 2U 3U)
+    vpunpcklwd  ymmA, ymmA, ymmE        ; ymmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36
+                                        ;       0G 1G 2G 3G 0I 1I 2I 3I 0K 1K 2K 3K 0M 1M 2M 3M)
+    vpunpckhwd  ymmG, ymmB, ymmF        ; ymmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F
+                                        ;       0P 1P 2P 3P 0R 1R 2R 3R 0T 1T 2T 3T 0V 1V 2V 3V)
+    vpunpcklwd  ymmB, ymmB, ymmF        ; ymmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37
+                                        ;       0H 1H 2H 3H 0J 1J 2J 3J 0L 1L 2L 3L 0N 1N 2N 3N)
+
+    vpunpckhdq  ymmE, ymmA, ymmB        ; ymmE=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vpunpckldq  ymmB, ymmA, ymmB        ; ymmB=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J)
+    vpunpckhdq  ymmF, ymmC, ymmG        ; ymmF=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+    vpunpckldq  ymmG, ymmC, ymmG        ; ymmG=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R)
+
+    vperm2i128  ymmA, ymmB, ymmE, 0x20  ; ymmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33
+                                        ;       04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    vperm2i128  ymmD, ymmG, ymmF, 0x20  ; ymmD=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B
+                                        ;       0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+    vperm2i128  ymmC, ymmB, ymmE, 0x31  ; ymmC=(0G 1G 2G 3G 0H 1H 2H 3H 0I 1I 2I 3I 0J 1J 2J 3J
+                                        ;       0K 1K 2K 3K 0L 1L 2L 3L 0M 1M 2M 3M 0N 1N 2N 3N)
+    vperm2i128  ymmH, ymmG, ymmF, 0x31  ; ymmH=(0O 1O 2O 3O 0P 1P 2P 3P 0Q 1Q 2Q 3Q 0R 1R 2R 3R
+                                        ;       0S 1S 2S 3S 0T 1T 2T 3T 0U 1U 2U 3U 0V 1V 2V 3V)
+
+    cmp         rcx, byte SIZEOF_YMMWORD
+    jb          short .column_st64
+
+    test        rdi, SIZEOF_YMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    vmovntdq    YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovntdq    YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovntdq    YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmC
+    vmovntdq    YMMWORD [rdi+3*SIZEOF_YMMWORD], ymmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    vmovdqu     YMMWORD [rdi+2*SIZEOF_YMMWORD], ymmC
+    vmovdqu     YMMWORD [rdi+3*SIZEOF_YMMWORD], ymmH
+.out0:
+    add         rdi, RGB_PIXELSIZE*SIZEOF_YMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_YMMWORD
+    jz          near .endcolumn
+
+    add         rsi, byte SIZEOF_YMMWORD  ; inptr0
+    dec         al
+    jnz         near .Yloop_2nd
+
+    add         rbx, byte SIZEOF_YMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_YMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st64:
+    cmp         rcx, byte SIZEOF_YMMWORD/2
+    jb          short .column_st32
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymmD
+    add         rdi, byte 2*SIZEOF_YMMWORD  ; outptr
+    vmovdqa     ymmA, ymmC
+    vmovdqa     ymmD, ymmH
+    sub         rcx, byte SIZEOF_YMMWORD/2
+.column_st32:
+    cmp         rcx, byte SIZEOF_YMMWORD/4
+    jb          short .column_st16
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymmA
+    add         rdi, byte SIZEOF_YMMWORD    ; outptr
+    vmovdqa     ymmA, ymmD
+    sub         rcx, byte SIZEOF_YMMWORD/4
+.column_st16:
+    cmp         rcx, byte SIZEOF_YMMWORD/8
+    jb          short .column_st15
+    vmovdqu     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    vperm2i128  ymmA, ymmA, ymmA, 1
+    sub         rcx, byte SIZEOF_YMMWORD/8
+.column_st15:
+    ; Store two pixels (8 bytes) of ymmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_YMMWORD/16
+    jb          short .column_st7
+    vmovq       MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_YMMWORD/16*4
+    sub         rcx, byte SIZEOF_YMMWORD/16
+    vpsrldq     xmmA, SIZEOF_YMMWORD/16*4
+.column_st7:
+    ; Store one pixel (4 bytes) of ymmA to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .endcolumn
+    vmovd       XMM_DWORD [rdi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+.endcolumn:
+    sfence                              ; flush the write buffer
+
+.return:
+    pop         rbx
+    vzeroupper
+    uncollect_args 4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v2_merged_upsample_avx2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+; r10d = JDIMENSION output_width
+; r11 = JSAMPIMAGE input_buf
+; r12d = JDIMENSION in_row_group_ctr
+; r13 = JSAMPARRAY output_buf
+
+    align       32
+    global      EXTN(jsimd_h2v2_merged_upsample_avx2)
+
+EXTN(jsimd_h2v2_merged_upsample_avx2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+    push        rbx
+
+    mov         eax, r10d
+
+    mov         rdi, r11
+    mov         ecx, r12d
+    mov         rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
+    mov         rdi, r13
+    lea         rsi, [rsi+rcx*SIZEOF_JSAMPROW]
+
+    push        rdx                     ; inptr2
+    push        rbx                     ; inptr1
+    push        rsi                     ; inptr00
+    mov         rbx, rsp
+
+    push        rdi
+    push        rcx
+    push        rax
+
+    %ifdef WIN64
+    mov         r8, rcx
+    mov         r9, rdi
+    mov         rcx, rax
+    mov         rdx, rbx
+    %else
+    mov         rdx, rcx
+    mov         rcx, rdi
+    mov         rdi, rax
+    mov         rsi, rbx
+    %endif
+
+    call        EXTN(jsimd_h2v1_merged_upsample_avx2)
+
+    pop         rax
+    pop         rcx
+    pop         rdi
+    pop         rsi
+    pop         rbx
+    pop         rdx
+
+    add         rdi, byte SIZEOF_JSAMPROW  ; outptr1
+    add         rsi, byte SIZEOF_JSAMPROW  ; inptr01
+
+    push        rdx                     ; inptr2
+    push        rbx                     ; inptr1
+    push        rsi                     ; inptr00
+    mov         rbx, rsp
+
+    push        rdi
+    push        rcx
+    push        rax
+
+    %ifdef WIN64
+    mov         r8, rcx
+    mov         r9, rdi
+    mov         rcx, rax
+    mov         rdx, rbx
+    %else
+    mov         rdx, rcx
+    mov         rcx, rdi
+    mov         rdi, rax
+    mov         rsi, rbx
+    %endif
+
+    call        EXTN(jsimd_h2v1_merged_upsample_avx2)
+
+    pop         rax
+    pop         rcx
+    pop         rdi
+    pop         rsi
+    pop         rbx
+    pop         rdx
+
+    pop         rbx
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jdmrgext-sse2.asm b/simd/x86_64/jdmrgext-sse2.asm
new file mode 100644
index 0000000..4c2bb04
--- /dev/null
+++ b/simd/x86_64/jdmrgext-sse2.asm
@@ -0,0 +1,537 @@
+;
+; jdmrgext.asm - merged upsampling/color conversion (64-bit SSE2)
+;
+; Copyright 2009, 2012 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2012, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jcolsamp.inc"
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v1_merged_upsample_sse2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+; r10d = JDIMENSION output_width
+; r11 = JSAMPIMAGE input_buf
+; r12d = JDIMENSION in_row_group_ctr
+; r13 = JSAMPARRAY output_buf
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  3
+
+    align       32
+    global      EXTN(jsimd_h2v1_merged_upsample_sse2)
+
+EXTN(jsimd_h2v1_merged_upsample_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 4
+    push        rbx
+
+    mov         ecx, r10d               ; col
+    test        rcx, rcx
+    jz          near .return
+
+    push        rcx
+
+    mov         rdi, r11
+    mov         ecx, r12d
+    mov         rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
+    mov         rdi, r13
+    mov         rsi, JSAMPROW [rsi+rcx*SIZEOF_JSAMPROW]  ; inptr0
+    mov         rbx, JSAMPROW [rbx+rcx*SIZEOF_JSAMPROW]  ; inptr1
+    mov         rdx, JSAMPROW [rdx+rcx*SIZEOF_JSAMPROW]  ; inptr2
+    mov         rdi, JSAMPROW [rdi]                      ; outptr
+
+    pop         rcx                     ; col
+
+.columnloop:
+
+    movdqa      xmm6, XMMWORD [rbx]     ; xmm6=Cb(0123456789ABCDEF)
+    movdqa      xmm7, XMMWORD [rdx]     ; xmm7=Cr(0123456789ABCDEF)
+
+    pxor        xmm1, xmm1              ; xmm1=(all 0's)
+    pcmpeqw     xmm3, xmm3
+    psllw       xmm3, 7                 ; xmm3={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    movdqa      xmm4, xmm6
+    punpckhbw   xmm6, xmm1              ; xmm6=Cb(89ABCDEF)=CbH
+    punpcklbw   xmm4, xmm1              ; xmm4=Cb(01234567)=CbL
+    movdqa      xmm0, xmm7
+    punpckhbw   xmm7, xmm1              ; xmm7=Cr(89ABCDEF)=CrH
+    punpcklbw   xmm0, xmm1              ; xmm0=Cr(01234567)=CrL
+
+    paddw       xmm6, xmm3
+    paddw       xmm4, xmm3
+    paddw       xmm7, xmm3
+    paddw       xmm0, xmm3
+
+    ; (Original)
+    ; R = Y                + 1.40200 * Cr
+    ; G = Y - 0.34414 * Cb - 0.71414 * Cr
+    ; B = Y + 1.77200 * Cb
+    ;
+    ; (This implementation)
+    ; R = Y                + 0.40200 * Cr + Cr
+    ; G = Y - 0.34414 * Cb + 0.28586 * Cr - Cr
+    ; B = Y - 0.22800 * Cb + Cb + Cb
+
+    movdqa      xmm5, xmm6              ; xmm5=CbH
+    movdqa      xmm2, xmm4              ; xmm2=CbL
+    paddw       xmm6, xmm6              ; xmm6=2*CbH
+    paddw       xmm4, xmm4              ; xmm4=2*CbL
+    movdqa      xmm1, xmm7              ; xmm1=CrH
+    movdqa      xmm3, xmm0              ; xmm3=CrL
+    paddw       xmm7, xmm7              ; xmm7=2*CrH
+    paddw       xmm0, xmm0              ; xmm0=2*CrL
+
+    pmulhw      xmm6, [rel PW_MF0228]   ; xmm6=(2*CbH * -FIX(0.22800))
+    pmulhw      xmm4, [rel PW_MF0228]   ; xmm4=(2*CbL * -FIX(0.22800))
+    pmulhw      xmm7, [rel PW_F0402]    ; xmm7=(2*CrH * FIX(0.40200))
+    pmulhw      xmm0, [rel PW_F0402]    ; xmm0=(2*CrL * FIX(0.40200))
+
+    paddw       xmm6, [rel PW_ONE]
+    paddw       xmm4, [rel PW_ONE]
+    psraw       xmm6, 1                 ; xmm6=(CbH * -FIX(0.22800))
+    psraw       xmm4, 1                 ; xmm4=(CbL * -FIX(0.22800))
+    paddw       xmm7, [rel PW_ONE]
+    paddw       xmm0, [rel PW_ONE]
+    psraw       xmm7, 1                 ; xmm7=(CrH * FIX(0.40200))
+    psraw       xmm0, 1                 ; xmm0=(CrL * FIX(0.40200))
+
+    paddw       xmm6, xmm5
+    paddw       xmm4, xmm2
+    paddw       xmm6, xmm5              ; xmm6=(CbH * FIX(1.77200))=(B-Y)H
+    paddw       xmm4, xmm2              ; xmm4=(CbL * FIX(1.77200))=(B-Y)L
+    paddw       xmm7, xmm1              ; xmm7=(CrH * FIX(1.40200))=(R-Y)H
+    paddw       xmm0, xmm3              ; xmm0=(CrL * FIX(1.40200))=(R-Y)L
+
+    movdqa      XMMWORD [wk(0)], xmm6   ; wk(0)=(B-Y)H
+    movdqa      XMMWORD [wk(1)], xmm7   ; wk(1)=(R-Y)H
+
+    movdqa      xmm6, xmm5
+    movdqa      xmm7, xmm2
+    punpcklwd   xmm5, xmm1
+    punpckhwd   xmm6, xmm1
+    pmaddwd     xmm5, [rel PW_MF0344_F0285]
+    pmaddwd     xmm6, [rel PW_MF0344_F0285]
+    punpcklwd   xmm2, xmm3
+    punpckhwd   xmm7, xmm3
+    pmaddwd     xmm2, [rel PW_MF0344_F0285]
+    pmaddwd     xmm7, [rel PW_MF0344_F0285]
+
+    paddd       xmm5, [rel PD_ONEHALF]
+    paddd       xmm6, [rel PD_ONEHALF]
+    psrad       xmm5, SCALEBITS
+    psrad       xmm6, SCALEBITS
+    paddd       xmm2, [rel PD_ONEHALF]
+    paddd       xmm7, [rel PD_ONEHALF]
+    psrad       xmm2, SCALEBITS
+    psrad       xmm7, SCALEBITS
+
+    packssdw    xmm5, xmm6              ; xmm5=CbH*-FIX(0.344)+CrH*FIX(0.285)
+    packssdw    xmm2, xmm7              ; xmm2=CbL*-FIX(0.344)+CrL*FIX(0.285)
+    psubw       xmm5, xmm1              ; xmm5=CbH*-FIX(0.344)+CrH*-FIX(0.714)=(G-Y)H
+    psubw       xmm2, xmm3              ; xmm2=CbL*-FIX(0.344)+CrL*-FIX(0.714)=(G-Y)L
+
+    movdqa      XMMWORD [wk(2)], xmm5   ; wk(2)=(G-Y)H
+
+    mov         al, 2                   ; Yctr
+    jmp         short .Yloop_1st
+
+.Yloop_2nd:
+    movdqa      xmm0, XMMWORD [wk(1)]   ; xmm0=(R-Y)H
+    movdqa      xmm2, XMMWORD [wk(2)]   ; xmm2=(G-Y)H
+    movdqa      xmm4, XMMWORD [wk(0)]   ; xmm4=(B-Y)H
+
+.Yloop_1st:
+    movdqa      xmm7, XMMWORD [rsi]     ; xmm7=Y(0123456789ABCDEF)
+
+    pcmpeqw     xmm6, xmm6
+    psrlw       xmm6, BYTE_BIT          ; xmm6={0xFF 0x00 0xFF 0x00 ..}
+    pand        xmm6, xmm7              ; xmm6=Y(02468ACE)=YE
+    psrlw       xmm7, BYTE_BIT          ; xmm7=Y(13579BDF)=YO
+
+    movdqa      xmm1, xmm0              ; xmm1=xmm0=(R-Y)(L/H)
+    movdqa      xmm3, xmm2              ; xmm3=xmm2=(G-Y)(L/H)
+    movdqa      xmm5, xmm4              ; xmm5=xmm4=(B-Y)(L/H)
+
+    paddw       xmm0, xmm6              ; xmm0=((R-Y)+YE)=RE=R(02468ACE)
+    paddw       xmm1, xmm7              ; xmm1=((R-Y)+YO)=RO=R(13579BDF)
+    packuswb    xmm0, xmm0              ; xmm0=R(02468ACE********)
+    packuswb    xmm1, xmm1              ; xmm1=R(13579BDF********)
+
+    paddw       xmm2, xmm6              ; xmm2=((G-Y)+YE)=GE=G(02468ACE)
+    paddw       xmm3, xmm7              ; xmm3=((G-Y)+YO)=GO=G(13579BDF)
+    packuswb    xmm2, xmm2              ; xmm2=G(02468ACE********)
+    packuswb    xmm3, xmm3              ; xmm3=G(13579BDF********)
+
+    paddw       xmm4, xmm6              ; xmm4=((B-Y)+YE)=BE=B(02468ACE)
+    paddw       xmm5, xmm7              ; xmm5=((B-Y)+YO)=BO=B(13579BDF)
+    packuswb    xmm4, xmm4              ; xmm4=B(02468ACE********)
+    packuswb    xmm5, xmm5              ; xmm5=B(13579BDF********)
+
+%if RGB_PIXELSIZE == 3  ; ---------------
+
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(** ** ** ** ** ** ** ** **), xmmH=(** ** ** ** ** ** ** ** **)
+
+    punpcklbw   xmmA, xmmC        ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmB        ; xmmE=(20 01 22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F)
+    punpcklbw   xmmD, xmmF        ; xmmD=(11 21 13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F)
+
+    movdqa      xmmG, xmmA
+    movdqa      xmmH, xmmA
+    punpcklwd   xmmA, xmmE        ; xmmA=(00 10 20 01 02 12 22 03 04 14 24 05 06 16 26 07)
+    punpckhwd   xmmG, xmmE        ; xmmG=(08 18 28 09 0A 1A 2A 0B 0C 1C 2C 0D 0E 1E 2E 0F)
+
+    psrldq      xmmH, 2           ; xmmH=(02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E -- --)
+    psrldq      xmmE, 2           ; xmmE=(22 03 24 05 26 07 28 09 2A 0B 2C 0D 2E 0F -- --)
+
+    movdqa      xmmC, xmmD
+    movdqa      xmmB, xmmD
+    punpcklwd   xmmD, xmmH        ; xmmD=(11 21 02 12 13 23 04 14 15 25 06 16 17 27 08 18)
+    punpckhwd   xmmC, xmmH        ; xmmC=(19 29 0A 1A 1B 2B 0C 1C 1D 2D 0E 1E 1F 2F -- --)
+
+    psrldq      xmmB, 2           ; xmmB=(13 23 15 25 17 27 19 29 1B 2B 1D 2D 1F 2F -- --)
+
+    movdqa      xmmF, xmmE
+    punpcklwd   xmmE, xmmB        ; xmmE=(22 03 13 23 24 05 15 25 26 07 17 27 28 09 19 29)
+    punpckhwd   xmmF, xmmB        ; xmmF=(2A 0B 1B 2B 2C 0D 1D 2D 2E 0F 1F 2F -- -- -- --)
+
+    pshufd      xmmH, xmmA, 0x4E  ; xmmH=(04 14 24 05 06 16 26 07 00 10 20 01 02 12 22 03)
+    movdqa      xmmB, xmmE
+    punpckldq   xmmA, xmmD        ; xmmA=(00 10 20 01 11 21 02 12 02 12 22 03 13 23 04 14)
+    punpckldq   xmmE, xmmH        ; xmmE=(22 03 13 23 04 14 24 05 24 05 15 25 06 16 26 07)
+    punpckhdq   xmmD, xmmB        ; xmmD=(15 25 06 16 26 07 17 27 17 27 08 18 28 09 19 29)
+
+    pshufd      xmmH, xmmG, 0x4E  ; xmmH=(0C 1C 2C 0D 0E 1E 2E 0F 08 18 28 09 0A 1A 2A 0B)
+    movdqa      xmmB, xmmF
+    punpckldq   xmmG, xmmC        ; xmmG=(08 18 28 09 19 29 0A 1A 0A 1A 2A 0B 1B 2B 0C 1C)
+    punpckldq   xmmF, xmmH        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 2C 0D 1D 2D 0E 1E 2E 0F)
+    punpckhdq   xmmC, xmmB        ; xmmC=(1D 2D 0E 1E 2E 0F 1F 2F 1F 2F -- -- -- -- -- --)
+
+    punpcklqdq  xmmA, xmmE        ; xmmA=(00 10 20 01 11 21 02 12 22 03 13 23 04 14 24 05)
+    punpcklqdq  xmmD, xmmG        ; xmmD=(15 25 06 16 26 07 17 27 08 18 28 09 19 29 0A 1A)
+    punpcklqdq  xmmF, xmmC        ; xmmF=(2A 0B 1B 2B 0C 1C 2C 0D 1D 2D 0E 1E 2E 0F 1F 2F)
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        rdi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmF
+.out0:
+    add         rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_XMMWORD
+    jz          near .endcolumn
+
+    add         rsi, byte SIZEOF_XMMWORD  ; inptr0
+    dec         al                        ; Yctr
+    jnz         near .Yloop_2nd
+
+    add         rbx, byte SIZEOF_XMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st32:
+    lea         rcx, [rcx+rcx*2]            ; imul ecx, RGB_PIXELSIZE
+    cmp         rcx, byte 2*SIZEOF_XMMWORD
+    jb          short .column_st16
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    add         rdi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmF
+    sub         rcx, byte 2*SIZEOF_XMMWORD
+    jmp         short .column_st15
+.column_st16:
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st15
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         rcx, byte SIZEOF_XMMWORD
+.column_st15:
+    ; Store the lower 8 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_MMWORD
+    jb          short .column_st7
+    movq        XMM_MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_MMWORD
+    sub         rcx, byte SIZEOF_MMWORD
+    psrldq      xmmA, SIZEOF_MMWORD
+.column_st7:
+    ; Store the lower 4 bytes of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_DWORD
+    jb          short .column_st3
+    movd        XMM_DWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_DWORD
+    sub         rcx, byte SIZEOF_DWORD
+    psrldq      xmmA, SIZEOF_DWORD
+.column_st3:
+    ; Store the lower 2 bytes of rax to the output when it has enough
+    ; space.
+    movd        eax, xmmA
+    cmp         rcx, byte SIZEOF_WORD
+    jb          short .column_st1
+    mov         WORD [rdi], ax
+    add         rdi, byte SIZEOF_WORD
+    sub         rcx, byte SIZEOF_WORD
+    shr         rax, 16
+.column_st1:
+    ; Store the lower 1 byte of rax to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .endcolumn
+    mov         BYTE [rdi], al
+
+%else  ; RGB_PIXELSIZE == 4 ; -----------
+
+%ifdef RGBX_FILLER_0XFF
+    pcmpeqb     xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pcmpeqb     xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%else
+    pxor        xmm6, xmm6              ; xmm6=XE=X(02468ACE********)
+    pxor        xmm7, xmm7              ; xmm7=XO=X(13579BDF********)
+%endif
+    ; xmmA=(00 02 04 06 08 0A 0C 0E **), xmmB=(01 03 05 07 09 0B 0D 0F **)
+    ; xmmC=(10 12 14 16 18 1A 1C 1E **), xmmD=(11 13 15 17 19 1B 1D 1F **)
+    ; xmmE=(20 22 24 26 28 2A 2C 2E **), xmmF=(21 23 25 27 29 2B 2D 2F **)
+    ; xmmG=(30 32 34 36 38 3A 3C 3E **), xmmH=(31 33 35 37 39 3B 3D 3F **)
+
+    punpcklbw   xmmA, xmmC  ; xmmA=(00 10 02 12 04 14 06 16 08 18 0A 1A 0C 1C 0E 1E)
+    punpcklbw   xmmE, xmmG  ; xmmE=(20 30 22 32 24 34 26 36 28 38 2A 3A 2C 3C 2E 3E)
+    punpcklbw   xmmB, xmmD  ; xmmB=(01 11 03 13 05 15 07 17 09 19 0B 1B 0D 1D 0F 1F)
+    punpcklbw   xmmF, xmmH  ; xmmF=(21 31 23 33 25 35 27 37 29 39 2B 3B 2D 3D 2F 3F)
+
+    movdqa      xmmC, xmmA
+    punpcklwd   xmmA, xmmE  ; xmmA=(00 10 20 30 02 12 22 32 04 14 24 34 06 16 26 36)
+    punpckhwd   xmmC, xmmE  ; xmmC=(08 18 28 38 0A 1A 2A 3A 0C 1C 2C 3C 0E 1E 2E 3E)
+    movdqa      xmmG, xmmB
+    punpcklwd   xmmB, xmmF  ; xmmB=(01 11 21 31 03 13 23 33 05 15 25 35 07 17 27 37)
+    punpckhwd   xmmG, xmmF  ; xmmG=(09 19 29 39 0B 1B 2B 3B 0D 1D 2D 3D 0F 1F 2F 3F)
+
+    movdqa      xmmD, xmmA
+    punpckldq   xmmA, xmmB  ; xmmA=(00 10 20 30 01 11 21 31 02 12 22 32 03 13 23 33)
+    punpckhdq   xmmD, xmmB  ; xmmD=(04 14 24 34 05 15 25 35 06 16 26 36 07 17 27 37)
+    movdqa      xmmH, xmmC
+    punpckldq   xmmC, xmmG  ; xmmC=(08 18 28 38 09 19 29 39 0A 1A 2A 3A 0B 1B 2B 3B)
+    punpckhdq   xmmH, xmmG  ; xmmH=(0C 1C 2C 3C 0D 1D 2D 3D 0E 1E 2E 3E 0F 1F 2F 3F)
+
+    cmp         rcx, byte SIZEOF_XMMWORD
+    jb          short .column_st32
+
+    test        rdi, SIZEOF_XMMWORD-1
+    jnz         short .out1
+    ; --(aligned)-------------------
+    movntdq     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movntdq     XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movntdq     XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
+    movntdq     XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
+    jmp         short .out0
+.out1:  ; --(unaligned)-----------------
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    movdqu      XMMWORD [rdi+2*SIZEOF_XMMWORD], xmmC
+    movdqu      XMMWORD [rdi+3*SIZEOF_XMMWORD], xmmH
+.out0:
+    add         rdi, byte RGB_PIXELSIZE*SIZEOF_XMMWORD  ; outptr
+    sub         rcx, byte SIZEOF_XMMWORD
+    jz          near .endcolumn
+
+    add         rsi, byte SIZEOF_XMMWORD  ; inptr0
+    dec         al                        ; Yctr
+    jnz         near .Yloop_2nd
+
+    add         rbx, byte SIZEOF_XMMWORD  ; inptr1
+    add         rdx, byte SIZEOF_XMMWORD  ; inptr2
+    jmp         near .columnloop
+
+.column_st32:
+    cmp         rcx, byte SIZEOF_XMMWORD/2
+    jb          short .column_st16
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    movdqu      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmmD
+    add         rdi, byte 2*SIZEOF_XMMWORD  ; outptr
+    movdqa      xmmA, xmmC
+    movdqa      xmmD, xmmH
+    sub         rcx, byte SIZEOF_XMMWORD/2
+.column_st16:
+    cmp         rcx, byte SIZEOF_XMMWORD/4
+    jb          short .column_st15
+    movdqu      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmmA
+    add         rdi, byte SIZEOF_XMMWORD    ; outptr
+    movdqa      xmmA, xmmD
+    sub         rcx, byte SIZEOF_XMMWORD/4
+.column_st15:
+    ; Store two pixels (8 bytes) of xmmA to the output when it has enough
+    ; space.
+    cmp         rcx, byte SIZEOF_XMMWORD/8
+    jb          short .column_st7
+    movq        XMM_MMWORD [rdi], xmmA
+    add         rdi, byte SIZEOF_XMMWORD/8*4
+    sub         rcx, byte SIZEOF_XMMWORD/8
+    psrldq      xmmA, SIZEOF_XMMWORD/8*4
+.column_st7:
+    ; Store one pixel (4 bytes) of xmmA to the output when it has enough
+    ; space.
+    test        rcx, rcx
+    jz          short .endcolumn
+    movd        XMM_DWORD [rdi], xmmA
+
+%endif  ; RGB_PIXELSIZE ; ---------------
+
+.endcolumn:
+    sfence                              ; flush the write buffer
+
+.return:
+    pop         rbx
+    uncollect_args 4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
+;
+; GLOBAL(void)
+; jsimd_h2v2_merged_upsample_sse2 (JDIMENSION output_width,
+;                                  JSAMPIMAGE input_buf,
+;                                  JDIMENSION in_row_group_ctr,
+;                                  JSAMPARRAY output_buf);
+;
+
+; r10d = JDIMENSION output_width
+; r11 = JSAMPIMAGE input_buf
+; r12d = JDIMENSION in_row_group_ctr
+; r13 = JSAMPARRAY output_buf
+
+    align       32
+    global      EXTN(jsimd_h2v2_merged_upsample_sse2)
+
+EXTN(jsimd_h2v2_merged_upsample_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+    push        rbx
+
+    mov         eax, r10d
+
+    mov         rdi, r11
+    mov         ecx, r12d
+    mov         rsi, JSAMPARRAY [rdi+0*SIZEOF_JSAMPARRAY]
+    mov         rbx, JSAMPARRAY [rdi+1*SIZEOF_JSAMPARRAY]
+    mov         rdx, JSAMPARRAY [rdi+2*SIZEOF_JSAMPARRAY]
+    mov         rdi, r13
+    lea         rsi, [rsi+rcx*SIZEOF_JSAMPROW]
+
+    push        rdx                     ; inptr2
+    push        rbx                     ; inptr1
+    push        rsi                     ; inptr00
+    mov         rbx, rsp
+
+    push        rdi
+    push        rcx
+    push        rax
+
+    %ifdef WIN64
+    mov         r8, rcx
+    mov         r9, rdi
+    mov         rcx, rax
+    mov         rdx, rbx
+    %else
+    mov         rdx, rcx
+    mov         rcx, rdi
+    mov         rdi, rax
+    mov         rsi, rbx
+    %endif
+
+    call        EXTN(jsimd_h2v1_merged_upsample_sse2)
+
+    pop         rax
+    pop         rcx
+    pop         rdi
+    pop         rsi
+    pop         rbx
+    pop         rdx
+
+    add         rdi, byte SIZEOF_JSAMPROW  ; outptr1
+    add         rsi, byte SIZEOF_JSAMPROW  ; inptr01
+
+    push        rdx                     ; inptr2
+    push        rbx                     ; inptr1
+    push        rsi                     ; inptr00
+    mov         rbx, rsp
+
+    push        rdi
+    push        rcx
+    push        rax
+
+    %ifdef WIN64
+    mov         r8, rcx
+    mov         r9, rdi
+    mov         rcx, rax
+    mov         rdx, rbx
+    %else
+    mov         rdx, rcx
+    mov         rcx, rdi
+    mov         rdi, rax
+    mov         rsi, rbx
+    %endif
+
+    call        EXTN(jsimd_h2v1_merged_upsample_sse2)
+
+    pop         rax
+    pop         rcx
+    pop         rdi
+    pop         rsi
+    pop         rbx
+    pop         rdx
+
+    pop         rbx
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jdsample-avx2.asm b/simd/x86_64/jdsample-avx2.asm
new file mode 100644
index 0000000..f3384ca
--- /dev/null
+++ b/simd/x86_64/jdsample-avx2.asm
@@ -0,0 +1,701 @@
+;
+; jdsample.asm - upsampling (64-bit AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2015, Intel Corporation.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fancy_upsample_avx2)
+
+EXTN(jconst_fancy_upsample_avx2):
+
+PW_ONE   times 16 dw 1
+PW_TWO   times 16 dw 2
+PW_THREE times 16 dw 3
+PW_SEVEN times 16 dw 7
+PW_EIGHT times 16 dw 8
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
+;
+; The upsampling algorithm is linear interpolation between pixel centers,
+; also known as a "triangle filter".  This is a good compromise between
+; speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
+; of the way between input pixel centers.
+;
+; GLOBAL(void)
+; jsimd_h2v1_fancy_upsample_avx2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION downsampled_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_fancy_upsample_avx2)
+
+EXTN(jsimd_h2v1_fancy_upsample_avx2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    push_xmm    3
+    collect_args 4
+
+    mov         eax, r11d               ; colctr
+    test        rax, rax
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          near .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+
+    vpxor       ymm0, ymm0, ymm0                 ; ymm0=(all 0's)
+    vpcmpeqb    xmm9, xmm9, xmm9
+    vpsrldq     xmm10, xmm9, (SIZEOF_XMMWORD-1)  ; (ff -- -- -- ... -- --) LSB is ff
+
+    vpslldq     xmm9, xmm9, (SIZEOF_XMMWORD-1)
+    vperm2i128  ymm9, ymm9, ymm9, 1              ; (---- ---- ... ---- ---- ff) MSB is ff
+
+.rowloop:
+    push        rax                     ; colctr
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+
+    test        rax, SIZEOF_YMMWORD-1
+    jz          short .skip
+    mov         dl, JSAMPLE [rsi+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rsi+rax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+.skip:
+    vpand       ymm7, ymm10, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+
+    add         rax, byte SIZEOF_YMMWORD-1
+    and         rax, byte -SIZEOF_YMMWORD
+    cmp         rax, byte SIZEOF_YMMWORD
+    ja          short .columnloop
+
+.columnloop_last:
+    vpand       ymm6, ymm9, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+    jmp         short .upsample
+
+.columnloop:
+    vmovdqu     ymm6, YMMWORD [rsi+1*SIZEOF_YMMWORD]
+    vperm2i128  ymm6, ymm0, ymm6, 0x20
+    vpslldq     ymm6, ymm6, 15
+
+.upsample:
+    vmovdqu     ymm1, YMMWORD [rsi+0*SIZEOF_YMMWORD]  ; ymm1=( 0  1  2 ... 29 30 31)
+
+    vperm2i128  ymm2, ymm0, ymm1, 0x20
+    vpalignr    ymm2, ymm1, ymm2, 15            ; ymm2=(--  0  1 ... 28 29 30)
+    vperm2i128  ymm4, ymm0, ymm1, 0x03
+    vpalignr    ymm3, ymm4, ymm1, 1             ; ymm3=( 1  2  3 ... 30 31 --)
+
+    vpor        ymm2, ymm2, ymm7                ; ymm2=(-1  0  1 ... 28 29 30)
+    vpor        ymm3, ymm3, ymm6                ; ymm3=( 1  2  3 ... 30 31 32)
+
+    vpsrldq     ymm7, ymm4, (SIZEOF_XMMWORD-1)  ; ymm7=(31 -- -- ... -- -- --)
+
+    vpunpckhbw  ymm4, ymm1, ymm0                ; ymm4=( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm5, ymm1, ymm0                ; ymm5=( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm1, ymm5, ymm4, 0x20          ; ymm1=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm4, ymm5, ymm4, 0x31          ; ymm4=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm5, ymm2, ymm0                ; ymm5=( 7  8  9 10 11 12 13 14 23 24 25 26 27 28 29 30)
+    vpunpcklbw  ymm6, ymm2, ymm0                ; ymm6=(-1  0  1  2  3  4  5  6 15 16 17 18 19 20 21 22)
+    vperm2i128  ymm2, ymm6, ymm5, 0x20          ; ymm2=(-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+    vperm2i128  ymm5, ymm6, ymm5, 0x31          ; ymm5=(15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vpunpckhbw  ymm6, ymm3, ymm0                ; ymm6=( 1  2  3  4  5  6  7  8 17 18 19 20 21 22 23 24)
+    vpunpcklbw  ymm8, ymm3, ymm0                ; ymm8=( 9 10 11 12 13 14 15 16 25 26 27 28 29 30 31 32)
+    vperm2i128  ymm3, ymm8, ymm6, 0x20          ; ymm3=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16)
+    vperm2i128  ymm6, ymm8, ymm6, 0x31          ; ymm6=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
+
+    vpmullw     ymm1, ymm1, [rel PW_THREE]
+    vpmullw     ymm4, ymm4, [rel PW_THREE]
+    vpaddw      ymm2, ymm2, [rel PW_ONE]
+    vpaddw      ymm5, ymm5, [rel PW_ONE]
+    vpaddw      ymm3, ymm3, [rel PW_TWO]
+    vpaddw      ymm6, ymm6, [rel PW_TWO]
+
+    vpaddw      ymm2, ymm2, ymm1
+    vpaddw      ymm5, ymm5, ymm4
+    vpsrlw      ymm2, ymm2, 2                   ; ymm2=OutLE=( 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30)
+    vpsrlw      ymm5, ymm5, 2                   ; ymm5=OutHE=(32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62)
+    vpaddw      ymm3, ymm3, ymm1
+    vpaddw      ymm6, ymm6, ymm4
+    vpsrlw      ymm3, ymm3, 2                   ; ymm3=OutLO=( 1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31)
+    vpsrlw      ymm6, ymm6, 2                   ; ymm6=OutHO=(33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63)
+
+    vpsllw      ymm3, ymm3, BYTE_BIT
+    vpsllw      ymm6, ymm6, BYTE_BIT
+    vpor        ymm2, ymm2, ymm3                ; ymm2=OutL=( 0  1  2 ... 29 30 31)
+    vpor        ymm5, ymm5, ymm6                ; ymm5=OutH=(32 33 34 ... 61 62 63)
+
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymm2
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymm5
+
+    sub         rax, byte SIZEOF_YMMWORD
+    add         rsi, byte 1*SIZEOF_YMMWORD  ; inptr
+    add         rdi, byte 2*SIZEOF_YMMWORD  ; outptr
+    cmp         rax, byte SIZEOF_YMMWORD
+    ja          near .columnloop
+    test        eax, eax
+    jnz         near .columnloop_last
+
+    pop         rsi
+    pop         rdi
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         rcx                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    vzeroupper
+    uncollect_args 4
+    pop_xmm     3
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
+; Again a triangle filter; see comments for h2v1 case, above.
+;
+; GLOBAL(void)
+; jsimd_h2v2_fancy_upsample_avx2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION downsampled_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_YMMWORD  ; ymmword wk[WK_NUM]
+%define WK_NUM  4
+
+    align       32
+    global      EXTN(jsimd_h2v2_fancy_upsample_avx2)
+
+EXTN(jsimd_h2v2_fancy_upsample_avx2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_YMMWORD)  ; align to 256 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    push_xmm    3
+    collect_args 4
+    push        rbx
+
+    mov         eax, r11d               ; colctr
+    test        rax, rax
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          near .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+.rowloop:
+    push        rax                     ; colctr
+    push        rcx
+    push        rdi
+    push        rsi
+
+    mov         rcx, JSAMPROW [rsi-1*SIZEOF_JSAMPROW]  ; inptr1(above)
+    mov         rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         rsi, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]  ; inptr1(below)
+    mov         rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]  ; outptr1
+
+    vpxor       ymm8, ymm8, ymm8                 ; ymm8=(all 0's)
+    vpcmpeqb    xmm9, xmm9, xmm9
+    vpsrldq     xmm10, xmm9, (SIZEOF_XMMWORD-2)  ; (ffff ---- ---- ... ---- ----) LSB is ffff
+    vpslldq     xmm9, xmm9, (SIZEOF_XMMWORD-2)
+    vperm2i128  ymm9, ymm9, ymm9, 1              ; (---- ---- ... ---- ---- ffff) MSB is ffff
+
+    test        rax, SIZEOF_YMMWORD-1
+    jz          short .skip
+    push        rdx
+    mov         dl, JSAMPLE [rcx+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rcx+rax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [rbx+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rbx+rax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [rsi+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rsi+rax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+    pop         rdx
+.skip:
+    ; -- process the first column block
+
+    vmovdqu     ymm0, YMMWORD [rbx+0*SIZEOF_YMMWORD]  ; ymm0=row[ 0][0]
+    vmovdqu     ymm1, YMMWORD [rcx+0*SIZEOF_YMMWORD]  ; ymm1=row[-1][0]
+    vmovdqu     ymm2, YMMWORD [rsi+0*SIZEOF_YMMWORD]  ; ymm2=row[+1][0]
+
+    vpunpckhbw  ymm4, ymm0, ymm8        ; ymm4=row[ 0]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm5, ymm0, ymm8        ; ymm5=row[ 0]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm0, ymm5, ymm4, 0x20  ; ymm0=row[ 0]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm4, ymm5, ymm4, 0x31  ; ymm4=row[ 0](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm5, ymm1, ymm8        ; ymm5=row[-1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm6, ymm1, ymm8        ; ymm6=row[-1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm1, ymm6, ymm5, 0x20  ; ymm1=row[-1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm5, ymm6, ymm5, 0x31  ; ymm5=row[-1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm6, ymm2, ymm8        ; ymm6=row[+1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm3, ymm2, ymm8        ; ymm3=row[+1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm2, ymm3, ymm6, 0x20  ; ymm2=row[+1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm6, ymm3, ymm6, 0x31  ; ymm6=row[+1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpmullw     ymm0, ymm0, [rel PW_THREE]
+    vpmullw     ymm4, ymm4, [rel PW_THREE]
+
+    vpaddw      ymm1, ymm1, ymm0        ; ymm1=Int0L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm5, ymm5, ymm4        ; ymm5=Int0H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+    vpaddw      ymm2, ymm2, ymm0        ; ymm2=Int1L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm6, ymm6, ymm4        ; ymm6=Int1H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vmovdqu     YMMWORD [rdx+0*SIZEOF_YMMWORD], ymm1  ; temporarily save
+    vmovdqu     YMMWORD [rdx+1*SIZEOF_YMMWORD], ymm5  ; the intermediate data
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymm2
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymm6
+
+    vpand       ymm1, ymm1, ymm10       ; ymm1=( 0 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vpand       ymm2, ymm2, ymm10       ; ymm2=( 0 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+
+    vmovdqa     YMMWORD [wk(0)], ymm1
+    vmovdqa     YMMWORD [wk(1)], ymm2
+
+    add         rax, byte SIZEOF_YMMWORD-1
+    and         rax, byte -SIZEOF_YMMWORD
+    cmp         rax, byte SIZEOF_YMMWORD
+    ja          short .columnloop
+
+.columnloop_last:
+    ; -- process the last column block
+
+    vpand       ymm1, ymm9, YMMWORD [rdx+1*SIZEOF_YMMWORD]
+    vpand       ymm2, ymm9, YMMWORD [rdi+1*SIZEOF_YMMWORD]
+
+    vmovdqa     YMMWORD [wk(2)], ymm1   ; ymm1=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 31)
+    vmovdqa     YMMWORD [wk(3)], ymm2   ; ymm2=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 31)
+
+    jmp         near .upsample
+
+.columnloop:
+    ; -- process the next column block
+
+    vmovdqu     ymm0, YMMWORD [rbx+1*SIZEOF_YMMWORD]  ; ymm0=row[ 0][1]
+    vmovdqu     ymm1, YMMWORD [rcx+1*SIZEOF_YMMWORD]  ; ymm1=row[-1][1]
+    vmovdqu     ymm2, YMMWORD [rsi+1*SIZEOF_YMMWORD]  ; ymm2=row[+1][1]
+
+    vpunpckhbw  ymm4, ymm0, ymm8        ; ymm4=row[ 0]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm5, ymm0, ymm8        ; ymm5=row[ 0]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm0, ymm5, ymm4, 0x20  ; ymm0=row[ 0]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm4, ymm5, ymm4, 0x31  ; ymm4=row[ 0](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm5, ymm1, ymm8        ; ymm5=row[-1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm6, ymm1, ymm8        ; ymm6=row[-1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm1, ymm6, ymm5, 0x20  ; ymm1=row[-1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm5, ymm6, ymm5, 0x31  ; ymm5=row[-1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpunpckhbw  ymm6, ymm2, ymm8        ; ymm6=row[+1]( 8  9 10 11 12 13 14 15 24 25 26 27 28 29 30 31)
+    vpunpcklbw  ymm7, ymm2, ymm8        ; ymm7=row[+1]( 0  1  2  3  4  5  6  7 16 17 18 19 20 21 22 23)
+    vperm2i128  ymm2, ymm7, ymm6, 0x20  ; ymm2=row[+1]( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vperm2i128  ymm6, ymm7, ymm6, 0x31  ; ymm6=row[+1](16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vpmullw     ymm0, ymm0, [rel PW_THREE]
+    vpmullw     ymm4, ymm4, [rel PW_THREE]
+
+    vpaddw      ymm1, ymm1, ymm0        ; ymm1=Int0L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm5, ymm5, ymm4        ; ymm5=Int0H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+    vpaddw      ymm2, ymm2, ymm0        ; ymm2=Int1L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vpaddw      ymm6, ymm6, ymm4        ; ymm6=Int1H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vmovdqu     YMMWORD [rdx+2*SIZEOF_YMMWORD], ymm1  ; temporarily save
+    vmovdqu     YMMWORD [rdx+3*SIZEOF_YMMWORD], ymm5  ; the intermediate data
+    vmovdqu     YMMWORD [rdi+2*SIZEOF_YMMWORD], ymm2
+    vmovdqu     YMMWORD [rdi+3*SIZEOF_YMMWORD], ymm6
+
+    vperm2i128  ymm1, ymm8, ymm1, 0x20
+    vpslldq     ymm1, ymm1, 14          ; ymm1=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- --  0)
+    vperm2i128  ymm2, ymm8, ymm2, 0x20
+    vpslldq     ymm2, ymm2, 14          ; ymm2=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- --  0)
+
+    vmovdqa     YMMWORD [wk(2)], ymm1
+    vmovdqa     YMMWORD [wk(3)], ymm2
+
+.upsample:
+    ; -- process the upper row
+
+    vmovdqu     ymm7, YMMWORD [rdx+0*SIZEOF_YMMWORD]  ; ymm7=Int0L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vmovdqu     ymm3, YMMWORD [rdx+1*SIZEOF_YMMWORD]  ; ymm3=Int0H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vperm2i128  ymm0, ymm8, ymm7, 0x03
+    vpalignr    ymm0, ymm0, ymm7, 2     ; ymm0=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 --)
+    vperm2i128  ymm4, ymm8, ymm3, 0x20
+    vpslldq     ymm4, ymm4, 14          ; ymm4=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 16)
+
+    vperm2i128  ymm5, ymm8, ymm7, 0x03
+    vpsrldq     ymm5, ymm5, 14          ; ymm5=(15 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm6, ymm8, ymm3, 0x20
+    vpalignr    ymm6, ymm3, ymm6, 14    ; ymm6=(-- 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vpor        ymm0, ymm0, ymm4        ; ymm0=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16)
+    vpor        ymm5, ymm5, ymm6        ; ymm5=(15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vperm2i128  ymm2, ymm8, ymm3, 0x03
+    vpalignr    ymm2, ymm2, ymm3, 2     ; ymm2=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 --)
+    vperm2i128  ymm4, ymm8, ymm3, 0x03
+    vpsrldq     ymm4, ymm4, 14          ; ymm4=(31 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm1, ymm8, ymm7, 0x20
+    vpalignr    ymm1, ymm7, ymm1, 14    ; ymm1=(--  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+
+    vpor        ymm1, ymm1, YMMWORD [wk(0)]  ; ymm1=(-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+    vpor        ymm2, ymm2, YMMWORD [wk(2)]  ; ymm2=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
+
+    vmovdqa     YMMWORD [wk(0)], ymm4
+
+    vpmullw     ymm7, ymm7, [rel PW_THREE]
+    vpmullw     ymm3, ymm3, [rel PW_THREE]
+    vpaddw      ymm1, ymm1, [rel PW_EIGHT]
+    vpaddw      ymm5, ymm5, [rel PW_EIGHT]
+    vpaddw      ymm0, ymm0, [rel PW_SEVEN]
+    vpaddw      ymm2, [rel PW_SEVEN]
+
+    vpaddw      ymm1, ymm1, ymm7
+    vpaddw      ymm5, ymm5, ymm3
+    vpsrlw      ymm1, ymm1, 4           ; ymm1=Out0LE=( 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30)
+    vpsrlw      ymm5, ymm5, 4           ; ymm5=Out0HE=(32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62)
+    vpaddw      ymm0, ymm0, ymm7
+    vpaddw      ymm2, ymm2, ymm3
+    vpsrlw      ymm0, ymm0, 4           ; ymm0=Out0LO=( 1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31)
+    vpsrlw      ymm2, ymm2, 4           ; ymm2=Out0HO=(33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63)
+
+    vpsllw      ymm0, ymm0, BYTE_BIT
+    vpsllw      ymm2, ymm2, BYTE_BIT
+    vpor        ymm1, ymm1, ymm0        ; ymm1=Out0L=( 0  1  2 ... 29 30 31)
+    vpor        ymm5, ymm5, ymm2        ; ymm5=Out0H=(32 33 34 ... 61 62 63)
+
+    vmovdqu     YMMWORD [rdx+0*SIZEOF_YMMWORD], ymm1
+    vmovdqu     YMMWORD [rdx+1*SIZEOF_YMMWORD], ymm5
+
+    ; -- process the lower row
+
+    vmovdqu     ymm6, YMMWORD [rdi+0*SIZEOF_YMMWORD]  ; ymm6=Int1L=( 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15)
+    vmovdqu     ymm4, YMMWORD [rdi+1*SIZEOF_YMMWORD]  ; ymm4=Int1H=(16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31)
+
+    vperm2i128  ymm7, ymm8, ymm6, 0x03
+    vpalignr    ymm7, ymm7, ymm6, 2     ; ymm7=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 --)
+    vperm2i128  ymm3, ymm8, ymm4, 0x20
+    vpslldq     ymm3, ymm3, 14          ; ymm3=(-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 16)
+
+    vperm2i128  ymm0, ymm8, ymm6, 0x03
+    vpsrldq     ymm0, ymm0, 14          ; ymm0=(15 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm2, ymm8, ymm4, 0x20
+    vpalignr    ymm2, ymm4, ymm2, 14    ; ymm2=(-- 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vpor        ymm7, ymm7, ymm3        ; ymm7=( 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16)
+    vpor        ymm0, ymm0, ymm2        ; ymm0=(15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30)
+
+    vperm2i128  ymm5, ymm8, ymm4, 0x03
+    vpalignr    ymm5, ymm5, ymm4, 2     ; ymm5=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 --)
+    vperm2i128  ymm3, ymm8, ymm4, 0x03
+    vpsrldq     ymm3, ymm3, 14          ; ymm3=(31 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --)
+    vperm2i128  ymm1, ymm8, ymm6, 0x20
+    vpalignr    ymm1, ymm6, ymm1, 14    ; ymm1=(--  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+
+    vpor        ymm1, ymm1, YMMWORD [wk(1)]  ; ymm1=(-1  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14)
+    vpor        ymm5, ymm5, YMMWORD [wk(3)]  ; ymm5=(17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32)
+
+    vmovdqa     YMMWORD [wk(1)], ymm3
+
+    vpmullw     ymm6, ymm6, [rel PW_THREE]
+    vpmullw     ymm4, ymm4, [rel PW_THREE]
+    vpaddw      ymm1, ymm1, [rel PW_EIGHT]
+    vpaddw      ymm0, ymm0, [rel PW_EIGHT]
+    vpaddw      ymm7, ymm7, [rel PW_SEVEN]
+    vpaddw      ymm5, ymm5, [rel PW_SEVEN]
+
+    vpaddw      ymm1, ymm1, ymm6
+    vpaddw      ymm0, ymm0, ymm4
+    vpsrlw      ymm1, ymm1, 4           ; ymm1=Out1LE=( 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30)
+    vpsrlw      ymm0, ymm0, 4           ; ymm0=Out1HE=(32 34 36 38 40 42 44 46 48 50 52 54 56 58 60 62)
+    vpaddw      ymm7, ymm7, ymm6
+    vpaddw      ymm5, ymm5, ymm4
+    vpsrlw      ymm7, ymm7, 4           ; ymm7=Out1LO=( 1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31)
+    vpsrlw      ymm5, ymm5, 4           ; ymm5=Out1HO=(33 35 37 39 41 43 45 47 49 51 53 55 57 59 61 63)
+
+    vpsllw      ymm7, ymm7, BYTE_BIT
+    vpsllw      ymm5, ymm5, BYTE_BIT
+    vpor        ymm1, ymm1, ymm7        ; ymm1=Out1L=( 0  1  2 ... 29 30 31)
+    vpor        ymm0, ymm0, ymm5        ; ymm0=Out1H=(32 33 34 ... 61 62 63)
+
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymm1
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymm0
+
+    sub         rax, byte SIZEOF_YMMWORD
+    add         rcx, byte 1*SIZEOF_YMMWORD  ; inptr1(above)
+    add         rbx, byte 1*SIZEOF_YMMWORD  ; inptr0
+    add         rsi, byte 1*SIZEOF_YMMWORD  ; inptr1(below)
+    add         rdx, byte 2*SIZEOF_YMMWORD  ; outptr0
+    add         rdi, byte 2*SIZEOF_YMMWORD  ; outptr1
+    cmp         rax, byte SIZEOF_YMMWORD
+    ja          near .columnloop
+    test        rax, rax
+    jnz         near .columnloop_last
+
+    pop         rsi
+    pop         rdi
+    pop         rcx
+    pop         rax
+
+    add         rsi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         rcx, byte 2                  ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    vzeroupper
+    uncollect_args 4
+    pop_xmm     3
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v1_upsample_avx2 (int max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION output_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_upsample_avx2)
+
+EXTN(jsimd_h2v1_upsample_avx2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+
+    mov         edx, r11d
+    add         rdx, byte (SIZEOF_YMMWORD-1)
+    and         rdx, -SIZEOF_YMMWORD
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          short .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+.rowloop:
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+    mov         rax, rdx                ; colctr
+.columnloop:
+
+    cmp         rax, byte SIZEOF_YMMWORD
+    ja          near .above_16
+
+    vmovdqu     xmm0, XMMWORD [rsi+0*SIZEOF_YMMWORD]
+    vpunpckhbw  xmm1, xmm0, xmm0
+    vpunpcklbw  xmm0, xmm0, xmm0
+
+    vmovdqu     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
+    vmovdqu     XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm1
+
+    jmp         short .nextrow
+
+.above_16:
+    vmovdqu     ymm0, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+
+    vpermq      ymm0, ymm0, 0xd8
+    vpunpckhbw  ymm1, ymm0, ymm0
+    vpunpcklbw  ymm0, ymm0, ymm0
+
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymm0
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymm1
+
+    sub         rax, byte 2*SIZEOF_YMMWORD
+    jz          short .nextrow
+
+    add         rsi, byte SIZEOF_YMMWORD    ; inptr
+    add         rdi, byte 2*SIZEOF_YMMWORD  ; outptr
+    jmp         short .columnloop
+
+.nextrow:
+    pop         rsi
+    pop         rdi
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         rcx                        ; rowctr
+    jg          short .rowloop
+
+.return:
+    vzeroupper
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v2_upsample_avx2 (int max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION output_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v2_upsample_avx2)
+
+EXTN(jsimd_h2v2_upsample_avx2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+    push        rbx
+
+    mov         edx, r11d
+    add         rdx, byte (SIZEOF_YMMWORD-1)
+    and         rdx, -SIZEOF_YMMWORD
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          near .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+.rowloop:
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]                    ; inptr
+    mov         rbx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]  ; outptr1
+    mov         rax, rdx                               ; colctr
+.columnloop:
+
+    cmp         rax, byte SIZEOF_YMMWORD
+    ja          short .above_16
+
+    vmovdqu     xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    vpunpckhbw  xmm1, xmm0, xmm0
+    vpunpcklbw  xmm0, xmm0, xmm0
+
+    vmovdqu     XMMWORD [rbx+0*SIZEOF_XMMWORD], xmm0
+    vmovdqu     XMMWORD [rbx+1*SIZEOF_XMMWORD], xmm1
+    vmovdqu     XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
+    vmovdqu     XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm1
+
+    jmp         near .nextrow
+
+.above_16:
+    vmovdqu     ymm0, YMMWORD [rsi+0*SIZEOF_YMMWORD]
+
+    vpermq      ymm0, ymm0, 0xd8
+    vpunpckhbw  ymm1, ymm0, ymm0
+    vpunpcklbw  ymm0, ymm0, ymm0
+
+    vmovdqu     YMMWORD [rbx+0*SIZEOF_YMMWORD], ymm0
+    vmovdqu     YMMWORD [rbx+1*SIZEOF_YMMWORD], ymm1
+    vmovdqu     YMMWORD [rdi+0*SIZEOF_YMMWORD], ymm0
+    vmovdqu     YMMWORD [rdi+1*SIZEOF_YMMWORD], ymm1
+
+    sub         rax, byte 2*SIZEOF_YMMWORD
+    jz          short .nextrow
+
+    add         rsi, byte SIZEOF_YMMWORD  ; inptr
+    add         rbx, 2*SIZEOF_YMMWORD     ; outptr0
+    add         rdi, 2*SIZEOF_YMMWORD     ; outptr1
+    jmp         short .columnloop
+
+.nextrow:
+    pop         rsi
+    pop         rdi
+
+    add         rsi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         rcx, byte 2                  ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    vzeroupper
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jdsample-sse2.asm b/simd/x86_64/jdsample-sse2.asm
new file mode 100644
index 0000000..42a8e78
--- /dev/null
+++ b/simd/x86_64/jdsample-sse2.asm
@@ -0,0 +1,670 @@
+;
+; jdsample.asm - upsampling (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fancy_upsample_sse2)
+
+EXTN(jconst_fancy_upsample_sse2):
+
+PW_ONE   times 8 dw 1
+PW_TWO   times 8 dw 2
+PW_THREE times 8 dw 3
+PW_SEVEN times 8 dw 7
+PW_EIGHT times 8 dw 8
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Fancy processing for the common case of 2:1 horizontal and 1:1 vertical.
+;
+; The upsampling algorithm is linear interpolation between pixel centers,
+; also known as a "triangle filter".  This is a good compromise between
+; speed and visual quality.  The centers of the output pixels are 1/4 and 3/4
+; of the way between input pixel centers.
+;
+; GLOBAL(void)
+; jsimd_h2v1_fancy_upsample_sse2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION downsampled_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_fancy_upsample_sse2)
+
+EXTN(jsimd_h2v1_fancy_upsample_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+
+    mov         eax, r11d               ; colctr
+    test        rax, rax
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          near .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+.rowloop:
+    push        rax                     ; colctr
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+
+    test        rax, SIZEOF_XMMWORD-1
+    jz          short .skip
+    mov         dl, JSAMPLE [rsi+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rsi+rax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+.skip:
+    pxor        xmm0, xmm0              ; xmm0=(all 0's)
+    pcmpeqb     xmm7, xmm7
+    psrldq      xmm7, (SIZEOF_XMMWORD-1)
+    pand        xmm7, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+
+    add         rax, byte SIZEOF_XMMWORD-1
+    and         rax, byte -SIZEOF_XMMWORD
+    cmp         rax, byte SIZEOF_XMMWORD
+    ja          short .columnloop
+
+.columnloop_last:
+    pcmpeqb     xmm6, xmm6
+    pslldq      xmm6, (SIZEOF_XMMWORD-1)
+    pand        xmm6, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    jmp         short .upsample
+
+.columnloop:
+    movdqa      xmm6, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+    pslldq      xmm6, (SIZEOF_XMMWORD-1)
+
+.upsample:
+    movdqa      xmm1, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+    movdqa      xmm2, xmm1
+    movdqa      xmm3, xmm1                ; xmm1=( 0  1  2 ... 13 14 15)
+    pslldq      xmm2, 1                   ; xmm2=(--  0  1 ... 12 13 14)
+    psrldq      xmm3, 1                   ; xmm3=( 1  2  3 ... 14 15 --)
+
+    por         xmm2, xmm7                ; xmm2=(-1  0  1 ... 12 13 14)
+    por         xmm3, xmm6                ; xmm3=( 1  2  3 ... 14 15 16)
+
+    movdqa      xmm7, xmm1
+    psrldq      xmm7, (SIZEOF_XMMWORD-1)  ; xmm7=(15 -- -- ... -- -- --)
+
+    movdqa      xmm4, xmm1
+    punpcklbw   xmm1, xmm0                ; xmm1=( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm4, xmm0                ; xmm4=( 8  9 10 11 12 13 14 15)
+    movdqa      xmm5, xmm2
+    punpcklbw   xmm2, xmm0                ; xmm2=(-1  0  1  2  3  4  5  6)
+    punpckhbw   xmm5, xmm0                ; xmm5=( 7  8  9 10 11 12 13 14)
+    movdqa      xmm6, xmm3
+    punpcklbw   xmm3, xmm0                ; xmm3=( 1  2  3  4  5  6  7  8)
+    punpckhbw   xmm6, xmm0                ; xmm6=( 9 10 11 12 13 14 15 16)
+
+    pmullw      xmm1, [rel PW_THREE]
+    pmullw      xmm4, [rel PW_THREE]
+    paddw       xmm2, [rel PW_ONE]
+    paddw       xmm5, [rel PW_ONE]
+    paddw       xmm3, [rel PW_TWO]
+    paddw       xmm6, [rel PW_TWO]
+
+    paddw       xmm2, xmm1
+    paddw       xmm5, xmm4
+    psrlw       xmm2, 2                 ; xmm2=OutLE=( 0  2  4  6  8 10 12 14)
+    psrlw       xmm5, 2                 ; xmm5=OutHE=(16 18 20 22 24 26 28 30)
+    paddw       xmm3, xmm1
+    paddw       xmm6, xmm4
+    psrlw       xmm3, 2                 ; xmm3=OutLO=( 1  3  5  7  9 11 13 15)
+    psrlw       xmm6, 2                 ; xmm6=OutHO=(17 19 21 23 25 27 29 31)
+
+    psllw       xmm3, BYTE_BIT
+    psllw       xmm6, BYTE_BIT
+    por         xmm2, xmm3              ; xmm2=OutL=( 0  1  2 ... 13 14 15)
+    por         xmm5, xmm6              ; xmm5=OutH=(16 17 18 ... 29 30 31)
+
+    movdqa      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm5
+
+    sub         rax, byte SIZEOF_XMMWORD
+    add         rsi, byte 1*SIZEOF_XMMWORD  ; inptr
+    add         rdi, byte 2*SIZEOF_XMMWORD  ; outptr
+    cmp         rax, byte SIZEOF_XMMWORD
+    ja          near .columnloop
+    test        eax, eax
+    jnz         near .columnloop_last
+
+    pop         rsi
+    pop         rdi
+    pop         rax
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         rcx                        ; rowctr
+    jg          near .rowloop
+
+.return:
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fancy processing for the common case of 2:1 horizontal and 2:1 vertical.
+; Again a triangle filter; see comments for h2v1 case, above.
+;
+; GLOBAL(void)
+; jsimd_h2v2_fancy_upsample_sse2 (int max_v_samp_factor,
+;                                 JDIMENSION downsampled_width,
+;                                 JSAMPARRAY input_data,
+;                                 JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION downsampled_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  4
+
+    align       32
+    global      EXTN(jsimd_h2v2_fancy_upsample_sse2)
+
+EXTN(jsimd_h2v2_fancy_upsample_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 4
+    push        rbx
+
+    mov         eax, r11d               ; colctr
+    test        rax, rax
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          near .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+.rowloop:
+    push        rax                     ; colctr
+    push        rcx
+    push        rdi
+    push        rsi
+
+    mov         rcx, JSAMPROW [rsi-1*SIZEOF_JSAMPROW]  ; inptr1(above)
+    mov         rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]  ; inptr0
+    mov         rsi, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]  ; inptr1(below)
+    mov         rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]  ; outptr1
+
+    test        rax, SIZEOF_XMMWORD-1
+    jz          short .skip
+    push        rdx
+    mov         dl, JSAMPLE [rcx+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rcx+rax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [rbx+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rbx+rax*SIZEOF_JSAMPLE], dl
+    mov         dl, JSAMPLE [rsi+(rax-1)*SIZEOF_JSAMPLE]
+    mov         JSAMPLE [rsi+rax*SIZEOF_JSAMPLE], dl    ; insert a dummy sample
+    pop         rdx
+.skip:
+    ; -- process the first column block
+
+    movdqa      xmm0, XMMWORD [rbx+0*SIZEOF_XMMWORD]  ; xmm0=row[ 0][0]
+    movdqa      xmm1, XMMWORD [rcx+0*SIZEOF_XMMWORD]  ; xmm1=row[-1][0]
+    movdqa      xmm2, XMMWORD [rsi+0*SIZEOF_XMMWORD]  ; xmm2=row[+1][0]
+
+    pxor        xmm3, xmm3              ; xmm3=(all 0's)
+    movdqa      xmm4, xmm0
+    punpcklbw   xmm0, xmm3              ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm4, xmm3              ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm5, xmm1
+    punpcklbw   xmm1, xmm3              ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm5, xmm3              ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm6, xmm2
+    punpcklbw   xmm2, xmm3              ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm6, xmm3              ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
+
+    pmullw      xmm0, [rel PW_THREE]
+    pmullw      xmm4, [rel PW_THREE]
+
+    pcmpeqb     xmm7, xmm7
+    psrldq      xmm7, (SIZEOF_XMMWORD-2)
+
+    paddw       xmm1, xmm0              ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm5, xmm4              ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
+    paddw       xmm2, xmm0              ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm6, xmm4              ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
+
+    movdqa      XMMWORD [rdx+0*SIZEOF_XMMWORD], xmm1  ; temporarily save
+    movdqa      XMMWORD [rdx+1*SIZEOF_XMMWORD], xmm5  ; the intermediate data
+    movdqa      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm6
+
+    pand        xmm1, xmm7              ; xmm1=( 0 -- -- -- -- -- -- --)
+    pand        xmm2, xmm7              ; xmm2=( 0 -- -- -- -- -- -- --)
+
+    movdqa      XMMWORD [wk(0)], xmm1
+    movdqa      XMMWORD [wk(1)], xmm2
+
+    add         rax, byte SIZEOF_XMMWORD-1
+    and         rax, byte -SIZEOF_XMMWORD
+    cmp         rax, byte SIZEOF_XMMWORD
+    ja          short .columnloop
+
+.columnloop_last:
+    ; -- process the last column block
+
+    pcmpeqb     xmm1, xmm1
+    pslldq      xmm1, (SIZEOF_XMMWORD-2)
+    movdqa      xmm2, xmm1
+
+    pand        xmm1, XMMWORD [rdx+1*SIZEOF_XMMWORD]
+    pand        xmm2, XMMWORD [rdi+1*SIZEOF_XMMWORD]
+
+    movdqa      XMMWORD [wk(2)], xmm1   ; xmm1=(-- -- -- -- -- -- -- 15)
+    movdqa      XMMWORD [wk(3)], xmm2   ; xmm2=(-- -- -- -- -- -- -- 15)
+
+    jmp         near .upsample
+
+.columnloop:
+    ; -- process the next column block
+
+    movdqa      xmm0, XMMWORD [rbx+1*SIZEOF_XMMWORD]  ; xmm0=row[ 0][1]
+    movdqa      xmm1, XMMWORD [rcx+1*SIZEOF_XMMWORD]  ; xmm1=row[-1][1]
+    movdqa      xmm2, XMMWORD [rsi+1*SIZEOF_XMMWORD]  ; xmm2=row[+1][1]
+
+    pxor        xmm3, xmm3              ; xmm3=(all 0's)
+    movdqa      xmm4, xmm0
+    punpcklbw   xmm0, xmm3              ; xmm0=row[ 0]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm4, xmm3              ; xmm4=row[ 0]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm5, xmm1
+    punpcklbw   xmm1, xmm3              ; xmm1=row[-1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm5, xmm3              ; xmm5=row[-1]( 8  9 10 11 12 13 14 15)
+    movdqa      xmm6, xmm2
+    punpcklbw   xmm2, xmm3              ; xmm2=row[+1]( 0  1  2  3  4  5  6  7)
+    punpckhbw   xmm6, xmm3              ; xmm6=row[+1]( 8  9 10 11 12 13 14 15)
+
+    pmullw      xmm0, [rel PW_THREE]
+    pmullw      xmm4, [rel PW_THREE]
+
+    paddw       xmm1, xmm0              ; xmm1=Int0L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm5, xmm4              ; xmm5=Int0H=( 8  9 10 11 12 13 14 15)
+    paddw       xmm2, xmm0              ; xmm2=Int1L=( 0  1  2  3  4  5  6  7)
+    paddw       xmm6, xmm4              ; xmm6=Int1H=( 8  9 10 11 12 13 14 15)
+
+    movdqa      XMMWORD [rdx+2*SIZEOF_XMMWORD], xmm1  ; temporarily save
+    movdqa      XMMWORD [rdx+3*SIZEOF_XMMWORD], xmm5  ; the intermediate data
+    movdqa      XMMWORD [rdi+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [rdi+3*SIZEOF_XMMWORD], xmm6
+
+    pslldq      xmm1, (SIZEOF_XMMWORD-2)  ; xmm1=(-- -- -- -- -- -- --  0)
+    pslldq      xmm2, (SIZEOF_XMMWORD-2)  ; xmm2=(-- -- -- -- -- -- --  0)
+
+    movdqa      XMMWORD [wk(2)], xmm1
+    movdqa      XMMWORD [wk(3)], xmm2
+
+.upsample:
+    ; -- process the upper row
+
+    movdqa      xmm7, XMMWORD [rdx+0*SIZEOF_XMMWORD]
+    movdqa      xmm3, XMMWORD [rdx+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm0, xmm7                ; xmm7=Int0L=( 0  1  2  3  4  5  6  7)
+    movdqa      xmm4, xmm3                ; xmm3=Int0H=( 8  9 10 11 12 13 14 15)
+    psrldq      xmm0, 2                   ; xmm0=( 1  2  3  4  5  6  7 --)
+    pslldq      xmm4, (SIZEOF_XMMWORD-2)  ; xmm4=(-- -- -- -- -- -- --  8)
+    movdqa      xmm5, xmm7
+    movdqa      xmm6, xmm3
+    psrldq      xmm5, (SIZEOF_XMMWORD-2)  ; xmm5=( 7 -- -- -- -- -- -- --)
+    pslldq      xmm6, 2                   ; xmm6=(--  8  9 10 11 12 13 14)
+
+    por         xmm0, xmm4                ; xmm0=( 1  2  3  4  5  6  7  8)
+    por         xmm5, xmm6                ; xmm5=( 7  8  9 10 11 12 13 14)
+
+    movdqa      xmm1, xmm7
+    movdqa      xmm2, xmm3
+    pslldq      xmm1, 2                   ; xmm1=(--  0  1  2  3  4  5  6)
+    psrldq      xmm2, 2                   ; xmm2=( 9 10 11 12 13 14 15 --)
+    movdqa      xmm4, xmm3
+    psrldq      xmm4, (SIZEOF_XMMWORD-2)  ; xmm4=(15 -- -- -- -- -- -- --)
+
+    por         xmm1, XMMWORD [wk(0)]     ; xmm1=(-1  0  1  2  3  4  5  6)
+    por         xmm2, XMMWORD [wk(2)]     ; xmm2=( 9 10 11 12 13 14 15 16)
+
+    movdqa      XMMWORD [wk(0)], xmm4
+
+    pmullw      xmm7, [rel PW_THREE]
+    pmullw      xmm3, [rel PW_THREE]
+    paddw       xmm1, [rel PW_EIGHT]
+    paddw       xmm5, [rel PW_EIGHT]
+    paddw       xmm0, [rel PW_SEVEN]
+    paddw       xmm2, [rel PW_SEVEN]
+
+    paddw       xmm1, xmm7
+    paddw       xmm5, xmm3
+    psrlw       xmm1, 4                 ; xmm1=Out0LE=( 0  2  4  6  8 10 12 14)
+    psrlw       xmm5, 4                 ; xmm5=Out0HE=(16 18 20 22 24 26 28 30)
+    paddw       xmm0, xmm7
+    paddw       xmm2, xmm3
+    psrlw       xmm0, 4                 ; xmm0=Out0LO=( 1  3  5  7  9 11 13 15)
+    psrlw       xmm2, 4                 ; xmm2=Out0HO=(17 19 21 23 25 27 29 31)
+
+    psllw       xmm0, BYTE_BIT
+    psllw       xmm2, BYTE_BIT
+    por         xmm1, xmm0              ; xmm1=Out0L=( 0  1  2 ... 13 14 15)
+    por         xmm5, xmm2              ; xmm5=Out0H=(16 17 18 ... 29 30 31)
+
+    movdqa      XMMWORD [rdx+0*SIZEOF_XMMWORD], xmm1
+    movdqa      XMMWORD [rdx+1*SIZEOF_XMMWORD], xmm5
+
+    ; -- process the lower row
+
+    movdqa      xmm6, XMMWORD [rdi+0*SIZEOF_XMMWORD]
+    movdqa      xmm4, XMMWORD [rdi+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm7, xmm6                ; xmm6=Int1L=( 0  1  2  3  4  5  6  7)
+    movdqa      xmm3, xmm4                ; xmm4=Int1H=( 8  9 10 11 12 13 14 15)
+    psrldq      xmm7, 2                   ; xmm7=( 1  2  3  4  5  6  7 --)
+    pslldq      xmm3, (SIZEOF_XMMWORD-2)  ; xmm3=(-- -- -- -- -- -- --  8)
+    movdqa      xmm0, xmm6
+    movdqa      xmm2, xmm4
+    psrldq      xmm0, (SIZEOF_XMMWORD-2)  ; xmm0=( 7 -- -- -- -- -- -- --)
+    pslldq      xmm2, 2                   ; xmm2=(--  8  9 10 11 12 13 14)
+
+    por         xmm7, xmm3                ; xmm7=( 1  2  3  4  5  6  7  8)
+    por         xmm0, xmm2                ; xmm0=( 7  8  9 10 11 12 13 14)
+
+    movdqa      xmm1, xmm6
+    movdqa      xmm5, xmm4
+    pslldq      xmm1, 2                   ; xmm1=(--  0  1  2  3  4  5  6)
+    psrldq      xmm5, 2                   ; xmm5=( 9 10 11 12 13 14 15 --)
+    movdqa      xmm3, xmm4
+    psrldq      xmm3, (SIZEOF_XMMWORD-2)  ; xmm3=(15 -- -- -- -- -- -- --)
+
+    por         xmm1, XMMWORD [wk(1)]     ; xmm1=(-1  0  1  2  3  4  5  6)
+    por         xmm5, XMMWORD [wk(3)]     ; xmm5=( 9 10 11 12 13 14 15 16)
+
+    movdqa      XMMWORD [wk(1)], xmm3
+
+    pmullw      xmm6, [rel PW_THREE]
+    pmullw      xmm4, [rel PW_THREE]
+    paddw       xmm1, [rel PW_EIGHT]
+    paddw       xmm0, [rel PW_EIGHT]
+    paddw       xmm7, [rel PW_SEVEN]
+    paddw       xmm5, [rel PW_SEVEN]
+
+    paddw       xmm1, xmm6
+    paddw       xmm0, xmm4
+    psrlw       xmm1, 4                 ; xmm1=Out1LE=( 0  2  4  6  8 10 12 14)
+    psrlw       xmm0, 4                 ; xmm0=Out1HE=(16 18 20 22 24 26 28 30)
+    paddw       xmm7, xmm6
+    paddw       xmm5, xmm4
+    psrlw       xmm7, 4                 ; xmm7=Out1LO=( 1  3  5  7  9 11 13 15)
+    psrlw       xmm5, 4                 ; xmm5=Out1HO=(17 19 21 23 25 27 29 31)
+
+    psllw       xmm7, BYTE_BIT
+    psllw       xmm5, BYTE_BIT
+    por         xmm1, xmm7              ; xmm1=Out1L=( 0  1  2 ... 13 14 15)
+    por         xmm0, xmm5              ; xmm0=Out1H=(16 17 18 ... 29 30 31)
+
+    movdqa      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm1
+    movdqa      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm0
+
+    sub         rax, byte SIZEOF_XMMWORD
+    add         rcx, byte 1*SIZEOF_XMMWORD  ; inptr1(above)
+    add         rbx, byte 1*SIZEOF_XMMWORD  ; inptr0
+    add         rsi, byte 1*SIZEOF_XMMWORD  ; inptr1(below)
+    add         rdx, byte 2*SIZEOF_XMMWORD  ; outptr0
+    add         rdi, byte 2*SIZEOF_XMMWORD  ; outptr1
+    cmp         rax, byte SIZEOF_XMMWORD
+    ja          near .columnloop
+    test        rax, rax
+    jnz         near .columnloop_last
+
+    pop         rsi
+    pop         rdi
+    pop         rcx
+    pop         rax
+
+    add         rsi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         rcx, byte 2                  ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    uncollect_args 4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v1_upsample_sse2 (int max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION output_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v1_upsample_sse2)
+
+EXTN(jsimd_h2v1_upsample_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+
+    mov         edx, r11d
+    add         rdx, byte (2*SIZEOF_XMMWORD)-1
+    and         rdx, byte -(2*SIZEOF_XMMWORD)
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          short .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+.rowloop:
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]     ; inptr
+    mov         rdi, JSAMPROW [rdi]     ; outptr
+    mov         rax, rdx                ; colctr
+.columnloop:
+
+    movdqa      xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+
+    movdqa      xmm1, xmm0
+    punpcklbw   xmm0, xmm0
+    punpckhbw   xmm1, xmm1
+
+    movdqa      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
+    movdqa      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm1
+
+    sub         rax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    movdqa      xmm2, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm3, xmm2
+    punpcklbw   xmm2, xmm2
+    punpckhbw   xmm3, xmm3
+
+    movdqa      XMMWORD [rdi+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [rdi+3*SIZEOF_XMMWORD], xmm3
+
+    sub         rax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    add         rsi, byte 2*SIZEOF_XMMWORD  ; inptr
+    add         rdi, byte 4*SIZEOF_XMMWORD  ; outptr
+    jmp         short .columnloop
+
+.nextrow:
+    pop         rsi
+    pop         rdi
+
+    add         rsi, byte SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte SIZEOF_JSAMPROW  ; output_data
+    dec         rcx                        ; rowctr
+    jg          short .rowloop
+
+.return:
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
+; It's still a box filter.
+;
+; GLOBAL(void)
+; jsimd_h2v2_upsample_sse2 (int max_v_samp_factor,
+;                           JDIMENSION output_width,
+;                           JSAMPARRAY input_data,
+;                           JSAMPARRAY *output_data_ptr);
+;
+
+; r10 = int max_v_samp_factor
+; r11d = JDIMENSION output_width
+; r12 = JSAMPARRAY input_data
+; r13 = JSAMPARRAY *output_data_ptr
+
+    align       32
+    global      EXTN(jsimd_h2v2_upsample_sse2)
+
+EXTN(jsimd_h2v2_upsample_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+    push        rbx
+
+    mov         edx, r11d
+    add         rdx, byte (2*SIZEOF_XMMWORD)-1
+    and         rdx, byte -(2*SIZEOF_XMMWORD)
+    jz          near .return
+
+    mov         rcx, r10                ; rowctr
+    test        rcx, rcx
+    jz          near .return
+
+    mov         rsi, r12                ; input_data
+    mov         rdi, r13
+    mov         rdi, JSAMPARRAY [rdi]   ; output_data
+.rowloop:
+    push        rdi
+    push        rsi
+
+    mov         rsi, JSAMPROW [rsi]                    ; inptr
+    mov         rbx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]  ; outptr0
+    mov         rdi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]  ; outptr1
+    mov         rax, rdx                               ; colctr
+.columnloop:
+
+    movdqa      xmm0, XMMWORD [rsi+0*SIZEOF_XMMWORD]
+
+    movdqa      xmm1, xmm0
+    punpcklbw   xmm0, xmm0
+    punpckhbw   xmm1, xmm1
+
+    movdqa      XMMWORD [rbx+0*SIZEOF_XMMWORD], xmm0
+    movdqa      XMMWORD [rbx+1*SIZEOF_XMMWORD], xmm1
+    movdqa      XMMWORD [rdi+0*SIZEOF_XMMWORD], xmm0
+    movdqa      XMMWORD [rdi+1*SIZEOF_XMMWORD], xmm1
+
+    sub         rax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    movdqa      xmm2, XMMWORD [rsi+1*SIZEOF_XMMWORD]
+
+    movdqa      xmm3, xmm2
+    punpcklbw   xmm2, xmm2
+    punpckhbw   xmm3, xmm3
+
+    movdqa      XMMWORD [rbx+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [rbx+3*SIZEOF_XMMWORD], xmm3
+    movdqa      XMMWORD [rdi+2*SIZEOF_XMMWORD], xmm2
+    movdqa      XMMWORD [rdi+3*SIZEOF_XMMWORD], xmm3
+
+    sub         rax, byte 2*SIZEOF_XMMWORD
+    jz          short .nextrow
+
+    add         rsi, byte 2*SIZEOF_XMMWORD  ; inptr
+    add         rbx, byte 4*SIZEOF_XMMWORD  ; outptr0
+    add         rdi, byte 4*SIZEOF_XMMWORD  ; outptr1
+    jmp         short .columnloop
+
+.nextrow:
+    pop         rsi
+    pop         rdi
+
+    add         rsi, byte 1*SIZEOF_JSAMPROW  ; input_data
+    add         rdi, byte 2*SIZEOF_JSAMPROW  ; output_data
+    sub         rcx, byte 2                  ; rowctr
+    jg          near .rowloop
+
+.return:
+    pop         rbx
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jfdctflt-sse.asm b/simd/x86_64/jfdctflt-sse.asm
new file mode 100644
index 0000000..127ef28
--- /dev/null
+++ b/simd/x86_64/jfdctflt-sse.asm
@@ -0,0 +1,357 @@
+;
+; jfdctflt.asm - floating-point FDCT (64-bit SSE)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a floating-point implementation of the forward DCT
+; (Discrete Cosine Transform). The following code is based directly on
+; the IJG's original jfdctflt.c; see the jfdctflt.c for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%macro  unpcklps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
+    shufps      %1, %2, 0x44
+%endmacro
+
+%macro  unpckhps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
+    shufps      %1, %2, 0xEE
+%endmacro
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fdct_float_sse)
+
+EXTN(jconst_fdct_float_sse):
+
+PD_0_382 times 4 dd 0.382683432365089771728460
+PD_0_707 times 4 dd 0.707106781186547524400844
+PD_0_541 times 4 dd 0.541196100146196984399723
+PD_1_306 times 4 dd 1.306562964876376527856643
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Perform the forward DCT on one block of samples.
+;
+; GLOBAL(void)
+; jsimd_fdct_float_sse (FAST_FLOAT *data)
+;
+
+; r10 = FAST_FLOAT *data
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  2
+
+    align       32
+    global      EXTN(jsimd_fdct_float_sse)
+
+EXTN(jsimd_fdct_float_sse):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 1
+
+    ; ---- Pass 1: process rows.
+
+    mov         rdx, r10                ; (FAST_FLOAT *)
+    mov         rcx, DCTSIZE/4
+.rowloop:
+
+    movaps      xmm0, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(2,1,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(3,1,rdx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm0=(20 21 22 23), xmm2=(24 25 26 27)
+    ; xmm1=(30 31 32 33), xmm3=(34 35 36 37)
+
+    movaps      xmm4, xmm0              ; transpose coefficients(phase 1)
+    unpcklps    xmm0, xmm1              ; xmm0=(20 30 21 31)
+    unpckhps    xmm4, xmm1              ; xmm4=(22 32 23 33)
+    movaps      xmm5, xmm2              ; transpose coefficients(phase 1)
+    unpcklps    xmm2, xmm3              ; xmm2=(24 34 25 35)
+    unpckhps    xmm5, xmm3              ; xmm5=(26 36 27 37)
+
+    movaps      xmm6, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm7, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(0,1,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(1,1,rdx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm6=(00 01 02 03), xmm1=(04 05 06 07)
+    ; xmm7=(10 11 12 13), xmm3=(14 15 16 17)
+
+    movaps      XMMWORD [wk(0)], xmm4   ; wk(0)=(22 32 23 33)
+    movaps      XMMWORD [wk(1)], xmm2   ; wk(1)=(24 34 25 35)
+
+    movaps      xmm4, xmm6              ; transpose coefficients(phase 1)
+    unpcklps    xmm6, xmm7              ; xmm6=(00 10 01 11)
+    unpckhps    xmm4, xmm7              ; xmm4=(02 12 03 13)
+    movaps      xmm2, xmm1              ; transpose coefficients(phase 1)
+    unpcklps    xmm1, xmm3              ; xmm1=(04 14 05 15)
+    unpckhps    xmm2, xmm3              ; xmm2=(06 16 07 17)
+
+    movaps      xmm7, xmm6              ; transpose coefficients(phase 2)
+    unpcklps2   xmm6, xmm0              ; xmm6=(00 10 20 30)=data0
+    unpckhps2   xmm7, xmm0              ; xmm7=(01 11 21 31)=data1
+    movaps      xmm3, xmm2              ; transpose coefficients(phase 2)
+    unpcklps2   xmm2, xmm5              ; xmm2=(06 16 26 36)=data6
+    unpckhps2   xmm3, xmm5              ; xmm3=(07 17 27 37)=data7
+
+    movaps      xmm0, xmm7
+    movaps      xmm5, xmm6
+    subps       xmm7, xmm2              ; xmm7=data1-data6=tmp6
+    subps       xmm6, xmm3              ; xmm6=data0-data7=tmp7
+    addps       xmm0, xmm2              ; xmm0=data1+data6=tmp1
+    addps       xmm5, xmm3              ; xmm5=data0+data7=tmp0
+
+    movaps      xmm2, XMMWORD [wk(0)]   ; xmm2=(22 32 23 33)
+    movaps      xmm3, XMMWORD [wk(1)]   ; xmm3=(24 34 25 35)
+    movaps      XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
+    movaps      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
+
+    movaps      xmm7, xmm4              ; transpose coefficients(phase 2)
+    unpcklps2   xmm4, xmm2              ; xmm4=(02 12 22 32)=data2
+    unpckhps2   xmm7, xmm2              ; xmm7=(03 13 23 33)=data3
+    movaps      xmm6, xmm1              ; transpose coefficients(phase 2)
+    unpcklps2   xmm1, xmm3              ; xmm1=(04 14 24 34)=data4
+    unpckhps2   xmm6, xmm3              ; xmm6=(05 15 25 35)=data5
+
+    movaps      xmm2, xmm7
+    movaps      xmm3, xmm4
+    addps       xmm7, xmm1              ; xmm7=data3+data4=tmp3
+    addps       xmm4, xmm6              ; xmm4=data2+data5=tmp2
+    subps       xmm2, xmm1              ; xmm2=data3-data4=tmp4
+    subps       xmm3, xmm6              ; xmm3=data2-data5=tmp5
+
+    ; -- Even part
+
+    movaps      xmm1, xmm5
+    movaps      xmm6, xmm0
+    subps       xmm5, xmm7              ; xmm5=tmp13
+    subps       xmm0, xmm4              ; xmm0=tmp12
+    addps       xmm1, xmm7              ; xmm1=tmp10
+    addps       xmm6, xmm4              ; xmm6=tmp11
+
+    addps       xmm0, xmm5
+    mulps       xmm0, [rel PD_0_707]    ; xmm0=z1
+
+    movaps      xmm7, xmm1
+    movaps      xmm4, xmm5
+    subps       xmm1, xmm6              ; xmm1=data4
+    subps       xmm5, xmm0              ; xmm5=data6
+    addps       xmm7, xmm6              ; xmm7=data0
+    addps       xmm4, xmm0              ; xmm4=data2
+
+    movaps      XMMWORD [XMMBLOCK(0,1,rdx,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(2,1,rdx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
+
+    ; -- Odd part
+
+    movaps      xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
+    movaps      xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
+
+    addps       xmm2, xmm3              ; xmm2=tmp10
+    addps       xmm3, xmm6              ; xmm3=tmp11
+    addps       xmm6, xmm0              ; xmm6=tmp12, xmm0=tmp7
+
+    mulps       xmm3, [rel PD_0_707]    ; xmm3=z3
+
+    movaps      xmm1, xmm2              ; xmm1=tmp10
+    subps       xmm2, xmm6
+    mulps       xmm2, [rel PD_0_382]    ; xmm2=z5
+    mulps       xmm1, [rel PD_0_541]    ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
+    mulps       xmm6, [rel PD_1_306]    ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
+    addps       xmm1, xmm2              ; xmm1=z2
+    addps       xmm6, xmm2              ; xmm6=z4
+
+    movaps      xmm5, xmm0
+    subps       xmm0, xmm3              ; xmm0=z13
+    addps       xmm5, xmm3              ; xmm5=z11
+
+    movaps      xmm7, xmm0
+    movaps      xmm4, xmm5
+    subps       xmm0, xmm1              ; xmm0=data3
+    subps       xmm5, xmm6              ; xmm5=data7
+    addps       xmm7, xmm1              ; xmm7=data5
+    addps       xmm4, xmm6              ; xmm4=data1
+
+    movaps      XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(3,1,rdx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(1,1,rdx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
+
+    add         rdx, 4*DCTSIZE*SIZEOF_FAST_FLOAT
+    dec         rcx
+    jnz         near .rowloop
+
+    ; ---- Pass 2: process columns.
+
+    mov         rdx, r10                ; (FAST_FLOAT *)
+    mov         rcx, DCTSIZE/4
+.columnloop:
+
+    movaps      xmm0, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm0=(02 12 22 32), xmm2=(42 52 62 72)
+    ; xmm1=(03 13 23 33), xmm3=(43 53 63 73)
+
+    movaps      xmm4, xmm0              ; transpose coefficients(phase 1)
+    unpcklps    xmm0, xmm1              ; xmm0=(02 03 12 13)
+    unpckhps    xmm4, xmm1              ; xmm4=(22 23 32 33)
+    movaps      xmm5, xmm2              ; transpose coefficients(phase 1)
+    unpcklps    xmm2, xmm3              ; xmm2=(42 43 52 53)
+    unpckhps    xmm5, xmm3              ; xmm5=(62 63 72 73)
+
+    movaps      xmm6, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm7, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_FAST_FLOAT)]
+
+    ; xmm6=(00 10 20 30), xmm1=(40 50 60 70)
+    ; xmm7=(01 11 21 31), xmm3=(41 51 61 71)
+
+    movaps      XMMWORD [wk(0)], xmm4   ; wk(0)=(22 23 32 33)
+    movaps      XMMWORD [wk(1)], xmm2   ; wk(1)=(42 43 52 53)
+
+    movaps      xmm4, xmm6              ; transpose coefficients(phase 1)
+    unpcklps    xmm6, xmm7              ; xmm6=(00 01 10 11)
+    unpckhps    xmm4, xmm7              ; xmm4=(20 21 30 31)
+    movaps      xmm2, xmm1              ; transpose coefficients(phase 1)
+    unpcklps    xmm1, xmm3              ; xmm1=(40 41 50 51)
+    unpckhps    xmm2, xmm3              ; xmm2=(60 61 70 71)
+
+    movaps      xmm7, xmm6              ; transpose coefficients(phase 2)
+    unpcklps2   xmm6, xmm0              ; xmm6=(00 01 02 03)=data0
+    unpckhps2   xmm7, xmm0              ; xmm7=(10 11 12 13)=data1
+    movaps      xmm3, xmm2              ; transpose coefficients(phase 2)
+    unpcklps2   xmm2, xmm5              ; xmm2=(60 61 62 63)=data6
+    unpckhps2   xmm3, xmm5              ; xmm3=(70 71 72 73)=data7
+
+    movaps      xmm0, xmm7
+    movaps      xmm5, xmm6
+    subps       xmm7, xmm2              ; xmm7=data1-data6=tmp6
+    subps       xmm6, xmm3              ; xmm6=data0-data7=tmp7
+    addps       xmm0, xmm2              ; xmm0=data1+data6=tmp1
+    addps       xmm5, xmm3              ; xmm5=data0+data7=tmp0
+
+    movaps      xmm2, XMMWORD [wk(0)]   ; xmm2=(22 23 32 33)
+    movaps      xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53)
+    movaps      XMMWORD [wk(0)], xmm7   ; wk(0)=tmp6
+    movaps      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
+
+    movaps      xmm7, xmm4              ; transpose coefficients(phase 2)
+    unpcklps2   xmm4, xmm2              ; xmm4=(20 21 22 23)=data2
+    unpckhps2   xmm7, xmm2              ; xmm7=(30 31 32 33)=data3
+    movaps      xmm6, xmm1              ; transpose coefficients(phase 2)
+    unpcklps2   xmm1, xmm3              ; xmm1=(40 41 42 43)=data4
+    unpckhps2   xmm6, xmm3              ; xmm6=(50 51 52 53)=data5
+
+    movaps      xmm2, xmm7
+    movaps      xmm3, xmm4
+    addps       xmm7, xmm1              ; xmm7=data3+data4=tmp3
+    addps       xmm4, xmm6              ; xmm4=data2+data5=tmp2
+    subps       xmm2, xmm1              ; xmm2=data3-data4=tmp4
+    subps       xmm3, xmm6              ; xmm3=data2-data5=tmp5
+
+    ; -- Even part
+
+    movaps      xmm1, xmm5
+    movaps      xmm6, xmm0
+    subps       xmm5, xmm7              ; xmm5=tmp13
+    subps       xmm0, xmm4              ; xmm0=tmp12
+    addps       xmm1, xmm7              ; xmm1=tmp10
+    addps       xmm6, xmm4              ; xmm6=tmp11
+
+    addps       xmm0, xmm5
+    mulps       xmm0, [rel PD_0_707]    ; xmm0=z1
+
+    movaps      xmm7, xmm1
+    movaps      xmm4, xmm5
+    subps       xmm1, xmm6              ; xmm1=data4
+    subps       xmm5, xmm0              ; xmm5=data6
+    addps       xmm7, xmm6              ; xmm7=data0
+    addps       xmm4, xmm0              ; xmm4=data2
+
+    movaps      XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
+
+    ; -- Odd part
+
+    movaps      xmm6, XMMWORD [wk(0)]   ; xmm6=tmp6
+    movaps      xmm0, XMMWORD [wk(1)]   ; xmm0=tmp7
+
+    addps       xmm2, xmm3              ; xmm2=tmp10
+    addps       xmm3, xmm6              ; xmm3=tmp11
+    addps       xmm6, xmm0              ; xmm6=tmp12, xmm0=tmp7
+
+    mulps       xmm3, [rel PD_0_707]    ; xmm3=z3
+
+    movaps      xmm1, xmm2              ; xmm1=tmp10
+    subps       xmm2, xmm6
+    mulps       xmm2, [rel PD_0_382]    ; xmm2=z5
+    mulps       xmm1, [rel PD_0_541]    ; xmm1=MULTIPLY(tmp10,FIX_0_541196)
+    mulps       xmm6, [rel PD_1_306]    ; xmm6=MULTIPLY(tmp12,FIX_1_306562)
+    addps       xmm1, xmm2              ; xmm1=z2
+    addps       xmm6, xmm2              ; xmm6=z4
+
+    movaps      xmm5, xmm0
+    subps       xmm0, xmm3              ; xmm0=z13
+    addps       xmm5, xmm3              ; xmm5=z11
+
+    movaps      xmm7, xmm0
+    movaps      xmm4, xmm5
+    subps       xmm0, xmm1              ; xmm0=data3
+    subps       xmm5, xmm6              ; xmm5=data7
+    addps       xmm7, xmm1              ; xmm7=data5
+    addps       xmm4, xmm6              ; xmm4=data1
+
+    movaps      XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_FAST_FLOAT)], xmm7
+    movaps      XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)], xmm4
+
+    add         rdx, byte 4*SIZEOF_FAST_FLOAT
+    dec         rcx
+    jnz         near .columnloop
+
+    uncollect_args 1
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jfdctfst-sse2.asm b/simd/x86_64/jfdctfst-sse2.asm
new file mode 100644
index 0000000..479e5da
--- /dev/null
+++ b/simd/x86_64/jfdctfst-sse2.asm
@@ -0,0 +1,391 @@
+;
+; jfdctfst.asm - fast integer FDCT (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a fast, not so accurate integer implementation of
+; the forward DCT (Discrete Cosine Transform). The following code is
+; based directly on the IJG's original jfdctfst.c; see the jfdctfst.c
+; for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  8  ; 14 is also OK.
+
+%if CONST_BITS == 8
+F_0_382 equ  98  ; FIX(0.382683433)
+F_0_541 equ 139  ; FIX(0.541196100)
+F_0_707 equ 181  ; FIX(0.707106781)
+F_1_306 equ 334  ; FIX(1.306562965)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_382 equ DESCALE( 410903207, 30-CONST_BITS)  ; FIX(0.382683433)
+F_0_541 equ DESCALE( 581104887, 30-CONST_BITS)  ; FIX(0.541196100)
+F_0_707 equ DESCALE( 759250124, 30-CONST_BITS)  ; FIX(0.707106781)
+F_1_306 equ DESCALE(1402911301, 30-CONST_BITS)  ; FIX(1.306562965)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
+; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
+
+%define PRE_MULTIPLY_SCALE_BITS  2
+%define CONST_SHIFT              (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
+
+    alignz      32
+    global      EXTN(jconst_fdct_ifast_sse2)
+
+EXTN(jconst_fdct_ifast_sse2):
+
+PW_F0707 times 8 dw F_0_707 << CONST_SHIFT
+PW_F0382 times 8 dw F_0_382 << CONST_SHIFT
+PW_F0541 times 8 dw F_0_541 << CONST_SHIFT
+PW_F1306 times 8 dw F_1_306 << CONST_SHIFT
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Perform the forward DCT on one block of samples.
+;
+; GLOBAL(void)
+; jsimd_fdct_ifast_sse2 (DCTELEM *data)
+;
+
+; r10 = DCTELEM *data
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  2
+
+    align       32
+    global      EXTN(jsimd_fdct_ifast_sse2)
+
+EXTN(jsimd_fdct_ifast_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 1
+
+    ; ---- Pass 1: process rows.
+
+    mov         rdx, r10                ; (DCTELEM *)
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)]
+
+    ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
+    ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm4, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm1              ; xmm0=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm4, xmm1              ; xmm4=(04 14 05 15 06 16 07 17)
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm3              ; xmm2=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm5, xmm3              ; xmm5=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm6, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm7, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)]
+
+    ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
+    ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
+    movdqa      XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm2, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm7              ; xmm6=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm2, xmm7              ; xmm2=(44 54 45 55 46 56 47 57)
+    movdqa      xmm5, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm3              ; xmm1=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm5, xmm3              ; xmm5=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm7, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm1              ; xmm6=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm7, xmm1              ; xmm7=(42 52 62 72 43 53 63 73)
+    movdqa      xmm3, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm5              ; xmm2=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm3, xmm5              ; xmm3=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=(42 52 62 72 43 53 63 73)
+    movdqa      XMMWORD [wk(1)], xmm2   ; wk(1)=(44 54 64 74 45 55 65 75)
+
+    movdqa      xmm7, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm1              ; xmm0=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm7, xmm1              ; xmm7=(02 12 22 32 03 13 23 33)
+    movdqa      xmm2, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm5              ; xmm4=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm2, xmm5              ; xmm2=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm1, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm6              ; xmm0=(00 10 20 30 40 50 60 70)=data0
+    punpckhqdq  xmm1, xmm6              ; xmm1=(01 11 21 31 41 51 61 71)=data1
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm3              ; xmm2=(06 16 26 36 46 56 66 76)=data6
+    punpckhqdq  xmm5, xmm3              ; xmm5=(07 17 27 37 47 57 67 77)=data7
+
+    movdqa      xmm6, xmm1
+    movdqa      xmm3, xmm0
+    psubw       xmm1, xmm2              ; xmm1=data1-data6=tmp6
+    psubw       xmm0, xmm5              ; xmm0=data0-data7=tmp7
+    paddw       xmm6, xmm2              ; xmm6=data1+data6=tmp1
+    paddw       xmm3, xmm5              ; xmm3=data0+data7=tmp0
+
+    movdqa      xmm2, XMMWORD [wk(0)]   ; xmm2=(42 52 62 72 43 53 63 73)
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=(44 54 64 74 45 55 65 75)
+    movdqa      XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
+
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm2              ; xmm7=(02 12 22 32 42 52 62 72)=data2
+    punpckhqdq  xmm1, xmm2              ; xmm1=(03 13 23 33 43 53 63 73)=data3
+    movdqa      xmm0, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm5              ; xmm4=(04 14 24 34 44 54 64 74)=data4
+    punpckhqdq  xmm0, xmm5              ; xmm0=(05 15 25 35 45 55 65 75)=data5
+
+    movdqa      xmm2, xmm1
+    movdqa      xmm5, xmm7
+    paddw       xmm1, xmm4              ; xmm1=data3+data4=tmp3
+    paddw       xmm7, xmm0              ; xmm7=data2+data5=tmp2
+    psubw       xmm2, xmm4              ; xmm2=data3-data4=tmp4
+    psubw       xmm5, xmm0              ; xmm5=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm0, xmm6
+    psubw       xmm3, xmm1              ; xmm3=tmp13
+    psubw       xmm6, xmm7              ; xmm6=tmp12
+    paddw       xmm4, xmm1              ; xmm4=tmp10
+    paddw       xmm0, xmm7              ; xmm0=tmp11
+
+    paddw       xmm6, xmm3
+    psllw       xmm6, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm6, [rel PW_F0707]    ; xmm6=z1
+
+    movdqa      xmm1, xmm4
+    movdqa      xmm7, xmm3
+    psubw       xmm4, xmm0              ; xmm4=data4
+    psubw       xmm3, xmm6              ; xmm3=data6
+    paddw       xmm1, xmm0              ; xmm1=data0
+    paddw       xmm7, xmm6              ; xmm7=data2
+
+    movdqa      xmm0, XMMWORD [wk(0)]   ; xmm0=tmp6
+    movdqa      xmm6, XMMWORD [wk(1)]   ; xmm6=tmp7
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=data4
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=data6
+
+    ; -- Odd part
+
+    paddw       xmm2, xmm5              ; xmm2=tmp10
+    paddw       xmm5, xmm0              ; xmm5=tmp11
+    paddw       xmm0, xmm6              ; xmm0=tmp12, xmm6=tmp7
+
+    psllw       xmm2, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm0, PRE_MULTIPLY_SCALE_BITS
+
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm5, [rel PW_F0707]    ; xmm5=z3
+
+    movdqa      xmm4, xmm2              ; xmm4=tmp10
+    psubw       xmm2, xmm0
+    pmulhw      xmm2, [rel PW_F0382]    ; xmm2=z5
+    pmulhw      xmm4, [rel PW_F0541]    ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
+    pmulhw      xmm0, [rel PW_F1306]    ; xmm0=MULTIPLY(tmp12,FIX_1_306562)
+    paddw       xmm4, xmm2              ; xmm4=z2
+    paddw       xmm0, xmm2              ; xmm0=z4
+
+    movdqa      xmm3, xmm6
+    psubw       xmm6, xmm5              ; xmm6=z13
+    paddw       xmm3, xmm5              ; xmm3=z11
+
+    movdqa      xmm2, xmm6
+    movdqa      xmm5, xmm3
+    psubw       xmm6, xmm4              ; xmm6=data3
+    psubw       xmm3, xmm0              ; xmm3=data7
+    paddw       xmm2, xmm4              ; xmm2=data5
+    paddw       xmm5, xmm0              ; xmm5=data1
+
+    ; ---- Pass 2: process columns.
+
+    ; xmm1=(00 10 20 30 40 50 60 70), xmm7=(02 12 22 32 42 52 62 72)
+    ; xmm5=(01 11 21 31 41 51 61 71), xmm6=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm4, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm5              ; xmm1=(00 01 10 11 20 21 30 31)
+    punpckhwd   xmm4, xmm5              ; xmm4=(40 41 50 51 60 61 70 71)
+    movdqa      xmm0, xmm7              ; transpose coefficients(phase 1)
+    punpcklwd   xmm7, xmm6              ; xmm7=(02 03 12 13 22 23 32 33)
+    punpckhwd   xmm0, xmm6              ; xmm0=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=col4
+    movdqa      xmm6, XMMWORD [wk(1)]   ; xmm6=col6
+
+    ; xmm5=(04 14 24 34 44 54 64 74), xmm6=(06 16 26 36 46 56 66 76)
+    ; xmm2=(05 15 25 35 45 55 65 75), xmm3=(07 17 27 37 47 57 67 77)
+
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=(02 03 12 13 22 23 32 33)
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm7, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm2              ; xmm5=(04 05 14 15 24 25 34 35)
+    punpckhwd   xmm7, xmm2              ; xmm7=(44 45 54 55 64 65 74 75)
+    movdqa      xmm0, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm3              ; xmm6=(06 07 16 17 26 27 36 37)
+    punpckhwd   xmm0, xmm3              ; xmm0=(46 47 56 57 66 67 76 77)
+
+    movdqa      xmm2, xmm5              ; transpose coefficients(phase 2)
+    punpckldq   xmm5, xmm6              ; xmm5=(04 05 06 07 14 15 16 17)
+    punpckhdq   xmm2, xmm6              ; xmm2=(24 25 26 27 34 35 36 37)
+    movdqa      xmm3, xmm7              ; transpose coefficients(phase 2)
+    punpckldq   xmm7, xmm0              ; xmm7=(44 45 46 47 54 55 56 57)
+    punpckhdq   xmm3, xmm0              ; xmm3=(64 65 66 67 74 75 76 77)
+
+    movdqa      xmm6, XMMWORD [wk(0)]   ; xmm6=(02 03 12 13 22 23 32 33)
+    movdqa      xmm0, XMMWORD [wk(1)]   ; xmm0=(42 43 52 53 62 63 72 73)
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=(24 25 26 27 34 35 36 37)
+    movdqa      XMMWORD [wk(1)], xmm7   ; wk(1)=(44 45 46 47 54 55 56 57)
+
+    movdqa      xmm2, xmm1              ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm6              ; xmm1=(00 01 02 03 10 11 12 13)
+    punpckhdq   xmm2, xmm6              ; xmm2=(20 21 22 23 30 31 32 33)
+    movdqa      xmm7, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm0              ; xmm4=(40 41 42 43 50 51 52 53)
+    punpckhdq   xmm7, xmm0              ; xmm7=(60 61 62 63 70 71 72 73)
+
+    movdqa      xmm6, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm5              ; xmm1=(00 01 02 03 04 05 06 07)=data0
+    punpckhqdq  xmm6, xmm5              ; xmm6=(10 11 12 13 14 15 16 17)=data1
+    movdqa      xmm0, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm3              ; xmm7=(60 61 62 63 64 65 66 67)=data6
+    punpckhqdq  xmm0, xmm3              ; xmm0=(70 71 72 73 74 75 76 77)=data7
+
+    movdqa      xmm5, xmm6
+    movdqa      xmm3, xmm1
+    psubw       xmm6, xmm7              ; xmm6=data1-data6=tmp6
+    psubw       xmm1, xmm0              ; xmm1=data0-data7=tmp7
+    paddw       xmm5, xmm7              ; xmm5=data1+data6=tmp1
+    paddw       xmm3, xmm0              ; xmm3=data0+data7=tmp0
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=(24 25 26 27 34 35 36 37)
+    movdqa      xmm0, XMMWORD [wk(1)]   ; xmm0=(44 45 46 47 54 55 56 57)
+    movdqa      XMMWORD [wk(0)], xmm6   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm1   ; wk(1)=tmp7
+
+    movdqa      xmm6, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm7              ; xmm2=(20 21 22 23 24 25 26 27)=data2
+    punpckhqdq  xmm6, xmm7              ; xmm6=(30 31 32 33 34 35 36 37)=data3
+    movdqa      xmm1, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm0              ; xmm4=(40 41 42 43 44 45 46 47)=data4
+    punpckhqdq  xmm1, xmm0              ; xmm1=(50 51 52 53 54 55 56 57)=data5
+
+    movdqa      xmm7, xmm6
+    movdqa      xmm0, xmm2
+    paddw       xmm6, xmm4              ; xmm6=data3+data4=tmp3
+    paddw       xmm2, xmm1              ; xmm2=data2+data5=tmp2
+    psubw       xmm7, xmm4              ; xmm7=data3-data4=tmp4
+    psubw       xmm0, xmm1              ; xmm0=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm1, xmm5
+    psubw       xmm3, xmm6              ; xmm3=tmp13
+    psubw       xmm5, xmm2              ; xmm5=tmp12
+    paddw       xmm4, xmm6              ; xmm4=tmp10
+    paddw       xmm1, xmm2              ; xmm1=tmp11
+
+    paddw       xmm5, xmm3
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm5, [rel PW_F0707]    ; xmm5=z1
+
+    movdqa      xmm6, xmm4
+    movdqa      xmm2, xmm3
+    psubw       xmm4, xmm1              ; xmm4=data4
+    psubw       xmm3, xmm5              ; xmm3=data6
+    paddw       xmm6, xmm1              ; xmm6=data0
+    paddw       xmm2, xmm5              ; xmm2=data2
+
+    movdqa      XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)], xmm4
+    movdqa      XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)], xmm3
+    movdqa      XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)], xmm6
+    movdqa      XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)], xmm2
+
+    ; -- Odd part
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=tmp6
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
+
+    paddw       xmm7, xmm0              ; xmm7=tmp10
+    paddw       xmm0, xmm1              ; xmm0=tmp11
+    paddw       xmm1, xmm5              ; xmm1=tmp12, xmm5=tmp7
+
+    psllw       xmm7, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm1, PRE_MULTIPLY_SCALE_BITS
+
+    psllw       xmm0, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm0, [rel PW_F0707]    ; xmm0=z3
+
+    movdqa      xmm4, xmm7              ; xmm4=tmp10
+    psubw       xmm7, xmm1
+    pmulhw      xmm7, [rel PW_F0382]    ; xmm7=z5
+    pmulhw      xmm4, [rel PW_F0541]    ; xmm4=MULTIPLY(tmp10,FIX_0_541196)
+    pmulhw      xmm1, [rel PW_F1306]    ; xmm1=MULTIPLY(tmp12,FIX_1_306562)
+    paddw       xmm4, xmm7              ; xmm4=z2
+    paddw       xmm1, xmm7              ; xmm1=z4
+
+    movdqa      xmm3, xmm5
+    psubw       xmm5, xmm0              ; xmm5=z13
+    paddw       xmm3, xmm0              ; xmm3=z11
+
+    movdqa      xmm6, xmm5
+    movdqa      xmm2, xmm3
+    psubw       xmm5, xmm4              ; xmm5=data3
+    psubw       xmm3, xmm1              ; xmm3=data7
+    paddw       xmm6, xmm4              ; xmm6=data5
+    paddw       xmm2, xmm1              ; xmm2=data1
+
+    movdqa      XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)], xmm5
+    movdqa      XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)], xmm3
+    movdqa      XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)], xmm6
+    movdqa      XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)], xmm2
+
+    uncollect_args 1
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jfdctint-sse2.asm b/simd/x86_64/jfdctint-sse2.asm
new file mode 100644
index 0000000..cdaa56f
--- /dev/null
+++ b/simd/x86_64/jfdctint-sse2.asm
@@ -0,0 +1,621 @@
+;
+; jfdctint.asm - accurate integer FDCT (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a slow-but-accurate integer implementation of the
+; forward DCT (Discrete Cosine Transform). The following code is based
+; directly on the IJG's original jfdctint.c; see the jfdctint.c for
+; more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  13
+%define PASS1_BITS  2
+
+%define DESCALE_P1  (CONST_BITS-PASS1_BITS)
+%define DESCALE_P2  (CONST_BITS+PASS1_BITS)
+
+%if CONST_BITS == 13
+F_0_298 equ  2446  ; FIX(0.298631336)
+F_0_390 equ  3196  ; FIX(0.390180644)
+F_0_541 equ  4433  ; FIX(0.541196100)
+F_0_765 equ  6270  ; FIX(0.765366865)
+F_0_899 equ  7373  ; FIX(0.899976223)
+F_1_175 equ  9633  ; FIX(1.175875602)
+F_1_501 equ 12299  ; FIX(1.501321110)
+F_1_847 equ 15137  ; FIX(1.847759065)
+F_1_961 equ 16069  ; FIX(1.961570560)
+F_2_053 equ 16819  ; FIX(2.053119869)
+F_2_562 equ 20995  ; FIX(2.562915447)
+F_3_072 equ 25172  ; FIX(3.072711026)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_298 equ DESCALE( 320652955, 30-CONST_BITS)  ; FIX(0.298631336)
+F_0_390 equ DESCALE( 418953276, 30-CONST_BITS)  ; FIX(0.390180644)
+F_0_541 equ DESCALE( 581104887, 30-CONST_BITS)  ; FIX(0.541196100)
+F_0_765 equ DESCALE( 821806413, 30-CONST_BITS)  ; FIX(0.765366865)
+F_0_899 equ DESCALE( 966342111, 30-CONST_BITS)  ; FIX(0.899976223)
+F_1_175 equ DESCALE(1262586813, 30-CONST_BITS)  ; FIX(1.175875602)
+F_1_501 equ DESCALE(1612031267, 30-CONST_BITS)  ; FIX(1.501321110)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_1_961 equ DESCALE(2106220350, 30-CONST_BITS)  ; FIX(1.961570560)
+F_2_053 equ DESCALE(2204520673, 30-CONST_BITS)  ; FIX(2.053119869)
+F_2_562 equ DESCALE(2751909506, 30-CONST_BITS)  ; FIX(2.562915447)
+F_3_072 equ DESCALE(3299298341, 30-CONST_BITS)  ; FIX(3.072711026)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_fdct_islow_sse2)
+
+EXTN(jconst_fdct_islow_sse2):
+
+PW_F130_F054   times 4 dw  (F_0_541+F_0_765), F_0_541
+PW_F054_MF130  times 4 dw  F_0_541, (F_0_541-F_1_847)
+PW_MF078_F117  times 4 dw  (F_1_175-F_1_961), F_1_175
+PW_F117_F078   times 4 dw  F_1_175, (F_1_175-F_0_390)
+PW_MF060_MF089 times 4 dw  (F_0_298-F_0_899),-F_0_899
+PW_MF089_F060  times 4 dw -F_0_899, (F_1_501-F_0_899)
+PW_MF050_MF256 times 4 dw  (F_2_053-F_2_562),-F_2_562
+PW_MF256_F050  times 4 dw -F_2_562, (F_3_072-F_2_562)
+PD_DESCALE_P1  times 4 dd  1 << (DESCALE_P1-1)
+PD_DESCALE_P2  times 4 dd  1 << (DESCALE_P2-1)
+PW_DESCALE_P2X times 8 dw  1 << (PASS1_BITS-1)
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Perform the forward DCT on one block of samples.
+;
+; GLOBAL(void)
+; jsimd_fdct_islow_sse2 (DCTELEM *data)
+;
+
+; r10 = DCTELEM *data
+
+%define wk(i)   rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM  6
+
+    align       32
+    global      EXTN(jsimd_fdct_islow_sse2)
+
+EXTN(jsimd_fdct_islow_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 1
+
+    ; ---- Pass 1: process rows.
+
+    mov         rdx, r10                ; (DCTELEM *)
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)]
+
+    ; xmm0=(00 01 02 03 04 05 06 07), xmm2=(20 21 22 23 24 25 26 27)
+    ; xmm1=(10 11 12 13 14 15 16 17), xmm3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm4, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm1              ; xmm0=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm4, xmm1              ; xmm4=(04 14 05 15 06 16 07 17)
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm3              ; xmm2=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm5, xmm3              ; xmm5=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm6, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm7, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)]
+
+    ; xmm6=( 4 12 20 28 36 44 52 60), xmm1=( 6 14 22 30 38 46 54 62)
+    ; xmm7=( 5 13 21 29 37 45 53 61), xmm3=( 7 15 23 31 39 47 55 63)
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=(20 30 21 31 22 32 23 33)
+    movdqa      XMMWORD [wk(1)], xmm5   ; wk(1)=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm2, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm7              ; xmm6=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm2, xmm7              ; xmm2=(44 54 45 55 46 56 47 57)
+    movdqa      xmm5, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm3              ; xmm1=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm5, xmm3              ; xmm5=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm7, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm1              ; xmm6=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm7, xmm1              ; xmm7=(42 52 62 72 43 53 63 73)
+    movdqa      xmm3, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm5              ; xmm2=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm3, xmm5              ; xmm3=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=(20 30 21 31 22 32 23 33)
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=(24 34 25 35 26 36 27 37)
+    movdqa      XMMWORD [wk(2)], xmm7   ; wk(2)=(42 52 62 72 43 53 63 73)
+    movdqa      XMMWORD [wk(3)], xmm2   ; wk(3)=(44 54 64 74 45 55 65 75)
+
+    movdqa      xmm7, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm1              ; xmm0=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm7, xmm1              ; xmm7=(02 12 22 32 03 13 23 33)
+    movdqa      xmm2, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm5              ; xmm4=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm2, xmm5              ; xmm2=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm1, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm6              ; xmm0=(00 10 20 30 40 50 60 70)=data0
+    punpckhqdq  xmm1, xmm6              ; xmm1=(01 11 21 31 41 51 61 71)=data1
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm3              ; xmm2=(06 16 26 36 46 56 66 76)=data6
+    punpckhqdq  xmm5, xmm3              ; xmm5=(07 17 27 37 47 57 67 77)=data7
+
+    movdqa      xmm6, xmm1
+    movdqa      xmm3, xmm0
+    psubw       xmm1, xmm2              ; xmm1=data1-data6=tmp6
+    psubw       xmm0, xmm5              ; xmm0=data0-data7=tmp7
+    paddw       xmm6, xmm2              ; xmm6=data1+data6=tmp1
+    paddw       xmm3, xmm5              ; xmm3=data0+data7=tmp0
+
+    movdqa      xmm2, XMMWORD [wk(2)]   ; xmm2=(42 52 62 72 43 53 63 73)
+    movdqa      xmm5, XMMWORD [wk(3)]   ; xmm5=(44 54 64 74 45 55 65 75)
+    movdqa      XMMWORD [wk(0)], xmm1   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=tmp7
+
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm2              ; xmm7=(02 12 22 32 42 52 62 72)=data2
+    punpckhqdq  xmm1, xmm2              ; xmm1=(03 13 23 33 43 53 63 73)=data3
+    movdqa      xmm0, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm5              ; xmm4=(04 14 24 34 44 54 64 74)=data4
+    punpckhqdq  xmm0, xmm5              ; xmm0=(05 15 25 35 45 55 65 75)=data5
+
+    movdqa      xmm2, xmm1
+    movdqa      xmm5, xmm7
+    paddw       xmm1, xmm4              ; xmm1=data3+data4=tmp3
+    paddw       xmm7, xmm0              ; xmm7=data2+data5=tmp2
+    psubw       xmm2, xmm4              ; xmm2=data3-data4=tmp4
+    psubw       xmm5, xmm0              ; xmm5=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm0, xmm6
+    paddw       xmm3, xmm1              ; xmm3=tmp10
+    paddw       xmm6, xmm7              ; xmm6=tmp11
+    psubw       xmm4, xmm1              ; xmm4=tmp13
+    psubw       xmm0, xmm7              ; xmm0=tmp12
+
+    movdqa      xmm1, xmm3
+    paddw       xmm3, xmm6              ; xmm3=tmp10+tmp11
+    psubw       xmm1, xmm6              ; xmm1=tmp10-tmp11
+
+    psllw       xmm3, PASS1_BITS        ; xmm3=data0
+    psllw       xmm1, PASS1_BITS        ; xmm1=data4
+
+    movdqa      XMMWORD [wk(2)], xmm3   ; wk(2)=data0
+    movdqa      XMMWORD [wk(3)], xmm1   ; wk(3)=data4
+
+    ; (Original)
+    ; z1 = (tmp12 + tmp13) * 0.541196100;
+    ; data2 = z1 + tmp13 * 0.765366865;
+    ; data6 = z1 + tmp12 * -1.847759065;
+    ;
+    ; (This implementation)
+    ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
+    ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
+
+    movdqa      xmm7, xmm4              ; xmm4=tmp13
+    movdqa      xmm6, xmm4
+    punpcklwd   xmm7, xmm0              ; xmm0=tmp12
+    punpckhwd   xmm6, xmm0
+    movdqa      xmm4, xmm7
+    movdqa      xmm0, xmm6
+    pmaddwd     xmm7, [rel PW_F130_F054]   ; xmm7=data2L
+    pmaddwd     xmm6, [rel PW_F130_F054]   ; xmm6=data2H
+    pmaddwd     xmm4, [rel PW_F054_MF130]  ; xmm4=data6L
+    pmaddwd     xmm0, [rel PW_F054_MF130]  ; xmm0=data6H
+
+    paddd       xmm7, [rel PD_DESCALE_P1]
+    paddd       xmm6, [rel PD_DESCALE_P1]
+    psrad       xmm7, DESCALE_P1
+    psrad       xmm6, DESCALE_P1
+    paddd       xmm4, [rel PD_DESCALE_P1]
+    paddd       xmm0, [rel PD_DESCALE_P1]
+    psrad       xmm4, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+
+    packssdw    xmm7, xmm6              ; xmm7=data2
+    packssdw    xmm4, xmm0              ; xmm4=data6
+
+    movdqa      XMMWORD [wk(4)], xmm7   ; wk(4)=data2
+    movdqa      XMMWORD [wk(5)], xmm4   ; wk(5)=data6
+
+    ; -- Odd part
+
+    movdqa      xmm3, XMMWORD [wk(0)]   ; xmm3=tmp6
+    movdqa      xmm1, XMMWORD [wk(1)]   ; xmm1=tmp7
+
+    movdqa      xmm6, xmm2              ; xmm2=tmp4
+    movdqa      xmm0, xmm5              ; xmm5=tmp5
+    paddw       xmm6, xmm3              ; xmm6=z3
+    paddw       xmm0, xmm1              ; xmm0=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm7, xmm6
+    movdqa      xmm4, xmm6
+    punpcklwd   xmm7, xmm0
+    punpckhwd   xmm4, xmm0
+    movdqa      xmm6, xmm7
+    movdqa      xmm0, xmm4
+    pmaddwd     xmm7, [rel PW_MF078_F117]  ; xmm7=z3L
+    pmaddwd     xmm4, [rel PW_MF078_F117]  ; xmm4=z3H
+    pmaddwd     xmm6, [rel PW_F117_F078]   ; xmm6=z4L
+    pmaddwd     xmm0, [rel PW_F117_F078]   ; xmm0=z4H
+
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=z3L
+    movdqa      XMMWORD [wk(1)], xmm4   ; wk(1)=z3H
+
+    ; (Original)
+    ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
+    ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
+    ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
+    ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
+    ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
+    ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
+    ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
+    ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
+    ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
+
+    movdqa      xmm7, xmm2
+    movdqa      xmm4, xmm2
+    punpcklwd   xmm7, xmm1
+    punpckhwd   xmm4, xmm1
+    movdqa      xmm2, xmm7
+    movdqa      xmm1, xmm4
+    pmaddwd     xmm7, [rel PW_MF060_MF089]  ; xmm7=tmp4L
+    pmaddwd     xmm4, [rel PW_MF060_MF089]  ; xmm4=tmp4H
+    pmaddwd     xmm2, [rel PW_MF089_F060]   ; xmm2=tmp7L
+    pmaddwd     xmm1, [rel PW_MF089_F060]   ; xmm1=tmp7H
+
+    paddd       xmm7, XMMWORD [wk(0)]   ; xmm7=data7L
+    paddd       xmm4, XMMWORD [wk(1)]   ; xmm4=data7H
+    paddd       xmm2, xmm6              ; xmm2=data1L
+    paddd       xmm1, xmm0              ; xmm1=data1H
+
+    paddd       xmm7, [rel PD_DESCALE_P1]
+    paddd       xmm4, [rel PD_DESCALE_P1]
+    psrad       xmm7, DESCALE_P1
+    psrad       xmm4, DESCALE_P1
+    paddd       xmm2, [rel PD_DESCALE_P1]
+    paddd       xmm1, [rel PD_DESCALE_P1]
+    psrad       xmm2, DESCALE_P1
+    psrad       xmm1, DESCALE_P1
+
+    packssdw    xmm7, xmm4              ; xmm7=data7
+    packssdw    xmm2, xmm1              ; xmm2=data1
+
+    movdqa      xmm4, xmm5
+    movdqa      xmm1, xmm5
+    punpcklwd   xmm4, xmm3
+    punpckhwd   xmm1, xmm3
+    movdqa      xmm5, xmm4
+    movdqa      xmm3, xmm1
+    pmaddwd     xmm4, [rel PW_MF050_MF256]  ; xmm4=tmp5L
+    pmaddwd     xmm1, [rel PW_MF050_MF256]  ; xmm1=tmp5H
+    pmaddwd     xmm5, [rel PW_MF256_F050]   ; xmm5=tmp6L
+    pmaddwd     xmm3, [rel PW_MF256_F050]   ; xmm3=tmp6H
+
+    paddd       xmm4, xmm6              ; xmm4=data5L
+    paddd       xmm1, xmm0              ; xmm1=data5H
+    paddd       xmm5, XMMWORD [wk(0)]   ; xmm5=data3L
+    paddd       xmm3, XMMWORD [wk(1)]   ; xmm3=data3H
+
+    paddd       xmm4, [rel PD_DESCALE_P1]
+    paddd       xmm1, [rel PD_DESCALE_P1]
+    psrad       xmm4, DESCALE_P1
+    psrad       xmm1, DESCALE_P1
+    paddd       xmm5, [rel PD_DESCALE_P1]
+    paddd       xmm3, [rel PD_DESCALE_P1]
+    psrad       xmm5, DESCALE_P1
+    psrad       xmm3, DESCALE_P1
+
+    packssdw    xmm4, xmm1              ; xmm4=data5
+    packssdw    xmm5, xmm3              ; xmm5=data3
+
+    ; ---- Pass 2: process columns.
+
+    movdqa      xmm6, XMMWORD [wk(2)]   ; xmm6=col0
+    movdqa      xmm0, XMMWORD [wk(4)]   ; xmm0=col2
+
+    ; xmm6=(00 10 20 30 40 50 60 70), xmm0=(02 12 22 32 42 52 62 72)
+    ; xmm2=(01 11 21 31 41 51 61 71), xmm5=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm1, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm2              ; xmm6=(00 01 10 11 20 21 30 31)
+    punpckhwd   xmm1, xmm2              ; xmm1=(40 41 50 51 60 61 70 71)
+    movdqa      xmm3, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm5              ; xmm0=(02 03 12 13 22 23 32 33)
+    punpckhwd   xmm3, xmm5              ; xmm3=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm2, XMMWORD [wk(3)]   ; xmm2=col4
+    movdqa      xmm5, XMMWORD [wk(5)]   ; xmm5=col6
+
+    ; xmm2=(04 14 24 34 44 54 64 74), xmm5=(06 16 26 36 46 56 66 76)
+    ; xmm4=(05 15 25 35 45 55 65 75), xmm7=(07 17 27 37 47 57 67 77)
+
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=(02 03 12 13 22 23 32 33)
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=(42 43 52 53 62 63 72 73)
+
+    movdqa      xmm0, xmm2              ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm4              ; xmm2=(04 05 14 15 24 25 34 35)
+    punpckhwd   xmm0, xmm4              ; xmm0=(44 45 54 55 64 65 74 75)
+    movdqa      xmm3, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm7              ; xmm5=(06 07 16 17 26 27 36 37)
+    punpckhwd   xmm3, xmm7              ; xmm3=(46 47 56 57 66 67 76 77)
+
+    movdqa      xmm4, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm5              ; xmm2=(04 05 06 07 14 15 16 17)
+    punpckhdq   xmm4, xmm5              ; xmm4=(24 25 26 27 34 35 36 37)
+    movdqa      xmm7, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm3              ; xmm0=(44 45 46 47 54 55 56 57)
+    punpckhdq   xmm7, xmm3              ; xmm7=(64 65 66 67 74 75 76 77)
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=(02 03 12 13 22 23 32 33)
+    movdqa      xmm3, XMMWORD [wk(1)]   ; xmm3=(42 43 52 53 62 63 72 73)
+    movdqa      XMMWORD [wk(2)], xmm4   ; wk(2)=(24 25 26 27 34 35 36 37)
+    movdqa      XMMWORD [wk(3)], xmm0   ; wk(3)=(44 45 46 47 54 55 56 57)
+
+    movdqa      xmm4, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm5              ; xmm6=(00 01 02 03 10 11 12 13)
+    punpckhdq   xmm4, xmm5              ; xmm4=(20 21 22 23 30 31 32 33)
+    movdqa      xmm0, xmm1              ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm3              ; xmm1=(40 41 42 43 50 51 52 53)
+    punpckhdq   xmm0, xmm3              ; xmm0=(60 61 62 63 70 71 72 73)
+
+    movdqa      xmm5, xmm6              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm6, xmm2              ; xmm6=(00 01 02 03 04 05 06 07)=data0
+    punpckhqdq  xmm5, xmm2              ; xmm5=(10 11 12 13 14 15 16 17)=data1
+    movdqa      xmm3, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm7              ; xmm0=(60 61 62 63 64 65 66 67)=data6
+    punpckhqdq  xmm3, xmm7              ; xmm3=(70 71 72 73 74 75 76 77)=data7
+
+    movdqa      xmm2, xmm5
+    movdqa      xmm7, xmm6
+    psubw       xmm5, xmm0              ; xmm5=data1-data6=tmp6
+    psubw       xmm6, xmm3              ; xmm6=data0-data7=tmp7
+    paddw       xmm2, xmm0              ; xmm2=data1+data6=tmp1
+    paddw       xmm7, xmm3              ; xmm7=data0+data7=tmp0
+
+    movdqa      xmm0, XMMWORD [wk(2)]   ; xmm0=(24 25 26 27 34 35 36 37)
+    movdqa      xmm3, XMMWORD [wk(3)]   ; xmm3=(44 45 46 47 54 55 56 57)
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=tmp6
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp7
+
+    movdqa      xmm5, xmm4              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm4, xmm0              ; xmm4=(20 21 22 23 24 25 26 27)=data2
+    punpckhqdq  xmm5, xmm0              ; xmm5=(30 31 32 33 34 35 36 37)=data3
+    movdqa      xmm6, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm3              ; xmm1=(40 41 42 43 44 45 46 47)=data4
+    punpckhqdq  xmm6, xmm3              ; xmm6=(50 51 52 53 54 55 56 57)=data5
+
+    movdqa      xmm0, xmm5
+    movdqa      xmm3, xmm4
+    paddw       xmm5, xmm1              ; xmm5=data3+data4=tmp3
+    paddw       xmm4, xmm6              ; xmm4=data2+data5=tmp2
+    psubw       xmm0, xmm1              ; xmm0=data3-data4=tmp4
+    psubw       xmm3, xmm6              ; xmm3=data2-data5=tmp5
+
+    ; -- Even part
+
+    movdqa      xmm1, xmm7
+    movdqa      xmm6, xmm2
+    paddw       xmm7, xmm5              ; xmm7=tmp10
+    paddw       xmm2, xmm4              ; xmm2=tmp11
+    psubw       xmm1, xmm5              ; xmm1=tmp13
+    psubw       xmm6, xmm4              ; xmm6=tmp12
+
+    movdqa      xmm5, xmm7
+    paddw       xmm7, xmm2              ; xmm7=tmp10+tmp11
+    psubw       xmm5, xmm2              ; xmm5=tmp10-tmp11
+
+    paddw       xmm7, [rel PW_DESCALE_P2X]
+    paddw       xmm5, [rel PW_DESCALE_P2X]
+    psraw       xmm7, PASS1_BITS        ; xmm7=data0
+    psraw       xmm5, PASS1_BITS        ; xmm5=data4
+
+    movdqa      XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_DCTELEM)], xmm7
+    movdqa      XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_DCTELEM)], xmm5
+
+    ; (Original)
+    ; z1 = (tmp12 + tmp13) * 0.541196100;
+    ; data2 = z1 + tmp13 * 0.765366865;
+    ; data6 = z1 + tmp12 * -1.847759065;
+    ;
+    ; (This implementation)
+    ; data2 = tmp13 * (0.541196100 + 0.765366865) + tmp12 * 0.541196100;
+    ; data6 = tmp13 * 0.541196100 + tmp12 * (0.541196100 - 1.847759065);
+
+    movdqa      xmm4, xmm1              ; xmm1=tmp13
+    movdqa      xmm2, xmm1
+    punpcklwd   xmm4, xmm6              ; xmm6=tmp12
+    punpckhwd   xmm2, xmm6
+    movdqa      xmm1, xmm4
+    movdqa      xmm6, xmm2
+    pmaddwd     xmm4, [rel PW_F130_F054]   ; xmm4=data2L
+    pmaddwd     xmm2, [rel PW_F130_F054]   ; xmm2=data2H
+    pmaddwd     xmm1, [rel PW_F054_MF130]  ; xmm1=data6L
+    pmaddwd     xmm6, [rel PW_F054_MF130]  ; xmm6=data6H
+
+    paddd       xmm4, [rel PD_DESCALE_P2]
+    paddd       xmm2, [rel PD_DESCALE_P2]
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm2, DESCALE_P2
+    paddd       xmm1, [rel PD_DESCALE_P2]
+    paddd       xmm6, [rel PD_DESCALE_P2]
+    psrad       xmm1, DESCALE_P2
+    psrad       xmm6, DESCALE_P2
+
+    packssdw    xmm4, xmm2              ; xmm4=data2
+    packssdw    xmm1, xmm6              ; xmm1=data6
+
+    movdqa      XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_DCTELEM)], xmm4
+    movdqa      XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_DCTELEM)], xmm1
+
+    ; -- Odd part
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp6
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp7
+
+    movdqa      xmm2, xmm0              ; xmm0=tmp4
+    movdqa      xmm6, xmm3              ; xmm3=tmp5
+    paddw       xmm2, xmm7              ; xmm2=z3
+    paddw       xmm6, xmm5              ; xmm6=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm1, xmm2
+    punpcklwd   xmm4, xmm6
+    punpckhwd   xmm1, xmm6
+    movdqa      xmm2, xmm4
+    movdqa      xmm6, xmm1
+    pmaddwd     xmm4, [rel PW_MF078_F117]  ; xmm4=z3L
+    pmaddwd     xmm1, [rel PW_MF078_F117]  ; xmm1=z3H
+    pmaddwd     xmm2, [rel PW_F117_F078]   ; xmm2=z4L
+    pmaddwd     xmm6, [rel PW_F117_F078]   ; xmm6=z4H
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=z3L
+    movdqa      XMMWORD [wk(1)], xmm1   ; wk(1)=z3H
+
+    ; (Original)
+    ; z1 = tmp4 + tmp7;  z2 = tmp5 + tmp6;
+    ; tmp4 = tmp4 * 0.298631336;  tmp5 = tmp5 * 2.053119869;
+    ; tmp6 = tmp6 * 3.072711026;  tmp7 = tmp7 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; data7 = tmp4 + z1 + z3;  data5 = tmp5 + z2 + z4;
+    ; data3 = tmp6 + z2 + z3;  data1 = tmp7 + z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp4 = tmp4 * (0.298631336 - 0.899976223) + tmp7 * -0.899976223;
+    ; tmp5 = tmp5 * (2.053119869 - 2.562915447) + tmp6 * -2.562915447;
+    ; tmp6 = tmp5 * -2.562915447 + tmp6 * (3.072711026 - 2.562915447);
+    ; tmp7 = tmp4 * -0.899976223 + tmp7 * (1.501321110 - 0.899976223);
+    ; data7 = tmp4 + z3;  data5 = tmp5 + z4;
+    ; data3 = tmp6 + z3;  data1 = tmp7 + z4;
+
+    movdqa      xmm4, xmm0
+    movdqa      xmm1, xmm0
+    punpcklwd   xmm4, xmm5
+    punpckhwd   xmm1, xmm5
+    movdqa      xmm0, xmm4
+    movdqa      xmm5, xmm1
+    pmaddwd     xmm4, [rel PW_MF060_MF089]  ; xmm4=tmp4L
+    pmaddwd     xmm1, [rel PW_MF060_MF089]  ; xmm1=tmp4H
+    pmaddwd     xmm0, [rel PW_MF089_F060]   ; xmm0=tmp7L
+    pmaddwd     xmm5, [rel PW_MF089_F060]   ; xmm5=tmp7H
+
+    paddd       xmm4,  XMMWORD [wk(0)]  ; xmm4=data7L
+    paddd       xmm1,  XMMWORD [wk(1)]  ; xmm1=data7H
+    paddd       xmm0, xmm2              ; xmm0=data1L
+    paddd       xmm5, xmm6              ; xmm5=data1H
+
+    paddd       xmm4, [rel PD_DESCALE_P2]
+    paddd       xmm1, [rel PD_DESCALE_P2]
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm1, DESCALE_P2
+    paddd       xmm0, [rel PD_DESCALE_P2]
+    paddd       xmm5, [rel PD_DESCALE_P2]
+    psrad       xmm0, DESCALE_P2
+    psrad       xmm5, DESCALE_P2
+
+    packssdw    xmm4, xmm1              ; xmm4=data7
+    packssdw    xmm0, xmm5              ; xmm0=data1
+
+    movdqa      XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_DCTELEM)], xmm4
+    movdqa      XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_DCTELEM)], xmm0
+
+    movdqa      xmm1, xmm3
+    movdqa      xmm5, xmm3
+    punpcklwd   xmm1, xmm7
+    punpckhwd   xmm5, xmm7
+    movdqa      xmm3, xmm1
+    movdqa      xmm7, xmm5
+    pmaddwd     xmm1, [rel PW_MF050_MF256]  ; xmm1=tmp5L
+    pmaddwd     xmm5, [rel PW_MF050_MF256]  ; xmm5=tmp5H
+    pmaddwd     xmm3, [rel PW_MF256_F050]   ; xmm3=tmp6L
+    pmaddwd     xmm7, [rel PW_MF256_F050]   ; xmm7=tmp6H
+
+    paddd       xmm1, xmm2              ; xmm1=data5L
+    paddd       xmm5, xmm6              ; xmm5=data5H
+    paddd       xmm3, XMMWORD [wk(0)]   ; xmm3=data3L
+    paddd       xmm7, XMMWORD [wk(1)]   ; xmm7=data3H
+
+    paddd       xmm1, [rel PD_DESCALE_P2]
+    paddd       xmm5, [rel PD_DESCALE_P2]
+    psrad       xmm1, DESCALE_P2
+    psrad       xmm5, DESCALE_P2
+    paddd       xmm3, [rel PD_DESCALE_P2]
+    paddd       xmm7, [rel PD_DESCALE_P2]
+    psrad       xmm3, DESCALE_P2
+    psrad       xmm7, DESCALE_P2
+
+    packssdw    xmm1, xmm5              ; xmm1=data5
+    packssdw    xmm3, xmm7              ; xmm3=data3
+
+    movdqa      XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_DCTELEM)], xmm1
+    movdqa      XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_DCTELEM)], xmm3
+
+    uncollect_args 1
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jidctflt-sse2.asm b/simd/x86_64/jidctflt-sse2.asm
new file mode 100644
index 0000000..6f22339
--- /dev/null
+++ b/simd/x86_64/jidctflt-sse2.asm
@@ -0,0 +1,482 @@
+;
+; jidctflt.asm - floating-point IDCT (64-bit SSE & SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a floating-point implementation of the inverse DCT
+; (Discrete Cosine Transform). The following code is based directly on
+; the IJG's original jidctflt.c; see the jidctflt.c for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%macro unpcklps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(0 1 4 5)
+    shufps      %1, %2, 0x44
+%endmacro
+
+%macro unpckhps2 2  ; %1=(0 1 2 3) / %2=(4 5 6 7) => %1=(2 3 6 7)
+    shufps      %1, %2, 0xEE
+%endmacro
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_idct_float_sse2)
+
+EXTN(jconst_idct_float_sse2):
+
+PD_1_414        times 4  dd  1.414213562373095048801689
+PD_1_847        times 4  dd  1.847759065022573512256366
+PD_1_082        times 4  dd  1.082392200292393968799446
+PD_M2_613       times 4  dd -2.613125929752753055713286
+PD_RNDINT_MAGIC times 4  dd  100663296.0  ; (float)(0x00C00000 << 3)
+PB_CENTERJSAMP  times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Perform dequantization and inverse DCT on one block of coefficients.
+;
+; GLOBAL(void)
+; jsimd_idct_float_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                        JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+; r10 = void *dct_table
+; r11 = JCOEFPTR coef_block
+; r12 = JSAMPARRAY output_buf
+; r13d = JDIMENSION output_col
+
+%define original_rbp  rbp+0
+%define wk(i)         rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+%define workspace     wk(0)-DCTSIZE2*SIZEOF_FAST_FLOAT
+                                        ; FAST_FLOAT workspace[DCTSIZE2]
+
+    align       32
+    global      EXTN(jsimd_idct_float_sse2)
+
+EXTN(jsimd_idct_float_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [workspace]
+    collect_args 4
+    push        rbx
+
+    ; ---- Pass 1: process columns from input, store into work array.
+
+    mov         rdx, r10                ; quantptr
+    mov         rsi, r11                ; inptr
+    lea         rdi, [workspace]        ; FAST_FLOAT *wsptr
+    mov         rcx, DCTSIZE/4          ; ctr
+.columnloop:
+%ifndef NO_ZERO_COLUMN_TEST_FLOAT_SSE
+    mov         eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    jnz         near .columnDCT
+
+    movq        xmm1, XMM_MMWORD [MMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm2, XMM_MMWORD [MMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm3, XMM_MMWORD [MMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm4, XMM_MMWORD [MMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm5, XMM_MMWORD [MMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm6, XMM_MMWORD [MMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm7, XMM_MMWORD [MMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, xmm2
+    por         xmm3, xmm4
+    por         xmm5, xmm6
+    por         xmm1, xmm3
+    por         xmm5, xmm7
+    por         xmm1, xmm5
+    packsswb    xmm1, xmm1
+    movd        eax, xmm1
+    test        rax, rax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movq        xmm0, XMM_MMWORD [MMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+
+    punpcklwd   xmm0, xmm0                  ; xmm0=(00 00 01 01 02 02 03 03)
+    psrad       xmm0, (DWORD_BIT-WORD_BIT)  ; xmm0=in0=(00 01 02 03)
+    cvtdq2ps    xmm0, xmm0                  ; xmm0=in0=(00 01 02 03)
+
+    mulps       xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+
+    movaps      xmm1, xmm0
+    movaps      xmm2, xmm0
+    movaps      xmm3, xmm0
+
+    shufps      xmm0, xmm0, 0x00        ; xmm0=(00 00 00 00)
+    shufps      xmm1, xmm1, 0x55        ; xmm1=(01 01 01 01)
+    shufps      xmm2, xmm2, 0xAA        ; xmm2=(02 02 02 02)
+    shufps      xmm3, xmm3, 0xFF        ; xmm3=(03 03 03 03)
+
+    movaps      XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(0,1,rdi,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(1,1,rdi,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_FAST_FLOAT)], xmm2
+    movaps      XMMWORD [XMMBLOCK(2,1,rdi,SIZEOF_FAST_FLOAT)], xmm2
+    movaps      XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_FAST_FLOAT)], xmm3
+    movaps      XMMWORD [XMMBLOCK(3,1,rdi,SIZEOF_FAST_FLOAT)], xmm3
+    jmp         near .nextcolumn
+%endif
+.columnDCT:
+
+    ; -- Even part
+
+    movq        xmm0, XMM_MMWORD [MMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm1, XMM_MMWORD [MMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm2, XMM_MMWORD [MMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm3, XMM_MMWORD [MMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+
+    punpcklwd   xmm0, xmm0                  ; xmm0=(00 00 01 01 02 02 03 03)
+    punpcklwd   xmm1, xmm1                  ; xmm1=(20 20 21 21 22 22 23 23)
+    psrad       xmm0, (DWORD_BIT-WORD_BIT)  ; xmm0=in0=(00 01 02 03)
+    psrad       xmm1, (DWORD_BIT-WORD_BIT)  ; xmm1=in2=(20 21 22 23)
+    cvtdq2ps    xmm0, xmm0                  ; xmm0=in0=(00 01 02 03)
+    cvtdq2ps    xmm1, xmm1                  ; xmm1=in2=(20 21 22 23)
+
+    punpcklwd   xmm2, xmm2                  ; xmm2=(40 40 41 41 42 42 43 43)
+    punpcklwd   xmm3, xmm3                  ; xmm3=(60 60 61 61 62 62 63 63)
+    psrad       xmm2, (DWORD_BIT-WORD_BIT)  ; xmm2=in4=(40 41 42 43)
+    psrad       xmm3, (DWORD_BIT-WORD_BIT)  ; xmm3=in6=(60 61 62 63)
+    cvtdq2ps    xmm2, xmm2                  ; xmm2=in4=(40 41 42 43)
+    cvtdq2ps    xmm3, xmm3                  ; xmm3=in6=(60 61 62 63)
+
+    mulps       xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm1, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm2, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm3, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+
+    movaps      xmm4, xmm0
+    movaps      xmm5, xmm1
+    subps       xmm0, xmm2              ; xmm0=tmp11
+    subps       xmm1, xmm3
+    addps       xmm4, xmm2              ; xmm4=tmp10
+    addps       xmm5, xmm3              ; xmm5=tmp13
+
+    mulps       xmm1, [rel PD_1_414]
+    subps       xmm1, xmm5              ; xmm1=tmp12
+
+    movaps      xmm6, xmm4
+    movaps      xmm7, xmm0
+    subps       xmm4, xmm5              ; xmm4=tmp3
+    subps       xmm0, xmm1              ; xmm0=tmp2
+    addps       xmm6, xmm5              ; xmm6=tmp0
+    addps       xmm7, xmm1              ; xmm7=tmp1
+
+    movaps      XMMWORD [wk(1)], xmm4   ; tmp3
+    movaps      XMMWORD [wk(0)], xmm0   ; tmp2
+
+    ; -- Odd part
+
+    movq        xmm2, XMM_MMWORD [MMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm3, XMM_MMWORD [MMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm5, XMM_MMWORD [MMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    movq        xmm1, XMM_MMWORD [MMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+
+    punpcklwd   xmm2, xmm2                  ; xmm2=(10 10 11 11 12 12 13 13)
+    punpcklwd   xmm3, xmm3                  ; xmm3=(30 30 31 31 32 32 33 33)
+    psrad       xmm2, (DWORD_BIT-WORD_BIT)  ; xmm2=in1=(10 11 12 13)
+    psrad       xmm3, (DWORD_BIT-WORD_BIT)  ; xmm3=in3=(30 31 32 33)
+    cvtdq2ps    xmm2, xmm2                  ; xmm2=in1=(10 11 12 13)
+    cvtdq2ps    xmm3, xmm3                  ; xmm3=in3=(30 31 32 33)
+
+    punpcklwd   xmm5, xmm5                  ; xmm5=(50 50 51 51 52 52 53 53)
+    punpcklwd   xmm1, xmm1                  ; xmm1=(70 70 71 71 72 72 73 73)
+    psrad       xmm5, (DWORD_BIT-WORD_BIT)  ; xmm5=in5=(50 51 52 53)
+    psrad       xmm1, (DWORD_BIT-WORD_BIT)  ; xmm1=in7=(70 71 72 73)
+    cvtdq2ps    xmm5, xmm5                  ; xmm5=in5=(50 51 52 53)
+    cvtdq2ps    xmm1, xmm1                  ; xmm1=in7=(70 71 72 73)
+
+    mulps       xmm2, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm5, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+    mulps       xmm1, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_FLOAT_MULT_TYPE)]
+
+    movaps      xmm4, xmm2
+    movaps      xmm0, xmm5
+    addps       xmm2, xmm1              ; xmm2=z11
+    addps       xmm5, xmm3              ; xmm5=z13
+    subps       xmm4, xmm1              ; xmm4=z12
+    subps       xmm0, xmm3              ; xmm0=z10
+
+    movaps      xmm1, xmm2
+    subps       xmm2, xmm5
+    addps       xmm1, xmm5              ; xmm1=tmp7
+
+    mulps       xmm2, [rel PD_1_414]    ; xmm2=tmp11
+
+    movaps      xmm3, xmm0
+    addps       xmm0, xmm4
+    mulps       xmm0, [rel PD_1_847]    ; xmm0=z5
+    mulps       xmm3, [rel PD_M2_613]   ; xmm3=(z10 * -2.613125930)
+    mulps       xmm4, [rel PD_1_082]    ; xmm4=(z12 * 1.082392200)
+    addps       xmm3, xmm0              ; xmm3=tmp12
+    subps       xmm4, xmm0              ; xmm4=tmp10
+
+    ; -- Final output stage
+
+    subps       xmm3, xmm1              ; xmm3=tmp6
+    movaps      xmm5, xmm6
+    movaps      xmm0, xmm7
+    addps       xmm6, xmm1              ; xmm6=data0=(00 01 02 03)
+    addps       xmm7, xmm3              ; xmm7=data1=(10 11 12 13)
+    subps       xmm5, xmm1              ; xmm5=data7=(70 71 72 73)
+    subps       xmm0, xmm3              ; xmm0=data6=(60 61 62 63)
+    subps       xmm2, xmm3              ; xmm2=tmp5
+
+    movaps      xmm1, xmm6              ; transpose coefficients(phase 1)
+    unpcklps    xmm6, xmm7              ; xmm6=(00 10 01 11)
+    unpckhps    xmm1, xmm7              ; xmm1=(02 12 03 13)
+    movaps      xmm3, xmm0              ; transpose coefficients(phase 1)
+    unpcklps    xmm0, xmm5              ; xmm0=(60 70 61 71)
+    unpckhps    xmm3, xmm5              ; xmm3=(62 72 63 73)
+
+    movaps      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
+    movaps      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp3
+
+    movaps      XMMWORD [wk(0)], xmm0   ; wk(0)=(60 70 61 71)
+    movaps      XMMWORD [wk(1)], xmm3   ; wk(1)=(62 72 63 73)
+
+    addps       xmm4, xmm2              ; xmm4=tmp4
+    movaps      xmm0, xmm7
+    movaps      xmm3, xmm5
+    addps       xmm7, xmm2              ; xmm7=data2=(20 21 22 23)
+    addps       xmm5, xmm4              ; xmm5=data4=(40 41 42 43)
+    subps       xmm0, xmm2              ; xmm0=data5=(50 51 52 53)
+    subps       xmm3, xmm4              ; xmm3=data3=(30 31 32 33)
+
+    movaps      xmm2, xmm7              ; transpose coefficients(phase 1)
+    unpcklps    xmm7, xmm3              ; xmm7=(20 30 21 31)
+    unpckhps    xmm2, xmm3              ; xmm2=(22 32 23 33)
+    movaps      xmm4, xmm5              ; transpose coefficients(phase 1)
+    unpcklps    xmm5, xmm0              ; xmm5=(40 50 41 51)
+    unpckhps    xmm4, xmm0              ; xmm4=(42 52 43 53)
+
+    movaps      xmm3, xmm6              ; transpose coefficients(phase 2)
+    unpcklps2   xmm6, xmm7              ; xmm6=(00 10 20 30)
+    unpckhps2   xmm3, xmm7              ; xmm3=(01 11 21 31)
+    movaps      xmm0, xmm1              ; transpose coefficients(phase 2)
+    unpcklps2   xmm1, xmm2              ; xmm1=(02 12 22 32)
+    unpckhps2   xmm0, xmm2              ; xmm0=(03 13 23 33)
+
+    movaps      xmm7, XMMWORD [wk(0)]   ; xmm7=(60 70 61 71)
+    movaps      xmm2, XMMWORD [wk(1)]   ; xmm2=(62 72 63 73)
+
+    movaps      XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_FAST_FLOAT)], xmm6
+    movaps      XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_FAST_FLOAT)], xmm3
+    movaps      XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_FAST_FLOAT)], xmm1
+    movaps      XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_FAST_FLOAT)], xmm0
+
+    movaps      xmm6, xmm5              ; transpose coefficients(phase 2)
+    unpcklps2   xmm5, xmm7              ; xmm5=(40 50 60 70)
+    unpckhps2   xmm6, xmm7              ; xmm6=(41 51 61 71)
+    movaps      xmm3, xmm4              ; transpose coefficients(phase 2)
+    unpcklps2   xmm4, xmm2              ; xmm4=(42 52 62 72)
+    unpckhps2   xmm3, xmm2              ; xmm3=(43 53 63 73)
+
+    movaps      XMMWORD [XMMBLOCK(0,1,rdi,SIZEOF_FAST_FLOAT)], xmm5
+    movaps      XMMWORD [XMMBLOCK(1,1,rdi,SIZEOF_FAST_FLOAT)], xmm6
+    movaps      XMMWORD [XMMBLOCK(2,1,rdi,SIZEOF_FAST_FLOAT)], xmm4
+    movaps      XMMWORD [XMMBLOCK(3,1,rdi,SIZEOF_FAST_FLOAT)], xmm3
+
+.nextcolumn:
+    add         rsi, byte 4*SIZEOF_JCOEF               ; coef_block
+    add         rdx, byte 4*SIZEOF_FLOAT_MULT_TYPE     ; quantptr
+    add         rdi,      4*DCTSIZE*SIZEOF_FAST_FLOAT  ; wsptr
+    dec         rcx                                    ; ctr
+    jnz         near .columnloop
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 0*32]
+    prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 1*32]
+    prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 2*32]
+    prefetchnta [rsi + (DCTSIZE2-8)*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows from work array, store into output array.
+
+    mov         rax, [original_rbp]
+    lea         rsi, [workspace]        ; FAST_FLOAT *wsptr
+    mov         rdi, r12                ; (JSAMPROW *)
+    mov         eax, r13d
+    mov         rcx, DCTSIZE/4          ; ctr
+.rowloop:
+
+    ; -- Even part
+
+    movaps      xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_FAST_FLOAT)]
+
+    movaps      xmm4, xmm0
+    movaps      xmm5, xmm1
+    subps       xmm0, xmm2              ; xmm0=tmp11
+    subps       xmm1, xmm3
+    addps       xmm4, xmm2              ; xmm4=tmp10
+    addps       xmm5, xmm3              ; xmm5=tmp13
+
+    mulps       xmm1, [rel PD_1_414]
+    subps       xmm1, xmm5              ; xmm1=tmp12
+
+    movaps      xmm6, xmm4
+    movaps      xmm7, xmm0
+    subps       xmm4, xmm5              ; xmm4=tmp3
+    subps       xmm0, xmm1              ; xmm0=tmp2
+    addps       xmm6, xmm5              ; xmm6=tmp0
+    addps       xmm7, xmm1              ; xmm7=tmp1
+
+    movaps      XMMWORD [wk(1)], xmm4   ; tmp3
+    movaps      XMMWORD [wk(0)], xmm0   ; tmp2
+
+    ; -- Odd part
+
+    movaps      xmm2, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm5, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_FAST_FLOAT)]
+
+    movaps      xmm4, xmm2
+    movaps      xmm0, xmm5
+    addps       xmm2, xmm1              ; xmm2=z11
+    addps       xmm5, xmm3              ; xmm5=z13
+    subps       xmm4, xmm1              ; xmm4=z12
+    subps       xmm0, xmm3              ; xmm0=z10
+
+    movaps      xmm1, xmm2
+    subps       xmm2, xmm5
+    addps       xmm1, xmm5              ; xmm1=tmp7
+
+    mulps       xmm2, [rel PD_1_414]    ; xmm2=tmp11
+
+    movaps      xmm3, xmm0
+    addps       xmm0, xmm4
+    mulps       xmm0, [rel PD_1_847]    ; xmm0=z5
+    mulps       xmm3, [rel PD_M2_613]   ; xmm3=(z10 * -2.613125930)
+    mulps       xmm4, [rel PD_1_082]    ; xmm4=(z12 * 1.082392200)
+    addps       xmm3, xmm0              ; xmm3=tmp12
+    subps       xmm4, xmm0              ; xmm4=tmp10
+
+    ; -- Final output stage
+
+    subps       xmm3, xmm1              ; xmm3=tmp6
+    movaps      xmm5, xmm6
+    movaps      xmm0, xmm7
+    addps       xmm6, xmm1              ; xmm6=data0=(00 10 20 30)
+    addps       xmm7, xmm3              ; xmm7=data1=(01 11 21 31)
+    subps       xmm5, xmm1              ; xmm5=data7=(07 17 27 37)
+    subps       xmm0, xmm3              ; xmm0=data6=(06 16 26 36)
+    subps       xmm2, xmm3              ; xmm2=tmp5
+
+    movaps      xmm1, [rel PD_RNDINT_MAGIC]  ; xmm1=[rel PD_RNDINT_MAGIC]
+    pcmpeqd     xmm3, xmm3
+    psrld       xmm3, WORD_BIT          ; xmm3={0xFFFF 0x0000 0xFFFF 0x0000 ..}
+
+    addps       xmm6, xmm1              ; xmm6=roundint(data0/8)=(00 ** 10 ** 20 ** 30 **)
+    addps       xmm7, xmm1              ; xmm7=roundint(data1/8)=(01 ** 11 ** 21 ** 31 **)
+    addps       xmm0, xmm1              ; xmm0=roundint(data6/8)=(06 ** 16 ** 26 ** 36 **)
+    addps       xmm5, xmm1              ; xmm5=roundint(data7/8)=(07 ** 17 ** 27 ** 37 **)
+
+    pand        xmm6, xmm3              ; xmm6=(00 -- 10 -- 20 -- 30 --)
+    pslld       xmm7, WORD_BIT          ; xmm7=(-- 01 -- 11 -- 21 -- 31)
+    pand        xmm0, xmm3              ; xmm0=(06 -- 16 -- 26 -- 36 --)
+    pslld       xmm5, WORD_BIT          ; xmm5=(-- 07 -- 17 -- 27 -- 37)
+    por         xmm6, xmm7              ; xmm6=(00 01 10 11 20 21 30 31)
+    por         xmm0, xmm5              ; xmm0=(06 07 16 17 26 27 36 37)
+
+    movaps      xmm1,  XMMWORD [wk(0)]  ; xmm1=tmp2
+    movaps      xmm3,  XMMWORD [wk(1)]  ; xmm3=tmp3
+
+    addps       xmm4, xmm2              ; xmm4=tmp4
+    movaps      xmm7, xmm1
+    movaps      xmm5, xmm3
+    addps       xmm1, xmm2              ; xmm1=data2=(02 12 22 32)
+    addps       xmm3, xmm4              ; xmm3=data4=(04 14 24 34)
+    subps       xmm7, xmm2              ; xmm7=data5=(05 15 25 35)
+    subps       xmm5, xmm4              ; xmm5=data3=(03 13 23 33)
+
+    movaps      xmm2, [rel PD_RNDINT_MAGIC]  ; xmm2=[rel PD_RNDINT_MAGIC]
+    pcmpeqd     xmm4, xmm4
+    psrld       xmm4, WORD_BIT          ; xmm4={0xFFFF 0x0000 0xFFFF 0x0000 ..}
+
+    addps       xmm3, xmm2              ; xmm3=roundint(data4/8)=(04 ** 14 ** 24 ** 34 **)
+    addps       xmm7, xmm2              ; xmm7=roundint(data5/8)=(05 ** 15 ** 25 ** 35 **)
+    addps       xmm1, xmm2              ; xmm1=roundint(data2/8)=(02 ** 12 ** 22 ** 32 **)
+    addps       xmm5, xmm2              ; xmm5=roundint(data3/8)=(03 ** 13 ** 23 ** 33 **)
+
+    pand        xmm3, xmm4              ; xmm3=(04 -- 14 -- 24 -- 34 --)
+    pslld       xmm7, WORD_BIT          ; xmm7=(-- 05 -- 15 -- 25 -- 35)
+    pand        xmm1, xmm4              ; xmm1=(02 -- 12 -- 22 -- 32 --)
+    pslld       xmm5, WORD_BIT          ; xmm5=(-- 03 -- 13 -- 23 -- 33)
+    por         xmm3, xmm7              ; xmm3=(04 05 14 15 24 25 34 35)
+    por         xmm1, xmm5              ; xmm1=(02 03 12 13 22 23 32 33)
+
+    movdqa      xmm2, [rel PB_CENTERJSAMP]  ; xmm2=[rel PB_CENTERJSAMP]
+
+    packsswb    xmm6, xmm3        ; xmm6=(00 01 10 11 20 21 30 31 04 05 14 15 24 25 34 35)
+    packsswb    xmm1, xmm0        ; xmm1=(02 03 12 13 22 23 32 33 06 07 16 17 26 27 36 37)
+    paddb       xmm6, xmm2
+    paddb       xmm1, xmm2
+
+    movdqa      xmm4, xmm6        ; transpose coefficients(phase 2)
+    punpcklwd   xmm6, xmm1        ; xmm6=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
+    punpckhwd   xmm4, xmm1        ; xmm4=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
+
+    movdqa      xmm7, xmm6        ; transpose coefficients(phase 3)
+    punpckldq   xmm6, xmm4        ; xmm6=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
+    punpckhdq   xmm7, xmm4        ; xmm7=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
+
+    pshufd      xmm5, xmm6, 0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
+    pshufd      xmm3, xmm7, 0x4E  ; xmm3=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
+
+    mov         rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
+    mov         rbx, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm6
+    movq        XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE], xmm7
+    mov         rdx, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
+    mov         rbx, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm5
+    movq        XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE], xmm3
+
+    add         rsi, byte 4*SIZEOF_FAST_FLOAT  ; wsptr
+    add         rdi, byte 4*SIZEOF_JSAMPROW
+    dec         rcx                            ; ctr
+    jnz         near .rowloop
+
+    pop         rbx
+    uncollect_args 4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jidctfst-sse2.asm b/simd/x86_64/jidctfst-sse2.asm
new file mode 100644
index 0000000..422ad1b
--- /dev/null
+++ b/simd/x86_64/jidctfst-sse2.asm
@@ -0,0 +1,491 @@
+;
+; jidctfst.asm - fast integer IDCT (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a fast, not so accurate integer implementation of
+; the inverse DCT (Discrete Cosine Transform). The following code is
+; based directly on the IJG's original jidctfst.c; see the jidctfst.c
+; for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  8  ; 14 is also OK.
+%define PASS1_BITS  2
+
+%if IFAST_SCALE_BITS != PASS1_BITS
+%error "'IFAST_SCALE_BITS' must be equal to 'PASS1_BITS'."
+%endif
+
+%if CONST_BITS == 8
+F_1_082 equ 277              ; FIX(1.082392200)
+F_1_414 equ 362              ; FIX(1.414213562)
+F_1_847 equ 473              ; FIX(1.847759065)
+F_2_613 equ 669              ; FIX(2.613125930)
+F_1_613 equ (F_2_613 - 256)  ; FIX(2.613125930) - FIX(1)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_1_082 equ DESCALE(1162209775, 30-CONST_BITS)  ; FIX(1.082392200)
+F_1_414 equ DESCALE(1518500249, 30-CONST_BITS)  ; FIX(1.414213562)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_2_613 equ DESCALE(2805822602, 30-CONST_BITS)  ; FIX(2.613125930)
+F_1_613 equ (F_2_613 - (1 << CONST_BITS))       ; FIX(2.613125930) - FIX(1)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+; PRE_MULTIPLY_SCALE_BITS <= 2 (to avoid overflow)
+; CONST_BITS + CONST_SHIFT + PRE_MULTIPLY_SCALE_BITS == 16 (for pmulhw)
+
+%define PRE_MULTIPLY_SCALE_BITS  2
+%define CONST_SHIFT              (16 - PRE_MULTIPLY_SCALE_BITS - CONST_BITS)
+
+    alignz      32
+    global      EXTN(jconst_idct_ifast_sse2)
+
+EXTN(jconst_idct_ifast_sse2):
+
+PW_F1414       times 8  dw  F_1_414 << CONST_SHIFT
+PW_F1847       times 8  dw  F_1_847 << CONST_SHIFT
+PW_MF1613      times 8  dw -F_1_613 << CONST_SHIFT
+PW_F1082       times 8  dw  F_1_082 << CONST_SHIFT
+PB_CENTERJSAMP times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Perform dequantization and inverse DCT on one block of coefficients.
+;
+; GLOBAL(void)
+; jsimd_idct_ifast_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                       JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+; r10 = jpeg_component_info *compptr
+; r11 = JCOEFPTR coef_block
+; r12 = JSAMPARRAY output_buf
+; r13d = JDIMENSION output_col
+
+%define original_rbp  rbp+0
+%define wk(i)         rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+
+    align       32
+    global      EXTN(jsimd_idct_ifast_sse2)
+
+EXTN(jsimd_idct_ifast_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 4
+
+    ; ---- Pass 1: process columns from input.
+
+    mov         rdx, r10                ; quantptr
+    mov         rsi, r11                ; inptr
+
+%ifndef NO_ZERO_COLUMN_TEST_IFAST_SSE2
+    mov         eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    jnz         near .columnDCT
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, xmm0
+    packsswb    xmm1, xmm1
+    packsswb    xmm1, xmm1
+    movd        eax, xmm1
+    test        rax, rax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    movdqa      xmm7, xmm0              ; xmm0=in0=(00 01 02 03 04 05 06 07)
+    punpcklwd   xmm0, xmm0              ; xmm0=(00 00 01 01 02 02 03 03)
+    punpckhwd   xmm7, xmm7              ; xmm7=(04 04 05 05 06 06 07 07)
+
+    pshufd      xmm6, xmm0, 0x00        ; xmm6=col0=(00 00 00 00 00 00 00 00)
+    pshufd      xmm2, xmm0, 0x55        ; xmm2=col1=(01 01 01 01 01 01 01 01)
+    pshufd      xmm5, xmm0, 0xAA        ; xmm5=col2=(02 02 02 02 02 02 02 02)
+    pshufd      xmm0, xmm0, 0xFF        ; xmm0=col3=(03 03 03 03 03 03 03 03)
+    pshufd      xmm1, xmm7, 0x00        ; xmm1=col4=(04 04 04 04 04 04 04 04)
+    pshufd      xmm4, xmm7, 0x55        ; xmm4=col5=(05 05 05 05 05 05 05 05)
+    pshufd      xmm3, xmm7, 0xAA        ; xmm3=col6=(06 06 06 06 06 06 06 06)
+    pshufd      xmm7, xmm7, 0xFF        ; xmm7=col7=(07 07 07 07 07 07 07 07)
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=col1
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=col3
+    jmp         near .column_end
+%endif
+.columnDCT:
+
+    ; -- Even part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+
+    movdqa      xmm4, xmm0
+    movdqa      xmm5, xmm1
+    psubw       xmm0, xmm2              ; xmm0=tmp11
+    psubw       xmm1, xmm3
+    paddw       xmm4, xmm2              ; xmm4=tmp10
+    paddw       xmm5, xmm3              ; xmm5=tmp13
+
+    psllw       xmm1, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm1, [rel PW_F1414]
+    psubw       xmm1, xmm5              ; xmm1=tmp12
+
+    movdqa      xmm6, xmm4
+    movdqa      xmm7, xmm0
+    psubw       xmm4, xmm5              ; xmm4=tmp3
+    psubw       xmm0, xmm1              ; xmm0=tmp2
+    paddw       xmm6, xmm5              ; xmm6=tmp0
+    paddw       xmm7, xmm1              ; xmm7=tmp1
+
+    movdqa      XMMWORD [wk(1)], xmm4   ; wk(1)=tmp3
+    movdqa      XMMWORD [wk(0)], xmm0   ; wk(0)=tmp2
+
+    ; -- Odd part
+
+    movdqa      xmm2, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+    movdqa      xmm5, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm5, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_IFAST_MULT_TYPE)]
+
+    movdqa      xmm4, xmm2
+    movdqa      xmm0, xmm5
+    psubw       xmm2, xmm1              ; xmm2=z12
+    psubw       xmm5, xmm3              ; xmm5=z10
+    paddw       xmm4, xmm1              ; xmm4=z11
+    paddw       xmm0, xmm3              ; xmm0=z13
+
+    movdqa      xmm1, xmm5              ; xmm1=z10(unscaled)
+    psllw       xmm2, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+
+    movdqa      xmm3, xmm4
+    psubw       xmm4, xmm0
+    paddw       xmm3, xmm0              ; xmm3=tmp7
+
+    psllw       xmm4, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm4, [rel PW_F1414]    ; xmm4=tmp11
+
+    ; To avoid overflow...
+    ;
+    ; (Original)
+    ; tmp12 = -2.613125930 * z10 + z5;
+    ;
+    ; (This implementation)
+    ; tmp12 = (-1.613125930 - 1) * z10 + z5;
+    ;       = -1.613125930 * z10 - z10 + z5;
+
+    movdqa      xmm0, xmm5
+    paddw       xmm5, xmm2
+    pmulhw      xmm5, [rel PW_F1847]    ; xmm5=z5
+    pmulhw      xmm0, [rel PW_MF1613]
+    pmulhw      xmm2, [rel PW_F1082]
+    psubw       xmm0, xmm1
+    psubw       xmm2, xmm5              ; xmm2=tmp10
+    paddw       xmm0, xmm5              ; xmm0=tmp12
+
+    ; -- Final output stage
+
+    psubw       xmm0, xmm3              ; xmm0=tmp6
+    movdqa      xmm1, xmm6
+    movdqa      xmm5, xmm7
+    paddw       xmm6, xmm3              ; xmm6=data0=(00 01 02 03 04 05 06 07)
+    paddw       xmm7, xmm0              ; xmm7=data1=(10 11 12 13 14 15 16 17)
+    psubw       xmm1, xmm3              ; xmm1=data7=(70 71 72 73 74 75 76 77)
+    psubw       xmm5, xmm0              ; xmm5=data6=(60 61 62 63 64 65 66 67)
+    psubw       xmm4, xmm0              ; xmm4=tmp5
+
+    movdqa      xmm3, xmm6              ; transpose coefficients(phase 1)
+    punpcklwd   xmm6, xmm7              ; xmm6=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm3, xmm7              ; xmm3=(04 14 05 15 06 16 07 17)
+    movdqa      xmm0, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm1              ; xmm5=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm0, xmm1              ; xmm0=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp2
+    movdqa      xmm1, XMMWORD [wk(1)]   ; xmm1=tmp3
+
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=(60 70 61 71 62 72 63 73)
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=(64 74 65 75 66 76 67 77)
+
+    paddw       xmm2, xmm4              ; xmm2=tmp4
+    movdqa      xmm5, xmm7
+    movdqa      xmm0, xmm1
+    paddw       xmm7, xmm4              ; xmm7=data2=(20 21 22 23 24 25 26 27)
+    paddw       xmm1, xmm2              ; xmm1=data4=(40 41 42 43 44 45 46 47)
+    psubw       xmm5, xmm4              ; xmm5=data5=(50 51 52 53 54 55 56 57)
+    psubw       xmm0, xmm2              ; xmm0=data3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm4, xmm7              ; transpose coefficients(phase 1)
+    punpcklwd   xmm7, xmm0              ; xmm7=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm4, xmm0              ; xmm4=(24 34 25 35 26 36 27 37)
+    movdqa      xmm2, xmm1              ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm5              ; xmm1=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm2, xmm5              ; xmm2=(44 54 45 55 46 56 47 57)
+
+    movdqa      xmm0, xmm3              ; transpose coefficients(phase 2)
+    punpckldq   xmm3, xmm4              ; xmm3=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm0, xmm4              ; xmm0=(06 16 26 36 07 17 27 37)
+    movdqa      xmm5, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm7              ; xmm6=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm5, xmm7              ; xmm5=(02 12 22 32 03 13 23 33)
+
+    movdqa      xmm4, XMMWORD [wk(0)]   ; xmm4=(60 70 61 71 62 72 63 73)
+    movdqa      xmm7, XMMWORD [wk(1)]   ; xmm7=(64 74 65 75 66 76 67 77)
+
+    movdqa      XMMWORD [wk(0)], xmm3   ; wk(0)=(04 14 24 34 05 15 25 35)
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm3, xmm1              ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm4              ; xmm1=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm3, xmm4              ; xmm3=(42 52 62 72 43 53 63 73)
+    movdqa      xmm0, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm7              ; xmm2=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm0, xmm7              ; xmm0=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm4, xmm6              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm6, xmm1              ; xmm6=col0=(00 10 20 30 40 50 60 70)
+    punpckhqdq  xmm4, xmm1              ; xmm4=col1=(01 11 21 31 41 51 61 71)
+    movdqa      xmm7, xmm5              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm5, xmm3              ; xmm5=col2=(02 12 22 32 42 52 62 72)
+    punpckhqdq  xmm7, xmm3              ; xmm7=col3=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm1, XMMWORD [wk(0)]   ; xmm1=(04 14 24 34 05 15 25 35)
+    movdqa      xmm3, XMMWORD [wk(1)]   ; xmm3=(06 16 26 36 07 17 27 37)
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=col1
+    movdqa      XMMWORD [wk(1)], xmm7   ; wk(1)=col3
+
+    movdqa      xmm4, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm2              ; xmm1=col4=(04 14 24 34 44 54 64 74)
+    punpckhqdq  xmm4, xmm2              ; xmm4=col5=(05 15 25 35 45 55 65 75)
+    movdqa      xmm7, xmm3              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm3, xmm0              ; xmm3=col6=(06 16 26 36 46 56 66 76)
+    punpckhqdq  xmm7, xmm0              ; xmm7=col7=(07 17 27 37 47 57 67 77)
+.column_end:
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows from work array, store into output array.
+
+    mov         rax, [original_rbp]
+    mov         rdi, r12                ; (JSAMPROW *)
+    mov         eax, r13d
+
+    ; -- Even part
+
+    ; xmm6=col0, xmm5=col2, xmm1=col4, xmm3=col6
+
+    movdqa      xmm2, xmm6
+    movdqa      xmm0, xmm5
+    psubw       xmm6, xmm1              ; xmm6=tmp11
+    psubw       xmm5, xmm3
+    paddw       xmm2, xmm1              ; xmm2=tmp10
+    paddw       xmm0, xmm3              ; xmm0=tmp13
+
+    psllw       xmm5, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm5, [rel PW_F1414]
+    psubw       xmm5, xmm0              ; xmm5=tmp12
+
+    movdqa      xmm1, xmm2
+    movdqa      xmm3, xmm6
+    psubw       xmm2, xmm0              ; xmm2=tmp3
+    psubw       xmm6, xmm5              ; xmm6=tmp2
+    paddw       xmm1, xmm0              ; xmm1=tmp0
+    paddw       xmm3, xmm5              ; xmm3=tmp1
+
+    movdqa      xmm0, XMMWORD [wk(0)]   ; xmm0=col1
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=col3
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=tmp3
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=tmp2
+
+    ; -- Odd part
+
+    ; xmm0=col1, xmm5=col3, xmm4=col5, xmm7=col7
+
+    movdqa      xmm2, xmm0
+    movdqa      xmm6, xmm4
+    psubw       xmm0, xmm7              ; xmm0=z12
+    psubw       xmm4, xmm5              ; xmm4=z10
+    paddw       xmm2, xmm7              ; xmm2=z11
+    paddw       xmm6, xmm5              ; xmm6=z13
+
+    movdqa      xmm7, xmm4              ; xmm7=z10(unscaled)
+    psllw       xmm0, PRE_MULTIPLY_SCALE_BITS
+    psllw       xmm4, PRE_MULTIPLY_SCALE_BITS
+
+    movdqa      xmm5, xmm2
+    psubw       xmm2, xmm6
+    paddw       xmm5, xmm6              ; xmm5=tmp7
+
+    psllw       xmm2, PRE_MULTIPLY_SCALE_BITS
+    pmulhw      xmm2, [rel PW_F1414]    ; xmm2=tmp11
+
+    ; To avoid overflow...
+    ;
+    ; (Original)
+    ; tmp12 = -2.613125930 * z10 + z5;
+    ;
+    ; (This implementation)
+    ; tmp12 = (-1.613125930 - 1) * z10 + z5;
+    ;       = -1.613125930 * z10 - z10 + z5;
+
+    movdqa      xmm6, xmm4
+    paddw       xmm4, xmm0
+    pmulhw      xmm4, [rel PW_F1847]    ; xmm4=z5
+    pmulhw      xmm6, [rel PW_MF1613]
+    pmulhw      xmm0, [rel PW_F1082]
+    psubw       xmm6, xmm7
+    psubw       xmm0, xmm4              ; xmm0=tmp10
+    paddw       xmm6, xmm4              ; xmm6=tmp12
+
+    ; -- Final output stage
+
+    psubw       xmm6, xmm5              ; xmm6=tmp6
+    movdqa      xmm7, xmm1
+    movdqa      xmm4, xmm3
+    paddw       xmm1, xmm5              ; xmm1=data0=(00 10 20 30 40 50 60 70)
+    paddw       xmm3, xmm6              ; xmm3=data1=(01 11 21 31 41 51 61 71)
+    psraw       xmm1, (PASS1_BITS+3)    ; descale
+    psraw       xmm3, (PASS1_BITS+3)    ; descale
+    psubw       xmm7, xmm5              ; xmm7=data7=(07 17 27 37 47 57 67 77)
+    psubw       xmm4, xmm6              ; xmm4=data6=(06 16 26 36 46 56 66 76)
+    psraw       xmm7, (PASS1_BITS+3)    ; descale
+    psraw       xmm4, (PASS1_BITS+3)    ; descale
+    psubw       xmm2, xmm6              ; xmm2=tmp5
+
+    packsswb    xmm1, xmm4        ; xmm1=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    packsswb    xmm3, xmm7        ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    movdqa      xmm5, XMMWORD [wk(1)]   ; xmm5=tmp2
+    movdqa      xmm6, XMMWORD [wk(0)]   ; xmm6=tmp3
+
+    paddw       xmm0, xmm2              ; xmm0=tmp4
+    movdqa      xmm4, xmm5
+    movdqa      xmm7, xmm6
+    paddw       xmm5, xmm2              ; xmm5=data2=(02 12 22 32 42 52 62 72)
+    paddw       xmm6, xmm0              ; xmm6=data4=(04 14 24 34 44 54 64 74)
+    psraw       xmm5, (PASS1_BITS+3)    ; descale
+    psraw       xmm6, (PASS1_BITS+3)    ; descale
+    psubw       xmm4, xmm2              ; xmm4=data5=(05 15 25 35 45 55 65 75)
+    psubw       xmm7, xmm0              ; xmm7=data3=(03 13 23 33 43 53 63 73)
+    psraw       xmm4, (PASS1_BITS+3)    ; descale
+    psraw       xmm7, (PASS1_BITS+3)    ; descale
+
+    movdqa      xmm2, [rel PB_CENTERJSAMP]  ; xmm2=[rel PB_CENTERJSAMP]
+
+    packsswb    xmm5, xmm6        ; xmm5=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
+    packsswb    xmm7, xmm4        ; xmm7=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
+
+    paddb       xmm1, xmm2
+    paddb       xmm3, xmm2
+    paddb       xmm5, xmm2
+    paddb       xmm7, xmm2
+
+    movdqa      xmm0, xmm1        ; transpose coefficients(phase 1)
+    punpcklbw   xmm1, xmm3        ; xmm1=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
+    punpckhbw   xmm0, xmm3        ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
+    movdqa      xmm6, xmm5        ; transpose coefficients(phase 1)
+    punpcklbw   xmm5, xmm7        ; xmm5=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
+    punpckhbw   xmm6, xmm7        ; xmm6=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
+
+    movdqa      xmm4, xmm1        ; transpose coefficients(phase 2)
+    punpcklwd   xmm1, xmm5        ; xmm1=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
+    punpckhwd   xmm4, xmm5        ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
+    movdqa      xmm2, xmm6        ; transpose coefficients(phase 2)
+    punpcklwd   xmm6, xmm0        ; xmm6=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
+    punpckhwd   xmm2, xmm0        ; xmm2=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
+
+    movdqa      xmm3, xmm1        ; transpose coefficients(phase 3)
+    punpckldq   xmm1, xmm6        ; xmm1=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
+    punpckhdq   xmm3, xmm6        ; xmm3=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
+    movdqa      xmm7, xmm4        ; transpose coefficients(phase 3)
+    punpckldq   xmm4, xmm2        ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
+    punpckhdq   xmm7, xmm2        ; xmm7=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
+
+    pshufd      xmm5, xmm1, 0x4E  ; xmm5=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
+    pshufd      xmm0, xmm3, 0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
+    pshufd      xmm6, xmm4, 0x4E  ; xmm6=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
+    pshufd      xmm2, xmm7, 0x4E  ; xmm2=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
+
+    mov         rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm1
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm3
+    mov         rdx, JSAMPROW [rdi+4*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+6*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm4
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm7
+
+    mov         rdx, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm5
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm0
+    mov         rdx, JSAMPROW [rdi+5*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+7*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm6
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm2
+
+    uncollect_args 4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jidctint-sse2.asm b/simd/x86_64/jidctint-sse2.asm
new file mode 100644
index 0000000..6487266
--- /dev/null
+++ b/simd/x86_64/jidctint-sse2.asm
@@ -0,0 +1,847 @@
+;
+; jidctint.asm - accurate integer IDCT (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains a slow-but-accurate integer implementation of the
+; inverse DCT (Discrete Cosine Transform). The following code is based
+; directly on the IJG's original jidctint.c; see the jidctint.c for
+; more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS  13
+%define PASS1_BITS  2
+
+%define DESCALE_P1  (CONST_BITS-PASS1_BITS)
+%define DESCALE_P2  (CONST_BITS+PASS1_BITS+3)
+
+%if CONST_BITS == 13
+F_0_298 equ  2446  ; FIX(0.298631336)
+F_0_390 equ  3196  ; FIX(0.390180644)
+F_0_541 equ  4433  ; FIX(0.541196100)
+F_0_765 equ  6270  ; FIX(0.765366865)
+F_0_899 equ  7373  ; FIX(0.899976223)
+F_1_175 equ  9633  ; FIX(1.175875602)
+F_1_501 equ 12299  ; FIX(1.501321110)
+F_1_847 equ 15137  ; FIX(1.847759065)
+F_1_961 equ 16069  ; FIX(1.961570560)
+F_2_053 equ 16819  ; FIX(2.053119869)
+F_2_562 equ 20995  ; FIX(2.562915447)
+F_3_072 equ 25172  ; FIX(3.072711026)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_298 equ DESCALE( 320652955, 30-CONST_BITS)  ; FIX(0.298631336)
+F_0_390 equ DESCALE( 418953276, 30-CONST_BITS)  ; FIX(0.390180644)
+F_0_541 equ DESCALE( 581104887, 30-CONST_BITS)  ; FIX(0.541196100)
+F_0_765 equ DESCALE( 821806413, 30-CONST_BITS)  ; FIX(0.765366865)
+F_0_899 equ DESCALE( 966342111, 30-CONST_BITS)  ; FIX(0.899976223)
+F_1_175 equ DESCALE(1262586813, 30-CONST_BITS)  ; FIX(1.175875602)
+F_1_501 equ DESCALE(1612031267, 30-CONST_BITS)  ; FIX(1.501321110)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_1_961 equ DESCALE(2106220350, 30-CONST_BITS)  ; FIX(1.961570560)
+F_2_053 equ DESCALE(2204520673, 30-CONST_BITS)  ; FIX(2.053119869)
+F_2_562 equ DESCALE(2751909506, 30-CONST_BITS)  ; FIX(2.562915447)
+F_3_072 equ DESCALE(3299298341, 30-CONST_BITS)  ; FIX(3.072711026)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_idct_islow_sse2)
+
+EXTN(jconst_idct_islow_sse2):
+
+PW_F130_F054   times 4  dw  (F_0_541+F_0_765), F_0_541
+PW_F054_MF130  times 4  dw  F_0_541, (F_0_541-F_1_847)
+PW_MF078_F117  times 4  dw  (F_1_175-F_1_961), F_1_175
+PW_F117_F078   times 4  dw  F_1_175, (F_1_175-F_0_390)
+PW_MF060_MF089 times 4  dw  (F_0_298-F_0_899),-F_0_899
+PW_MF089_F060  times 4  dw -F_0_899, (F_1_501-F_0_899)
+PW_MF050_MF256 times 4  dw  (F_2_053-F_2_562),-F_2_562
+PW_MF256_F050  times 4  dw -F_2_562, (F_3_072-F_2_562)
+PD_DESCALE_P1  times 4  dd  1 << (DESCALE_P1-1)
+PD_DESCALE_P2  times 4  dd  1 << (DESCALE_P2-1)
+PB_CENTERJSAMP times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Perform dequantization and inverse DCT on one block of coefficients.
+;
+; GLOBAL(void)
+; jsimd_idct_islow_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                        JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+; r10 = jpeg_component_info *compptr
+; r11 = JCOEFPTR coef_block
+; r12 = JSAMPARRAY output_buf
+; r13d = JDIMENSION output_col
+
+%define original_rbp  rbp+0
+%define wk(i)         rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        12
+
+    align       32
+    global      EXTN(jsimd_idct_islow_sse2)
+
+EXTN(jsimd_idct_islow_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 4
+
+    ; ---- Pass 1: process columns from input.
+
+    mov         rdx, r10                ; quantptr
+    mov         rsi, r11                ; inptr
+
+%ifndef NO_ZERO_COLUMN_TEST_ISLOW_SSE2
+    mov         eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    jnz         near .columnDCT
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, xmm0
+    packsswb    xmm1, xmm1
+    packsswb    xmm1, xmm1
+    movd        eax, xmm1
+    test        rax, rax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movdqa      xmm5, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm5, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    psllw       xmm5, PASS1_BITS
+
+    movdqa      xmm4, xmm5              ; xmm5=in0=(00 01 02 03 04 05 06 07)
+    punpcklwd   xmm5, xmm5              ; xmm5=(00 00 01 01 02 02 03 03)
+    punpckhwd   xmm4, xmm4              ; xmm4=(04 04 05 05 06 06 07 07)
+
+    pshufd      xmm7, xmm5, 0x00        ; xmm7=col0=(00 00 00 00 00 00 00 00)
+    pshufd      xmm6, xmm5, 0x55        ; xmm6=col1=(01 01 01 01 01 01 01 01)
+    pshufd      xmm1, xmm5, 0xAA        ; xmm1=col2=(02 02 02 02 02 02 02 02)
+    pshufd      xmm5, xmm5, 0xFF        ; xmm5=col3=(03 03 03 03 03 03 03 03)
+    pshufd      xmm0, xmm4, 0x00        ; xmm0=col4=(04 04 04 04 04 04 04 04)
+    pshufd      xmm3, xmm4, 0x55        ; xmm3=col5=(05 05 05 05 05 05 05 05)
+    pshufd      xmm2, xmm4, 0xAA        ; xmm2=col6=(06 06 06 06 06 06 06 06)
+    pshufd      xmm4, xmm4, 0xFF        ; xmm4=col7=(07 07 07 07 07 07 07 07)
+
+    movdqa      XMMWORD [wk(8)], xmm6   ; wk(8)=col1
+    movdqa      XMMWORD [wk(9)], xmm5   ; wk(9)=col3
+    movdqa      XMMWORD [wk(10)], xmm3  ; wk(10)=col5
+    movdqa      XMMWORD [wk(11)], xmm4  ; wk(11)=col7
+    jmp         near .column_end
+%endif
+.columnDCT:
+
+    ; -- Even part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(4,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(4,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    ; (Original)
+    ; z1 = (z2 + z3) * 0.541196100;
+    ; tmp2 = z1 + z3 * -1.847759065;
+    ; tmp3 = z1 + z2 * 0.765366865;
+    ;
+    ; (This implementation)
+    ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
+    ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
+
+    movdqa      xmm4, xmm1              ; xmm1=in2=z2
+    movdqa      xmm5, xmm1
+    punpcklwd   xmm4, xmm3              ; xmm3=in6=z3
+    punpckhwd   xmm5, xmm3
+    movdqa      xmm1, xmm4
+    movdqa      xmm3, xmm5
+    pmaddwd     xmm4, [rel PW_F130_F054]   ; xmm4=tmp3L
+    pmaddwd     xmm5, [rel PW_F130_F054]   ; xmm5=tmp3H
+    pmaddwd     xmm1, [rel PW_F054_MF130]  ; xmm1=tmp2L
+    pmaddwd     xmm3, [rel PW_F054_MF130]  ; xmm3=tmp2H
+
+    movdqa      xmm6, xmm0
+    paddw       xmm0, xmm2              ; xmm0=in0+in4
+    psubw       xmm6, xmm2              ; xmm6=in0-in4
+
+    pxor        xmm7, xmm7
+    pxor        xmm2, xmm2
+    punpcklwd   xmm7, xmm0              ; xmm7=tmp0L
+    punpckhwd   xmm2, xmm0              ; xmm2=tmp0H
+    psrad       xmm7, (16-CONST_BITS)   ; psrad xmm7,16 & pslld xmm7,CONST_BITS
+    psrad       xmm2, (16-CONST_BITS)   ; psrad xmm2,16 & pslld xmm2,CONST_BITS
+
+    movdqa      xmm0, xmm7
+    paddd       xmm7, xmm4              ; xmm7=tmp10L
+    psubd       xmm0, xmm4              ; xmm0=tmp13L
+    movdqa      xmm4, xmm2
+    paddd       xmm2, xmm5              ; xmm2=tmp10H
+    psubd       xmm4, xmm5              ; xmm4=tmp13H
+
+    movdqa      XMMWORD [wk(0)], xmm7   ; wk(0)=tmp10L
+    movdqa      XMMWORD [wk(1)], xmm2   ; wk(1)=tmp10H
+    movdqa      XMMWORD [wk(2)], xmm0   ; wk(2)=tmp13L
+    movdqa      XMMWORD [wk(3)], xmm4   ; wk(3)=tmp13H
+
+    pxor        xmm5, xmm5
+    pxor        xmm7, xmm7
+    punpcklwd   xmm5, xmm6              ; xmm5=tmp1L
+    punpckhwd   xmm7, xmm6              ; xmm7=tmp1H
+    psrad       xmm5, (16-CONST_BITS)   ; psrad xmm5,16 & pslld xmm5,CONST_BITS
+    psrad       xmm7, (16-CONST_BITS)   ; psrad xmm7,16 & pslld xmm7,CONST_BITS
+
+    movdqa      xmm2, xmm5
+    paddd       xmm5, xmm1              ; xmm5=tmp11L
+    psubd       xmm2, xmm1              ; xmm2=tmp12L
+    movdqa      xmm0, xmm7
+    paddd       xmm7, xmm3              ; xmm7=tmp11H
+    psubd       xmm0, xmm3              ; xmm0=tmp12H
+
+    movdqa      XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
+    movdqa      XMMWORD [wk(5)], xmm7   ; wk(5)=tmp11H
+    movdqa      XMMWORD [wk(6)], xmm2   ; wk(6)=tmp12L
+    movdqa      XMMWORD [wk(7)], xmm0   ; wk(7)=tmp12H
+
+    ; -- Odd part
+
+    movdqa      xmm4, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm6, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm4, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm6, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    movdqa      xmm5, xmm6
+    movdqa      xmm7, xmm4
+    paddw       xmm5, xmm3              ; xmm5=z3
+    paddw       xmm7, xmm1              ; xmm7=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm2, xmm5
+    movdqa      xmm0, xmm5
+    punpcklwd   xmm2, xmm7
+    punpckhwd   xmm0, xmm7
+    movdqa      xmm5, xmm2
+    movdqa      xmm7, xmm0
+    pmaddwd     xmm2, [rel PW_MF078_F117]  ; xmm2=z3L
+    pmaddwd     xmm0, [rel PW_MF078_F117]  ; xmm0=z3H
+    pmaddwd     xmm5, [rel PW_F117_F078]   ; xmm5=z4L
+    pmaddwd     xmm7, [rel PW_F117_F078]   ; xmm7=z4H
+
+    movdqa      XMMWORD [wk(10)], xmm2  ; wk(10)=z3L
+    movdqa      XMMWORD [wk(11)], xmm0  ; wk(11)=z3H
+
+    ; (Original)
+    ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
+    ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
+    ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
+    ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
+    ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
+    ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
+    ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
+    ; tmp0 += z3;  tmp1 += z4;
+    ; tmp2 += z3;  tmp3 += z4;
+
+    movdqa      xmm2, xmm3
+    movdqa      xmm0, xmm3
+    punpcklwd   xmm2, xmm4
+    punpckhwd   xmm0, xmm4
+    movdqa      xmm3, xmm2
+    movdqa      xmm4, xmm0
+    pmaddwd     xmm2, [rel PW_MF060_MF089]  ; xmm2=tmp0L
+    pmaddwd     xmm0, [rel PW_MF060_MF089]  ; xmm0=tmp0H
+    pmaddwd     xmm3, [rel PW_MF089_F060]   ; xmm3=tmp3L
+    pmaddwd     xmm4, [rel PW_MF089_F060]   ; xmm4=tmp3H
+
+    paddd       xmm2, XMMWORD [wk(10)]  ; xmm2=tmp0L
+    paddd       xmm0, XMMWORD [wk(11)]  ; xmm0=tmp0H
+    paddd       xmm3, xmm5              ; xmm3=tmp3L
+    paddd       xmm4, xmm7              ; xmm4=tmp3H
+
+    movdqa      XMMWORD [wk(8)], xmm2   ; wk(8)=tmp0L
+    movdqa      XMMWORD [wk(9)], xmm0   ; wk(9)=tmp0H
+
+    movdqa      xmm2, xmm1
+    movdqa      xmm0, xmm1
+    punpcklwd   xmm2, xmm6
+    punpckhwd   xmm0, xmm6
+    movdqa      xmm1, xmm2
+    movdqa      xmm6, xmm0
+    pmaddwd     xmm2, [rel PW_MF050_MF256]  ; xmm2=tmp1L
+    pmaddwd     xmm0, [rel PW_MF050_MF256]  ; xmm0=tmp1H
+    pmaddwd     xmm1, [rel PW_MF256_F050]   ; xmm1=tmp2L
+    pmaddwd     xmm6, [rel PW_MF256_F050]   ; xmm6=tmp2H
+
+    paddd       xmm2, xmm5              ; xmm2=tmp1L
+    paddd       xmm0, xmm7              ; xmm0=tmp1H
+    paddd       xmm1, XMMWORD [wk(10)]  ; xmm1=tmp2L
+    paddd       xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
+
+    movdqa      XMMWORD [wk(10)], xmm2  ; wk(10)=tmp1L
+    movdqa      XMMWORD [wk(11)], xmm0  ; wk(11)=tmp1H
+
+    ; -- Final output stage
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
+    movdqa      xmm7, XMMWORD [wk(1)]   ; xmm7=tmp10H
+
+    movdqa      xmm2, xmm5
+    movdqa      xmm0, xmm7
+    paddd       xmm5, xmm3              ; xmm5=data0L
+    paddd       xmm7, xmm4              ; xmm7=data0H
+    psubd       xmm2, xmm3              ; xmm2=data7L
+    psubd       xmm0, xmm4              ; xmm0=data7H
+
+    movdqa      xmm3, [rel PD_DESCALE_P1]  ; xmm3=[rel PD_DESCALE_P1]
+
+    paddd       xmm5, xmm3
+    paddd       xmm7, xmm3
+    psrad       xmm5, DESCALE_P1
+    psrad       xmm7, DESCALE_P1
+    paddd       xmm2, xmm3
+    paddd       xmm0, xmm3
+    psrad       xmm2, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+
+    packssdw    xmm5, xmm7              ; xmm5=data0=(00 01 02 03 04 05 06 07)
+    packssdw    xmm2, xmm0              ; xmm2=data7=(70 71 72 73 74 75 76 77)
+
+    movdqa      xmm4, XMMWORD [wk(4)]   ; xmm4=tmp11L
+    movdqa      xmm3, XMMWORD [wk(5)]   ; xmm3=tmp11H
+
+    movdqa      xmm7, xmm4
+    movdqa      xmm0, xmm3
+    paddd       xmm4, xmm1              ; xmm4=data1L
+    paddd       xmm3, xmm6              ; xmm3=data1H
+    psubd       xmm7, xmm1              ; xmm7=data6L
+    psubd       xmm0, xmm6              ; xmm0=data6H
+
+    movdqa      xmm1, [rel PD_DESCALE_P1]  ; xmm1=[rel PD_DESCALE_P1]
+
+    paddd       xmm4, xmm1
+    paddd       xmm3, xmm1
+    psrad       xmm4, DESCALE_P1
+    psrad       xmm3, DESCALE_P1
+    paddd       xmm7, xmm1
+    paddd       xmm0, xmm1
+    psrad       xmm7, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+
+    packssdw    xmm4, xmm3              ; xmm4=data1=(10 11 12 13 14 15 16 17)
+    packssdw    xmm7, xmm0              ; xmm7=data6=(60 61 62 63 64 65 66 67)
+
+    movdqa      xmm6, xmm5              ; transpose coefficients(phase 1)
+    punpcklwd   xmm5, xmm4              ; xmm5=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm6, xmm4              ; xmm6=(04 14 05 15 06 16 07 17)
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 1)
+    punpcklwd   xmm7, xmm2              ; xmm7=(60 70 61 71 62 72 63 73)
+    punpckhwd   xmm1, xmm2              ; xmm1=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm3, XMMWORD [wk(6)]   ; xmm3=tmp12L
+    movdqa      xmm0, XMMWORD [wk(7)]   ; xmm0=tmp12H
+    movdqa      xmm4, XMMWORD [wk(10)]  ; xmm4=tmp1L
+    movdqa      xmm2, XMMWORD [wk(11)]  ; xmm2=tmp1H
+
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 01 11 02 12 03 13)
+    movdqa      XMMWORD [wk(1)], xmm6   ; wk(1)=(04 14 05 15 06 16 07 17)
+    movdqa      XMMWORD [wk(4)], xmm7   ; wk(4)=(60 70 61 71 62 72 63 73)
+    movdqa      XMMWORD [wk(5)], xmm1   ; wk(5)=(64 74 65 75 66 76 67 77)
+
+    movdqa      xmm5, xmm3
+    movdqa      xmm6, xmm0
+    paddd       xmm3, xmm4              ; xmm3=data2L
+    paddd       xmm0, xmm2              ; xmm0=data2H
+    psubd       xmm5, xmm4              ; xmm5=data5L
+    psubd       xmm6, xmm2              ; xmm6=data5H
+
+    movdqa      xmm7, [rel PD_DESCALE_P1]  ; xmm7=[rel PD_DESCALE_P1]
+
+    paddd       xmm3, xmm7
+    paddd       xmm0, xmm7
+    psrad       xmm3, DESCALE_P1
+    psrad       xmm0, DESCALE_P1
+    paddd       xmm5, xmm7
+    paddd       xmm6, xmm7
+    psrad       xmm5, DESCALE_P1
+    psrad       xmm6, DESCALE_P1
+
+    packssdw    xmm3, xmm0              ; xmm3=data2=(20 21 22 23 24 25 26 27)
+    packssdw    xmm5, xmm6              ; xmm5=data5=(50 51 52 53 54 55 56 57)
+
+    movdqa      xmm1, XMMWORD [wk(2)]   ; xmm1=tmp13L
+    movdqa      xmm4, XMMWORD [wk(3)]   ; xmm4=tmp13H
+    movdqa      xmm2, XMMWORD [wk(8)]   ; xmm2=tmp0L
+    movdqa      xmm7, XMMWORD [wk(9)]   ; xmm7=tmp0H
+
+    movdqa      xmm0, xmm1
+    movdqa      xmm6, xmm4
+    paddd       xmm1, xmm2              ; xmm1=data3L
+    paddd       xmm4, xmm7              ; xmm4=data3H
+    psubd       xmm0, xmm2              ; xmm0=data4L
+    psubd       xmm6, xmm7              ; xmm6=data4H
+
+    movdqa      xmm2, [rel PD_DESCALE_P1]  ; xmm2=[rel PD_DESCALE_P1]
+
+    paddd       xmm1, xmm2
+    paddd       xmm4, xmm2
+    psrad       xmm1, DESCALE_P1
+    psrad       xmm4, DESCALE_P1
+    paddd       xmm0, xmm2
+    paddd       xmm6, xmm2
+    psrad       xmm0, DESCALE_P1
+    psrad       xmm6, DESCALE_P1
+
+    packssdw    xmm1, xmm4              ; xmm1=data3=(30 31 32 33 34 35 36 37)
+    packssdw    xmm0, xmm6              ; xmm0=data4=(40 41 42 43 44 45 46 47)
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=(00 10 01 11 02 12 03 13)
+    movdqa      xmm2, XMMWORD [wk(1)]   ; xmm2=(04 14 05 15 06 16 07 17)
+
+    movdqa      xmm4, xmm3              ; transpose coefficients(phase 1)
+    punpcklwd   xmm3, xmm1              ; xmm3=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm4, xmm1              ; xmm4=(24 34 25 35 26 36 27 37)
+    movdqa      xmm6, xmm0              ; transpose coefficients(phase 1)
+    punpcklwd   xmm0, xmm5              ; xmm0=(40 50 41 51 42 52 43 53)
+    punpckhwd   xmm6, xmm5              ; xmm6=(44 54 45 55 46 56 47 57)
+
+    movdqa      xmm1, xmm7              ; transpose coefficients(phase 2)
+    punpckldq   xmm7, xmm3              ; xmm7=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm1, xmm3              ; xmm1=(02 12 22 32 03 13 23 33)
+    movdqa      xmm5, xmm2              ; transpose coefficients(phase 2)
+    punpckldq   xmm2, xmm4              ; xmm2=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm5, xmm4              ; xmm5=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm3, XMMWORD [wk(4)]   ; xmm3=(60 70 61 71 62 72 63 73)
+    movdqa      xmm4, XMMWORD [wk(5)]   ; xmm4=(64 74 65 75 66 76 67 77)
+
+    movdqa      XMMWORD [wk(6)], xmm2   ; wk(6)=(04 14 24 34 05 15 25 35)
+    movdqa      XMMWORD [wk(7)], xmm5   ; wk(7)=(06 16 26 36 07 17 27 37)
+
+    movdqa      xmm2, xmm0              ; transpose coefficients(phase 2)
+    punpckldq   xmm0, xmm3              ; xmm0=(40 50 60 70 41 51 61 71)
+    punpckhdq   xmm2, xmm3              ; xmm2=(42 52 62 72 43 53 63 73)
+    movdqa      xmm5, xmm6              ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm4              ; xmm6=(44 54 64 74 45 55 65 75)
+    punpckhdq   xmm5, xmm4              ; xmm5=(46 56 66 76 47 57 67 77)
+
+    movdqa      xmm3, xmm7              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm7, xmm0              ; xmm7=col0=(00 10 20 30 40 50 60 70)
+    punpckhqdq  xmm3, xmm0              ; xmm3=col1=(01 11 21 31 41 51 61 71)
+    movdqa      xmm4, xmm1              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm1, xmm2              ; xmm1=col2=(02 12 22 32 42 52 62 72)
+    punpckhqdq  xmm4, xmm2              ; xmm4=col3=(03 13 23 33 43 53 63 73)
+
+    movdqa      xmm0, XMMWORD [wk(6)]   ; xmm0=(04 14 24 34 05 15 25 35)
+    movdqa      xmm2, XMMWORD [wk(7)]   ; xmm2=(06 16 26 36 07 17 27 37)
+
+    movdqa      XMMWORD [wk(8)], xmm3   ; wk(8)=col1
+    movdqa      XMMWORD [wk(9)], xmm4   ; wk(9)=col3
+
+    movdqa      xmm3, xmm0              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm0, xmm6              ; xmm0=col4=(04 14 24 34 44 54 64 74)
+    punpckhqdq  xmm3, xmm6              ; xmm3=col5=(05 15 25 35 45 55 65 75)
+    movdqa      xmm4, xmm2              ; transpose coefficients(phase 3)
+    punpcklqdq  xmm2, xmm5              ; xmm2=col6=(06 16 26 36 46 56 66 76)
+    punpckhqdq  xmm4, xmm5              ; xmm4=col7=(07 17 27 37 47 57 67 77)
+
+    movdqa      XMMWORD [wk(10)], xmm3  ; wk(10)=col5
+    movdqa      XMMWORD [wk(11)], xmm4  ; wk(11)=col7
+.column_end:
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows from work array, store into output array.
+
+    mov         rax, [original_rbp]
+    mov         rdi, r12                ; (JSAMPROW *)
+    mov         eax, r13d
+
+    ; -- Even part
+
+    ; xmm7=col0, xmm1=col2, xmm0=col4, xmm2=col6
+
+    ; (Original)
+    ; z1 = (z2 + z3) * 0.541196100;
+    ; tmp2 = z1 + z3 * -1.847759065;
+    ; tmp3 = z1 + z2 * 0.765366865;
+    ;
+    ; (This implementation)
+    ; tmp2 = z2 * 0.541196100 + z3 * (0.541196100 - 1.847759065);
+    ; tmp3 = z2 * (0.541196100 + 0.765366865) + z3 * 0.541196100;
+
+    movdqa      xmm6, xmm1              ; xmm1=in2=z2
+    movdqa      xmm5, xmm1
+    punpcklwd   xmm6, xmm2              ; xmm2=in6=z3
+    punpckhwd   xmm5, xmm2
+    movdqa      xmm1, xmm6
+    movdqa      xmm2, xmm5
+    pmaddwd     xmm6, [rel PW_F130_F054]   ; xmm6=tmp3L
+    pmaddwd     xmm5, [rel PW_F130_F054]   ; xmm5=tmp3H
+    pmaddwd     xmm1, [rel PW_F054_MF130]  ; xmm1=tmp2L
+    pmaddwd     xmm2, [rel PW_F054_MF130]  ; xmm2=tmp2H
+
+    movdqa      xmm3, xmm7
+    paddw       xmm7, xmm0              ; xmm7=in0+in4
+    psubw       xmm3, xmm0              ; xmm3=in0-in4
+
+    pxor        xmm4, xmm4
+    pxor        xmm0, xmm0
+    punpcklwd   xmm4, xmm7              ; xmm4=tmp0L
+    punpckhwd   xmm0, xmm7              ; xmm0=tmp0H
+    psrad       xmm4, (16-CONST_BITS)   ; psrad xmm4,16 & pslld xmm4,CONST_BITS
+    psrad       xmm0, (16-CONST_BITS)   ; psrad xmm0,16 & pslld xmm0,CONST_BITS
+
+    movdqa      xmm7, xmm4
+    paddd       xmm4, xmm6              ; xmm4=tmp10L
+    psubd       xmm7, xmm6              ; xmm7=tmp13L
+    movdqa      xmm6, xmm0
+    paddd       xmm0, xmm5              ; xmm0=tmp10H
+    psubd       xmm6, xmm5              ; xmm6=tmp13H
+
+    movdqa      XMMWORD [wk(0)], xmm4   ; wk(0)=tmp10L
+    movdqa      XMMWORD [wk(1)], xmm0   ; wk(1)=tmp10H
+    movdqa      XMMWORD [wk(2)], xmm7   ; wk(2)=tmp13L
+    movdqa      XMMWORD [wk(3)], xmm6   ; wk(3)=tmp13H
+
+    pxor        xmm5, xmm5
+    pxor        xmm4, xmm4
+    punpcklwd   xmm5, xmm3              ; xmm5=tmp1L
+    punpckhwd   xmm4, xmm3              ; xmm4=tmp1H
+    psrad       xmm5, (16-CONST_BITS)   ; psrad xmm5,16 & pslld xmm5,CONST_BITS
+    psrad       xmm4, (16-CONST_BITS)   ; psrad xmm4,16 & pslld xmm4,CONST_BITS
+
+    movdqa      xmm0, xmm5
+    paddd       xmm5, xmm1              ; xmm5=tmp11L
+    psubd       xmm0, xmm1              ; xmm0=tmp12L
+    movdqa      xmm7, xmm4
+    paddd       xmm4, xmm2              ; xmm4=tmp11H
+    psubd       xmm7, xmm2              ; xmm7=tmp12H
+
+    movdqa      XMMWORD [wk(4)], xmm5   ; wk(4)=tmp11L
+    movdqa      XMMWORD [wk(5)], xmm4   ; wk(5)=tmp11H
+    movdqa      XMMWORD [wk(6)], xmm0   ; wk(6)=tmp12L
+    movdqa      XMMWORD [wk(7)], xmm7   ; wk(7)=tmp12H
+
+    ; -- Odd part
+
+    movdqa      xmm6, XMMWORD [wk(9)]   ; xmm6=col3
+    movdqa      xmm3, XMMWORD [wk(8)]   ; xmm3=col1
+    movdqa      xmm1, XMMWORD [wk(11)]  ; xmm1=col7
+    movdqa      xmm2, XMMWORD [wk(10)]  ; xmm2=col5
+
+    movdqa      xmm5, xmm6
+    movdqa      xmm4, xmm3
+    paddw       xmm5, xmm1              ; xmm5=z3
+    paddw       xmm4, xmm2              ; xmm4=z4
+
+    ; (Original)
+    ; z5 = (z3 + z4) * 1.175875602;
+    ; z3 = z3 * -1.961570560;  z4 = z4 * -0.390180644;
+    ; z3 += z5;  z4 += z5;
+    ;
+    ; (This implementation)
+    ; z3 = z3 * (1.175875602 - 1.961570560) + z4 * 1.175875602;
+    ; z4 = z3 * 1.175875602 + z4 * (1.175875602 - 0.390180644);
+
+    movdqa      xmm0, xmm5
+    movdqa      xmm7, xmm5
+    punpcklwd   xmm0, xmm4
+    punpckhwd   xmm7, xmm4
+    movdqa      xmm5, xmm0
+    movdqa      xmm4, xmm7
+    pmaddwd     xmm0, [rel PW_MF078_F117]  ; xmm0=z3L
+    pmaddwd     xmm7, [rel PW_MF078_F117]  ; xmm7=z3H
+    pmaddwd     xmm5, [rel PW_F117_F078]   ; xmm5=z4L
+    pmaddwd     xmm4, [rel PW_F117_F078]   ; xmm4=z4H
+
+    movdqa      XMMWORD [wk(10)], xmm0  ; wk(10)=z3L
+    movdqa      XMMWORD [wk(11)], xmm7  ; wk(11)=z3H
+
+    ; (Original)
+    ; z1 = tmp0 + tmp3;  z2 = tmp1 + tmp2;
+    ; tmp0 = tmp0 * 0.298631336;  tmp1 = tmp1 * 2.053119869;
+    ; tmp2 = tmp2 * 3.072711026;  tmp3 = tmp3 * 1.501321110;
+    ; z1 = z1 * -0.899976223;  z2 = z2 * -2.562915447;
+    ; tmp0 += z1 + z3;  tmp1 += z2 + z4;
+    ; tmp2 += z2 + z3;  tmp3 += z1 + z4;
+    ;
+    ; (This implementation)
+    ; tmp0 = tmp0 * (0.298631336 - 0.899976223) + tmp3 * -0.899976223;
+    ; tmp1 = tmp1 * (2.053119869 - 2.562915447) + tmp2 * -2.562915447;
+    ; tmp2 = tmp1 * -2.562915447 + tmp2 * (3.072711026 - 2.562915447);
+    ; tmp3 = tmp0 * -0.899976223 + tmp3 * (1.501321110 - 0.899976223);
+    ; tmp0 += z3;  tmp1 += z4;
+    ; tmp2 += z3;  tmp3 += z4;
+
+    movdqa      xmm0, xmm1
+    movdqa      xmm7, xmm1
+    punpcklwd   xmm0, xmm3
+    punpckhwd   xmm7, xmm3
+    movdqa      xmm1, xmm0
+    movdqa      xmm3, xmm7
+    pmaddwd     xmm0, [rel PW_MF060_MF089]  ; xmm0=tmp0L
+    pmaddwd     xmm7, [rel PW_MF060_MF089]  ; xmm7=tmp0H
+    pmaddwd     xmm1, [rel PW_MF089_F060]   ; xmm1=tmp3L
+    pmaddwd     xmm3, [rel PW_MF089_F060]   ; xmm3=tmp3H
+
+    paddd       xmm0, XMMWORD [wk(10)]  ; xmm0=tmp0L
+    paddd       xmm7, XMMWORD [wk(11)]  ; xmm7=tmp0H
+    paddd       xmm1, xmm5              ; xmm1=tmp3L
+    paddd       xmm3, xmm4              ; xmm3=tmp3H
+
+    movdqa      XMMWORD [wk(8)], xmm0   ; wk(8)=tmp0L
+    movdqa      XMMWORD [wk(9)], xmm7   ; wk(9)=tmp0H
+
+    movdqa      xmm0, xmm2
+    movdqa      xmm7, xmm2
+    punpcklwd   xmm0, xmm6
+    punpckhwd   xmm7, xmm6
+    movdqa      xmm2, xmm0
+    movdqa      xmm6, xmm7
+    pmaddwd     xmm0, [rel PW_MF050_MF256]  ; xmm0=tmp1L
+    pmaddwd     xmm7, [rel PW_MF050_MF256]  ; xmm7=tmp1H
+    pmaddwd     xmm2, [rel PW_MF256_F050]   ; xmm2=tmp2L
+    pmaddwd     xmm6, [rel PW_MF256_F050]   ; xmm6=tmp2H
+
+    paddd       xmm0, xmm5              ; xmm0=tmp1L
+    paddd       xmm7, xmm4              ; xmm7=tmp1H
+    paddd       xmm2, XMMWORD [wk(10)]  ; xmm2=tmp2L
+    paddd       xmm6, XMMWORD [wk(11)]  ; xmm6=tmp2H
+
+    movdqa      XMMWORD [wk(10)], xmm0  ; wk(10)=tmp1L
+    movdqa      XMMWORD [wk(11)], xmm7  ; wk(11)=tmp1H
+
+    ; -- Final output stage
+
+    movdqa      xmm5, XMMWORD [wk(0)]   ; xmm5=tmp10L
+    movdqa      xmm4, XMMWORD [wk(1)]   ; xmm4=tmp10H
+
+    movdqa      xmm0, xmm5
+    movdqa      xmm7, xmm4
+    paddd       xmm5, xmm1              ; xmm5=data0L
+    paddd       xmm4, xmm3              ; xmm4=data0H
+    psubd       xmm0, xmm1              ; xmm0=data7L
+    psubd       xmm7, xmm3              ; xmm7=data7H
+
+    movdqa      xmm1, [rel PD_DESCALE_P2]  ; xmm1=[rel PD_DESCALE_P2]
+
+    paddd       xmm5, xmm1
+    paddd       xmm4, xmm1
+    psrad       xmm5, DESCALE_P2
+    psrad       xmm4, DESCALE_P2
+    paddd       xmm0, xmm1
+    paddd       xmm7, xmm1
+    psrad       xmm0, DESCALE_P2
+    psrad       xmm7, DESCALE_P2
+
+    packssdw    xmm5, xmm4              ; xmm5=data0=(00 10 20 30 40 50 60 70)
+    packssdw    xmm0, xmm7              ; xmm0=data7=(07 17 27 37 47 57 67 77)
+
+    movdqa      xmm3, XMMWORD [wk(4)]   ; xmm3=tmp11L
+    movdqa      xmm1, XMMWORD [wk(5)]   ; xmm1=tmp11H
+
+    movdqa      xmm4, xmm3
+    movdqa      xmm7, xmm1
+    paddd       xmm3, xmm2              ; xmm3=data1L
+    paddd       xmm1, xmm6              ; xmm1=data1H
+    psubd       xmm4, xmm2              ; xmm4=data6L
+    psubd       xmm7, xmm6              ; xmm7=data6H
+
+    movdqa      xmm2, [rel PD_DESCALE_P2]  ; xmm2=[rel PD_DESCALE_P2]
+
+    paddd       xmm3, xmm2
+    paddd       xmm1, xmm2
+    psrad       xmm3, DESCALE_P2
+    psrad       xmm1, DESCALE_P2
+    paddd       xmm4, xmm2
+    paddd       xmm7, xmm2
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm7, DESCALE_P2
+
+    packssdw    xmm3, xmm1              ; xmm3=data1=(01 11 21 31 41 51 61 71)
+    packssdw    xmm4, xmm7              ; xmm4=data6=(06 16 26 36 46 56 66 76)
+
+    packsswb    xmm5, xmm4              ; xmm5=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    packsswb    xmm3, xmm0              ; xmm3=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    movdqa      xmm6, XMMWORD [wk(6)]   ; xmm6=tmp12L
+    movdqa      xmm2, XMMWORD [wk(7)]   ; xmm2=tmp12H
+    movdqa      xmm1, XMMWORD [wk(10)]  ; xmm1=tmp1L
+    movdqa      xmm7, XMMWORD [wk(11)]  ; xmm7=tmp1H
+
+    movdqa      XMMWORD [wk(0)], xmm5   ; wk(0)=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    movdqa      xmm4, xmm6
+    movdqa      xmm0, xmm2
+    paddd       xmm6, xmm1              ; xmm6=data2L
+    paddd       xmm2, xmm7              ; xmm2=data2H
+    psubd       xmm4, xmm1              ; xmm4=data5L
+    psubd       xmm0, xmm7              ; xmm0=data5H
+
+    movdqa      xmm5, [rel PD_DESCALE_P2]  ; xmm5=[rel PD_DESCALE_P2]
+
+    paddd       xmm6, xmm5
+    paddd       xmm2, xmm5
+    psrad       xmm6, DESCALE_P2
+    psrad       xmm2, DESCALE_P2
+    paddd       xmm4, xmm5
+    paddd       xmm0, xmm5
+    psrad       xmm4, DESCALE_P2
+    psrad       xmm0, DESCALE_P2
+
+    packssdw    xmm6, xmm2              ; xmm6=data2=(02 12 22 32 42 52 62 72)
+    packssdw    xmm4, xmm0              ; xmm4=data5=(05 15 25 35 45 55 65 75)
+
+    movdqa      xmm3, XMMWORD [wk(2)]   ; xmm3=tmp13L
+    movdqa      xmm1, XMMWORD [wk(3)]   ; xmm1=tmp13H
+    movdqa      xmm7, XMMWORD [wk(8)]   ; xmm7=tmp0L
+    movdqa      xmm5, XMMWORD [wk(9)]   ; xmm5=tmp0H
+
+    movdqa      xmm2, xmm3
+    movdqa      xmm0, xmm1
+    paddd       xmm3, xmm7              ; xmm3=data3L
+    paddd       xmm1, xmm5              ; xmm1=data3H
+    psubd       xmm2, xmm7              ; xmm2=data4L
+    psubd       xmm0, xmm5              ; xmm0=data4H
+
+    movdqa      xmm7, [rel PD_DESCALE_P2]  ; xmm7=[rel PD_DESCALE_P2]
+
+    paddd       xmm3, xmm7
+    paddd       xmm1, xmm7
+    psrad       xmm3, DESCALE_P2
+    psrad       xmm1, DESCALE_P2
+    paddd       xmm2, xmm7
+    paddd       xmm0, xmm7
+    psrad       xmm2, DESCALE_P2
+    psrad       xmm0, DESCALE_P2
+
+    movdqa      xmm5, [rel PB_CENTERJSAMP]  ; xmm5=[rel PB_CENTERJSAMP]
+
+    packssdw    xmm3, xmm1             ; xmm3=data3=(03 13 23 33 43 53 63 73)
+    packssdw    xmm2, xmm0             ; xmm2=data4=(04 14 24 34 44 54 64 74)
+
+    movdqa      xmm7, XMMWORD [wk(0)]  ; xmm7=(00 10 20 30 40 50 60 70 06 16 26 36 46 56 66 76)
+    movdqa      xmm1, XMMWORD [wk(1)]  ; xmm1=(01 11 21 31 41 51 61 71 07 17 27 37 47 57 67 77)
+
+    packsswb    xmm6, xmm2             ; xmm6=(02 12 22 32 42 52 62 72 04 14 24 34 44 54 64 74)
+    packsswb    xmm3, xmm4             ; xmm3=(03 13 23 33 43 53 63 73 05 15 25 35 45 55 65 75)
+
+    paddb       xmm7, xmm5
+    paddb       xmm1, xmm5
+    paddb       xmm6, xmm5
+    paddb       xmm3, xmm5
+
+    movdqa      xmm0, xmm7        ; transpose coefficients(phase 1)
+    punpcklbw   xmm7, xmm1        ; xmm7=(00 01 10 11 20 21 30 31 40 41 50 51 60 61 70 71)
+    punpckhbw   xmm0, xmm1        ; xmm0=(06 07 16 17 26 27 36 37 46 47 56 57 66 67 76 77)
+    movdqa      xmm2, xmm6        ; transpose coefficients(phase 1)
+    punpcklbw   xmm6, xmm3        ; xmm6=(02 03 12 13 22 23 32 33 42 43 52 53 62 63 72 73)
+    punpckhbw   xmm2, xmm3        ; xmm2=(04 05 14 15 24 25 34 35 44 45 54 55 64 65 74 75)
+
+    movdqa      xmm4, xmm7        ; transpose coefficients(phase 2)
+    punpcklwd   xmm7, xmm6        ; xmm7=(00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33)
+    punpckhwd   xmm4, xmm6        ; xmm4=(40 41 42 43 50 51 52 53 60 61 62 63 70 71 72 73)
+    movdqa      xmm5, xmm2        ; transpose coefficients(phase 2)
+    punpcklwd   xmm2, xmm0        ; xmm2=(04 05 06 07 14 15 16 17 24 25 26 27 34 35 36 37)
+    punpckhwd   xmm5, xmm0        ; xmm5=(44 45 46 47 54 55 56 57 64 65 66 67 74 75 76 77)
+
+    movdqa      xmm1, xmm7        ; transpose coefficients(phase 3)
+    punpckldq   xmm7, xmm2        ; xmm7=(00 01 02 03 04 05 06 07 10 11 12 13 14 15 16 17)
+    punpckhdq   xmm1, xmm2        ; xmm1=(20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 37)
+    movdqa      xmm3, xmm4        ; transpose coefficients(phase 3)
+    punpckldq   xmm4, xmm5        ; xmm4=(40 41 42 43 44 45 46 47 50 51 52 53 54 55 56 57)
+    punpckhdq   xmm3, xmm5        ; xmm3=(60 61 62 63 64 65 66 67 70 71 72 73 74 75 76 77)
+
+    pshufd      xmm6, xmm7, 0x4E  ; xmm6=(10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07)
+    pshufd      xmm0, xmm1, 0x4E  ; xmm0=(30 31 32 33 34 35 36 37 20 21 22 23 24 25 26 27)
+    pshufd      xmm2, xmm4, 0x4E  ; xmm2=(50 51 52 53 54 55 56 57 40 41 42 43 44 45 46 47)
+    pshufd      xmm5, xmm3, 0x4E  ; xmm5=(70 71 72 73 74 75 76 77 60 61 62 63 64 65 66 67)
+
+    mov         rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm7
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm1
+    mov         rdx, JSAMPROW [rdi+4*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+6*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm4
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm3
+
+    mov         rdx, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm6
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm0
+    mov         rdx, JSAMPROW [rdi+5*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+7*SIZEOF_JSAMPROW]
+    movq        XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE], xmm2
+    movq        XMM_MMWORD [rsi+rax*SIZEOF_JSAMPLE], xmm5
+
+    uncollect_args 4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jidctred-sse2.asm b/simd/x86_64/jidctred-sse2.asm
new file mode 100644
index 0000000..69b71f0
--- /dev/null
+++ b/simd/x86_64/jidctred-sse2.asm
@@ -0,0 +1,575 @@
+;
+; jidctred.asm - reduced-size IDCT (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; This file contains inverse-DCT routines that produce reduced-size
+; output: either 4x4 or 2x2 pixels from an 8x8 DCT block.
+; The following code is based directly on the IJG's original jidctred.c;
+; see the jidctred.c for more details.
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+
+%define CONST_BITS    13
+%define PASS1_BITS    2
+
+%define DESCALE_P1_4  (CONST_BITS-PASS1_BITS+1)
+%define DESCALE_P2_4  (CONST_BITS+PASS1_BITS+3+1)
+%define DESCALE_P1_2  (CONST_BITS-PASS1_BITS+2)
+%define DESCALE_P2_2  (CONST_BITS+PASS1_BITS+3+2)
+
+%if CONST_BITS == 13
+F_0_211 equ  1730  ; FIX(0.211164243)
+F_0_509 equ  4176  ; FIX(0.509795579)
+F_0_601 equ  4926  ; FIX(0.601344887)
+F_0_720 equ  5906  ; FIX(0.720959822)
+F_0_765 equ  6270  ; FIX(0.765366865)
+F_0_850 equ  6967  ; FIX(0.850430095)
+F_0_899 equ  7373  ; FIX(0.899976223)
+F_1_061 equ  8697  ; FIX(1.061594337)
+F_1_272 equ 10426  ; FIX(1.272758580)
+F_1_451 equ 11893  ; FIX(1.451774981)
+F_1_847 equ 15137  ; FIX(1.847759065)
+F_2_172 equ 17799  ; FIX(2.172734803)
+F_2_562 equ 20995  ; FIX(2.562915447)
+F_3_624 equ 29692  ; FIX(3.624509785)
+%else
+; NASM cannot do compile-time arithmetic on floating-point constants.
+%define DESCALE(x,n)  (((x)+(1<<((n)-1)))>>(n))
+F_0_211 equ DESCALE( 226735879, 30-CONST_BITS)  ; FIX(0.211164243)
+F_0_509 equ DESCALE( 547388834, 30-CONST_BITS)  ; FIX(0.509795579)
+F_0_601 equ DESCALE( 645689155, 30-CONST_BITS)  ; FIX(0.601344887)
+F_0_720 equ DESCALE( 774124714, 30-CONST_BITS)  ; FIX(0.720959822)
+F_0_765 equ DESCALE( 821806413, 30-CONST_BITS)  ; FIX(0.765366865)
+F_0_850 equ DESCALE( 913142361, 30-CONST_BITS)  ; FIX(0.850430095)
+F_0_899 equ DESCALE( 966342111, 30-CONST_BITS)  ; FIX(0.899976223)
+F_1_061 equ DESCALE(1139878239, 30-CONST_BITS)  ; FIX(1.061594337)
+F_1_272 equ DESCALE(1366614119, 30-CONST_BITS)  ; FIX(1.272758580)
+F_1_451 equ DESCALE(1558831516, 30-CONST_BITS)  ; FIX(1.451774981)
+F_1_847 equ DESCALE(1984016188, 30-CONST_BITS)  ; FIX(1.847759065)
+F_2_172 equ DESCALE(2332956230, 30-CONST_BITS)  ; FIX(2.172734803)
+F_2_562 equ DESCALE(2751909506, 30-CONST_BITS)  ; FIX(2.562915447)
+F_3_624 equ DESCALE(3891787747, 30-CONST_BITS)  ; FIX(3.624509785)
+%endif
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_CONST
+
+    alignz      32
+    global      EXTN(jconst_idct_red_sse2)
+
+EXTN(jconst_idct_red_sse2):
+
+PW_F184_MF076   times 4  dw  F_1_847,-F_0_765
+PW_F256_F089    times 4  dw  F_2_562, F_0_899
+PW_F106_MF217   times 4  dw  F_1_061,-F_2_172
+PW_MF060_MF050  times 4  dw -F_0_601,-F_0_509
+PW_F145_MF021   times 4  dw  F_1_451,-F_0_211
+PW_F362_MF127   times 4  dw  F_3_624,-F_1_272
+PW_F085_MF072   times 4  dw  F_0_850,-F_0_720
+PD_DESCALE_P1_4 times 4  dd  1 << (DESCALE_P1_4-1)
+PD_DESCALE_P2_4 times 4  dd  1 << (DESCALE_P2_4-1)
+PD_DESCALE_P1_2 times 4  dd  1 << (DESCALE_P1_2-1)
+PD_DESCALE_P2_2 times 4  dd  1 << (DESCALE_P2_2-1)
+PB_CENTERJSAMP  times 16 db  CENTERJSAMPLE
+
+    alignz      32
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Perform dequantization and inverse DCT on one block of coefficients,
+; producing a reduced-size 4x4 output block.
+;
+; GLOBAL(void)
+; jsimd_idct_4x4_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                      JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+; r10 = void *dct_table
+; r11 = JCOEFPTR coef_block
+; r12 = JSAMPARRAY output_buf
+; r13d = JDIMENSION output_col
+
+%define original_rbp  rbp+0
+%define wk(i)         rbp-(WK_NUM-(i))*SIZEOF_XMMWORD  ; xmmword wk[WK_NUM]
+%define WK_NUM        2
+
+    align       32
+    global      EXTN(jsimd_idct_4x4_sse2)
+
+EXTN(jsimd_idct_4x4_sse2):
+    push        rbp
+    mov         rax, rsp                     ; rax = original rbp
+    sub         rsp, byte 4
+    and         rsp, byte (-SIZEOF_XMMWORD)  ; align to 128 bits
+    mov         [rsp], rax
+    mov         rbp, rsp                     ; rbp = aligned rbp
+    lea         rsp, [wk(0)]
+    collect_args 4
+
+    ; ---- Pass 1: process columns from input.
+
+    mov         rdx, r10                ; quantptr
+    mov         rsi, r11                ; inptr
+
+%ifndef NO_ZERO_COLUMN_TEST_4X4_SSE2
+    mov         eax, DWORD [DWBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    or          eax, DWORD [DWBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    jnz         short .columnDCT
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+    por         xmm1, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    por         xmm0, xmm1
+    packsswb    xmm0, xmm0
+    packsswb    xmm0, xmm0
+    movd        eax, xmm0
+    test        rax, rax
+    jnz         short .columnDCT
+
+    ; -- AC terms all zero
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    psllw       xmm0, PASS1_BITS
+
+    movdqa      xmm3, xmm0        ; xmm0=in0=(00 01 02 03 04 05 06 07)
+    punpcklwd   xmm0, xmm0        ; xmm0=(00 00 01 01 02 02 03 03)
+    punpckhwd   xmm3, xmm3        ; xmm3=(04 04 05 05 06 06 07 07)
+
+    pshufd      xmm1, xmm0, 0x50  ; xmm1=[col0 col1]=(00 00 00 00 01 01 01 01)
+    pshufd      xmm0, xmm0, 0xFA  ; xmm0=[col2 col3]=(02 02 02 02 03 03 03 03)
+    pshufd      xmm6, xmm3, 0x50  ; xmm6=[col4 col5]=(04 04 04 04 05 05 05 05)
+    pshufd      xmm3, xmm3, 0xFA  ; xmm3=[col6 col7]=(06 06 06 06 07 07 07 07)
+
+    jmp         near .column_end
+%endif
+.columnDCT:
+
+    ; -- Odd part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    movdqa      xmm4, xmm0
+    movdqa      xmm5, xmm0
+    punpcklwd   xmm4, xmm1
+    punpckhwd   xmm5, xmm1
+    movdqa      xmm0, xmm4
+    movdqa      xmm1, xmm5
+    pmaddwd     xmm4, [rel PW_F256_F089]   ; xmm4=(tmp2L)
+    pmaddwd     xmm5, [rel PW_F256_F089]   ; xmm5=(tmp2H)
+    pmaddwd     xmm0, [rel PW_F106_MF217]  ; xmm0=(tmp0L)
+    pmaddwd     xmm1, [rel PW_F106_MF217]  ; xmm1=(tmp0H)
+
+    movdqa      xmm6, xmm2
+    movdqa      xmm7, xmm2
+    punpcklwd   xmm6, xmm3
+    punpckhwd   xmm7, xmm3
+    movdqa      xmm2, xmm6
+    movdqa      xmm3, xmm7
+    pmaddwd     xmm6, [rel PW_MF060_MF050]  ; xmm6=(tmp2L)
+    pmaddwd     xmm7, [rel PW_MF060_MF050]  ; xmm7=(tmp2H)
+    pmaddwd     xmm2, [rel PW_F145_MF021]   ; xmm2=(tmp0L)
+    pmaddwd     xmm3, [rel PW_F145_MF021]   ; xmm3=(tmp0H)
+
+    paddd       xmm6, xmm4              ; xmm6=tmp2L
+    paddd       xmm7, xmm5              ; xmm7=tmp2H
+    paddd       xmm2, xmm0              ; xmm2=tmp0L
+    paddd       xmm3, xmm1              ; xmm3=tmp0H
+
+    movdqa      XMMWORD [wk(0)], xmm2   ; wk(0)=tmp0L
+    movdqa      XMMWORD [wk(1)], xmm3   ; wk(1)=tmp0H
+
+    ; -- Even part
+
+    movdqa      xmm4, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm5, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm0, XMMWORD [XMMBLOCK(6,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm4, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm5, XMMWORD [XMMBLOCK(2,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(6,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    pxor        xmm1, xmm1
+    pxor        xmm2, xmm2
+    punpcklwd   xmm1, xmm4               ; xmm1=tmp0L
+    punpckhwd   xmm2, xmm4               ; xmm2=tmp0H
+    psrad       xmm1, (16-CONST_BITS-1)  ; psrad xmm1,16 & pslld xmm1,CONST_BITS+1
+    psrad       xmm2, (16-CONST_BITS-1)  ; psrad xmm2,16 & pslld xmm2,CONST_BITS+1
+
+    movdqa      xmm3, xmm5              ; xmm5=in2=z2
+    punpcklwd   xmm5, xmm0              ; xmm0=in6=z3
+    punpckhwd   xmm3, xmm0
+    pmaddwd     xmm5, [rel PW_F184_MF076]  ; xmm5=tmp2L
+    pmaddwd     xmm3, [rel PW_F184_MF076]  ; xmm3=tmp2H
+
+    movdqa      xmm4, xmm1
+    movdqa      xmm0, xmm2
+    paddd       xmm1, xmm5              ; xmm1=tmp10L
+    paddd       xmm2, xmm3              ; xmm2=tmp10H
+    psubd       xmm4, xmm5              ; xmm4=tmp12L
+    psubd       xmm0, xmm3              ; xmm0=tmp12H
+
+    ; -- Final output stage
+
+    movdqa      xmm5, xmm1
+    movdqa      xmm3, xmm2
+    paddd       xmm1, xmm6              ; xmm1=data0L
+    paddd       xmm2, xmm7              ; xmm2=data0H
+    psubd       xmm5, xmm6              ; xmm5=data3L
+    psubd       xmm3, xmm7              ; xmm3=data3H
+
+    movdqa      xmm6, [rel PD_DESCALE_P1_4]  ; xmm6=[rel PD_DESCALE_P1_4]
+
+    paddd       xmm1, xmm6
+    paddd       xmm2, xmm6
+    psrad       xmm1, DESCALE_P1_4
+    psrad       xmm2, DESCALE_P1_4
+    paddd       xmm5, xmm6
+    paddd       xmm3, xmm6
+    psrad       xmm5, DESCALE_P1_4
+    psrad       xmm3, DESCALE_P1_4
+
+    packssdw    xmm1, xmm2              ; xmm1=data0=(00 01 02 03 04 05 06 07)
+    packssdw    xmm5, xmm3              ; xmm5=data3=(30 31 32 33 34 35 36 37)
+
+    movdqa      xmm7, XMMWORD [wk(0)]   ; xmm7=tmp0L
+    movdqa      xmm6, XMMWORD [wk(1)]   ; xmm6=tmp0H
+
+    movdqa      xmm2, xmm4
+    movdqa      xmm3, xmm0
+    paddd       xmm4, xmm7              ; xmm4=data1L
+    paddd       xmm0, xmm6              ; xmm0=data1H
+    psubd       xmm2, xmm7              ; xmm2=data2L
+    psubd       xmm3, xmm6              ; xmm3=data2H
+
+    movdqa      xmm7, [rel PD_DESCALE_P1_4]  ; xmm7=[rel PD_DESCALE_P1_4]
+
+    paddd       xmm4, xmm7
+    paddd       xmm0, xmm7
+    psrad       xmm4, DESCALE_P1_4
+    psrad       xmm0, DESCALE_P1_4
+    paddd       xmm2, xmm7
+    paddd       xmm3, xmm7
+    psrad       xmm2, DESCALE_P1_4
+    psrad       xmm3, DESCALE_P1_4
+
+    packssdw    xmm4, xmm0        ; xmm4=data1=(10 11 12 13 14 15 16 17)
+    packssdw    xmm2, xmm3        ; xmm2=data2=(20 21 22 23 24 25 26 27)
+
+    movdqa      xmm6, xmm1        ; transpose coefficients(phase 1)
+    punpcklwd   xmm1, xmm4        ; xmm1=(00 10 01 11 02 12 03 13)
+    punpckhwd   xmm6, xmm4        ; xmm6=(04 14 05 15 06 16 07 17)
+    movdqa      xmm7, xmm2        ; transpose coefficients(phase 1)
+    punpcklwd   xmm2, xmm5        ; xmm2=(20 30 21 31 22 32 23 33)
+    punpckhwd   xmm7, xmm5        ; xmm7=(24 34 25 35 26 36 27 37)
+
+    movdqa      xmm0, xmm1        ; transpose coefficients(phase 2)
+    punpckldq   xmm1, xmm2        ; xmm1=[col0 col1]=(00 10 20 30 01 11 21 31)
+    punpckhdq   xmm0, xmm2        ; xmm0=[col2 col3]=(02 12 22 32 03 13 23 33)
+    movdqa      xmm3, xmm6        ; transpose coefficients(phase 2)
+    punpckldq   xmm6, xmm7        ; xmm6=[col4 col5]=(04 14 24 34 05 15 25 35)
+    punpckhdq   xmm3, xmm7        ; xmm3=[col6 col7]=(06 16 26 36 07 17 27 37)
+.column_end:
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows, store into output array.
+
+    mov         rax, [original_rbp]
+    mov         rdi, r12                ; (JSAMPROW *)
+    mov         eax, r13d
+
+    ; -- Even part
+
+    pxor        xmm4, xmm4
+    punpcklwd   xmm4, xmm1               ; xmm4=tmp0
+    psrad       xmm4, (16-CONST_BITS-1)  ; psrad xmm4,16 & pslld xmm4,CONST_BITS+1
+
+    ; -- Odd part
+
+    punpckhwd   xmm1, xmm0
+    punpckhwd   xmm6, xmm3
+    movdqa      xmm5, xmm1
+    movdqa      xmm2, xmm6
+    pmaddwd     xmm1, [rel PW_F256_F089]    ; xmm1=(tmp2)
+    pmaddwd     xmm6, [rel PW_MF060_MF050]  ; xmm6=(tmp2)
+    pmaddwd     xmm5, [rel PW_F106_MF217]   ; xmm5=(tmp0)
+    pmaddwd     xmm2, [rel PW_F145_MF021]   ; xmm2=(tmp0)
+
+    paddd       xmm6, xmm1              ; xmm6=tmp2
+    paddd       xmm2, xmm5              ; xmm2=tmp0
+
+    ; -- Even part
+
+    punpcklwd   xmm0, xmm3
+    pmaddwd     xmm0, [rel PW_F184_MF076]  ; xmm0=tmp2
+
+    movdqa      xmm7, xmm4
+    paddd       xmm4, xmm0              ; xmm4=tmp10
+    psubd       xmm7, xmm0              ; xmm7=tmp12
+
+    ; -- Final output stage
+
+    movdqa      xmm1, [rel PD_DESCALE_P2_4]  ; xmm1=[rel PD_DESCALE_P2_4]
+
+    movdqa      xmm5, xmm4
+    movdqa      xmm3, xmm7
+    paddd       xmm4, xmm6              ; xmm4=data0=(00 10 20 30)
+    paddd       xmm7, xmm2              ; xmm7=data1=(01 11 21 31)
+    psubd       xmm5, xmm6              ; xmm5=data3=(03 13 23 33)
+    psubd       xmm3, xmm2              ; xmm3=data2=(02 12 22 32)
+
+    paddd       xmm4, xmm1
+    paddd       xmm7, xmm1
+    psrad       xmm4, DESCALE_P2_4
+    psrad       xmm7, DESCALE_P2_4
+    paddd       xmm5, xmm1
+    paddd       xmm3, xmm1
+    psrad       xmm5, DESCALE_P2_4
+    psrad       xmm3, DESCALE_P2_4
+
+    packssdw    xmm4, xmm3              ; xmm4=(00 10 20 30 02 12 22 32)
+    packssdw    xmm7, xmm5              ; xmm7=(01 11 21 31 03 13 23 33)
+
+    movdqa      xmm0, xmm4              ; transpose coefficients(phase 1)
+    punpcklwd   xmm4, xmm7              ; xmm4=(00 01 10 11 20 21 30 31)
+    punpckhwd   xmm0, xmm7              ; xmm0=(02 03 12 13 22 23 32 33)
+
+    movdqa      xmm6, xmm4              ; transpose coefficients(phase 2)
+    punpckldq   xmm4, xmm0              ; xmm4=(00 01 02 03 10 11 12 13)
+    punpckhdq   xmm6, xmm0              ; xmm6=(20 21 22 23 30 31 32 33)
+
+    packsswb    xmm4, xmm6              ; xmm4=(00 01 02 03 10 11 12 13 20 ..)
+    paddb       xmm4, [rel PB_CENTERJSAMP]
+
+    pshufd      xmm2, xmm4, 0x39        ; xmm2=(10 11 12 13 20 21 22 23 30 ..)
+    pshufd      xmm1, xmm4, 0x4E        ; xmm1=(20 21 22 23 30 31 32 33 00 ..)
+    pshufd      xmm3, xmm4, 0x93        ; xmm3=(30 31 32 33 00 01 02 03 10 ..)
+
+    mov         rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
+    movd        XMM_DWORD [rdx+rax*SIZEOF_JSAMPLE], xmm4
+    movd        XMM_DWORD [rsi+rax*SIZEOF_JSAMPLE], xmm2
+    mov         rdx, JSAMPROW [rdi+2*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+3*SIZEOF_JSAMPROW]
+    movd        XMM_DWORD [rdx+rax*SIZEOF_JSAMPLE], xmm1
+    movd        XMM_DWORD [rsi+rax*SIZEOF_JSAMPLE], xmm3
+
+    uncollect_args 4
+    mov         rsp, rbp                ; rsp <- aligned rbp
+    pop         rsp                     ; rsp <- original rbp
+    pop         rbp
+    ret
+
+
+; --------------------------------------------------------------------------
+;
+; Perform dequantization and inverse DCT on one block of coefficients,
+; producing a reduced-size 2x2 output block.
+;
+; GLOBAL(void)
+; jsimd_idct_2x2_sse2 (void *dct_table, JCOEFPTR coef_block,
+;                      JSAMPARRAY output_buf, JDIMENSION output_col)
+;
+
+; r10 = void *dct_table
+; r11 = JCOEFPTR coef_block
+; r12 = JSAMPARRAY output_buf
+; r13d = JDIMENSION output_col
+
+    align       32
+    global      EXTN(jsimd_idct_2x2_sse2)
+
+EXTN(jsimd_idct_2x2_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 4
+    push        rbx
+
+    ; ---- Pass 1: process columns from input.
+
+    mov         rdx, r10                ; quantptr
+    mov         rsi, r11                ; inptr
+
+    ; | input:                  | result:        |
+    ; | 00 01 ** 03 ** 05 ** 07 |                |
+    ; | 10 11 ** 13 ** 15 ** 17 |                |
+    ; | ** ** ** ** ** ** ** ** |                |
+    ; | 30 31 ** 33 ** 35 ** 37 | A0 A1 A3 A5 A7 |
+    ; | ** ** ** ** ** ** ** ** | B0 B1 B3 B5 B7 |
+    ; | 50 51 ** 53 ** 55 ** 57 |                |
+    ; | ** ** ** ** ** ** ** ** |                |
+    ; | 70 71 ** 73 ** 75 ** 77 |                |
+
+    ; -- Odd part
+
+    movdqa      xmm0, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm1, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm0, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm1, XMMWORD [XMMBLOCK(3,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    movdqa      xmm2, XMMWORD [XMMBLOCK(5,0,rsi,SIZEOF_JCOEF)]
+    movdqa      xmm3, XMMWORD [XMMBLOCK(7,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm2, XMMWORD [XMMBLOCK(5,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+    pmullw      xmm3, XMMWORD [XMMBLOCK(7,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    ; xmm0=(10 11 ** 13 ** 15 ** 17), xmm1=(30 31 ** 33 ** 35 ** 37)
+    ; xmm2=(50 51 ** 53 ** 55 ** 57), xmm3=(70 71 ** 73 ** 75 ** 77)
+
+    pcmpeqd     xmm7, xmm7
+    pslld       xmm7, WORD_BIT          ; xmm7={0x0000 0xFFFF 0x0000 0xFFFF ..}
+
+    movdqa      xmm4, xmm0              ; xmm4=(10 11 ** 13 ** 15 ** 17)
+    movdqa      xmm5, xmm2              ; xmm5=(50 51 ** 53 ** 55 ** 57)
+    punpcklwd   xmm4, xmm1              ; xmm4=(10 30 11 31 ** ** 13 33)
+    punpcklwd   xmm5, xmm3              ; xmm5=(50 70 51 71 ** ** 53 73)
+    pmaddwd     xmm4, [rel PW_F362_MF127]
+    pmaddwd     xmm5, [rel PW_F085_MF072]
+
+    psrld       xmm0, WORD_BIT          ; xmm0=(11 -- 13 -- 15 -- 17 --)
+    pand        xmm1, xmm7              ; xmm1=(-- 31 -- 33 -- 35 -- 37)
+    psrld       xmm2, WORD_BIT          ; xmm2=(51 -- 53 -- 55 -- 57 --)
+    pand        xmm3, xmm7              ; xmm3=(-- 71 -- 73 -- 75 -- 77)
+    por         xmm0, xmm1              ; xmm0=(11 31 13 33 15 35 17 37)
+    por         xmm2, xmm3              ; xmm2=(51 71 53 73 55 75 57 77)
+    pmaddwd     xmm0, [rel PW_F362_MF127]
+    pmaddwd     xmm2, [rel PW_F085_MF072]
+
+    paddd       xmm4, xmm5              ; xmm4=tmp0[col0 col1 **** col3]
+    paddd       xmm0, xmm2              ; xmm0=tmp0[col1 col3 col5 col7]
+
+    ; -- Even part
+
+    movdqa      xmm6, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_JCOEF)]
+    pmullw      xmm6, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_ISLOW_MULT_TYPE)]
+
+    ; xmm6=(00 01 ** 03 ** 05 ** 07)
+
+    movdqa      xmm1, xmm6              ; xmm1=(00 01 ** 03 ** 05 ** 07)
+    pslld       xmm6, WORD_BIT          ; xmm6=(-- 00 -- ** -- ** -- **)
+    pand        xmm1, xmm7              ; xmm1=(-- 01 -- 03 -- 05 -- 07)
+    psrad       xmm6, (WORD_BIT-CONST_BITS-2)  ; xmm6=tmp10[col0 **** **** ****]
+    psrad       xmm1, (WORD_BIT-CONST_BITS-2)  ; xmm1=tmp10[col1 col3 col5 col7]
+
+    ; -- Final output stage
+
+    movdqa      xmm3, xmm6
+    movdqa      xmm5, xmm1
+    paddd       xmm6, xmm4      ; xmm6=data0[col0 **** **** ****]=(A0 ** ** **)
+    paddd       xmm1, xmm0      ; xmm1=data0[col1 col3 col5 col7]=(A1 A3 A5 A7)
+    psubd       xmm3, xmm4      ; xmm3=data1[col0 **** **** ****]=(B0 ** ** **)
+    psubd       xmm5, xmm0      ; xmm5=data1[col1 col3 col5 col7]=(B1 B3 B5 B7)
+
+    movdqa      xmm2, [rel PD_DESCALE_P1_2]  ; xmm2=[rel PD_DESCALE_P1_2]
+
+    punpckldq   xmm6, xmm3              ; xmm6=(A0 B0 ** **)
+
+    movdqa      xmm7, xmm1
+    punpcklqdq  xmm1, xmm5              ; xmm1=(A1 A3 B1 B3)
+    punpckhqdq  xmm7, xmm5              ; xmm7=(A5 A7 B5 B7)
+
+    paddd       xmm6, xmm2
+    psrad       xmm6, DESCALE_P1_2
+
+    paddd       xmm1, xmm2
+    paddd       xmm7, xmm2
+    psrad       xmm1, DESCALE_P1_2
+    psrad       xmm7, DESCALE_P1_2
+
+    ; -- Prefetch the next coefficient block
+
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 0*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 1*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 2*32]
+    prefetchnta [rsi + DCTSIZE2*SIZEOF_JCOEF + 3*32]
+
+    ; ---- Pass 2: process rows, store into output array.
+
+    mov         rdi, r12                ; (JSAMPROW *)
+    mov         eax, r13d
+
+    ; | input:| result:|
+    ; | A0 B0 |        |
+    ; | A1 B1 | C0 C1  |
+    ; | A3 B3 | D0 D1  |
+    ; | A5 B5 |        |
+    ; | A7 B7 |        |
+
+    ; -- Odd part
+
+    packssdw    xmm1, xmm1              ; xmm1=(A1 A3 B1 B3 A1 A3 B1 B3)
+    packssdw    xmm7, xmm7              ; xmm7=(A5 A7 B5 B7 A5 A7 B5 B7)
+    pmaddwd     xmm1, [rel PW_F362_MF127]
+    pmaddwd     xmm7, [rel PW_F085_MF072]
+
+    paddd       xmm1, xmm7              ; xmm1=tmp0[row0 row1 row0 row1]
+
+    ; -- Even part
+
+    pslld       xmm6, (CONST_BITS+2)    ; xmm6=tmp10[row0 row1 **** ****]
+
+    ; -- Final output stage
+
+    movdqa      xmm4, xmm6
+    paddd       xmm6, xmm1     ; xmm6=data0[row0 row1 **** ****]=(C0 C1 ** **)
+    psubd       xmm4, xmm1     ; xmm4=data1[row0 row1 **** ****]=(D0 D1 ** **)
+
+    punpckldq   xmm6, xmm4     ; xmm6=(C0 D0 C1 D1)
+
+    paddd       xmm6, [rel PD_DESCALE_P2_2]
+    psrad       xmm6, DESCALE_P2_2
+
+    packssdw    xmm6, xmm6              ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1)
+    packsswb    xmm6, xmm6              ; xmm6=(C0 D0 C1 D1 C0 D0 C1 D1 ..)
+    paddb       xmm6, [rel PB_CENTERJSAMP]
+
+    pextrw      ebx, xmm6, 0x00         ; ebx=(C0 D0 -- --)
+    pextrw      ecx, xmm6, 0x01         ; ecx=(C1 D1 -- --)
+
+    mov         rdx, JSAMPROW [rdi+0*SIZEOF_JSAMPROW]
+    mov         rsi, JSAMPROW [rdi+1*SIZEOF_JSAMPROW]
+    mov         WORD [rdx+rax*SIZEOF_JSAMPLE], bx
+    mov         WORD [rsi+rax*SIZEOF_JSAMPLE], cx
+
+    pop         rbx
+    uncollect_args 4
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jquantf-sse2.asm b/simd/x86_64/jquantf-sse2.asm
new file mode 100644
index 0000000..3699d44
--- /dev/null
+++ b/simd/x86_64/jquantf-sse2.asm
@@ -0,0 +1,157 @@
+;
+; jquantf.asm - sample data conversion and quantization (64-bit SSE & SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Load data into workspace, applying unsigned->signed conversion
+;
+; GLOBAL(void)
+; jsimd_convsamp_float_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
+;                            FAST_FLOAT *workspace);
+;
+
+; r10 = JSAMPARRAY sample_data
+; r11d = JDIMENSION start_col
+; r12 = FAST_FLOAT *workspace
+
+    align       32
+    global      EXTN(jsimd_convsamp_float_sse2)
+
+EXTN(jsimd_convsamp_float_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 3
+    push        rbx
+
+    pcmpeqw     xmm7, xmm7
+    psllw       xmm7, 7
+    packsswb    xmm7, xmm7              ; xmm7 = PB_CENTERJSAMPLE (0x808080..)
+
+    mov         rsi, r10
+    mov         eax, r11d
+    mov         rdi, r12
+    mov         rcx, DCTSIZE/2
+.convloop:
+    mov         rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+    mov         rdx, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+
+    movq        xmm0, XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE]
+    movq        xmm1, XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE]
+
+    psubb       xmm0, xmm7              ; xmm0=(01234567)
+    psubb       xmm1, xmm7              ; xmm1=(89ABCDEF)
+
+    punpcklbw   xmm0, xmm0              ; xmm0=(*0*1*2*3*4*5*6*7)
+    punpcklbw   xmm1, xmm1              ; xmm1=(*8*9*A*B*C*D*E*F)
+
+    punpcklwd   xmm2, xmm0              ; xmm2=(***0***1***2***3)
+    punpckhwd   xmm0, xmm0              ; xmm0=(***4***5***6***7)
+    punpcklwd   xmm3, xmm1              ; xmm3=(***8***9***A***B)
+    punpckhwd   xmm1, xmm1              ; xmm1=(***C***D***E***F)
+
+    psrad       xmm2, (DWORD_BIT-BYTE_BIT)  ; xmm2=(0123)
+    psrad       xmm0, (DWORD_BIT-BYTE_BIT)  ; xmm0=(4567)
+    cvtdq2ps    xmm2, xmm2                  ; xmm2=(0123)
+    cvtdq2ps    xmm0, xmm0                  ; xmm0=(4567)
+    psrad       xmm3, (DWORD_BIT-BYTE_BIT)  ; xmm3=(89AB)
+    psrad       xmm1, (DWORD_BIT-BYTE_BIT)  ; xmm1=(CDEF)
+    cvtdq2ps    xmm3, xmm3                  ; xmm3=(89AB)
+    cvtdq2ps    xmm1, xmm1                  ; xmm1=(CDEF)
+
+    movaps      XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_FAST_FLOAT)], xmm2
+    movaps      XMMWORD [XMMBLOCK(0,1,rdi,SIZEOF_FAST_FLOAT)], xmm0
+    movaps      XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_FAST_FLOAT)], xmm3
+    movaps      XMMWORD [XMMBLOCK(1,1,rdi,SIZEOF_FAST_FLOAT)], xmm1
+
+    add         rsi, byte 2*SIZEOF_JSAMPROW
+    add         rdi, byte 2*DCTSIZE*SIZEOF_FAST_FLOAT
+    dec         rcx
+    jnz         short .convloop
+
+    pop         rbx
+    uncollect_args 3
+    pop         rbp
+    ret
+
+
+; --------------------------------------------------------------------------
+;
+; Quantize/descale the coefficients, and store into coef_block
+;
+; GLOBAL(void)
+; jsimd_quantize_float_sse2 (JCOEFPTR coef_block, FAST_FLOAT *divisors,
+;                         FAST_FLOAT *workspace);
+;
+
+; r10 = JCOEFPTR coef_block
+; r11 = FAST_FLOAT *divisors
+; r12 = FAST_FLOAT *workspace
+
+    align       32
+    global      EXTN(jsimd_quantize_float_sse2)
+
+EXTN(jsimd_quantize_float_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 3
+
+    mov         rsi, r12
+    mov         rdx, r11
+    mov         rdi, r10
+    mov         rax, DCTSIZE2/16
+.quantloop:
+    movaps      xmm0, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm1, XMMWORD [XMMBLOCK(0,1,rsi,SIZEOF_FAST_FLOAT)]
+    mulps       xmm0, XMMWORD [XMMBLOCK(0,0,rdx,SIZEOF_FAST_FLOAT)]
+    mulps       xmm1, XMMWORD [XMMBLOCK(0,1,rdx,SIZEOF_FAST_FLOAT)]
+    movaps      xmm2, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_FAST_FLOAT)]
+    movaps      xmm3, XMMWORD [XMMBLOCK(1,1,rsi,SIZEOF_FAST_FLOAT)]
+    mulps       xmm2, XMMWORD [XMMBLOCK(1,0,rdx,SIZEOF_FAST_FLOAT)]
+    mulps       xmm3, XMMWORD [XMMBLOCK(1,1,rdx,SIZEOF_FAST_FLOAT)]
+
+    cvtps2dq    xmm0, xmm0
+    cvtps2dq    xmm1, xmm1
+    cvtps2dq    xmm2, xmm2
+    cvtps2dq    xmm3, xmm3
+
+    packssdw    xmm0, xmm1
+    packssdw    xmm2, xmm3
+
+    movdqa      XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_JCOEF)], xmm0
+    movdqa      XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_JCOEF)], xmm2
+
+    add         rsi, byte 16*SIZEOF_FAST_FLOAT
+    add         rdx, byte 16*SIZEOF_FAST_FLOAT
+    add         rdi, byte 16*SIZEOF_JCOEF
+    dec         rax
+    jnz         short .quantloop
+
+    uncollect_args 3
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jquanti-avx2.asm b/simd/x86_64/jquanti-avx2.asm
new file mode 100644
index 0000000..60ce19f
--- /dev/null
+++ b/simd/x86_64/jquanti-avx2.asm
@@ -0,0 +1,96 @@
+;
+; jquanti.asm - sample data conversion and quantization (64-bit AVX2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+; Copyright (C) 2016, Matthieu Darbois.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+
+; --------------------------------------------------------------------------
+;
+; Quantize/descale the coefficients, and store into coef_block
+;
+; This implementation is based on an algorithm described in
+;   "How to optimize for the Pentium family of microprocessors"
+;   (http://www.agner.org/assem/).
+;
+; GLOBAL(void)
+; jsimd_quantize_avx2 (JCOEFPTR coef_block, DCTELEM *divisors,
+;                      DCTELEM *workspace);
+;
+
+%define RECIPROCAL(m,n,b)  XMMBLOCK(DCTSIZE*0+(m),(n),(b),SIZEOF_DCTELEM)
+%define CORRECTION(m,n,b)  XMMBLOCK(DCTSIZE*1+(m),(n),(b),SIZEOF_DCTELEM)
+%define SCALE(m,n,b)       XMMBLOCK(DCTSIZE*2+(m),(n),(b),SIZEOF_DCTELEM)
+
+; r10 = JCOEFPTR coef_block
+; r11 = DCTELEM *divisors
+; r12 = DCTELEM *workspace
+
+    align       32
+    global      EXTN(jsimd_quantize_avx2)
+
+EXTN(jsimd_quantize_avx2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 3
+
+    vmovdqu     ymm4, [XMMBLOCK(0,0,r12,SIZEOF_DCTELEM)]
+    vmovdqu     ymm5, [XMMBLOCK(2,0,r12,SIZEOF_DCTELEM)]
+    vmovdqu     ymm6, [XMMBLOCK(4,0,r12,SIZEOF_DCTELEM)]
+    vmovdqu     ymm7, [XMMBLOCK(6,0,r12,SIZEOF_DCTELEM)]
+    vpabsw      ymm0, ymm4
+    vpabsw      ymm1, ymm5
+    vpabsw      ymm2, ymm6
+    vpabsw      ymm3, ymm7
+
+    vpaddw      ymm0, YMMWORD [CORRECTION(0,0,r11)]  ; correction + roundfactor
+    vpaddw      ymm1, YMMWORD [CORRECTION(2,0,r11)]
+    vpaddw      ymm2, YMMWORD [CORRECTION(4,0,r11)]
+    vpaddw      ymm3, YMMWORD [CORRECTION(6,0,r11)]
+    vpmulhuw    ymm0, YMMWORD [RECIPROCAL(0,0,r11)]  ; reciprocal
+    vpmulhuw    ymm1, YMMWORD [RECIPROCAL(2,0,r11)]
+    vpmulhuw    ymm2, YMMWORD [RECIPROCAL(4,0,r11)]
+    vpmulhuw    ymm3, YMMWORD [RECIPROCAL(6,0,r11)]
+    vpmulhuw    ymm0, YMMWORD [SCALE(0,0,r11)]       ; scale
+    vpmulhuw    ymm1, YMMWORD [SCALE(2,0,r11)]
+    vpmulhuw    ymm2, YMMWORD [SCALE(4,0,r11)]
+    vpmulhuw    ymm3, YMMWORD [SCALE(6,0,r11)]
+
+    vpsignw     ymm0, ymm0, ymm4
+    vpsignw     ymm1, ymm1, ymm5
+    vpsignw     ymm2, ymm2, ymm6
+    vpsignw     ymm3, ymm3, ymm7
+
+    vmovdqu     [XMMBLOCK(0,0,r10,SIZEOF_DCTELEM)], ymm0
+    vmovdqu     [XMMBLOCK(2,0,r10,SIZEOF_DCTELEM)], ymm1
+    vmovdqu     [XMMBLOCK(4,0,r10,SIZEOF_DCTELEM)], ymm2
+    vmovdqu     [XMMBLOCK(6,0,r10,SIZEOF_DCTELEM)], ymm3
+
+    vzeroupper
+    uncollect_args 3
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/x86_64/jquanti-sse2.asm b/simd/x86_64/jquanti-sse2.asm
new file mode 100644
index 0000000..4b0873e
--- /dev/null
+++ b/simd/x86_64/jquanti-sse2.asm
@@ -0,0 +1,186 @@
+;
+; jquanti.asm - sample data conversion and quantization (64-bit SSE2)
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2009, 2016, D. R. Commander.
+;
+; Based on the x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+%include "jdct.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Load data into workspace, applying unsigned->signed conversion
+;
+; GLOBAL(void)
+; jsimd_convsamp_sse2 (JSAMPARRAY sample_data, JDIMENSION start_col,
+;                      DCTELEM *workspace);
+;
+
+; r10 = JSAMPARRAY sample_data
+; r11d = JDIMENSION start_col
+; r12 = DCTELEM *workspace
+
+    align       32
+    global      EXTN(jsimd_convsamp_sse2)
+
+EXTN(jsimd_convsamp_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 3
+    push        rbx
+
+    pxor        xmm6, xmm6              ; xmm6=(all 0's)
+    pcmpeqw     xmm7, xmm7
+    psllw       xmm7, 7                 ; xmm7={0xFF80 0xFF80 0xFF80 0xFF80 ..}
+
+    mov         rsi, r10
+    mov         eax, r11d
+    mov         rdi, r12
+    mov         rcx, DCTSIZE/4
+.convloop:
+    mov         rbx, JSAMPROW [rsi+0*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+    mov         rdx, JSAMPROW [rsi+1*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+
+    movq        xmm0, XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE]  ; xmm0=(01234567)
+    movq        xmm1, XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE]  ; xmm1=(89ABCDEF)
+
+    mov         rbx, JSAMPROW [rsi+2*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+    mov         rdx, JSAMPROW [rsi+3*SIZEOF_JSAMPROW]  ; (JSAMPLE *)
+
+    movq        xmm2, XMM_MMWORD [rbx+rax*SIZEOF_JSAMPLE]  ; xmm2=(GHIJKLMN)
+    movq        xmm3, XMM_MMWORD [rdx+rax*SIZEOF_JSAMPLE]  ; xmm3=(OPQRSTUV)
+
+    punpcklbw   xmm0, xmm6              ; xmm0=(01234567)
+    punpcklbw   xmm1, xmm6              ; xmm1=(89ABCDEF)
+    paddw       xmm0, xmm7
+    paddw       xmm1, xmm7
+    punpcklbw   xmm2, xmm6              ; xmm2=(GHIJKLMN)
+    punpcklbw   xmm3, xmm6              ; xmm3=(OPQRSTUV)
+    paddw       xmm2, xmm7
+    paddw       xmm3, xmm7
+
+    movdqa      XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_DCTELEM)], xmm0
+    movdqa      XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_DCTELEM)], xmm1
+    movdqa      XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_DCTELEM)], xmm2
+    movdqa      XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_DCTELEM)], xmm3
+
+    add         rsi, byte 4*SIZEOF_JSAMPROW
+    add         rdi, byte 4*DCTSIZE*SIZEOF_DCTELEM
+    dec         rcx
+    jnz         short .convloop
+
+    pop         rbx
+    uncollect_args 3
+    pop         rbp
+    ret
+
+; --------------------------------------------------------------------------
+;
+; Quantize/descale the coefficients, and store into coef_block
+;
+; This implementation is based on an algorithm described in
+;   "How to optimize for the Pentium family of microprocessors"
+;   (http://www.agner.org/assem/).
+;
+; GLOBAL(void)
+; jsimd_quantize_sse2 (JCOEFPTR coef_block, DCTELEM *divisors,
+;                      DCTELEM *workspace);
+;
+
+%define RECIPROCAL(m,n,b)  XMMBLOCK(DCTSIZE*0+(m),(n),(b),SIZEOF_DCTELEM)
+%define CORRECTION(m,n,b)  XMMBLOCK(DCTSIZE*1+(m),(n),(b),SIZEOF_DCTELEM)
+%define SCALE(m,n,b)       XMMBLOCK(DCTSIZE*2+(m),(n),(b),SIZEOF_DCTELEM)
+
+; r10 = JCOEFPTR coef_block
+; r11 = DCTELEM *divisors
+; r12 = DCTELEM *workspace
+
+    align       32
+    global      EXTN(jsimd_quantize_sse2)
+
+EXTN(jsimd_quantize_sse2):
+    push        rbp
+    mov         rax, rsp
+    mov         rbp, rsp
+    collect_args 3
+
+    mov         rsi, r12
+    mov         rdx, r11
+    mov         rdi, r10
+    mov         rax, DCTSIZE2/32
+.quantloop:
+    movdqa      xmm4, XMMWORD [XMMBLOCK(0,0,rsi,SIZEOF_DCTELEM)]
+    movdqa      xmm5, XMMWORD [XMMBLOCK(1,0,rsi,SIZEOF_DCTELEM)]
+    movdqa      xmm6, XMMWORD [XMMBLOCK(2,0,rsi,SIZEOF_DCTELEM)]
+    movdqa      xmm7, XMMWORD [XMMBLOCK(3,0,rsi,SIZEOF_DCTELEM)]
+    movdqa      xmm0, xmm4
+    movdqa      xmm1, xmm5
+    movdqa      xmm2, xmm6
+    movdqa      xmm3, xmm7
+    psraw       xmm4, (WORD_BIT-1)
+    psraw       xmm5, (WORD_BIT-1)
+    psraw       xmm6, (WORD_BIT-1)
+    psraw       xmm7, (WORD_BIT-1)
+    pxor        xmm0, xmm4
+    pxor        xmm1, xmm5
+    pxor        xmm2, xmm6
+    pxor        xmm3, xmm7
+    psubw       xmm0, xmm4              ; if (xmm0 < 0) xmm0 = -xmm0;
+    psubw       xmm1, xmm5              ; if (xmm1 < 0) xmm1 = -xmm1;
+    psubw       xmm2, xmm6              ; if (xmm2 < 0) xmm2 = -xmm2;
+    psubw       xmm3, xmm7              ; if (xmm3 < 0) xmm3 = -xmm3;
+
+    paddw       xmm0, XMMWORD [CORRECTION(0,0,rdx)]  ; correction + roundfactor
+    paddw       xmm1, XMMWORD [CORRECTION(1,0,rdx)]
+    paddw       xmm2, XMMWORD [CORRECTION(2,0,rdx)]
+    paddw       xmm3, XMMWORD [CORRECTION(3,0,rdx)]
+    pmulhuw     xmm0, XMMWORD [RECIPROCAL(0,0,rdx)]  ; reciprocal
+    pmulhuw     xmm1, XMMWORD [RECIPROCAL(1,0,rdx)]
+    pmulhuw     xmm2, XMMWORD [RECIPROCAL(2,0,rdx)]
+    pmulhuw     xmm3, XMMWORD [RECIPROCAL(3,0,rdx)]
+    pmulhuw     xmm0, XMMWORD [SCALE(0,0,rdx)]       ; scale
+    pmulhuw     xmm1, XMMWORD [SCALE(1,0,rdx)]
+    pmulhuw     xmm2, XMMWORD [SCALE(2,0,rdx)]
+    pmulhuw     xmm3, XMMWORD [SCALE(3,0,rdx)]
+
+    pxor        xmm0, xmm4
+    pxor        xmm1, xmm5
+    pxor        xmm2, xmm6
+    pxor        xmm3, xmm7
+    psubw       xmm0, xmm4
+    psubw       xmm1, xmm5
+    psubw       xmm2, xmm6
+    psubw       xmm3, xmm7
+    movdqa      XMMWORD [XMMBLOCK(0,0,rdi,SIZEOF_DCTELEM)], xmm0
+    movdqa      XMMWORD [XMMBLOCK(1,0,rdi,SIZEOF_DCTELEM)], xmm1
+    movdqa      XMMWORD [XMMBLOCK(2,0,rdi,SIZEOF_DCTELEM)], xmm2
+    movdqa      XMMWORD [XMMBLOCK(3,0,rdi,SIZEOF_DCTELEM)], xmm3
+
+    add         rsi, byte 32*SIZEOF_DCTELEM
+    add         rdx, byte 32*SIZEOF_DCTELEM
+    add         rdi, byte 32*SIZEOF_JCOEF
+    dec         rax
+    jnz         near .quantloop
+
+    uncollect_args 3
+    pop         rbp
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/simd/jsimd_x86_64.c b/simd/x86_64/jsimd.c
similarity index 72%
rename from simd/jsimd_x86_64.c
rename to simd/x86_64/jsimd.c
index a62bcdb..e40f0cf 100644
--- a/simd/jsimd_x86_64.c
+++ b/simd/x86_64/jsimd.c
@@ -15,12 +15,12 @@
  */
 
 #define JPEG_INTERNALS
-#include "../jinclude.h"
-#include "../jpeglib.h"
+#include "../../jinclude.h"
+#include "../../jpeglib.h"
+#include "../../jsimd.h"
+#include "../../jdct.h"
+#include "../../jsimddct.h"
 #include "../jsimd.h"
-#include "../jdct.h"
-#include "../jsimddct.h"
-#include "jsimd.h"
 
 /*
  * In the PIC cases, we have no guarantee that constants will keep
@@ -29,6 +29,7 @@
 #define IS_ALIGNED(ptr, order) (((size_t)ptr & ((1 << order) - 1)) == 0)
 
 #define IS_ALIGNED_SSE(ptr) (IS_ALIGNED(ptr, 4)) /* 16 byte alignment */
+#define IS_ALIGNED_AVX(ptr) (IS_ALIGNED(ptr, 5)) /* 32 byte alignment */
 
 static unsigned int simd_support = ~0;
 static unsigned int simd_huffman = 1;
@@ -46,9 +47,15 @@ init_simd (void)
   if (simd_support != ~0U)
     return;
 
-  simd_support = JSIMD_SSE2 | JSIMD_SSE;
+  simd_support = jpeg_simd_cpu_support();
 
   /* Force different settings through environment variables */
+  env = getenv("JSIMD_FORCESSE2");
+  if ((env != NULL) && (strcmp(env, "1") == 0))
+    simd_support &= JSIMD_SSE2;
+  env = getenv("JSIMD_FORCEAVX2");
+  if ((env != NULL) && (strcmp(env, "1") == 0))
+    simd_support &= JSIMD_AVX2;
   env = getenv("JSIMD_FORCENONE");
   if ((env != NULL) && (strcmp(env, "1") == 0))
     simd_support = 0;
@@ -70,6 +77,9 @@ jsimd_can_rgb_ycc (void)
   if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_rgb_ycc_convert_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_rgb_ycc_convert_sse2))
     return 1;
@@ -90,6 +100,9 @@ jsimd_can_rgb_gray (void)
   if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_rgb_gray_convert_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_rgb_gray_convert_sse2))
     return 1;
@@ -110,6 +123,9 @@ jsimd_can_ycc_rgb (void)
   if ((RGB_PIXELSIZE != 3) && (RGB_PIXELSIZE != 4))
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_ycc_rgb_convert_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_ycc_rgb_convert_sse2))
     return 1;
@@ -128,37 +144,48 @@ jsimd_rgb_ycc_convert (j_compress_ptr cinfo,
                        JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
                        JDIMENSION output_row, int num_rows)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*sse2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
   switch(cinfo->in_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_extrgb_ycc_convert_avx2;
       sse2fct=jsimd_extrgb_ycc_convert_sse2;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_extrgbx_ycc_convert_avx2;
       sse2fct=jsimd_extrgbx_ycc_convert_sse2;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_extbgr_ycc_convert_avx2;
       sse2fct=jsimd_extbgr_ycc_convert_sse2;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_extbgrx_ycc_convert_avx2;
       sse2fct=jsimd_extbgrx_ycc_convert_sse2;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_extxbgr_ycc_convert_avx2;
       sse2fct=jsimd_extxbgr_ycc_convert_sse2;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_extxrgb_ycc_convert_avx2;
       sse2fct=jsimd_extxrgb_ycc_convert_sse2;
       break;
     default:
+      avx2fct=jsimd_rgb_ycc_convert_avx2;
       sse2fct=jsimd_rgb_ycc_convert_sse2;
       break;
   }
 
-  sse2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+  else
+    sse2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
 }
 
 GLOBAL(void)
@@ -166,37 +193,48 @@ jsimd_rgb_gray_convert (j_compress_ptr cinfo,
                         JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
                         JDIMENSION output_row, int num_rows)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
   void (*sse2fct)(JDIMENSION, JSAMPARRAY, JSAMPIMAGE, JDIMENSION, int);
 
   switch(cinfo->in_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_extrgb_gray_convert_avx2;
       sse2fct=jsimd_extrgb_gray_convert_sse2;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_extrgbx_gray_convert_avx2;
       sse2fct=jsimd_extrgbx_gray_convert_sse2;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_extbgr_gray_convert_avx2;
       sse2fct=jsimd_extbgr_gray_convert_sse2;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_extbgrx_gray_convert_avx2;
       sse2fct=jsimd_extbgrx_gray_convert_sse2;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_extxbgr_gray_convert_avx2;
       sse2fct=jsimd_extxbgr_gray_convert_sse2;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_extxrgb_gray_convert_avx2;
       sse2fct=jsimd_extxrgb_gray_convert_sse2;
       break;
     default:
+      avx2fct=jsimd_rgb_gray_convert_avx2;
       sse2fct=jsimd_rgb_gray_convert_sse2;
       break;
   }
 
-  sse2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
+  else
+    sse2fct(cinfo->image_width, input_buf, output_buf, output_row, num_rows);
 }
 
 GLOBAL(void)
@@ -204,37 +242,48 @@ jsimd_ycc_rgb_convert (j_decompress_ptr cinfo,
                        JSAMPIMAGE input_buf, JDIMENSION input_row,
                        JSAMPARRAY output_buf, int num_rows)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
   void (*sse2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY, int);
 
   switch(cinfo->out_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_ycc_extrgb_convert_avx2;
       sse2fct=jsimd_ycc_extrgb_convert_sse2;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_ycc_extrgbx_convert_avx2;
       sse2fct=jsimd_ycc_extrgbx_convert_sse2;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_ycc_extbgr_convert_avx2;
       sse2fct=jsimd_ycc_extbgr_convert_sse2;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_ycc_extbgrx_convert_avx2;
       sse2fct=jsimd_ycc_extbgrx_convert_sse2;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_ycc_extxbgr_convert_avx2;
       sse2fct=jsimd_ycc_extxbgr_convert_sse2;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_ycc_extxrgb_convert_avx2;
       sse2fct=jsimd_ycc_extxrgb_convert_sse2;
       break;
     default:
+      avx2fct=jsimd_ycc_rgb_convert_avx2;
       sse2fct=jsimd_ycc_rgb_convert_sse2;
       break;
   }
 
-  sse2fct(cinfo->output_width, input_buf, input_row, output_buf, num_rows);
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->output_width, input_buf, input_row, output_buf, num_rows);
+  else
+    sse2fct(cinfo->output_width, input_buf, input_row, output_buf, num_rows);
 }
 
 GLOBAL(void)
@@ -255,6 +304,8 @@ jsimd_can_h2v2_downsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
 
@@ -272,6 +323,8 @@ jsimd_can_h2v1_downsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
 
@@ -282,18 +335,32 @@ GLOBAL(void)
 jsimd_h2v2_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
                        JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
-  jsimd_h2v2_downsample_sse2(cinfo->image_width, cinfo->max_v_samp_factor,
-                             compptr->v_samp_factor, compptr->width_in_blocks,
-                             input_data, output_data);
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v2_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
+                               compptr->v_samp_factor,
+                               compptr->width_in_blocks, input_data,
+                               output_data);
+  else
+    jsimd_h2v2_downsample_sse2(cinfo->image_width, cinfo->max_v_samp_factor,
+                               compptr->v_samp_factor,
+                               compptr->width_in_blocks, input_data,
+                               output_data);
 }
 
 GLOBAL(void)
 jsimd_h2v1_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
                        JSAMPARRAY input_data, JSAMPARRAY output_data)
 {
-  jsimd_h2v1_downsample_sse2(cinfo->image_width, cinfo->max_v_samp_factor,
-                             compptr->v_samp_factor, compptr->width_in_blocks,
-                             input_data, output_data);
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v1_downsample_avx2(cinfo->image_width, cinfo->max_v_samp_factor,
+                               compptr->v_samp_factor,
+                               compptr->width_in_blocks, input_data,
+                               output_data);
+  else
+    jsimd_h2v1_downsample_sse2(cinfo->image_width, cinfo->max_v_samp_factor,
+                               compptr->v_samp_factor,
+                               compptr->width_in_blocks, input_data,
+                               output_data);
 }
 
 GLOBAL(int)
@@ -307,6 +374,8 @@ jsimd_can_h2v2_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
 
@@ -324,6 +393,8 @@ jsimd_can_h2v1_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
 
@@ -336,8 +407,12 @@ jsimd_h2v2_upsample (j_decompress_ptr cinfo,
                      JSAMPARRAY input_data,
                      JSAMPARRAY *output_data_ptr)
 {
-  jsimd_h2v2_upsample_sse2(cinfo->max_v_samp_factor, cinfo->output_width,
-                           input_data, output_data_ptr);
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v2_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
+                             input_data, output_data_ptr);
+  else
+    jsimd_h2v2_upsample_sse2(cinfo->max_v_samp_factor, cinfo->output_width,
+                             input_data, output_data_ptr);
 }
 
 GLOBAL(void)
@@ -346,8 +421,12 @@ jsimd_h2v1_upsample (j_decompress_ptr cinfo,
                      JSAMPARRAY input_data,
                      JSAMPARRAY *output_data_ptr)
 {
-  jsimd_h2v1_upsample_sse2(cinfo->max_v_samp_factor, cinfo->output_width,
-                           input_data, output_data_ptr);
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v1_upsample_avx2(cinfo->max_v_samp_factor, cinfo->output_width,
+                             input_data, output_data_ptr);
+  else
+    jsimd_h2v1_upsample_sse2(cinfo->max_v_samp_factor, cinfo->output_width,
+                             input_data, output_data_ptr);
 }
 
 GLOBAL(int)
@@ -361,6 +440,9 @@ jsimd_can_h2v2_fancy_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_fancy_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
     return 1;
@@ -379,6 +461,9 @@ jsimd_can_h2v1_fancy_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_fancy_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_fancy_upsample_sse2))
     return 1;
@@ -392,9 +477,14 @@ jsimd_h2v2_fancy_upsample (j_decompress_ptr cinfo,
                            JSAMPARRAY input_data,
                            JSAMPARRAY *output_data_ptr)
 {
-  jsimd_h2v2_fancy_upsample_sse2(cinfo->max_v_samp_factor,
-                                 compptr->downsampled_width, input_data,
-                                 output_data_ptr);
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v2_fancy_upsample_avx2(cinfo->max_v_samp_factor,
+                                   compptr->downsampled_width, input_data,
+                                   output_data_ptr);
+  else
+    jsimd_h2v2_fancy_upsample_sse2(cinfo->max_v_samp_factor,
+                                   compptr->downsampled_width, input_data,
+                                   output_data_ptr);
 }
 
 GLOBAL(void)
@@ -403,9 +493,14 @@ jsimd_h2v1_fancy_upsample (j_decompress_ptr cinfo,
                            JSAMPARRAY input_data,
                            JSAMPARRAY *output_data_ptr)
 {
-  jsimd_h2v1_fancy_upsample_sse2(cinfo->max_v_samp_factor,
-                                 compptr->downsampled_width, input_data,
-                                 output_data_ptr);
+  if (simd_support & JSIMD_AVX2)
+    jsimd_h2v1_fancy_upsample_avx2(cinfo->max_v_samp_factor,
+                                   compptr->downsampled_width, input_data,
+                                   output_data_ptr);
+  else
+    jsimd_h2v1_fancy_upsample_sse2(cinfo->max_v_samp_factor,
+                                   compptr->downsampled_width, input_data,
+                                   output_data_ptr);
 }
 
 GLOBAL(int)
@@ -419,6 +514,9 @@ jsimd_can_h2v2_merged_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_merged_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_merged_upsample_sse2))
     return 1;
@@ -437,6 +535,9 @@ jsimd_can_h2v1_merged_upsample (void)
   if (sizeof(JDIMENSION) != 4)
     return 0;
 
+  if ((simd_support & JSIMD_AVX2) &&
+      IS_ALIGNED_AVX(jconst_merged_upsample_avx2))
+    return 1;
   if ((simd_support & JSIMD_SSE2) &&
       IS_ALIGNED_SSE(jconst_merged_upsample_sse2))
     return 1;
@@ -450,37 +551,48 @@ jsimd_h2v2_merged_upsample (j_decompress_ptr cinfo,
                             JDIMENSION in_row_group_ctr,
                             JSAMPARRAY output_buf)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*sse2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
   switch(cinfo->out_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_h2v2_extrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extrgb_merged_upsample_sse2;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_h2v2_extrgbx_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extrgbx_merged_upsample_sse2;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_h2v2_extbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_h2v2_extbgrx_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extbgrx_merged_upsample_sse2;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_h2v2_extxbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extxbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_h2v2_extxrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_extxrgb_merged_upsample_sse2;
       break;
     default:
+      avx2fct=jsimd_h2v2_merged_upsample_avx2;
       sse2fct=jsimd_h2v2_merged_upsample_sse2;
       break;
   }
 
-  sse2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+  else
+    sse2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
 }
 
 GLOBAL(void)
@@ -489,37 +601,48 @@ jsimd_h2v1_merged_upsample (j_decompress_ptr cinfo,
                             JDIMENSION in_row_group_ctr,
                             JSAMPARRAY output_buf)
 {
+  void (*avx2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
   void (*sse2fct)(JDIMENSION, JSAMPIMAGE, JDIMENSION, JSAMPARRAY);
 
   switch(cinfo->out_color_space) {
     case JCS_EXT_RGB:
+      avx2fct=jsimd_h2v1_extrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extrgb_merged_upsample_sse2;
       break;
     case JCS_EXT_RGBX:
     case JCS_EXT_RGBA:
+      avx2fct=jsimd_h2v1_extrgbx_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extrgbx_merged_upsample_sse2;
       break;
     case JCS_EXT_BGR:
+      avx2fct=jsimd_h2v1_extbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_BGRX:
     case JCS_EXT_BGRA:
+      avx2fct=jsimd_h2v1_extbgrx_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extbgrx_merged_upsample_sse2;
       break;
     case JCS_EXT_XBGR:
     case JCS_EXT_ABGR:
+      avx2fct=jsimd_h2v1_extxbgr_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extxbgr_merged_upsample_sse2;
       break;
     case JCS_EXT_XRGB:
     case JCS_EXT_ARGB:
+      avx2fct=jsimd_h2v1_extxrgb_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_extxrgb_merged_upsample_sse2;
       break;
     default:
+      avx2fct=jsimd_h2v1_merged_upsample_avx2;
       sse2fct=jsimd_h2v1_merged_upsample_sse2;
       break;
   }
 
-  sse2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+  if (simd_support & JSIMD_AVX2)
+    avx2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
+  else
+    sse2fct(cinfo->output_width, input_buf, in_row_group_ctr, output_buf);
 }
 
 GLOBAL(int)
@@ -660,6 +783,8 @@ jsimd_can_quantize (void)
   if (sizeof(DCTELEM) != 2)
     return 0;
 
+  if (simd_support & JSIMD_AVX2)
+    return 1;
   if (simd_support & JSIMD_SSE2)
     return 1;
 
@@ -689,7 +814,10 @@ GLOBAL(void)
 jsimd_quantize (JCOEFPTR coef_block, DCTELEM *divisors,
                 DCTELEM *workspace)
 {
-  jsimd_quantize_sse2(coef_block, divisors, workspace);
+  if (simd_support & JSIMD_AVX2)
+    jsimd_quantize_avx2(coef_block, divisors, workspace);
+  else
+    jsimd_quantize_sse2(coef_block, divisors, workspace);
 }
 
 GLOBAL(void)
diff --git a/simd/x86_64/jsimdcpu.asm b/simd/x86_64/jsimdcpu.asm
new file mode 100644
index 0000000..a1ebb85
--- /dev/null
+++ b/simd/x86_64/jsimdcpu.asm
@@ -0,0 +1,78 @@
+;
+; jsimdcpu.asm - SIMD instruction support check
+;
+; Copyright 2009 Pierre Ossman <ossman@cendio.se> for Cendio AB
+; Copyright (C) 2016, D. R. Commander.
+;
+; Based on
+; x86 SIMD extension for IJG JPEG library
+; Copyright (C) 1999-2006, MIYASAKA Masaru.
+; For conditions of distribution and use, see copyright notice in jsimdext.inc
+;
+; This file should be assembled with NASM (Netwide Assembler),
+; can *not* be assembled with Microsoft's MASM or any compatible
+; assembler (including Borland's Turbo Assembler).
+; NASM is available from http://nasm.sourceforge.net/ or
+; http://sourceforge.net/project/showfiles.php?group_id=6208
+;
+; [TAB8]
+
+%include "jsimdext.inc"
+
+; --------------------------------------------------------------------------
+    SECTION     SEG_TEXT
+    BITS        64
+;
+; Check if the CPU supports SIMD instructions
+;
+; GLOBAL(unsigned int)
+; jpeg_simd_cpu_support (void)
+;
+
+    align       32
+    global      EXTN(jpeg_simd_cpu_support)
+
+EXTN(jpeg_simd_cpu_support):
+    push        rbx
+    push        rdi
+
+    xor         rdi, rdi                ; simd support flag
+
+    ; Check for AVX2 instruction support
+    mov         rax, 7
+    xor         rcx, rcx
+    cpuid
+    mov         rax, rbx                ; rax = Extended feature flags
+
+    or          rdi, JSIMD_SSE2
+    or          rdi, JSIMD_SSE
+    test        rax, 1<<5               ; bit5:AVX2
+    jz          short .return
+
+    ; Check for AVX2 O/S support
+    mov         rax, 1
+    xor         rcx, rcx
+    cpuid
+    test        rcx, 1<<27
+    jz          short .return           ; O/S does not support XSAVE
+    test        rcx, 1<<28
+    jz          short .return           ; CPU does not support AVX2
+
+    xor         rcx, rcx
+    xgetbv
+    test        rax, 6                  ; O/S does not manage XMM/YMM state
+                                        ; using XSAVE
+    jz          short .return
+
+    or          rdi, JSIMD_AVX2
+
+.return:
+    mov         rax, rdi
+
+    pop         rdi
+    pop         rbx
+    ret
+
+; For some reason, the OS X linker does not honor the request to align the
+; segment unless we do this.
+    align       32
diff --git a/testimages/test1.icc b/testimages/test1.icc
new file mode 100644
index 0000000..d0245c8
Binary files /dev/null and b/testimages/test1.icc differ
diff --git a/testimages/test1.icc.txt b/testimages/test1.icc.txt
new file mode 100644
index 0000000..57fc52f
--- /dev/null
+++ b/testimages/test1.icc.txt
@@ -0,0 +1,20 @@
+Little CMS
+Copyright (c) 1998-2011 Marti Maria Saguer
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/testimages/test2.icc b/testimages/test2.icc
new file mode 100644
index 0000000..73f1b5a
Binary files /dev/null and b/testimages/test2.icc differ
diff --git a/testimages/test2.icc.txt b/testimages/test2.icc.txt
new file mode 100644
index 0000000..57fc52f
--- /dev/null
+++ b/testimages/test2.icc.txt
@@ -0,0 +1,20 @@
+Little CMS
+Copyright (c) 1998-2011 Marti Maria Saguer
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
+of the Software, and to permit persons to whom the Software is furnished to do
+so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/tjbench.c b/tjbench.c
index 21b297c..a5be7d4 100644
--- a/tjbench.c
+++ b/tjbench.c
@@ -42,7 +42,11 @@
 	printf("ERROR in line %d while %s:\n%s\n", __LINE__, op, err);  \
 	retval=-1;  goto bailout;}
 #define _throwunix(m) _throw(m, strerror(errno))
-#define _throwtj(m) _throw(m, tjGetErrorStr())
+#define _throwtj(m) {  \
+	printf("%s in line %d while %s:\n%s\n",  \
+		tjGetErrorCode(handle)==TJERR_WARNING ? "WARNING" : "ERROR", __LINE__,  \
+		m, tjGetErrorStr2(handle));  \
+	retval=-1;  goto bailout;}
 #define _throwbmp(m) _throw(m, bmpgeterr())
 
 int flags=TJFLAG_NOREALLOC, componly=0, decomponly=0, doyuv=0, quiet=0,
@@ -751,6 +755,8 @@ void usage(char *progname)
 	printf("     codec\n");
 	printf("-accuratedct = Use the most accurate DCT/IDCT algorithms available in the\n");
 	printf("     underlying codec\n");
+	printf("-progressive = Use progressive entropy coding in JPEG images generated by\n");
+	printf("     compression and transform operations.\n");
 	printf("-subsamp <s> = When testing JPEG compression, this option specifies the level\n");
 	printf("     of chrominance subsampling to use (<s> = 444, 422, 440, 420, 411, or\n");
 	printf("     GRAY).  The default is to test Grayscale, 4:2:0, 4:2:2, and 4:4:4 in\n");
@@ -785,7 +791,10 @@ void usage(char *progname)
 	printf("     consistency of the results.\n");
 	printf("-componly = Stop after running compression tests.  Do not test decompression.\n");
 	printf("-nowrite = Do not write reference or output images (improves consistency of\n");
-	printf("     performance measurements.)\n\n");
+	printf("     performance measurements.)\n");
+	printf("-stoponwarning = Immediately discontinue the current\n");
+	printf("     compression/decompression/transform operation if the underlying codec\n");
+	printf("     throws a warning (non-fatal error)\n\n");
 	printf("NOTE:  If the quality is specified as a range (e.g. 90-100), a separate\n");
 	printf("test will be performed for all quality values in the range.\n\n");
 	exit(1);
@@ -799,7 +808,7 @@ int main(int argc, char *argv[])
 	int minarg=2, retval=0, subsamp=-1;
 
 	if((scalingfactors=tjGetScalingFactors(&nsf))==NULL || nsf==0)
-		_throwtj("executing tjGetScalingFactors()");
+		_throw("executing tjGetScalingFactors()", tjGetErrorStr());
 
 	if(argc<minarg) usage(argv[0]);
 
@@ -850,6 +859,11 @@ int main(int argc, char *argv[])
 				printf("Using most accurate DCT/IDCT algorithm\n\n");
 				flags|=TJFLAG_ACCURATEDCT;
 			}
+			if(!strcasecmp(argv[i], "-progressive"))
+			{
+				printf("Using progressive entropy coding\n\n");
+				flags|=TJFLAG_PROGRESSIVE;
+			}
 			if(!strcasecmp(argv[i], "-rgb")) pf=TJPF_RGB;
 			if(!strcasecmp(argv[i], "-rgbx")) pf=TJPF_RGBX;
 			if(!strcasecmp(argv[i], "-bgr")) pf=TJPF_BGR;
@@ -933,6 +947,7 @@ int main(int argc, char *argv[])
 			}
 			if(!strcasecmp(argv[i], "-componly")) componly=1;
 			if(!strcasecmp(argv[i], "-nowrite")) dowrite=0;
+			if(!strcasecmp(argv[i], "-stoponwarning")) flags|=TJFLAG_STOPONWARNING;
 		}
 	}
 
diff --git a/tjbenchtest.in b/tjbenchtest.in
index ef11b24..ad4a493 100755
--- a/tjbenchtest.in
+++ b/tjbenchtest.in
@@ -21,9 +21,9 @@ runme()
 
 EXT=bmp
 IMAGES="vgl_5674_0098.${EXT} vgl_6434_0018a.${EXT} vgl_6548_0026a.${EXT} nightshot_iso_100.${EXT}"
-IMGDIR=@srcdir@/testimages
+IMGDIR=@CMAKE_CURRENT_SOURCE_DIR@/testimages
 OUTDIR=`mktemp -d /tmp/__tjbenchtest_output.XXXXXX`
-EXEDIR=.
+EXEDIR=@CMAKE_CURRENT_BINARY_DIR@
 BMPARG=
 NSARG=
 YUVARG=
@@ -164,7 +164,7 @@ for image in $IMAGES; do
 
 	# Scaled decompression
 	for scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do
-		scalearg=`echo $scale | sed s@_@/@g`
+		scalearg=`echo $scale | sed 's/\_/\//g'`
 		for samp in GRAY 420 422 444; do
 			runme $EXEDIR/djpeg -rgb -scale ${scalearg} $NSARG $BMPARG -outfile $OUTDIR/${basename}_${samp}_${scale}_djpeg.${EXT} $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg
 			runme $EXEDIR/tjbench $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -scale ${scalearg} -quiet -benchtime 0.01 -warmup 0 $YUVARG $ALLOCARG
@@ -235,7 +235,7 @@ for image in $IMAGES; do
 	for xform in hflip vflip transpose transverse rot90 rot180 rot270; do
 		for samp in GRAY 444 422 420; do
 			for scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do
-				scalearg=`echo $scale | sed s@_@/@g`
+				scalearg=`echo $scale | sed 's/\_/\//g'`
 				runme $EXEDIR/djpeg -rgb -scale ${scalearg} $NSARG $BMPARG -outfile $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.${EXT} $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg
 				runme $EXEDIR/tjbench $OUTDIR/${basename}_${samp}_Q95.jpg $BMPARG -$xform -scale ${scalearg} -quiet -benchtime 0.01 -warmup 0 $YUVARG $ALLOCARG
 				runme cmp $OUTDIR/${basename}_${samp}_Q95_${scale}.${EXT} $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.${EXT}
diff --git a/tjbenchtest.java.in b/tjbenchtest.java.in
index acdabd0..91f2112 100755
--- a/tjbenchtest.java.in
+++ b/tjbenchtest.java.in
@@ -20,10 +20,10 @@ runme()
 }
 
 IMAGES="vgl_5674_0098.bmp vgl_6434_0018a.bmp vgl_6548_0026a.bmp nightshot_iso_100.bmp"
-IMGDIR=@srcdir@/testimages
+IMGDIR=@CMAKE_CURRENT_SOURCE_DIR@/testimages
 OUTDIR=`mktemp -d /tmp/__tjbenchtest_java_output.XXXXXX`
-EXEDIR=.
-JAVA="@JAVA@ -cp java/turbojpeg.jar -Djava.library.path=.libs"
+EXEDIR=@CMAKE_CURRENT_BINARY_DIR@
+JAVA="@Java_JAVA_EXECUTABLE@ -cp $EXEDIR/java/turbojpeg.jar -Djava.library.path=$EXEDIR"
 BMPARG=
 NSARG=
 YUVARG=
@@ -137,7 +137,7 @@ for image in $IMAGES; do
 
 	# Scaled decompression
 	for scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do
-		scalearg=`echo $scale | sed s@_@/@g`
+		scalearg=`echo $scale | sed 's/\_/\//g'`
 		for samp in GRAY 420 422 444; do
 			runme $EXEDIR/djpeg -rgb -scale ${scalearg} $NSARG -bmp -outfile $OUTDIR/${basename}_${samp}_${scale}_djpeg.bmp $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg
 			runme $JAVA TJBench $OUTDIR/${basename}_${samp}_Q95.jpg -scale ${scalearg} -quiet -benchtime 0.01 -warmup 0 $YUVARG
@@ -193,7 +193,7 @@ for image in $IMAGES; do
 	for xform in hflip vflip transpose transverse rot90 rot180 rot270; do
 		for samp in GRAY 444 422 420; do
 			for scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do
-				scalearg=`echo $scale | sed s@_@/@g`
+				scalearg=`echo $scale | sed 's/\_/\//g'`
 				runme $EXEDIR/djpeg -rgb -scale ${scalearg} $NSARG -bmp -outfile $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.bmp $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg
 				runme $JAVA TJBench $OUTDIR/${basename}_${samp}_Q95.jpg -$xform -scale ${scalearg} -quiet -benchtime 0.01 -warmup 0 $YUVARG
 				runme cmp -i 54:54 $OUTDIR/${basename}_${samp}_Q95_${scale}.bmp $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.bmp
diff --git a/tjexampletest.in b/tjexampletest.in
index 40b342e..619d04f 100755
--- a/tjexampletest.in
+++ b/tjexampletest.in
@@ -20,10 +20,10 @@ runme()
 }
 
 IMAGES="vgl_5674_0098.bmp vgl_6434_0018a.bmp vgl_6548_0026a.bmp nightshot_iso_100.bmp"
-IMGDIR=@srcdir@/testimages
+IMGDIR=@CMAKE_CURRENT_SOURCE_DIR@/testimages
 OUTDIR=__tjexampletest_output
-EXEDIR=.
-JAVA="@JAVA@ -cp java/turbojpeg.jar -Djava.library.path=.libs"
+EXEDIR=@CMAKE_CURRENT_BINARY_DIR@
+JAVA="@Java_JAVA_EXECUTABLE@ -cp $EXEDIR/java/turbojpeg.jar -Djava.library.path=$EXEDIR"
 
 if [ -d $OUTDIR ]; then
 	rm -rf $OUTDIR
@@ -85,7 +85,7 @@ for image in $IMAGES; do
 
 	# Scaled decompression
 	for scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do
-		scalearg=`echo $scale | sed s@_@/@g`
+		scalearg=`echo $scale | sed 's/\_/\//g'`
 		for samp in GRAY 420 422 444; do
 			$EXEDIR/djpeg -rgb -bmp -scale ${scalearg} $OUTDIR/${basename}_${samp}_fast_cjpeg.jpg >$OUTDIR/${basename}_${samp}_${scale}_djpeg.bmp
 			runme $JAVA TJExample $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${scale}.bmp -scale ${scalearg}
@@ -136,7 +136,7 @@ for image in $IMAGES; do
 	for xform in hflip vflip transpose transverse rot90 rot180 rot270; do
 		for samp in GRAY 444 422 420; do
 			for scale in 2_1 15_8 7_4 13_8 3_2 11_8 5_4 9_8 7_8 3_4 5_8 1_2 3_8 1_4 1_8; do
-				scalearg=`echo $scale | sed s@_@/@g`
+				scalearg=`echo $scale | sed 's/\_/\//g'`
 				$EXEDIR/djpeg -rgb -bmp -scale ${scalearg} $OUTDIR/${basename}_${samp}_${xform}_jpegtran.jpg >$OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.bmp
 				runme $JAVA TJExample $OUTDIR/${basename}_${samp}_fast.jpg $OUTDIR/${basename}_${samp}_${xform}_${scale}.bmp -$xform -scale ${scalearg} -crop 16,16,70x60
 				runme cmp -i 54:54 $OUTDIR/${basename}_${samp}_${xform}_${scale}.bmp $OUTDIR/${basename}_${samp}_${xform}_${scale}_jpegtran.bmp
diff --git a/transupp.c b/transupp.c
index b51ef39..569c509 100644
--- a/transupp.c
+++ b/transupp.c
@@ -1576,9 +1576,12 @@ jcopy_markers_setup (j_decompress_ptr srcinfo, JCOPY_OPTION option)
     jpeg_save_markers(srcinfo, JPEG_COM, 0xFFFF);
   }
   /* Save all types of APPn markers iff ALL option */
-  if (option == JCOPYOPT_ALL) {
-    for (m = 0; m < 16; m++)
+  if (option == JCOPYOPT_ALL || option == JCOPYOPT_ALL_EXCEPT_ICC) {
+    for (m = 0; m < 16; m++) {
+      if (option == JCOPYOPT_ALL_EXCEPT_ICC && m == 2)
+        continue;
       jpeg_save_markers(srcinfo, JPEG_APP0 + m, 0xFFFF);
+    }
   }
 #endif /* SAVE_MARKERS_SUPPORTED */
 }
diff --git a/transupp.h b/transupp.h
index bf3118a..ac96b98 100644
--- a/transupp.h
+++ b/transupp.h
@@ -3,8 +3,8 @@
  *
  * This file was part of the Independent JPEG Group's software:
  * Copyright (C) 1997-2011, Thomas G. Lane, Guido Vollbeding.
- * It was modified by The libjpeg-turbo Project to include only code relevant
- * to libjpeg-turbo.
+ * libjpeg-turbo Modifications:
+ * Copyright (C) 2017, D. R. Commander.
  * For conditions of distribution and use, see the accompanying README.ijg
  * file.
  *
@@ -193,7 +193,8 @@ EXTERN(boolean) jtransform_perfect_transform
 typedef enum {
   JCOPYOPT_NONE,          /* copy no optional markers */
   JCOPYOPT_COMMENTS,      /* copy only comment (COM) markers */
-  JCOPYOPT_ALL            /* copy all optional markers */
+  JCOPYOPT_ALL,           /* copy all optional markers */
+  JCOPYOPT_ALL_EXCEPT_ICC /* copy all optional markers except APP2 */
 } JCOPY_OPTION;
 
 #define JCOPYOPT_DEFAULT  JCOPYOPT_COMMENTS     /* recommended default */
diff --git a/turbojpeg-jni.c b/turbojpeg-jni.c
index eaba670..4f39c91 100644
--- a/turbojpeg-jni.c
+++ b/turbojpeg-jni.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C)2011-2016 D. R. Commander.  All Rights Reserved.
+ * Copyright (C)2011-2017 D. R. Commander.  All Rights Reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -39,27 +39,41 @@
 
 #define PAD(v, p) ((v+(p)-1)&(~((p)-1)))
 
+#define bailif0(f) {if(!(f) || (*env)->ExceptionCheck(env)) {  \
+	goto bailout;  \
+}}
+
 #define _throw(msg, exceptionClass) {  \
 	jclass _exccls=(*env)->FindClass(env, exceptionClass);  \
-	if(!_exccls || (*env)->ExceptionCheck(env)) goto bailout;  \
+	bailif0(_exccls);  \
 	(*env)->ThrowNew(env, _exccls, msg);  \
 	goto bailout;  \
 }
 
-#define _throwtj() _throw(tjGetErrorStr(), "org/libjpegturbo/turbojpeg/TJException")
+#define _throwtj() {  \
+	jclass _exccls;  \
+	jmethodID _excid;  \
+	jobject _excobj;  \
+	jstring _errstr;  \
+	bailif0(_errstr = (*env)->NewStringUTF(env, tjGetErrorStr2(handle)));  \
+	bailif0(_exccls = (*env)->FindClass(env,  \
+		"org/libjpegturbo/turbojpeg/TJException"));  \
+	bailif0(_excid = (*env)->GetMethodID(env, _exccls, "<init>",  \
+		"(Ljava/lang/String;I)V"));  \
+	bailif0(_excobj = (*env)->NewObject(env, _exccls, _excid, _errstr,  \
+		tjGetErrorCode(handle)));  \
+	(*env)->Throw(env, _excobj);  \
+	goto bailout;  \
+}
 
 #define _throwarg(msg) _throw(msg, "java/lang/IllegalArgumentException")
 
 #define _throwmem() _throw("Memory allocation failure", "java/lang/OutOfMemoryError");
 
-#define bailif0(f) {if(!(f) || (*env)->ExceptionCheck(env)) {  \
-	goto bailout;  \
-}}
-
 #define gethandle()  \
 	jclass _cls=(*env)->GetObjectClass(env, obj);  \
 	jfieldID _fid;  \
-	if(!_cls || (*env)->ExceptionCheck(env)) goto bailout;  \
+	bailif0(_cls);  \
 	bailif0(_fid=(*env)->GetFieldID(env, _cls, "handle", "J"));  \
 	handle=(tjhandle)(size_t)(*env)->GetLongField(env, obj, _fid);  \
 
@@ -174,7 +188,7 @@ JNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJCompressor_init
 	tjhandle handle;
 
 	if((handle=tjInitCompress())==NULL)
-		_throwtj();
+		_throw(tjGetErrorStr(), "org/libjpegturbo/turbojpeg/TJException");
 
 	bailif0(cls=(*env)->GetObjectClass(env, obj));
 	bailif0(fid=(*env)->GetFieldID(env, cls, "handle", "J"));
@@ -551,7 +565,8 @@ JNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJDecompressor_init
 	jfieldID fid;
 	tjhandle handle;
 
-	if((handle=tjInitDecompress())==NULL) _throwtj();
+	if((handle=tjInitDecompress())==NULL)
+		_throw(tjGetErrorStr(), "org/libjpegturbo/turbojpeg/TJException");
 
 	bailif0(cls=(*env)->GetObjectClass(env, obj));
 	bailif0(fid=(*env)->GetFieldID(env, cls, "handle", "J"));
@@ -958,7 +973,8 @@ JNIEXPORT void JNICALL Java_org_libjpegturbo_turbojpeg_TJTransformer_init
 	jfieldID fid;
 	tjhandle handle;
 
-	if((handle=tjInitTransform())==NULL) _throwtj();
+	if((handle=tjInitTransform())==NULL)
+		_throw(tjGetErrorStr(), "org/libjpegturbo/turbojpeg/TJException");
 
 	bailif0(cls=(*env)->GetObjectClass(env, obj));
 	bailif0(fid=(*env)->GetFieldID(env, cls, "handle", "J"));
diff --git a/turbojpeg-mapfile b/turbojpeg-mapfile
index 35d55ae..8df3687 100755
--- a/turbojpeg-mapfile
+++ b/turbojpeg-mapfile
@@ -54,3 +54,10 @@ TURBOJPEG_1.4
 		tjPlaneSizeYUV;
 		tjPlaneWidth;
 } TURBOJPEG_1.2;
+
+TURBOJPEG_1.6
+{
+	global:
+		tjGetErrorCode;
+		tjGetErrorStr2;
+} TURBOJPEG_1.4;
diff --git a/turbojpeg-mapfile.jni b/turbojpeg-mapfile.jni
index 9c1d25b..9395dca 100755
--- a/turbojpeg-mapfile.jni
+++ b/turbojpeg-mapfile.jni
@@ -90,3 +90,10 @@ TURBOJPEG_1.4
 		Java_org_libjpegturbo_turbojpeg_TJ_planeSizeYUV__IIIII;
 		Java_org_libjpegturbo_turbojpeg_TJ_planeWidth__III;
 } TURBOJPEG_1.3;
+
+TURBOJPEG_1.6
+{
+	global:
+		tjGetErrorCode;
+		tjGetErrorStr2;
+} TURBOJPEG_1.4;
diff --git a/turbojpeg.c b/turbojpeg.c
index c9bc619..3b29c22 100644
--- a/turbojpeg.c
+++ b/turbojpeg.c
@@ -60,7 +60,7 @@ struct my_error_mgr
 	struct jpeg_error_mgr pub;
 	jmp_buf setjmp_buffer;
 	void (*emit_message)(j_common_ptr, int);
-	boolean warning;
+	boolean warning, stopOnWarning;
 };
 typedef struct my_error_mgr *my_error_ptr;
 
@@ -82,7 +82,11 @@ static void my_emit_message(j_common_ptr cinfo, int msg_level)
 {
 	my_error_ptr myerr=(my_error_ptr)cinfo->err;
 	myerr->emit_message(cinfo, msg_level);
-	if(msg_level<0) myerr->warning=TRUE;
+	if(msg_level<0)
+	{
+		myerr->warning=TRUE;
+		if(myerr->stopOnWarning) longjmp(myerr->setjmp_buffer, 1);
+	}
 }
 
 
@@ -96,6 +100,8 @@ typedef struct _tjinstance
 	struct jpeg_decompress_struct dinfo;
 	struct my_error_mgr jerr;
 	int init, headerRead;
+	char errStr[JMSG_LENGTH_MAX];
+	boolean isInstanceError;
 } tjinstance;
 
 static const int pixelsize[TJ_NUMSAMP]={3, 3, 3, 1, 3, 3};
@@ -126,26 +132,31 @@ static const tjscalingfactor sf[NUMSF]={
 	{1, 8}
 };
 
-#define _throw(m) {snprintf(errStr, JMSG_LENGTH_MAX, "%s", m);  \
+#define _throwg(m) {snprintf(errStr, JMSG_LENGTH_MAX, "%s", m);  \
 	retval=-1;  goto bailout;}
+#define _throw(m) {snprintf(this->errStr, JMSG_LENGTH_MAX, "%s", m);  \
+	this->isInstanceError=TRUE;  _throwg(m);}
 #define getinstance(handle) tjinstance *this=(tjinstance *)handle;  \
 	j_compress_ptr cinfo=NULL;  j_decompress_ptr dinfo=NULL;  \
 	if(!this) {snprintf(errStr, JMSG_LENGTH_MAX, "Invalid handle");  \
 		return -1;}  \
 	cinfo=&this->cinfo;  dinfo=&this->dinfo;  \
-	this->jerr.warning=FALSE;
+	this->jerr.warning=FALSE;  \
+	this->isInstanceError=FALSE;
 #define getcinstance(handle) tjinstance *this=(tjinstance *)handle;  \
 	j_compress_ptr cinfo=NULL;  \
 	if(!this) {snprintf(errStr, JMSG_LENGTH_MAX, "Invalid handle");  \
 		return -1;}  \
 	cinfo=&this->cinfo;  \
-	this->jerr.warning=FALSE;
+	this->jerr.warning=FALSE;  \
+	this->isInstanceError=FALSE;
 #define getdinstance(handle) tjinstance *this=(tjinstance *)handle;  \
 	j_decompress_ptr dinfo=NULL;  \
 	if(!this) {snprintf(errStr, JMSG_LENGTH_MAX, "Invalid handle");  \
 		return -1;}  \
 	dinfo=&this->dinfo;  \
-	this->jerr.warning=FALSE;
+	this->jerr.warning=FALSE;  \
+	this->isInstanceError=FALSE;
 
 static int getPixelFormat(int pixelSize, int flags)
 {
@@ -252,8 +263,10 @@ static int setCompDefaults(struct jpeg_compress_struct *cinfo,
 		jpeg_set_colorspace(cinfo, JCS_YCCK);
 	else jpeg_set_colorspace(cinfo, JCS_YCbCr);
 
+	if(flags&TJFLAG_PROGRESSIVE)
+		jpeg_simple_progression(cinfo);
 #ifndef NO_GETENV
-	if((env=getenv("TJ_PROGRESSIVE"))!=NULL && strlen(env)>0
+	else if((env=getenv("TJ_PROGRESSIVE"))!=NULL && strlen(env)>0
 		&& !strcmp(env, "1"))
 		jpeg_simple_progression(cinfo);
 #endif
@@ -272,37 +285,36 @@ static int setCompDefaults(struct jpeg_compress_struct *cinfo,
 	return retval;
 }
 
-static int setDecompDefaults(struct jpeg_decompress_struct *dinfo,
-	int pixelFormat, int flags)
+static int setDecompDefaults(tjinstance *this, int pixelFormat, int flags)
 {
 	int retval=0;
 
 	switch(pixelFormat)
 	{
 		case TJPF_GRAY:
-			dinfo->out_color_space=JCS_GRAYSCALE;  break;
+			this->dinfo.out_color_space=JCS_GRAYSCALE;  break;
 		#if JCS_EXTENSIONS==1
 		case TJPF_RGB:
-			dinfo->out_color_space=JCS_EXT_RGB;  break;
+			this->dinfo.out_color_space=JCS_EXT_RGB;  break;
 		case TJPF_BGR:
-			dinfo->out_color_space=JCS_EXT_BGR;  break;
+			this->dinfo.out_color_space=JCS_EXT_BGR;  break;
 		case TJPF_RGBX:
-			dinfo->out_color_space=JCS_EXT_RGBX;  break;
+			this->dinfo.out_color_space=JCS_EXT_RGBX;  break;
 		case TJPF_BGRX:
-			dinfo->out_color_space=JCS_EXT_BGRX;  break;
+			this->dinfo.out_color_space=JCS_EXT_BGRX;  break;
 		case TJPF_XRGB:
-			dinfo->out_color_space=JCS_EXT_XRGB;  break;
+			this->dinfo.out_color_space=JCS_EXT_XRGB;  break;
 		case TJPF_XBGR:
-			dinfo->out_color_space=JCS_EXT_XBGR;  break;
+			this->dinfo.out_color_space=JCS_EXT_XBGR;  break;
 		#if JCS_ALPHA_EXTENSIONS==1
 		case TJPF_RGBA:
-			dinfo->out_color_space=JCS_EXT_RGBA;  break;
+			this->dinfo.out_color_space=JCS_EXT_RGBA;  break;
 		case TJPF_BGRA:
-			dinfo->out_color_space=JCS_EXT_BGRA;  break;
+			this->dinfo.out_color_space=JCS_EXT_BGRA;  break;
 		case TJPF_ARGB:
-			dinfo->out_color_space=JCS_EXT_ARGB;  break;
+			this->dinfo.out_color_space=JCS_EXT_ARGB;  break;
 		case TJPF_ABGR:
-			dinfo->out_color_space=JCS_EXT_ABGR;  break;
+			this->dinfo.out_color_space=JCS_EXT_ABGR;  break;
 		#endif
 		#else
 		case TJPF_RGB:
@@ -315,15 +327,15 @@ static int setDecompDefaults(struct jpeg_decompress_struct *dinfo,
 		case TJPF_BGRA:
 		case TJPF_ARGB:
 		case TJPF_ABGR:
-			dinfo->out_color_space=JCS_RGB;  break;
+			this->dinfo.out_color_space=JCS_RGB;  break;
 		#endif
 		case TJPF_CMYK:
-			dinfo->out_color_space=JCS_CMYK;  break;
+			this->dinfo.out_color_space=JCS_CMYK;  break;
 		default:
 			_throw("Unsupported pixel format");
 	}
 
-	if(flags&TJFLAG_FASTDCT) dinfo->dct_method=JDCT_FASTEST;
+	if(flags&TJFLAG_FASTDCT) this->dinfo.dct_method=JDCT_FASTEST;
 
 	bailout:
 	return retval;
@@ -542,12 +554,32 @@ static void fromRGB(unsigned char *src, unsigned char *dst, int width,
 
 /* General API functions */
 
+DLLEXPORT char* DLLCALL tjGetErrorStr2(tjhandle handle)
+{
+	tjinstance *this=(tjinstance *)handle;
+	if(this && this->isInstanceError)
+	{
+		this->isInstanceError=FALSE;
+		return this->errStr;
+	}
+	else return errStr;
+}
+
+
 DLLEXPORT char* DLLCALL tjGetErrorStr(void)
 {
 	return errStr;
 }
 
 
+DLLEXPORT int DLLCALL tjGetErrorCode(tjhandle handle)
+{
+	tjinstance *this=(tjinstance *)handle;
+	if(this && this->jerr.warning) return TJERR_WARNING;
+	else return TJERR_FATAL;
+}
+
+
 DLLEXPORT int DLLCALL tjDestroy(tjhandle handle)
 {
 	getinstance(handle);
@@ -615,6 +647,7 @@ DLLEXPORT tjhandle DLLCALL tjInitCompress(void)
 		return NULL;
 	}
 	MEMZERO(this, sizeof(tjinstance));
+	snprintf(this->errStr, JMSG_LENGTH_MAX, "No error");
 	return _tjInitCompress(this);
 }
 
@@ -624,7 +657,7 @@ DLLEXPORT unsigned long DLLCALL tjBufSize(int width, int height,
 {
 	unsigned long retval=0;  int mcuw, mcuh, chromasf;
 	if(width<1 || height<1 || jpegSubsamp<0 || jpegSubsamp>=NUMSUBOPT)
-		_throw("tjBufSize(): Invalid argument");
+		_throwg("tjBufSize(): Invalid argument");
 
 	/* This allows for rare corner cases in which a JPEG image can actually be
 	   larger than the uncompressed input (we wouldn't mention it if it hadn't
@@ -642,7 +675,7 @@ DLLEXPORT unsigned long DLLCALL TJBUFSIZE(int width, int height)
 {
 	unsigned long retval=0;
 	if(width<1 || height<1)
-		_throw("TJBUFSIZE(): Invalid argument");
+		_throwg("TJBUFSIZE(): Invalid argument");
 
 	/* This allows for rare corner cases in which a JPEG image can actually be
 	   larger than the uncompressed input (we wouldn't mention it if it hadn't
@@ -660,7 +693,7 @@ DLLEXPORT unsigned long DLLCALL tjBufSizeYUV2(int width, int pad, int height,
 	int retval=0, nc, i;
 
 	if(subsamp<0 || subsamp>=NUMSUBOPT)
-		_throw("tjBufSizeYUV2(): Invalid argument");
+		_throwg("tjBufSizeYUV2(): Invalid argument");
 
 	nc=(subsamp==TJSAMP_GRAY? 1:3);
 	for(i=0; i<nc; i++)
@@ -694,10 +727,10 @@ DLLEXPORT int tjPlaneWidth(int componentID, int width, int subsamp)
 	int pw, nc, retval=0;
 
 	if(width<1 || subsamp<0 || subsamp>=TJ_NUMSAMP)
-		_throw("tjPlaneWidth(): Invalid argument");
+		_throwg("tjPlaneWidth(): Invalid argument");
 	nc=(subsamp==TJSAMP_GRAY? 1:3);
 	if(componentID<0 || componentID>=nc)
-		_throw("tjPlaneWidth(): Invalid argument");
+		_throwg("tjPlaneWidth(): Invalid argument");
 
 	pw=PAD(width, tjMCUWidth[subsamp]/8);
 	if(componentID==0)
@@ -715,10 +748,10 @@ DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp)
 	int ph, nc, retval=0;
 
 	if(height<1 || subsamp<0 || subsamp>=TJ_NUMSAMP)
-		_throw("tjPlaneHeight(): Invalid argument");
+		_throwg("tjPlaneHeight(): Invalid argument");
 	nc=(subsamp==TJSAMP_GRAY? 1:3);
 	if(componentID<0 || componentID>=nc)
-		_throw("tjPlaneHeight(): Invalid argument");
+		_throwg("tjPlaneHeight(): Invalid argument");
 
 	ph=PAD(height, tjMCUHeight[subsamp]/8);
 	if(componentID==0)
@@ -738,7 +771,7 @@ DLLEXPORT unsigned long DLLCALL tjPlaneSizeYUV(int componentID, int width,
 	int pw, ph;
 
 	if(width<1 || height<1 || subsamp<0 || subsamp>=NUMSUBOPT)
-		_throw("tjPlaneSizeYUV(): Invalid argument");
+		_throwg("tjPlaneSizeYUV(): Invalid argument");
 
 	pw=tjPlaneWidth(componentID, width, subsamp);
 	ph=tjPlaneHeight(componentID, height, subsamp);
@@ -764,6 +797,7 @@ DLLEXPORT int DLLCALL tjCompress2(tjhandle handle, const unsigned char *srcBuf,
 	#endif
 
 	getcinstance(handle)
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 	if((this->init&COMPRESS)==0)
 		_throw("tjCompress2(): Instance has not been initialized for compression");
 
@@ -872,6 +906,7 @@ DLLEXPORT int DLLCALL tjEncodeYUVPlanes(tjhandle handle,
 	#endif
 
 	getcinstance(handle);
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 
 	for(i=0; i<MAX_COMPONENTS; i++)
 	{
@@ -951,29 +986,29 @@ DLLEXPORT int DLLCALL tjEncodeYUVPlanes(tjhandle handle,
 		compptr=&cinfo->comp_info[i];
 		_tmpbuf[i]=(JSAMPLE *)malloc(
 			PAD((compptr->width_in_blocks*cinfo->max_h_samp_factor*DCTSIZE)
-				/compptr->h_samp_factor, 16) * cinfo->max_v_samp_factor + 16);
+				/compptr->h_samp_factor, 32) * cinfo->max_v_samp_factor + 32);
 		if(!_tmpbuf[i]) _throw("tjEncodeYUVPlanes(): Memory allocation failure");
 		tmpbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*cinfo->max_v_samp_factor);
 		if(!tmpbuf[i]) _throw("tjEncodeYUVPlanes(): Memory allocation failure");
 		for(row=0; row<cinfo->max_v_samp_factor; row++)
 		{
 			unsigned char *_tmpbuf_aligned=
-				(unsigned char *)PAD((size_t)_tmpbuf[i], 16);
+				(unsigned char *)PAD((size_t)_tmpbuf[i], 32);
 			tmpbuf[i][row]=&_tmpbuf_aligned[
 				PAD((compptr->width_in_blocks*cinfo->max_h_samp_factor*DCTSIZE)
-					/compptr->h_samp_factor, 16) * row];
+					/compptr->h_samp_factor, 32) * row];
 		}
-		_tmpbuf2[i]=(JSAMPLE *)malloc(PAD(compptr->width_in_blocks*DCTSIZE, 16)
-			* compptr->v_samp_factor + 16);
+		_tmpbuf2[i]=(JSAMPLE *)malloc(PAD(compptr->width_in_blocks*DCTSIZE, 32)
+			* compptr->v_samp_factor + 32);
 		if(!_tmpbuf2[i]) _throw("tjEncodeYUVPlanes(): Memory allocation failure");
 		tmpbuf2[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*compptr->v_samp_factor);
 		if(!tmpbuf2[i]) _throw("tjEncodeYUVPlanes(): Memory allocation failure");
 		for(row=0; row<compptr->v_samp_factor; row++)
 		{
 			unsigned char *_tmpbuf2_aligned=
-				(unsigned char *)PAD((size_t)_tmpbuf2[i], 16);
+				(unsigned char *)PAD((size_t)_tmpbuf2[i], 32);
 			tmpbuf2[i][row]=&_tmpbuf2_aligned[
-				PAD(compptr->width_in_blocks*DCTSIZE, 16) * row];
+				PAD(compptr->width_in_blocks*DCTSIZE, 32) * row];
 		}
 		pw[i]=pw0*compptr->h_samp_factor/cinfo->max_h_samp_factor;
 		ph[i]=ph0*compptr->v_samp_factor/cinfo->max_v_samp_factor;
@@ -1032,6 +1067,8 @@ DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,
 	unsigned char *dstPlanes[3];
 	int pw0, ph0, strides[3], retval=-1;
 
+	getcinstance(handle);
+
 	if(width<=0 || height<=0 || dstBuf==NULL || pad<0 || !isPow2(pad)
 		|| subsamp<0 || subsamp>=NUMSUBOPT)
 		_throw("tjEncodeYUV3(): Invalid argument");
@@ -1089,6 +1126,7 @@ DLLEXPORT int DLLCALL tjCompressFromYUVPlanes(tjhandle handle,
 	JSAMPLE *_tmpbuf=NULL, *ptr;  JSAMPROW *tmpbuf[MAX_COMPONENTS];
 
 	getcinstance(handle)
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 
 	for(i=0; i<MAX_COMPONENTS; i++)
 	{
@@ -1224,6 +1262,8 @@ DLLEXPORT int DLLCALL tjCompressFromYUV(tjhandle handle,
 	const unsigned char *srcPlanes[3];
 	int pw0, ph0, strides[3], retval=-1;
 
+	getcinstance(handle);
+
 	if(srcBuf==NULL || width<=0 || pad<1 || height<=0 || subsamp<0
 		|| subsamp>=NUMSUBOPT)
 		_throw("tjCompressFromYUV(): Invalid argument");
@@ -1292,6 +1332,7 @@ DLLEXPORT tjhandle DLLCALL tjInitDecompress(void)
 		return NULL;
 	}
 	MEMZERO(this, sizeof(tjinstance));
+	snprintf(this->errStr, JMSG_LENGTH_MAX, "No error");
 	return _tjInitDecompress(this);
 }
 
@@ -1390,6 +1431,7 @@ DLLEXPORT int DLLCALL tjDecompress2(tjhandle handle,
 	#endif
 
 	getdinstance(handle);
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 	if((this->init&DECOMPRESS)==0)
 		_throw("tjDecompress2(): Instance has not been initialized for decompression");
 
@@ -1410,7 +1452,7 @@ DLLEXPORT int DLLCALL tjDecompress2(tjhandle handle,
 
 	jpeg_mem_src_tj(dinfo, jpegBuf, jpegSize);
 	jpeg_read_header(dinfo, TRUE);
-	if(setDecompDefaults(dinfo, pixelFormat, flags)==-1)
+	if(setDecompDefaults(this, pixelFormat, flags)==-1)
 	{
 		retval=-1;  goto bailout;
 	}
@@ -1570,6 +1612,7 @@ DLLEXPORT int DLLCALL tjDecodeYUVPlanes(tjhandle handle,
 	void (*old_reset_marker_reader)(j_decompress_ptr);
 
 	getdinstance(handle);
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 
 	for(i=0; i<MAX_COMPONENTS; i++)
 	{
@@ -1616,7 +1659,7 @@ DLLEXPORT int DLLCALL tjDecodeYUVPlanes(tjhandle handle,
 	dinfo->marker->read_markers=old_read_markers;
 	dinfo->marker->reset_marker_reader=old_reset_marker_reader;
 
-	if(setDecompDefaults(dinfo, pixelFormat, flags)==-1)
+	if(setDecompDefaults(this, pixelFormat, flags)==-1)
 	{
 		retval=-1;  goto bailout;
 	}
@@ -1657,17 +1700,17 @@ DLLEXPORT int DLLCALL tjDecodeYUVPlanes(tjhandle handle,
 	for(i=0; i<dinfo->num_components; i++)
 	{
 		compptr=&dinfo->comp_info[i];
-		_tmpbuf[i]=(JSAMPLE *)malloc(PAD(compptr->width_in_blocks*DCTSIZE, 16)
-			* compptr->v_samp_factor + 16);
+		_tmpbuf[i]=(JSAMPLE *)malloc(PAD(compptr->width_in_blocks*DCTSIZE, 32)
+			* compptr->v_samp_factor + 32);
 		if(!_tmpbuf[i]) _throw("tjDecodeYUVPlanes(): Memory allocation failure");
 		tmpbuf[i]=(JSAMPROW *)malloc(sizeof(JSAMPROW)*compptr->v_samp_factor);
 		if(!tmpbuf[i]) _throw("tjDecodeYUVPlanes(): Memory allocation failure");
 		for(row=0; row<compptr->v_samp_factor; row++)
 		{
 			unsigned char *_tmpbuf_aligned=
-				(unsigned char *)PAD((size_t)_tmpbuf[i], 16);
+				(unsigned char *)PAD((size_t)_tmpbuf[i], 32);
 			tmpbuf[i][row]=&_tmpbuf_aligned[
-				PAD(compptr->width_in_blocks*DCTSIZE, 16) * row];
+				PAD(compptr->width_in_blocks*DCTSIZE, 32) * row];
 		}
 		pw[i]=pw0*compptr->h_samp_factor/dinfo->max_h_samp_factor;
 		ph[i]=ph0*compptr->v_samp_factor/dinfo->max_v_samp_factor;
@@ -1728,6 +1771,8 @@ DLLEXPORT int DLLCALL tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
 	const unsigned char *srcPlanes[3];
 	int pw0, ph0, strides[3], retval=-1;
 
+	getdinstance(handle);
+
 	if(srcBuf==NULL || pad<0 || !isPow2(pad) || subsamp<0 || subsamp>=NUMSUBOPT
 		|| width<=0 || height<=0)
 		_throw("tjDecodeYUV(): Invalid argument");
@@ -1769,6 +1814,7 @@ DLLEXPORT int DLLCALL tjDecompressToYUVPlanes(tjhandle handle,
 	int dctsize;
 
 	getdinstance(handle);
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 
 	for(i=0; i<MAX_COMPONENTS; i++)
 	{
@@ -1947,6 +1993,7 @@ DLLEXPORT int DLLCALL tjDecompressToYUV2(tjhandle handle,
 	int i, jpegwidth, jpegheight, scaledw, scaledh;
 
 	getdinstance(handle);
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 
 	if(jpegBuf==NULL || jpegSize<=0 || dstBuf==NULL || width<0 || pad<1
 		|| !isPow2(pad) || height<0)
@@ -2025,6 +2072,7 @@ DLLEXPORT tjhandle DLLCALL tjInitTransform(void)
 		return NULL;
 	}
 	MEMZERO(this, sizeof(tjinstance));
+	snprintf(this->errStr, JMSG_LENGTH_MAX, "No error");
 	handle=_tjInitCompress(this);
 	if(!handle) return NULL;
 	handle=_tjInitDecompress(this);
@@ -2041,6 +2089,7 @@ DLLEXPORT int DLLCALL tjTransform(tjhandle handle,
 	int retval=0, i, jpegSubsamp;
 
 	getinstance(handle);
+	this->jerr.stopOnWarning=(flags & TJFLAG_STOPONWARNING) ? TRUE : FALSE;
 	if((this->init&COMPRESS)==0 || (this->init&DECOMPRESS)==0)
 		_throw("tjTransform(): Instance has not been initialized for transformation");
 
@@ -2140,6 +2189,8 @@ DLLEXPORT int DLLCALL tjTransform(tjhandle handle,
 		jpeg_copy_critical_parameters(dinfo, cinfo);
 		dstcoefs=jtransform_adjust_parameters(dinfo, cinfo, srccoefs,
 			&xinfo[i]);
+		if(flags&TJFLAG_PROGRESSIVE)
+			jpeg_simple_progression(cinfo);
 		if(!(t[i].options&TJXOPT_NOOUTPUT))
 		{
 			jpeg_write_coefficients(cinfo, dstcoefs);
diff --git a/turbojpeg.h b/turbojpeg.h
index f60caf8..8b4a4da 100644
--- a/turbojpeg.h
+++ b/turbojpeg.h
@@ -383,6 +383,42 @@ enum TJCS
  * when decompressing, because this has been shown to have a larger effect.
  */
 #define TJFLAG_ACCURATEDCT   4096
+/**
+ * Immediately discontinue the current compression/decompression/transform
+ * operation if the underlying codec throws a warning (non-fatal error).  The
+ * default behavior is to allow the operation to complete unless a fatal error
+ * is encountered.
+ */
+#define TJFLAG_STOPONWARNING 8192
+/**
+ * Use progressive entropy coding in JPEG images generated by the compression
+ * and transform functions.  Progressive entropy coding will generally improve
+ * compression relative to baseline entropy coding (the default), but it will
+ * reduce compression and decompression performance considerably.
+ */
+#define TJFLAG_PROGRESSIVE   16384
+
+
+/**
+ * The number of error codes
+ */
+#define TJ_NUMERR 2
+
+/**
+ * Error codes
+ */
+enum TJERR
+{
+  /**
+   * The error was non-fatal and recoverable, but the image may still be
+   * corrupt.
+   */
+  TJERR_WARNING=0,
+  /**
+   * The error was fatal and non-recoverable.
+   */
+  TJERR_FATAL
+};
 
 
 /**
@@ -608,7 +644,7 @@ extern "C" {
  * Create a TurboJPEG compressor instance.
  *
  * @return a handle to the newly-created instance, or NULL if an error
- * occurred (see #tjGetErrorStr().)
+ * occurred (see #tjGetErrorStr2().)
  */
 DLLEXPORT tjhandle DLLCALL tjInitCompress(void);
 
@@ -670,7 +706,8 @@ DLLEXPORT tjhandle DLLCALL tjInitCompress(void);
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
 */
 DLLEXPORT int DLLCALL tjCompress2(tjhandle handle, const unsigned char *srcBuf,
   int width, int pitch, int height, int pixelFormat, unsigned char **jpegBuf,
@@ -734,7 +771,8 @@ DLLEXPORT int DLLCALL tjCompress2(tjhandle handle, const unsigned char *srcBuf,
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
 */
 DLLEXPORT int DLLCALL tjCompressFromYUV(tjhandle handle,
   const unsigned char *srcBuf, int width, int pad, int height, int subsamp,
@@ -804,7 +842,8 @@ DLLEXPORT int DLLCALL tjCompressFromYUV(tjhandle handle,
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
 */
 DLLEXPORT int DLLCALL tjCompressFromYUVPlanes(tjhandle handle,
   const unsigned char **srcPlanes, int width, const int *strides, int height,
@@ -964,7 +1003,8 @@ DLLEXPORT int tjPlaneHeight(int componentID, int height, int subsamp);
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
 */
 DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,
   const unsigned char *srcBuf, int width, int pitch, int height,
@@ -1022,7 +1062,8 @@ DLLEXPORT int DLLCALL tjEncodeYUV3(tjhandle handle,
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
 */
 DLLEXPORT int DLLCALL tjEncodeYUVPlanes(tjhandle handle,
   const unsigned char *srcBuf, int width, int pitch, int height,
@@ -1034,7 +1075,7 @@ DLLEXPORT int DLLCALL tjEncodeYUVPlanes(tjhandle handle,
  * Create a TurboJPEG decompressor instance.
  *
  * @return a handle to the newly-created instance, or NULL if an error
- * occurred (see #tjGetErrorStr().)
+ * occurred (see #tjGetErrorStr2().)
 */
 DLLEXPORT tjhandle DLLCALL tjInitDecompress(void);
 
@@ -1062,7 +1103,8 @@ DLLEXPORT tjhandle DLLCALL tjInitDecompress(void);
  * of the JPEG colorspace constants, indicating the colorspace of the JPEG
  * image (see @ref TJCS "JPEG colorspaces".)
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
 */
 DLLEXPORT int DLLCALL tjDecompressHeader3(tjhandle handle,
   const unsigned char *jpegBuf, unsigned long jpegSize, int *width,
@@ -1077,7 +1119,7 @@ DLLEXPORT int DLLCALL tjDecompressHeader3(tjhandle handle,
  * the number of elements in the list
  *
  * @return a pointer to a list of fractional scaling factors, or NULL if an
- * error is encountered (see #tjGetErrorStr().)
+ * error is encountered (see #tjGetErrorStr2().)
 */
 DLLEXPORT tjscalingfactor* DLLCALL tjGetScalingFactors(int *numscalingfactors);
 
@@ -1129,7 +1171,8 @@ DLLEXPORT tjscalingfactor* DLLCALL tjGetScalingFactors(int *numscalingfactors);
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
  */
 DLLEXPORT int DLLCALL tjDecompress2(tjhandle handle,
   const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
@@ -1179,7 +1222,8 @@ DLLEXPORT int DLLCALL tjDecompress2(tjhandle handle,
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
  */
 DLLEXPORT int DLLCALL tjDecompressToYUV2(tjhandle handle,
   const unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
@@ -1235,7 +1279,8 @@ DLLEXPORT int DLLCALL tjDecompressToYUV2(tjhandle handle,
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
  */
 DLLEXPORT int DLLCALL tjDecompressToYUVPlanes(tjhandle handle,
   const unsigned char *jpegBuf, unsigned long jpegSize,
@@ -1287,7 +1332,8 @@ DLLEXPORT int DLLCALL tjDecompressToYUVPlanes(tjhandle handle,
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
  */
 DLLEXPORT int DLLCALL tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
   int pad, int subsamp, unsigned char *dstBuf, int width, int pitch,
@@ -1344,7 +1390,8 @@ DLLEXPORT int DLLCALL tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
  */
 DLLEXPORT int DLLCALL tjDecodeYUVPlanes(tjhandle handle,
   const unsigned char **srcPlanes, const int *strides, int subsamp,
@@ -1356,7 +1403,7 @@ DLLEXPORT int DLLCALL tjDecodeYUVPlanes(tjhandle handle,
  * Create a new TurboJPEG transformer instance.
  *
  * @return a handle to the newly-created instance, or NULL if an error
- * occurred (see #tjGetErrorStr().)
+ * occurred (see #tjGetErrorStr2().)
  */
 DLLEXPORT tjhandle DLLCALL tjInitTransform(void);
 
@@ -1418,7 +1465,8 @@ DLLEXPORT tjhandle DLLCALL tjInitTransform(void);
  * @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
  * "flags"
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
+ * and #tjGetErrorCode().)
  */
 DLLEXPORT int DLLCALL tjTransform(tjhandle handle,
   const unsigned char *jpegBuf, unsigned long jpegSize, int n,
@@ -1432,7 +1480,7 @@ DLLEXPORT int DLLCALL tjTransform(tjhandle handle,
  * @param handle a handle to a TurboJPEG compressor, decompressor or
  * transformer instance
  *
- * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)
+ * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2().)
  */
 DLLEXPORT int DLLCALL tjDestroy(tjhandle handle);
 
@@ -1469,9 +1517,27 @@ DLLEXPORT void DLLCALL tjFree(unsigned char *buffer);
 /**
  * Returns a descriptive error message explaining why the last command failed.
  *
+ * @param handle a handle to a TurboJPEG compressor, decompressor, or
+ * transformer instance, or NULL if the error was generated by a global
+ * function (but note that retrieving the error message for a global function
+ * is not thread-safe.)
+ *
  * @return a descriptive error message explaining why the last command failed.
  */
-DLLEXPORT char* DLLCALL tjGetErrorStr(void);
+DLLEXPORT char* DLLCALL tjGetErrorStr2(tjhandle handle);
+
+
+/**
+ * Returns a code indicating the severity of the last error.  See
+ * @ref TJERR "Error codes".
+ *
+ * @param handle a handle to a TurboJPEG compressor, decompressor or
+ * transformer instance
+ *
+ * @return a code indicating the severity of the last error.  See
+ * @ref TJERR "Error codes".
+ */
+DLLEXPORT int DLLCALL tjGetErrorCode(tjhandle handle);
 
 
 /* Deprecated functions and macros */
@@ -1534,6 +1600,8 @@ DLLEXPORT int DLLCALL tjDecompressToYUV(tjhandle handle,
   unsigned char *jpegBuf, unsigned long jpegSize, unsigned char *dstBuf,
   int flags);
 
+DLLEXPORT char* DLLCALL tjGetErrorStr(void);
+
 
 /**
  * @}
diff --git a/win/jconfig.h.in b/win/jconfig.h.in
index 9d35121..e3c3d1c 100644
--- a/win/jconfig.h.in
+++ b/win/jconfig.h.in
@@ -1,35 +1,24 @@
-/* jconfig.vc --- jconfig.h for Microsoft Visual C++ on Windows 95 or NT. */
-/* see jconfig.txt for explanations */
-
 #define JPEG_LIB_VERSION @JPEG_LIB_VERSION@
 #define LIBJPEG_TURBO_VERSION @VERSION@
 #define LIBJPEG_TURBO_VERSION_NUMBER @LIBJPEG_TURBO_VERSION_NUMBER@
+
 #cmakedefine C_ARITH_CODING_SUPPORTED
 #cmakedefine D_ARITH_CODING_SUPPORTED
 #cmakedefine MEM_SRCDST_SUPPORTED
-
-/*
- * Define BITS_IN_JSAMPLE as either
- *   8   for 8-bit sample values (the usual setting)
- *   12  for 12-bit sample values
- * Only 8 and 12 are legal data precisions for lossy JPEG according to the
- * JPEG standard, and the IJG code does not support anything else!
- * We do not support run-time selection of data precision, sorry.
- */
+#cmakedefine WITH_SIMD
 
 #define BITS_IN_JSAMPLE  @BITS_IN_JSAMPLE@      /* use 8 or 12 */
 
-#define HAVE_UNSIGNED_CHAR
-#define HAVE_UNSIGNED_SHORT
-/* #define void char */
-/* #define const */
-#undef __CHAR_UNSIGNED__
 #define HAVE_STDDEF_H
 #define HAVE_STDLIB_H
-#undef NEED_BSD_STRINGS
 #undef NEED_SYS_TYPES_H
-#undef NEED_FAR_POINTERS	/* we presume a 32-bit flat memory model */
+#undef NEED_BSD_STRINGS
+
+#define HAVE_UNSIGNED_CHAR
+#define HAVE_UNSIGNED_SHORT
 #undef INCOMPLETE_TYPES_BROKEN
+#undef RIGHT_SHIFT_IS_UNSIGNED
+#undef __CHAR_UNSIGNED__
 
 /* Define "boolean" as unsigned char, not int, per Windows custom */
 #ifndef __RPCNDR_H__		/* don't conflict if rpcndr.h already read */
@@ -43,9 +32,3 @@ typedef short INT16;
 typedef signed int INT32;
 #endif
 #define XMD_H                   /* prevent jmorecfg.h from redefining it */
-
-#ifdef JPEG_INTERNALS
-
-#undef RIGHT_SHIFT_IS_UNSIGNED
-
-#endif /* JPEG_INTERNALS */
diff --git a/win/jconfigint.h.in b/win/jconfigint.h.in
deleted file mode 100644
index 2131bf5..0000000
--- a/win/jconfigint.h.in
+++ /dev/null
@@ -1,13 +0,0 @@
-#define VERSION "@VERSION@"
-#define BUILD "@BUILD@"
-#define PACKAGE_NAME "@CMAKE_PROJECT_NAME@"
-
-#ifndef INLINE
-#if defined(__GNUC__)
-#define INLINE inline __attribute__((always_inline))
-#elif defined(_MSC_VER)
-#define INLINE __forceinline
-#else
-#define INLINE
-#endif
-#endif
diff --git a/win/jpeg62-memsrcdst.def b/win/jpeg62-memsrcdst.def
index 6499316..6f44d28 100755
--- a/win/jpeg62-memsrcdst.def
+++ b/win/jpeg62-memsrcdst.def
@@ -104,3 +104,5 @@ EXPORTS
 	jpeg_mem_src @ 103 ; 
 	jpeg_skip_scanlines @ 104 ; 
 	jpeg_crop_scanline @ 105 ; 
+	jpeg_read_icc_profile @ 106 ; 
+	jpeg_write_icc_profile @ 107 ; 
diff --git a/win/jpeg62.def b/win/jpeg62.def
index 9f30b1a..8f70df6 100755
--- a/win/jpeg62.def
+++ b/win/jpeg62.def
@@ -102,3 +102,5 @@ EXPORTS
 	jzero_far @ 101 ; 
 	jpeg_skip_scanlines @ 102 ; 
 	jpeg_crop_scanline @ 103 ; 
+	jpeg_read_icc_profile @ 104 ; 
+	jpeg_write_icc_profile @ 105 ; 
diff --git a/win/jpeg7-memsrcdst.def b/win/jpeg7-memsrcdst.def
index 37a4777..521d957 100644
--- a/win/jpeg7-memsrcdst.def
+++ b/win/jpeg7-memsrcdst.def
@@ -106,3 +106,5 @@ EXPORTS
 	jpeg_mem_src @ 105 ; 
 	jpeg_skip_scanlines @ 106 ; 
 	jpeg_crop_scanline @ 107 ; 
+	jpeg_read_icc_profile @ 108 ; 
+	jpeg_write_icc_profile @ 109 ; 
diff --git a/win/jpeg7.def b/win/jpeg7.def
index 92463c5..2415bb2 100644
--- a/win/jpeg7.def
+++ b/win/jpeg7.def
@@ -104,3 +104,5 @@ EXPORTS
 	jzero_far @ 103 ; 
 	jpeg_skip_scanlines @ 104 ; 
 	jpeg_crop_scanline @ 105 ; 
+	jpeg_read_icc_profile @ 106 ; 
+	jpeg_write_icc_profile @ 107 ; 
diff --git a/win/jpeg8.def b/win/jpeg8.def
index 19246ac..b8d0455 100644
--- a/win/jpeg8.def
+++ b/win/jpeg8.def
@@ -107,3 +107,5 @@ EXPORTS
 	jzero_far @ 106 ; 
 	jpeg_skip_scanlines @ 107 ; 
 	jpeg_crop_scanline @ 108 ; 
+	jpeg_read_icc_profile @ 109 ; 
+	jpeg_write_icc_profile @ 110 ; 
diff --git a/win/jsimdcfg.inc b/win/jsimdcfg.inc
index 9d4aede..667024a 100755
--- a/win/jsimdcfg.inc
+++ b/win/jsimdcfg.inc
@@ -90,5 +90,4 @@
 %define JSIMD_3DNOW 0x02
 %define JSIMD_SSE 0x04
 %define JSIMD_SSE2 0x08
-; Short forms of external names for systems with brain-damaged linkers.
-;
+%define JSIMD_AVX2 0x80
